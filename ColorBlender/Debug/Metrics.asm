; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Metrics.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_ReturnUniqueColors@24
PUBLIC	_CountUniqueColors@16
PUBLIC	?GetLargestQuantities@@YGHPAIHHPAUColorResult@@@Z ; GetLargestQuantities
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\metrics.cpp
_TEXT	SEGMENT
_SmallestValue$1 = -16					; size = 4
_IndexOfSmallestValue$2 = -12				; size = 4
_k$3 = -8						; size = 4
_i$4 = -4						; size = 4
_ColorCounts$ = 8					; size = 4
_MaxColors$ = 12					; size = 4
_GreatestCount$ = 16					; size = 4
_Results$ = 20						; size = 4
?GetLargestQuantities@@YGHPAIHHPAUColorResult@@@Z PROC	; GetLargestQuantities

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 40   : 	if (ColorCounts == NULL)

	cmp	DWORD PTR _ColorCounts$[ebp], 0
	jne	SHORT $LN8@GetLargest

; 41   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@GetLargest
$LN8@GetLargest:

; 42   : 	if (Results == NULL)

	cmp	DWORD PTR _Results$[ebp], 0
	jne	SHORT $LN9@GetLargest

; 43   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@GetLargest
$LN9@GetLargest:

; 44   : 
; 45   : 	for (int i = 0; i < MaxColors; i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN4@GetLargest
$LN2@GetLargest:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN4@GetLargest:
	mov	ecx, DWORD PTR _i$4[ebp]
	cmp	ecx, DWORD PTR _MaxColors$[ebp]
	jge	$LN1@GetLargest

; 46   : 	{
; 47   : 		if (ColorCounts[i] == 0)

	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR _ColorCounts$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $LN10@GetLargest

; 48   : 			continue;

	jmp	SHORT $LN2@GetLargest
$LN10@GetLargest:

; 49   : 		int SmallestValue = MAXINT;

	mov	DWORD PTR _SmallestValue$1[ebp], 2147483647 ; 7fffffffH

; 50   : 		int IndexOfSmallestValue = 0;

	mov	DWORD PTR _IndexOfSmallestValue$2[ebp], 0

; 51   : 		for (int k = 0; k < GreatestCount; k++)

	mov	DWORD PTR _k$3[ebp], 0
	jmp	SHORT $LN7@GetLargest
$LN5@GetLargest:
	mov	ecx, DWORD PTR _k$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$3[ebp], ecx
$LN7@GetLargest:
	mov	edx, DWORD PTR _k$3[ebp]
	cmp	edx, DWORD PTR _GreatestCount$[ebp]
	jge	SHORT $LN6@GetLargest

; 52   : 		{
; 53   : 			if (Results[k].ColorCount < SmallestValue)

	imul	eax, DWORD PTR _k$3[ebp], 12
	mov	ecx, DWORD PTR _Results$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	cmp	edx, DWORD PTR _SmallestValue$1[ebp]
	jae	SHORT $LN11@GetLargest

; 54   : 			{
; 55   : 				SmallestValue = Results[k].ColorCount;

	imul	eax, DWORD PTR _k$3[ebp], 12
	mov	ecx, DWORD PTR _Results$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _SmallestValue$1[ebp], edx

; 56   : 				IndexOfSmallestValue = k;

	mov	eax, DWORD PTR _k$3[ebp]
	mov	DWORD PTR _IndexOfSmallestValue$2[ebp], eax
$LN11@GetLargest:

; 57   : 			}
; 58   : 		}

	jmp	SHORT $LN5@GetLargest
$LN6@GetLargest:

; 59   : 		if (ColorCounts[i] < Results[IndexOfSmallestValue].ColorCount)

	imul	ecx, DWORD PTR _IndexOfSmallestValue$2[ebp], 12
	mov	edx, DWORD PTR _i$4[ebp]
	mov	eax, DWORD PTR _ColorCounts$[ebp]
	mov	esi, DWORD PTR _Results$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	cmp	edx, DWORD PTR [esi+ecx+4]
	jae	SHORT $LN12@GetLargest

; 60   : 			continue;

	jmp	$LN2@GetLargest
$LN12@GetLargest:

; 61   : 		Results[IndexOfSmallestValue].ColorValue = i;

	imul	eax, DWORD PTR _IndexOfSmallestValue$2[ebp], 12
	mov	ecx, DWORD PTR _Results$[ebp]
	mov	edx, DWORD PTR _i$4[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 62   : 		Results[IndexOfSmallestValue].ColorCount = ColorCounts[i];

	imul	eax, DWORD PTR _IndexOfSmallestValue$2[ebp], 12
	mov	ecx, DWORD PTR _Results$[ebp]
	mov	edx, DWORD PTR _i$4[ebp]
	mov	esi, DWORD PTR _ColorCounts$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax+4], edx

; 63   : 		Results[IndexOfSmallestValue].Initialized = TRUE;

	imul	eax, DWORD PTR _IndexOfSmallestValue$2[ebp], 12
	mov	ecx, DWORD PTR _Results$[ebp]
	mov	DWORD PTR [ecx+eax+8], 1

; 64   : 	}

	jmp	$LN2@GetLargest
$LN1@GetLargest:

; 65   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetLargestQuantities@@YGHPAIHHPAUColorResult@@@Z ENDP	; GetLargestQuantities
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\metrics.cpp
_TEXT	SEGMENT
$T1 = -52						; size = 4
_Src$ = -48						; size = 4
_Index$2 = -44						; size = 4
_RowOffset$3 = -40					; size = 4
$T4 = -36						; size = 4
_Count$ = -32						; size = 4
_MaxColors$ = -28					; size = 4
_i$5 = -24						; size = 4
_Pixel$6 = -20						; size = 4
_Column$7 = -16						; size = 4
_Row$8 = -12						; size = 4
_i$9 = -8						; size = 4
_Map$ = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_UniqueColorCount$ = 20					; size = 4
_CountUniqueColors@16 PROC

; 135  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 136  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN14@CountUniqu

; 137  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CountUniqu
$LN14@CountUniqu:

; 138  : 
; 139  : 	int MaxColors = 256 * 256 * 256;

	mov	DWORD PTR _MaxColors$[ebp], 16777216	; 01000000H

; 140  : 	UINT32 *Src = (UINT32 *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 141  : 	UINT32 *Map = (UINT32 *)new UINT32[MaxColors];

	xor	ecx, ecx
	mov	eax, DWORD PTR _MaxColors$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _Map$[ebp], eax

; 142  : 	for (int i = 0; i < MaxColors; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN4@CountUniqu
$LN2@CountUniqu:
	mov	ecx, DWORD PTR _i$9[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$9[ebp], ecx
$LN4@CountUniqu:
	mov	edx, DWORD PTR _i$9[ebp]
	cmp	edx, DWORD PTR _MaxColors$[ebp]
	jge	SHORT $LN3@CountUniqu

; 143  : 		Map[i] = 0;

	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR _Map$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0
	jmp	SHORT $LN2@CountUniqu
$LN3@CountUniqu:

; 144  : 
; 145  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$8[ebp], 0
	jmp	SHORT $LN7@CountUniqu
$LN5@CountUniqu:
	mov	edx, DWORD PTR _Row$8[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$8[ebp], edx
$LN7@CountUniqu:
	mov	eax, DWORD PTR _Row$8[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	SHORT $LN6@CountUniqu

; 146  : 	{
; 147  : 		int RowOffset = Row * Height;

	mov	ecx, DWORD PTR _Row$8[ebp]
	imul	ecx, DWORD PTR _Height$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], ecx

; 148  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$7[ebp], 0
	jmp	SHORT $LN10@CountUniqu
$LN8@CountUniqu:
	mov	edx, DWORD PTR _Column$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$7[ebp], edx
$LN10@CountUniqu:
	mov	eax, DWORD PTR _Column$7[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN9@CountUniqu

; 149  : 		{
; 150  : 			int Index = RowOffset + Column;

	mov	ecx, DWORD PTR _RowOffset$3[ebp]
	add	ecx, DWORD PTR _Column$7[ebp]
	mov	DWORD PTR _Index$2[ebp], ecx

; 151  : 			UINT32 Pixel = Src[Index];

	mov	edx, DWORD PTR _Index$2[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _Pixel$6[ebp], ecx

; 152  : 			Pixel = Pixel & 0x00ffffff;

	mov	edx, DWORD PTR _Pixel$6[ebp]
	and	edx, 16777215				; 00ffffffH
	mov	DWORD PTR _Pixel$6[ebp], edx

; 153  : 			Map[Pixel]++;

	mov	eax, DWORD PTR _Pixel$6[ebp]
	mov	ecx, DWORD PTR _Map$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	add	edx, 1
	mov	eax, DWORD PTR _Pixel$6[ebp]
	mov	ecx, DWORD PTR _Map$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 154  : 		}

	jmp	SHORT $LN8@CountUniqu
$LN9@CountUniqu:

; 155  : 	}

	jmp	SHORT $LN5@CountUniqu
$LN6@CountUniqu:

; 156  : 
; 157  : 	int Count = 0;

	mov	DWORD PTR _Count$[ebp], 0

; 158  : 	for (int i = 0; i < MaxColors; i++)

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN13@CountUniqu
$LN11@CountUniqu:
	mov	edx, DWORD PTR _i$5[ebp]
	add	edx, 1
	mov	DWORD PTR _i$5[ebp], edx
$LN13@CountUniqu:
	mov	eax, DWORD PTR _i$5[ebp]
	cmp	eax, DWORD PTR _MaxColors$[ebp]
	jge	SHORT $LN12@CountUniqu

; 159  : 	{
; 160  : 		if (Map[i] == 0)

	mov	ecx, DWORD PTR _i$5[ebp]
	mov	edx, DWORD PTR _Map$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN15@CountUniqu

; 161  : 			continue;

	jmp	SHORT $LN11@CountUniqu
$LN15@CountUniqu:

; 162  : 		Count++;

	mov	eax, DWORD PTR _Count$[ebp]
	add	eax, 1
	mov	DWORD PTR _Count$[ebp], eax

; 163  : 	}

	jmp	SHORT $LN11@CountUniqu
$LN12@CountUniqu:

; 164  : 	*UniqueColorCount = Count;

	mov	ecx, DWORD PTR _UniqueColorCount$[ebp]
	mov	edx, DWORD PTR _Count$[ebp]
	mov	DWORD PTR [ecx], edx

; 165  : 
; 166  : 	delete[] Map;

	mov	eax, DWORD PTR _Map$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 167  : 	return Success;

	xor	eax, eax
$LN1@CountUniqu:

; 168  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CountUniqueColors@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\metrics.cpp
_TEXT	SEGMENT
_OpResult$ = -68					; size = 4
$T1 = -64						; size = 4
_FinalResultCount$ = -60				; size = 4
_Counts$ = -56						; size = 4
_Src$ = -52						; size = 4
_Index$2 = -48						; size = 4
_RowOffset$3 = -44					; size = 4
$T4 = -40						; size = 4
tv135 = -36						; size = 4
_MaxColors$ = -32					; size = 4
_i$5 = -28						; size = 4
_Pixel$6 = -24						; size = 4
_Column$7 = -20						; size = 4
_Row$8 = -16						; size = 4
_i$9 = -12						; size = 4
_Count$ = -8						; size = 4
_Map$ = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_UniqueColorCount$ = 20					; size = 4
_Results$ = 24						; size = 4
_ColorsToReturn$ = 28					; size = 4
_ReturnUniqueColors@24 PROC

; 84   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 85   : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN14@ReturnUniq

; 86   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ReturnUniq
$LN14@ReturnUniq:

; 87   : 	if (Results == NULL)

	cmp	DWORD PTR _Results$[ebp], 0
	jne	SHORT $LN15@ReturnUniq

; 88   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ReturnUniq
$LN15@ReturnUniq:

; 89   : 
; 90   : 	int MaxColors = 256 * 256 * 256;

	mov	DWORD PTR _MaxColors$[ebp], 16777216	; 01000000H

; 91   : 
; 92   : 	ColorResult *Counts = (ColorResult *)Results;

	mov	eax, DWORD PTR _Results$[ebp]
	mov	DWORD PTR _Counts$[ebp], eax

; 93   : 	UINT32 *Src = (UINT32 *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 94   : 	UINT32 *Map = (UINT32 *)new UINT32[MaxColors];

	xor	ecx, ecx
	mov	eax, DWORD PTR _MaxColors$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _Map$[ebp], eax

; 95   : 	for (int i = 0; i < MaxColors; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN4@ReturnUniq
$LN2@ReturnUniq:
	mov	ecx, DWORD PTR _i$9[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$9[ebp], ecx
$LN4@ReturnUniq:
	mov	edx, DWORD PTR _i$9[ebp]
	cmp	edx, DWORD PTR _MaxColors$[ebp]
	jge	SHORT $LN3@ReturnUniq

; 96   : 		Map[i] = 0;

	mov	eax, DWORD PTR _i$9[ebp]
	mov	ecx, DWORD PTR _Map$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0
	jmp	SHORT $LN2@ReturnUniq
$LN3@ReturnUniq:

; 97   : 
; 98   : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$8[ebp], 0
	jmp	SHORT $LN7@ReturnUniq
$LN5@ReturnUniq:
	mov	edx, DWORD PTR _Row$8[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$8[ebp], edx
$LN7@ReturnUniq:
	mov	eax, DWORD PTR _Row$8[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	SHORT $LN6@ReturnUniq

; 99   : 	{
; 100  : 		int RowOffset = Row * Height;

	mov	ecx, DWORD PTR _Row$8[ebp]
	imul	ecx, DWORD PTR _Height$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], ecx

; 101  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$7[ebp], 0
	jmp	SHORT $LN10@ReturnUniq
$LN8@ReturnUniq:
	mov	edx, DWORD PTR _Column$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$7[ebp], edx
$LN10@ReturnUniq:
	mov	eax, DWORD PTR _Column$7[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN9@ReturnUniq

; 102  : 		{
; 103  : 			int Index = RowOffset + Column;

	mov	ecx, DWORD PTR _RowOffset$3[ebp]
	add	ecx, DWORD PTR _Column$7[ebp]
	mov	DWORD PTR _Index$2[ebp], ecx

; 104  : 			UINT32 Pixel = Src[Index];

	mov	edx, DWORD PTR _Index$2[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _Pixel$6[ebp], ecx

; 105  : 			Pixel = Pixel & 0x00ffffff;

	mov	edx, DWORD PTR _Pixel$6[ebp]
	and	edx, 16777215				; 00ffffffH
	mov	DWORD PTR _Pixel$6[ebp], edx

; 106  : 			Map[Pixel]++;

	mov	eax, DWORD PTR _Pixel$6[ebp]
	mov	ecx, DWORD PTR _Map$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	add	edx, 1
	mov	eax, DWORD PTR _Pixel$6[ebp]
	mov	ecx, DWORD PTR _Map$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 107  : 		}

	jmp	SHORT $LN8@ReturnUniq
$LN9@ReturnUniq:

; 108  : 	}

	jmp	SHORT $LN5@ReturnUniq
$LN6@ReturnUniq:

; 109  : 
; 110  : 	int Count = 0;

	mov	DWORD PTR _Count$[ebp], 0

; 111  : 	for (int i = 0; i < MaxColors; i++)

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN13@ReturnUniq
$LN11@ReturnUniq:
	mov	edx, DWORD PTR _i$5[ebp]
	add	edx, 1
	mov	DWORD PTR _i$5[ebp], edx
$LN13@ReturnUniq:
	mov	eax, DWORD PTR _i$5[ebp]
	cmp	eax, DWORD PTR _MaxColors$[ebp]
	jge	SHORT $LN12@ReturnUniq

; 112  : 	{
; 113  : 		if (Map[i] == 0)

	mov	ecx, DWORD PTR _i$5[ebp]
	mov	edx, DWORD PTR _Map$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN16@ReturnUniq

; 114  : 			continue;

	jmp	SHORT $LN11@ReturnUniq
$LN16@ReturnUniq:

; 115  : 		Count++;

	mov	eax, DWORD PTR _Count$[ebp]
	add	eax, 1
	mov	DWORD PTR _Count$[ebp], eax

; 116  : 	}

	jmp	SHORT $LN11@ReturnUniq
$LN12@ReturnUniq:

; 117  : 	*UniqueColorCount = Count;

	mov	ecx, DWORD PTR _UniqueColorCount$[ebp]
	mov	edx, DWORD PTR _Count$[ebp]
	mov	DWORD PTR [ecx], edx

; 118  : 
; 119  : 	int FinalResultCount = Count < ColorsToReturn ? Count : ColorsToReturn;

	mov	eax, DWORD PTR _Count$[ebp]
	cmp	eax, DWORD PTR _ColorsToReturn$[ebp]
	jge	SHORT $LN18@ReturnUniq
	mov	ecx, DWORD PTR _Count$[ebp]
	mov	DWORD PTR tv135[ebp], ecx
	jmp	SHORT $LN19@ReturnUniq
$LN18@ReturnUniq:
	mov	edx, DWORD PTR _ColorsToReturn$[ebp]
	mov	DWORD PTR tv135[ebp], edx
$LN19@ReturnUniq:
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR _FinalResultCount$[ebp], eax

; 120  : 	int OpResult = GetLargestQuantities(Map, MaxColors, FinalResultCount, Counts);

	mov	ecx, DWORD PTR _Counts$[ebp]
	push	ecx
	mov	edx, DWORD PTR _FinalResultCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _MaxColors$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Map$[ebp]
	push	ecx
	call	?GetLargestQuantities@@YGHPAIHHPAUColorResult@@@Z ; GetLargestQuantities
	mov	DWORD PTR _OpResult$[ebp], eax

; 121  : 
; 122  : 	delete[] Map;

	mov	edx, DWORD PTR _Map$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 123  : 	return Success;

	xor	eax, eax
$LN1@ReturnUniq:

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_ReturnUniqueColors@24 ENDP
_TEXT	ENDS
END
