; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\PixelMath.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_PixelMathLogicalOperation@44
PUBLIC	_PixelMathOperation@48
PUBLIC	?ExecuteOperation@@YGEEHH@Z			; ExecuteOperation
PUBLIC	?ExecuteOperation2@@YGEEHHH@Z			; ExecuteOperation2
PUBLIC	__real@0000000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@41efffffffe00000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__imp__rand_s:PROC
EXTRN	__imp__acosh:PROC
EXTRN	__imp__asinh:PROC
EXTRN	__imp__atanh:PROC
EXTRN	__imp__log2:PROC
EXTRN	__CIcosh:PROC
EXTRN	__CIfmod:PROC
EXTRN	__CIsinh:PROC
EXTRN	__CItanh:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__libm_sse2_acos_precise:PROC
EXTRN	__libm_sse2_asin_precise:PROC
EXTRN	__libm_sse2_atan_precise:PROC
EXTRN	__libm_sse2_cos_precise:PROC
EXTRN	__libm_sse2_log10_precise:PROC
EXTRN	__libm_sse2_log_precise:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	__libm_sse2_tan_precise:PROC
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@41efffffffe00000
CONST	SEGMENT
__real@41efffffffe00000 DQ 041efffffffe00000r	; 4.29497e+09
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\pixelmath.cpp
_TEXT	SEGMENT
_Result$ = -20						; size = 8
_DValue$ = -12						; size = 8
tv68 = -4						; size = 4
_Value$ = 8						; size = 1
_Operation$ = 12					; size = 4
_NormalizeResults$ = 16					; size = 4
_NormalizeValues$ = 20					; size = 4
?ExecuteOperation2@@YGEEHHH@Z PROC			; ExecuteOperation2

; 179  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 180  : 	double DValue = (double)Value;

	movzx	eax, BYTE PTR _Value$[ebp]
	cvtsi2sd xmm0, eax
	movsd	QWORD PTR _DValue$[ebp], xmm0

; 181  : 	if (NormalizeValues)

	cmp	DWORD PTR _NormalizeValues$[ebp], 0
	je	SHORT $LN4@ExecuteOpe

; 182  : 		DValue = DValue / 255.0;

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _DValue$[ebp], xmm0
$LN4@ExecuteOpe:

; 183  : 	double Result = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Result$[ebp], xmm0

; 184  : 
; 185  : 	switch (Operation)

	mov	ecx, DWORD PTR _Operation$[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR tv68[ebp]
	sub	edx, 100				; 00000064H
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 14			; 0000000eH
	ja	$LN26@ExecuteOpe
	mov	eax, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN29@ExecuteOpe[eax*4]
$LN5@ExecuteOpe:

; 186  : 	{
; 187  : 	case PixelMathSin:
; 188  : 		Result = sin(DValue);

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	call	__libm_sse2_sin_precise
	movsd	QWORD PTR _Result$[ebp], xmm0

; 189  : 		break;

	jmp	$LN2@ExecuteOpe
$LN6@ExecuteOpe:

; 190  : 
; 191  : 	case PixelMathASin:
; 192  : 		Result = asin(DValue);

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	call	__libm_sse2_asin_precise
	movsd	QWORD PTR _Result$[ebp], xmm0

; 193  : 		break;

	jmp	$LN2@ExecuteOpe
$LN7@ExecuteOpe:

; 194  : 
; 195  : 	case PixelMathSinh:
; 196  : 		Result = sinh(DValue);

	fld	QWORD PTR _DValue$[ebp]
	call	__CIsinh
	fstp	QWORD PTR _Result$[ebp]

; 197  : 		break;

	jmp	$LN2@ExecuteOpe
$LN8@ExecuteOpe:

; 198  : 
; 199  : 	case PixelMathASinh:
; 200  : 		Result = asinh(DValue);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _DValue$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__asinh
	add	esp, 8
	fstp	QWORD PTR _Result$[ebp]

; 201  : 		break;

	jmp	$LN2@ExecuteOpe
$LN9@ExecuteOpe:

; 202  : 
; 203  : 	case PixelMathCos:
; 204  : 		Result = cos(DValue);

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	call	__libm_sse2_cos_precise
	movsd	QWORD PTR _Result$[ebp], xmm0

; 205  : 		break;

	jmp	$LN2@ExecuteOpe
$LN10@ExecuteOpe:

; 206  : 
; 207  : 	case PixelMathACos:
; 208  : 		Result = acos(DValue);

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	call	__libm_sse2_acos_precise
	movsd	QWORD PTR _Result$[ebp], xmm0

; 209  : 		break;

	jmp	$LN2@ExecuteOpe
$LN11@ExecuteOpe:

; 210  : 
; 211  : 	case PixelMathCosH:
; 212  : 		Result = cosh(DValue);

	fld	QWORD PTR _DValue$[ebp]
	call	__CIcosh
	fstp	QWORD PTR _Result$[ebp]

; 213  : 		break;

	jmp	$LN2@ExecuteOpe
$LN12@ExecuteOpe:

; 214  : 
; 215  : 	case PixelMathACosH:
; 216  : 		Result = acosh(DValue);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _DValue$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__acosh
	add	esp, 8
	fstp	QWORD PTR _Result$[ebp]

; 217  : 		break;

	jmp	$LN2@ExecuteOpe
$LN13@ExecuteOpe:

; 218  : 
; 219  : 	case PixelMathTan:
; 220  : 		Result = tan(DValue);

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	call	__libm_sse2_tan_precise
	movsd	QWORD PTR _Result$[ebp], xmm0

; 221  : 		break;

	jmp	$LN2@ExecuteOpe
$LN14@ExecuteOpe:

; 222  : 
; 223  : 	case PixelMathATan:
; 224  : 		Result = atan(DValue);

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	call	__libm_sse2_atan_precise
	movsd	QWORD PTR _Result$[ebp], xmm0

; 225  : 		break;

	jmp	$LN2@ExecuteOpe
$LN15@ExecuteOpe:

; 226  : 
; 227  : 	case PixelMathTanH:
; 228  : 		Result = tanh(DValue);

	fld	QWORD PTR _DValue$[ebp]
	call	__CItanh
	fstp	QWORD PTR _Result$[ebp]

; 229  : 		break;

	jmp	$LN2@ExecuteOpe
$LN16@ExecuteOpe:

; 230  : 
; 231  : 	case PixelMathATanH:
; 232  : 		Result = atanh(DValue);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _DValue$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__atanh
	add	esp, 8
	fstp	QWORD PTR _Result$[ebp]

; 233  : 		break;

	jmp	$LN2@ExecuteOpe
$LN17@ExecuteOpe:

; 234  : 
; 235  : 	case PixelMathLog:
; 236  : 		if (DValue == 0.0)

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@ExecuteOpe

; 237  : 			Result = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Result$[ebp], xmm0

; 238  : 		else

	jmp	SHORT $LN19@ExecuteOpe
$LN18@ExecuteOpe:

; 239  : 			Result = log(DValue);

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	call	__libm_sse2_log_precise
	movsd	QWORD PTR _Result$[ebp], xmm0
$LN19@ExecuteOpe:

; 240  : 		break;

	jmp	SHORT $LN2@ExecuteOpe
$LN20@ExecuteOpe:

; 241  : 
; 242  : 	case PixelMathLog10:
; 243  : 		if (DValue == 0.0)

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN21@ExecuteOpe

; 244  : 			Result = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Result$[ebp], xmm0

; 245  : 		else

	jmp	SHORT $LN22@ExecuteOpe
$LN21@ExecuteOpe:

; 246  : 			Result = log10(DValue);

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	call	__libm_sse2_log10_precise
	movsd	QWORD PTR _Result$[ebp], xmm0
$LN22@ExecuteOpe:

; 247  : 		break;

	jmp	SHORT $LN2@ExecuteOpe
$LN23@ExecuteOpe:

; 248  : 
; 249  : 	case PixelMathLog2:
; 250  : 		if (DValue == 0.0)

	movsd	xmm0, QWORD PTR _DValue$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN24@ExecuteOpe

; 251  : 			Result = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Result$[ebp], xmm0

; 252  : 		else

	jmp	SHORT $LN25@ExecuteOpe
$LN24@ExecuteOpe:

; 253  : 			Result = log2(DValue);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _DValue$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__log2
	add	esp, 8
	fstp	QWORD PTR _Result$[ebp]
$LN25@ExecuteOpe:

; 254  : 		break;

	jmp	SHORT $LN2@ExecuteOpe
$LN26@ExecuteOpe:

; 255  : 
; 256  : 	default:
; 257  : 		return Value;

	mov	al, BYTE PTR _Value$[ebp]
$LN2@ExecuteOpe:

; 258  : 	}
; 259  : 
; 260  : 	if (NormalizeResults)
; 261  : 	{
; 262  : 
; 263  : 	}
; 264  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN29@ExecuteOpe:
	DD	$LN17@ExecuteOpe
	DD	$LN20@ExecuteOpe
	DD	$LN5@ExecuteOpe
	DD	$LN9@ExecuteOpe
	DD	$LN13@ExecuteOpe
	DD	$LN23@ExecuteOpe
	DD	$LN6@ExecuteOpe
	DD	$LN7@ExecuteOpe
	DD	$LN8@ExecuteOpe
	DD	$LN10@ExecuteOpe
	DD	$LN11@ExecuteOpe
	DD	$LN12@ExecuteOpe
	DD	$LN14@ExecuteOpe
	DD	$LN15@ExecuteOpe
	DD	$LN16@ExecuteOpe
?ExecuteOperation2@@YGEEHHH@Z ENDP			; ExecuteOperation2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\pixelmath.cpp
_TEXT	SEGMENT
_sr$1 = -48						; size = 8
tv159 = -40						; size = 8
tv157 = -32						; size = 8
_RandomBits$2 = -24					; size = 4
_number$3 = -20						; size = 4
_err$4 = -16						; size = 4
tv172 = -12						; size = 4
tv64 = -8						; size = 4
_Scratch$ = -4						; size = 4
_Value$ = 8						; size = 1
_Operation$ = 12					; size = 4
_Constant$ = 16						; size = 4
?ExecuteOperation@@YGEEHH@Z PROC			; ExecuteOperation

; 26   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 27   : 	int Scratch = 0;

	mov	DWORD PTR _Scratch$[ebp], 0

; 28   : 
; 29   : 	switch (Operation)

	mov	eax, DWORD PTR _Operation$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 8
	ja	$LN2@ExecuteOpe
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN20@ExecuteOpe[ecx*4]
$LN4@ExecuteOpe:

; 30   : 	{
; 31   : 	case PixelMathLogicalAnd:
; 32   : 		return Value & Constant;

	movzx	eax, BYTE PTR _Value$[ebp]
	and	eax, DWORD PTR _Constant$[ebp]
	jmp	$LN1@ExecuteOpe
$LN5@ExecuteOpe:

; 33   : 
; 34   : 	case PixelMathLogicalOr:
; 35   : 		return Value | Constant;

	movzx	eax, BYTE PTR _Value$[ebp]
	or	eax, DWORD PTR _Constant$[ebp]
	jmp	$LN1@ExecuteOpe
$LN6@ExecuteOpe:

; 36   : 
; 37   : 	case PixelMathLogicalXor:
; 38   : 		return Value ^ Constant;

	movzx	eax, BYTE PTR _Value$[ebp]
	xor	eax, DWORD PTR _Constant$[ebp]
	jmp	$LN1@ExecuteOpe
$LN7@ExecuteOpe:

; 39   : 
; 40   : 	case PixelMathArithmeticAdd:
; 41   : 		Scratch = Value + Constant;

	movzx	edx, BYTE PTR _Value$[ebp]
	add	edx, DWORD PTR _Constant$[ebp]
	mov	DWORD PTR _Scratch$[ebp], edx

; 42   : 		if (Scratch > 0xff)

	cmp	DWORD PTR _Scratch$[ebp], 255		; 000000ffH
	jle	SHORT $LN8@ExecuteOpe

; 43   : 			Scratch = 0xff;

	mov	DWORD PTR _Scratch$[ebp], 255		; 000000ffH
$LN8@ExecuteOpe:

; 44   : 		return Scratch;

	mov	al, BYTE PTR _Scratch$[ebp]
	jmp	$LN1@ExecuteOpe
$LN9@ExecuteOpe:

; 45   : 
; 46   : 	case PixelMathArithmeticSubtract:
; 47   : 		Scratch = Value - Constant;

	movzx	eax, BYTE PTR _Value$[ebp]
	sub	eax, DWORD PTR _Constant$[ebp]
	mov	DWORD PTR _Scratch$[ebp], eax

; 48   : 		if (Scratch < 0)

	jns	SHORT $LN10@ExecuteOpe

; 49   : 			Scratch = 0;

	mov	DWORD PTR _Scratch$[ebp], 0
$LN10@ExecuteOpe:

; 50   : 		return Scratch;

	mov	al, BYTE PTR _Scratch$[ebp]
	jmp	$LN1@ExecuteOpe
$LN11@ExecuteOpe:

; 51   : 
; 52   : 	case PixelMathArithmeticMultiply:
; 53   : 		Scratch = Value * Constant;

	movzx	ecx, BYTE PTR _Value$[ebp]
	imul	ecx, DWORD PTR _Constant$[ebp]
	mov	DWORD PTR _Scratch$[ebp], ecx

; 54   : 		if (Scratch > 0xff)

	cmp	DWORD PTR _Scratch$[ebp], 255		; 000000ffH
	jle	SHORT $LN12@ExecuteOpe

; 55   : 			Scratch = 0xff;

	mov	DWORD PTR _Scratch$[ebp], 255		; 000000ffH
$LN12@ExecuteOpe:

; 56   : 		return Scratch;

	mov	al, BYTE PTR _Scratch$[ebp]
	jmp	$LN1@ExecuteOpe
$LN13@ExecuteOpe:

; 57   : 
; 58   : 	case PixelMathArithmeticDivide:
; 59   : 		if (Constant == 0)

	cmp	DWORD PTR _Constant$[ebp], 0
	jne	SHORT $LN14@ExecuteOpe

; 60   : 			return Value;

	mov	al, BYTE PTR _Value$[ebp]
	jmp	$LN1@ExecuteOpe
$LN14@ExecuteOpe:

; 61   : 		Scratch = Value / Constant;

	movzx	eax, BYTE PTR _Value$[ebp]
	cdq
	idiv	DWORD PTR _Constant$[ebp]
	mov	DWORD PTR _Scratch$[ebp], eax

; 62   : 		return Scratch;

	mov	al, BYTE PTR _Scratch$[ebp]
	jmp	$LN1@ExecuteOpe
$LN15@ExecuteOpe:

; 63   : 
; 64   : 	case PixelMathArithmeticMod:
; 65   : 		if (Constant == 0)

	cmp	DWORD PTR _Constant$[ebp], 0
	jne	SHORT $LN16@ExecuteOpe

; 66   : 			return Value;

	mov	al, BYTE PTR _Value$[ebp]
	jmp	$LN1@ExecuteOpe
$LN16@ExecuteOpe:

; 67   : 		Scratch = (int)fmod(Value, Constant);

	movzx	edx, BYTE PTR _Value$[ebp]
	cvtsi2sd xmm0, edx
	movsd	QWORD PTR tv157[ebp], xmm0
	fld	QWORD PTR tv157[ebp]
	cvtsi2sd xmm0, DWORD PTR _Constant$[ebp]
	movsd	QWORD PTR tv159[ebp], xmm0
	fld	QWORD PTR tv159[ebp]
	call	__CIfmod
	call	__ftol2_sse
	mov	DWORD PTR _Scratch$[ebp], eax

; 68   : 		return Scratch;

	mov	al, BYTE PTR _Scratch$[ebp]
	jmp	SHORT $LN1@ExecuteOpe
$LN17@ExecuteOpe:

; 69   : 
; 70   : 	case pixelMathRandomWithMask:
; 71   : 		unsigned int number;
; 72   : 		errno_t err = rand_s(&number);

	lea	eax, DWORD PTR _number$3[ebp]
	push	eax
	call	DWORD PTR __imp__rand_s
	add	esp, 4
	mov	DWORD PTR _err$4[ebp], eax

; 73   : 		if (err != 0)

	cmp	DWORD PTR _err$4[ebp], 0
	je	SHORT $LN18@ExecuteOpe

; 74   : 			return Value;

	mov	al, BYTE PTR _Value$[ebp]
	jmp	SHORT $LN1@ExecuteOpe
$LN18@ExecuteOpe:

; 75   : 		double sr = (double)number / (double)UINT_MAX;

	mov	ecx, DWORD PTR _number$3[ebp]
	mov	DWORD PTR tv172[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv172[ebp]
	mov	edx, DWORD PTR tv172[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	divsd	xmm0, QWORD PTR __real@41efffffffe00000
	movsd	QWORD PTR _sr$1[ebp], xmm0

; 76   : 		int RandomBits = (int)(sr * 255.0);

	movsd	xmm0, QWORD PTR _sr$1[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si eax, xmm0
	mov	DWORD PTR _RandomBits$2[ebp], eax

; 77   : 		Scratch = (Value & ~Constant) | (RandomBits & Constant);

	movzx	ecx, BYTE PTR _Value$[ebp]
	mov	edx, DWORD PTR _Constant$[ebp]
	not	edx
	and	ecx, edx
	mov	eax, DWORD PTR _RandomBits$2[ebp]
	and	eax, DWORD PTR _Constant$[ebp]
	or	ecx, eax
	mov	DWORD PTR _Scratch$[ebp], ecx

; 78   : 		return Scratch;

	mov	al, BYTE PTR _Scratch$[ebp]
	jmp	SHORT $LN1@ExecuteOpe
$LN2@ExecuteOpe:

; 79   : 	}
; 80   : 	return 0;

	xor	al, al
$LN1@ExecuteOpe:

; 81   : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN20@ExecuteOpe:
	DD	$LN4@ExecuteOpe
	DD	$LN5@ExecuteOpe
	DD	$LN6@ExecuteOpe
	DD	$LN7@ExecuteOpe
	DD	$LN9@ExecuteOpe
	DD	$LN11@ExecuteOpe
	DD	$LN13@ExecuteOpe
	DD	$LN15@ExecuteOpe
	DD	$LN17@ExecuteOpe
?ExecuteOperation@@YGEEHH@Z ENDP			; ExecuteOperation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\pixelmath.cpp
_TEXT	SEGMENT
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Destination$ = -24					; size = 4
_Source$ = -20						; size = 4
_Column$2 = -16						; size = 4
_Row$3 = -12						; size = 4
_Index$4 = -8						; size = 4
_A$5 = -4						; size = 1
_B$6 = -3						; size = 1
_G$7 = -2						; size = 1
_R$8 = -1						; size = 1
_SourceBuffer$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_DestinationBuffer$ = 24				; size = 4
_Operation$ = 28					; size = 4
_NormalizeResults$ = 32					; size = 4
_NormalizeValues$ = 36					; size = 4
_ApplyToAlpha$ = 40					; size = 4
_ApplyToRed$ = 44					; size = 4
_ApplyToGreen$ = 48					; size = 4
_ApplyToBlue$ = 52					; size = 4
_PixelMathOperation@48 PROC

; 283  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 284  : 	if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN8@PixelMathO

; 285  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PixelMathO
$LN8@PixelMathO:

; 286  : 	if (DestinationBuffer == NULL)

	cmp	DWORD PTR _DestinationBuffer$[ebp], 0
	jne	SHORT $LN9@PixelMathO

; 287  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PixelMathO
$LN9@PixelMathO:

; 288  : 	if (Operation < PixelMathLog || Operation > PixelMathLog10)

	cmp	DWORD PTR _Operation$[ebp], 100		; 00000064H
	jl	SHORT $LN11@PixelMathO
	cmp	DWORD PTR _Operation$[ebp], 101		; 00000065H
	jle	SHORT $LN10@PixelMathO
$LN11@PixelMathO:

; 289  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PixelMathO
$LN10@PixelMathO:

; 290  : 
; 291  : 	BYTE *Source = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 292  : 	BYTE *Destination = (BYTE *)DestinationBuffer;

	mov	ecx, DWORD PTR _DestinationBuffer$[ebp]
	mov	DWORD PTR _Destination$[ebp], ecx

; 293  : 
; 294  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 295  : 
; 296  : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@PixelMathO
$LN2@PixelMathO:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@PixelMathO:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@PixelMathO

; 297  : 	{
; 298  : 		int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 299  : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@PixelMathO
$LN5@PixelMathO:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@PixelMathO:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@PixelMathO

; 300  : 		{
; 301  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 302  : 			BYTE A = Source[Index + 3];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$5[ebp], al

; 303  : 			BYTE R = Source[Index + 2];

	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$8[ebp], dl

; 304  : 			BYTE G = Source[Index + 1];

	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$7[ebp], cl

; 305  : 			BYTE B = Source[Index + 0];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$6[ebp], al

; 306  : 
; 307  : 			if (ApplyToRed)

	cmp	DWORD PTR _ApplyToRed$[ebp], 0
	je	SHORT $LN12@PixelMathO

; 308  : 				R = ExecuteOperation2(R, Operation, NormalizeResults, NormalizeValues);

	mov	ecx, DWORD PTR _NormalizeValues$[ebp]
	push	ecx
	mov	edx, DWORD PTR _NormalizeResults$[ebp]
	push	edx
	mov	eax, DWORD PTR _Operation$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _R$8[ebp]
	push	ecx
	call	?ExecuteOperation2@@YGEEHHH@Z		; ExecuteOperation2
	mov	BYTE PTR _R$8[ebp], al
$LN12@PixelMathO:

; 309  : 			if (ApplyToGreen)

	cmp	DWORD PTR _ApplyToGreen$[ebp], 0
	je	SHORT $LN13@PixelMathO

; 310  : 				G = ExecuteOperation2(G, Operation, NormalizeResults, NormalizeValues);

	mov	edx, DWORD PTR _NormalizeValues$[ebp]
	push	edx
	mov	eax, DWORD PTR _NormalizeResults$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Operation$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$7[ebp]
	push	edx
	call	?ExecuteOperation2@@YGEEHHH@Z		; ExecuteOperation2
	mov	BYTE PTR _G$7[ebp], al
$LN13@PixelMathO:

; 311  : 			if (ApplyToBlue)

	cmp	DWORD PTR _ApplyToBlue$[ebp], 0
	je	SHORT $LN14@PixelMathO

; 312  : 				B = ExecuteOperation2(B, Operation, NormalizeResults, NormalizeValues);

	mov	eax, DWORD PTR _NormalizeValues$[ebp]
	push	eax
	mov	ecx, DWORD PTR _NormalizeResults$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Operation$[ebp]
	push	edx
	movzx	eax, BYTE PTR _B$6[ebp]
	push	eax
	call	?ExecuteOperation2@@YGEEHHH@Z		; ExecuteOperation2
	mov	BYTE PTR _B$6[ebp], al
$LN14@PixelMathO:

; 313  : 
; 314  : 			Destination[Index + 3] = A;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _A$5[ebp]
	mov	BYTE PTR [ecx+3], dl

; 315  : 			Destination[Index + 2] = R;

	mov	eax, DWORD PTR _Destination$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _R$8[ebp]
	mov	BYTE PTR [eax+2], cl

; 316  : 			Destination[Index + 1] = G;

	mov	edx, DWORD PTR _Destination$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _G$7[ebp]
	mov	BYTE PTR [edx+1], al

; 317  : 			Destination[Index + 0] = B;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _B$6[ebp]
	mov	BYTE PTR [ecx], dl

; 318  : 		}

	jmp	$LN5@PixelMathO
$LN6@PixelMathO:

; 319  : 	}

	jmp	$LN2@PixelMathO
$LN3@PixelMathO:

; 320  : 
; 321  : 	return Success;

	xor	eax, eax
$LN1@PixelMathO:

; 322  : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_PixelMathOperation@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\pixelmath.cpp
_TEXT	SEGMENT
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Destination$ = -24					; size = 4
_Source$ = -20						; size = 4
_Column$2 = -16						; size = 4
_Row$3 = -12						; size = 4
_Index$4 = -8						; size = 4
_B$5 = -4						; size = 1
_G$6 = -3						; size = 1
_R$7 = -2						; size = 1
_A$8 = -1						; size = 1
_SourceBuffer$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_DestinationBuffer$ = 24				; size = 4
_Operation$ = 28					; size = 4
_Constant$ = 32						; size = 4
_ApplyToAlpha$ = 36					; size = 4
_ApplyToRed$ = 40					; size = 4
_ApplyToGreen$ = 44					; size = 4
_ApplyToBlue$ = 48					; size = 4
_PixelMathLogicalOperation@44 PROC

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 100  : 	if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN8@PixelMathL

; 101  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PixelMathL
$LN8@PixelMathL:

; 102  : 	if (DestinationBuffer == NULL)

	cmp	DWORD PTR _DestinationBuffer$[ebp], 0
	jne	SHORT $LN9@PixelMathL

; 103  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PixelMathL
$LN9@PixelMathL:

; 104  : 	if (Operation < PixelMathLogicalAnd || Operation > pixelMathRandomWithMask)

	cmp	DWORD PTR _Operation$[ebp], 0
	jl	SHORT $LN11@PixelMathL
	cmp	DWORD PTR _Operation$[ebp], 8
	jle	SHORT $LN10@PixelMathL
$LN11@PixelMathL:

; 105  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PixelMathL
$LN10@PixelMathL:

; 106  : 
; 107  : 	BYTE *Source = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 108  : 	BYTE *Destination = (BYTE *)DestinationBuffer;

	mov	ecx, DWORD PTR _DestinationBuffer$[ebp]
	mov	DWORD PTR _Destination$[ebp], ecx

; 109  : 
; 110  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 111  : 
; 112  : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@PixelMathL
$LN2@PixelMathL:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@PixelMathL:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@PixelMathL

; 113  : 	{
; 114  : 		int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 115  : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@PixelMathL
$LN5@PixelMathL:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@PixelMathL:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@PixelMathL

; 116  : 		{
; 117  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 118  : 			BYTE A = Source[Index + 3];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 119  : 			BYTE R = Source[Index + 2];

	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$7[ebp], dl

; 120  : 			BYTE G = Source[Index + 1];

	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$6[ebp], cl

; 121  : 			BYTE B = Source[Index + 0];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$5[ebp], al

; 122  : 
; 123  : 			if (ApplyToAlpha)

	cmp	DWORD PTR _ApplyToAlpha$[ebp], 0
	je	SHORT $LN12@PixelMathL

; 124  : 				A = ExecuteOperation(A, Operation, Constant);

	mov	ecx, DWORD PTR _Constant$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Operation$[ebp]
	push	edx
	movzx	eax, BYTE PTR _A$8[ebp]
	push	eax
	call	?ExecuteOperation@@YGEEHH@Z		; ExecuteOperation
	mov	BYTE PTR _A$8[ebp], al
$LN12@PixelMathL:

; 125  : 			if (ApplyToRed)

	cmp	DWORD PTR _ApplyToRed$[ebp], 0
	je	SHORT $LN13@PixelMathL

; 126  : 				R = ExecuteOperation(R, Operation, Constant);

	mov	ecx, DWORD PTR _Constant$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Operation$[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$7[ebp]
	push	eax
	call	?ExecuteOperation@@YGEEHH@Z		; ExecuteOperation
	mov	BYTE PTR _R$7[ebp], al
$LN13@PixelMathL:

; 127  : 			if (ApplyToGreen)

	cmp	DWORD PTR _ApplyToGreen$[ebp], 0
	je	SHORT $LN14@PixelMathL

; 128  : 				G = ExecuteOperation(G, Operation, Constant);

	mov	ecx, DWORD PTR _Constant$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Operation$[ebp]
	push	edx
	movzx	eax, BYTE PTR _G$6[ebp]
	push	eax
	call	?ExecuteOperation@@YGEEHH@Z		; ExecuteOperation
	mov	BYTE PTR _G$6[ebp], al
$LN14@PixelMathL:

; 129  : 			if (ApplyToBlue)

	cmp	DWORD PTR _ApplyToBlue$[ebp], 0
	je	SHORT $LN15@PixelMathL

; 130  : 				B = ExecuteOperation(B, Operation, Constant);

	mov	ecx, DWORD PTR _Constant$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Operation$[ebp]
	push	edx
	movzx	eax, BYTE PTR _B$5[ebp]
	push	eax
	call	?ExecuteOperation@@YGEEHH@Z		; ExecuteOperation
	mov	BYTE PTR _B$5[ebp], al
$LN15@PixelMathL:

; 131  : 
; 132  : 			Destination[Index + 3] = A;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 133  : 			Destination[Index + 2] = R;

	mov	eax, DWORD PTR _Destination$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [eax+2], cl

; 134  : 			Destination[Index + 1] = G;

	mov	edx, DWORD PTR _Destination$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [edx+1], al

; 135  : 			Destination[Index + 0] = B;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _B$5[ebp]
	mov	BYTE PTR [ecx], dl

; 136  : 		}

	jmp	$LN5@PixelMathL
$LN6@PixelMathL:

; 137  : 	}

	jmp	$LN2@PixelMathL
$LN3@PixelMathL:

; 138  : 
; 139  : 	return Success;

	xor	eax, eax
$LN1@PixelMathL:

; 140  : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_PixelMathLogicalOperation@44 ENDP
_TEXT	ENDS
END
