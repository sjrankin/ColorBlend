; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Luminance.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_InvertLuminance@28
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@406fe00000000000
EXTRN	_RGBtoHSL2@24:PROC
EXTRN	_HSLtoRGB2@36:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\luminance.cpp
_TEXT	SEGMENT
_H$1 = -56						; size = 8
_S$2 = -48						; size = 8
_L$3 = -40						; size = 8
_RowOffset$4 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Src$ = -24						; size = 4
_Dest$ = -20						; size = 4
_Column$5 = -16						; size = 4
_Row$6 = -12						; size = 4
_Index$7 = -8						; size = 4
_WL$8 = -4						; size = 1
_B$9 = -3						; size = 1
_G$10 = -2						; size = 1
_R$11 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_UseThreshold$ = 28					; size = 4
_LuminanceThreshold$ = 32				; size = 1
_InvertLuminance@28 PROC

; 8    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 9    :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@InvertLumi

; 10   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@InvertLumi
$LN8@InvertLumi:

; 11   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN9@InvertLumi

; 12   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@InvertLumi
$LN9@InvertLumi:

; 13   : 
; 14   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 15   :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 16   :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 17   : 
; 18   :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@InvertLumi
$LN2@InvertLumi:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@InvertLumi:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@InvertLumi

; 19   :     {
; 20   :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 21   :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@InvertLumi
$LN5@InvertLumi:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@InvertLumi:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@InvertLumi

; 22   :         {
; 23   :             int Index = RowOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 24   :             BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$11[ebp], al

; 25   :             BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$10[ebp], dl

; 26   :             BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$9[ebp], cl

; 27   :             /*
; 28   :             double Luminance = GetPixelLuminance(R, G, B);
; 29   :             SetPixelLuminance(&R, &G, &B, (1.0 - Luminance));
; 30   :             */
; 31   :             double H = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _H$1[ebp], xmm0

; 32   :             double S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$2[ebp], xmm0

; 33   :             double L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$3[ebp], xmm0

; 34   :             RGBtoHSL2(R, G, B, &H, &S, &L);

	lea	edx, DWORD PTR _L$3[ebp]
	push	edx
	lea	eax, DWORD PTR _S$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _H$1[ebp]
	push	ecx
	movzx	edx, BYTE PTR _B$9[ebp]
	push	edx
	movzx	eax, BYTE PTR _G$10[ebp]
	push	eax
	movzx	ecx, BYTE PTR _R$11[ebp]
	push	ecx
	call	_RGBtoHSL2@24

; 35   :             BYTE WL = (BYTE)(L * 255.0);

	movsd	xmm0, QWORD PTR _L$3[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si edx, xmm0
	mov	BYTE PTR _WL$8[ebp], dl

; 36   :             if (UseThreshold)

	cmp	DWORD PTR _UseThreshold$[ebp], 0
	je	SHORT $LN10@InvertLumi

; 37   :             {
; 38   :                 if (WL >= LuminanceThreshold)

	movzx	eax, BYTE PTR _WL$8[ebp]
	movzx	ecx, BYTE PTR _LuminanceThreshold$[ebp]
	cmp	eax, ecx
	jl	SHORT $LN12@InvertLumi

; 39   :                     L = 1.0 - L;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _L$3[ebp]
	movsd	QWORD PTR _L$3[ebp], xmm0
$LN12@InvertLumi:

; 40   :                 //                    L = (double)((0xff - WL) / 255.0);
; 41   :             }
; 42   :             else

	jmp	SHORT $LN11@InvertLumi
$LN10@InvertLumi:

; 43   :                 //                L = (double)((0xff - WL) / 255.0);
; 44   :                 L = 1.0 - L;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _L$3[ebp]
	movsd	QWORD PTR _L$3[ebp], xmm0
$LN11@InvertLumi:

; 45   :             HSLtoRGB2(H, S, L, &R, &G, &B);

	lea	edx, DWORD PTR _B$9[ebp]
	push	edx
	lea	eax, DWORD PTR _G$10[ebp]
	push	eax
	lea	ecx, DWORD PTR _R$11[ebp]
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB2@36

; 46   :             Dest[Index + 3] = 0xff;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH

; 47   :             Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [eax+2], cl

; 48   :             Dest[Index + 1] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [edx+1], al

; 49   :             Dest[Index + 0] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [ecx], dl

; 50   :         }

	jmp	$LN5@InvertLumi
$LN6@InvertLumi:

; 51   :     }

	jmp	$LN2@InvertLumi
$LN3@InvertLumi:

; 52   : 
; 53   :     return Success;

	xor	eax, eax
$LN1@InvertLumi:

; 54   : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_InvertLuminance@28 ENDP
_TEXT	ENDS
END
