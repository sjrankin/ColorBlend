; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Steganography.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_RandomizeImageBitsRegion@60
PUBLIC	_RandomizeImageBits1@44
PUBLIC	_RandomizeImageBits2@28
PUBLIC	_AddDataToRegion@72
PUBLIC	_AddData1@56
PUBLIC	_AddData2@48
PUBLIC	_AddData3@32
PUBLIC	_AddStringToRegion@72
PUBLIC	_AddString1@56
PUBLIC	_AddString2@48
PUBLIC	_AddString3@32
PUBLIC	_BytesRequiredToFit@8
PUBLIC	_CanFit@48
PUBLIC	_DataMerge@48
PUBLIC	?RandomizeByte@@YGEEEI@Z			; RandomizeByte
PUBLIC	?BytePerCharacter@@YGHE@Z			; BytePerCharacter
PUBLIC	?SwapBytes@@YGXAAE0@Z				; SwapBytes
PUBLIC	?SetBits@@YGEEEE@Z				; SetBits
PUBLIC	?MaskOffset@@YGHE@Z				; MaskOffset
PUBLIC	?GetBits@@YGEEE@Z				; GetBits
PUBLIC	?SplitData@@YGXPAXHEPAEAAH@Z			; SplitData
PUBLIC	?MakeHeader@@YGHEIPAE@Z				; MakeHeader
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__srand:PROC
EXTRN	__imp__rand:PROC
EXTRN	?BitCountTable2@@YGHE@Z:PROC			; BitCountTable2
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
_HeaderSize$ = -12					; size = 4
tv67 = -8						; size = 4
_s$ = -1						; size = 1
_SplitSize$ = 8						; size = 1
_DataCount$ = 12					; size = 4
_Header$ = 16						; size = 4
?MakeHeader@@YGHEIPAE@Z PROC				; MakeHeader

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 430  :     int HeaderSize = 5 * SplitSize == 4 ? 2 : 4;

	movzx	eax, BYTE PTR _SplitSize$[ebp]
	imul	ecx, eax, 5
	cmp	ecx, 4
	jne	SHORT $LN5@MakeHeader
	mov	DWORD PTR tv67[ebp], 2
	jmp	SHORT $LN6@MakeHeader
$LN5@MakeHeader:
	mov	DWORD PTR tv67[ebp], 4
$LN6@MakeHeader:
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR _HeaderSize$[ebp], edx

; 431  :     Header = new BYTE[HeaderSize];

	mov	eax, DWORD PTR _HeaderSize$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _Header$[ebp], ecx

; 432  :     BYTE s = 0;

	mov	BYTE PTR _s$[ebp], 0

; 433  :     if (SplitSize == 4)

	movzx	edx, BYTE PTR _SplitSize$[ebp]
	cmp	edx, 4
	jne	$LN2@MakeHeader

; 434  :     {
; 435  :         Header[0] = (SplitSize & 0xf0) >> 4;

	movzx	eax, BYTE PTR _SplitSize$[ebp]
	and	eax, 240				; 000000f0H
	sar	eax, 4
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 436  :         Header[1] = (SplitSize & 0x0f);

	movzx	edx, BYTE PTR _SplitSize$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 437  :         s = (DataCount & 0xff000000) >> 24;

	mov	edx, DWORD PTR _DataCount$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _s$[ebp], dl

; 438  :         Header[2] = (s & 0xf0) >> 4;

	movzx	eax, BYTE PTR _s$[ebp]
	and	eax, 240				; 000000f0H
	sar	eax, 4
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 439  :         Header[3] = (s & 0x0f);

	movzx	eax, BYTE PTR _s$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 440  :         s = (DataCount & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _DataCount$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _s$[ebp], dl

; 441  :         Header[4] = (s & 0xf0) >> 4;

	movzx	eax, BYTE PTR _s$[ebp]
	and	eax, 240				; 000000f0H
	sar	eax, 4
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 442  :         Header[5] = (s & 0x0f);

	movzx	eax, BYTE PTR _s$[ebp]
	and	eax, 15					; 0000000fH
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 443  :         s = (DataCount & 0x0000ff00) >> 8;

	mov	edx, DWORD PTR _DataCount$[ebp]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _s$[ebp], dl

; 444  :         Header[6] = (s & 0xf0) >> 4;

	movzx	eax, BYTE PTR _s$[ebp]
	and	eax, 240				; 000000f0H
	sar	eax, 4
	mov	ecx, 1
	imul	edx, ecx, 6
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 445  :         Header[7] = (s & 0x0f);

	movzx	edx, BYTE PTR _s$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 1
	imul	ecx, eax, 7
	mov	eax, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 446  :         s = (DataCount & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _DataCount$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _s$[ebp], cl

; 447  :         Header[8] = (s & 0xf0) >> 4;

	movzx	edx, BYTE PTR _s$[ebp]
	and	edx, 240				; 000000f0H
	sar	edx, 4
	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 448  :         Header[9] = (s & 0x0f);

	movzx	edx, BYTE PTR _s$[ebp]
	and	edx, 15					; 0000000fH
	mov	eax, 1
	imul	ecx, eax, 9
	mov	eax, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 449  :     }
; 450  :     else

	jmp	$LN3@MakeHeader
$LN2@MakeHeader:

; 451  :     {
; 452  :         Header[0] = (SplitSize & 0xc0) >> 6;

	movzx	ecx, BYTE PTR _SplitSize$[ebp]
	and	ecx, 192				; 000000c0H
	sar	ecx, 6
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 453  :         Header[1] = (SplitSize & 0x30) >> 4;

	movzx	eax, BYTE PTR _SplitSize$[ebp]
	and	eax, 48					; 00000030H
	sar	eax, 4
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 454  :         Header[2] = (SplitSize & 0x0c) >> 2;

	movzx	eax, BYTE PTR _SplitSize$[ebp]
	and	eax, 12					; 0000000cH
	sar	eax, 2
	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 455  :         Header[3] = (SplitSize & 0x03);

	movzx	eax, BYTE PTR _SplitSize$[ebp]
	and	eax, 3
	mov	ecx, 1
	imul	edx, ecx, 3
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 456  :         s = (DataCount & 0xff000000) >> 24;

	mov	edx, DWORD PTR _DataCount$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _s$[ebp], dl

; 457  :         Header[4] = (s & 0xc0) >> 6;

	movzx	eax, BYTE PTR _s$[ebp]
	and	eax, 192				; 000000c0H
	sar	eax, 6
	mov	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 458  :         Header[5] = (s & 0x30) >> 4;

	movzx	eax, BYTE PTR _s$[ebp]
	and	eax, 48					; 00000030H
	sar	eax, 4
	mov	ecx, 1
	imul	edx, ecx, 5
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 459  :         Header[6] = (s & 0x0c) >> 2;

	movzx	edx, BYTE PTR _s$[ebp]
	and	edx, 12					; 0000000cH
	sar	edx, 2
	mov	eax, 1
	imul	ecx, eax, 6
	mov	eax, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 460  :         Header[7] = (s & 0x03);

	movzx	ecx, BYTE PTR _s$[ebp]
	and	ecx, 3
	mov	edx, 1
	imul	eax, edx, 7
	mov	edx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 461  :         s = (DataCount & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _DataCount$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _s$[ebp], al

; 462  :         Header[8] = (s & 0xc0) >> 6;

	movzx	ecx, BYTE PTR _s$[ebp]
	and	ecx, 192				; 000000c0H
	sar	ecx, 6
	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 463  :         Header[9] = (s & 0x30) >> 4;

	movzx	ecx, BYTE PTR _s$[ebp]
	and	ecx, 48					; 00000030H
	sar	ecx, 4
	mov	edx, 1
	imul	eax, edx, 9
	mov	edx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 464  :         Header[10] = (s & 0x0c) >> 2;

	movzx	eax, BYTE PTR _s$[ebp]
	and	eax, 12					; 0000000cH
	sar	eax, 2
	mov	ecx, 1
	imul	edx, ecx, 10
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 465  :         Header[11] = (s & 0x03);

	movzx	edx, BYTE PTR _s$[ebp]
	and	edx, 3
	mov	eax, 1
	imul	ecx, eax, 11
	mov	eax, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 466  :         s = (DataCount & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _DataCount$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _s$[ebp], cl

; 467  :         Header[12] = (s & 0xc0) >> 6;

	movzx	edx, BYTE PTR _s$[ebp]
	and	edx, 192				; 000000c0H
	sar	edx, 6
	mov	eax, 1
	imul	ecx, eax, 12
	mov	eax, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 468  :         Header[13] = (s & 0x30) >> 4;

	movzx	ecx, BYTE PTR _s$[ebp]
	and	ecx, 48					; 00000030H
	sar	ecx, 4
	mov	edx, 1
	imul	eax, edx, 13
	mov	edx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 469  :         Header[14] = (s & 0x0c) >> 2;

	movzx	eax, BYTE PTR _s$[ebp]
	and	eax, 12					; 0000000cH
	sar	eax, 2
	mov	ecx, 1
	imul	edx, ecx, 14
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 470  :         Header[15] = (s & 0x03);

	movzx	edx, BYTE PTR _s$[ebp]
	and	edx, 3
	mov	eax, 1
	imul	ecx, eax, 15
	mov	eax, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 471  :         s = (DataCount & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _DataCount$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _s$[ebp], cl

; 472  :         Header[16] = (s & 0xc0) >> 6;

	movzx	edx, BYTE PTR _s$[ebp]
	and	edx, 192				; 000000c0H
	sar	edx, 6
	mov	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 473  :         Header[17] = (s & 0x30) >> 4;

	movzx	edx, BYTE PTR _s$[ebp]
	and	edx, 48					; 00000030H
	sar	edx, 4
	mov	eax, 1
	imul	ecx, eax, 17
	mov	eax, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 474  :         Header[18] = (s & 0x0c) >> 2;

	movzx	ecx, BYTE PTR _s$[ebp]
	and	ecx, 12					; 0000000cH
	sar	ecx, 2
	mov	edx, 1
	imul	eax, edx, 18
	mov	edx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 475  :         Header[19] = (s & 0x03);

	movzx	eax, BYTE PTR _s$[ebp]
	and	eax, 3
	mov	ecx, 1
	imul	edx, ecx, 19
	mov	ecx, DWORD PTR _Header$[ebp]
	mov	BYTE PTR [ecx+edx], al
$LN3@MakeHeader:

; 476  :     }
; 477  :     return HeaderSize;

	mov	eax, DWORD PTR _HeaderSize$[ebp]

; 478  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MakeHeader@@YGHEIPAE@Z ENDP				; MakeHeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Index$1 = -20						; size = 4
$T2 = -16						; size = 4
_BytesPerByte$ = -12					; size = 4
_k$3 = -8						; size = 4
_i$4 = -4						; size = 4
_Data$ = 8						; size = 4
_DataLength$ = 12					; size = 4
_ChannelMask$ = 16					; size = 1
_BrokenData$ = 20					; size = 4
_BrokenDataCount$ = 24					; size = 4
?SplitData@@YGXPAXHEPAEAAH@Z PROC			; SplitData

; 319  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 320  :     BrokenDataCount = BytesRequiredToFit(ChannelMask, DataLength);

	mov	eax, DWORD PTR _DataLength$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _ChannelMask$[ebp]
	push	ecx
	call	_BytesRequiredToFit@8
	mov	edx, DWORD PTR _BrokenDataCount$[ebp]
	mov	DWORD PTR [edx], eax

; 321  :     BrokenData = (BYTE *)new BYTE[BrokenDataCount];

	mov	eax, DWORD PTR _BrokenDataCount$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _BrokenData$[ebp], edx

; 322  :     int BytesPerByte = BytePerCharacter(ChannelMask);

	movzx	eax, BYTE PTR _ChannelMask$[ebp]
	push	eax
	call	?BytePerCharacter@@YGHE@Z		; BytePerCharacter
	mov	DWORD PTR _BytesPerByte$[ebp], eax

; 323  :     for (int i = 0; i < BrokenDataCount; i += BytesPerByte)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN4@SplitData
$LN2@SplitData:
	mov	ecx, DWORD PTR _i$4[ebp]
	add	ecx, DWORD PTR _BytesPerByte$[ebp]
	mov	DWORD PTR _i$4[ebp], ecx
$LN4@SplitData:
	mov	edx, DWORD PTR _BrokenDataCount$[ebp]
	mov	eax, DWORD PTR _i$4[ebp]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN1@SplitData

; 324  :     {
; 325  :         for (int k = 0; k < BytesPerByte; k++)

	mov	DWORD PTR _k$3[ebp], 0
	jmp	SHORT $LN7@SplitData
$LN5@SplitData:
	mov	ecx, DWORD PTR _k$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$3[ebp], ecx
$LN7@SplitData:
	mov	edx, DWORD PTR _k$3[ebp]
	cmp	edx, DWORD PTR _BytesPerByte$[ebp]
	jge	SHORT $LN6@SplitData

; 326  :         {
; 327  :             int Index = i + k;

	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, DWORD PTR _k$3[ebp]
	mov	DWORD PTR _Index$1[ebp], eax

; 328  : 
; 329  :         }

	jmp	SHORT $LN5@SplitData
$LN6@SplitData:

; 330  :     }

	jmp	SHORT $LN2@SplitData
$LN1@SplitData:

; 331  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?SplitData@@YGXPAXHEPAEAAH@Z ENDP			; SplitData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Final$ = -1						; size = 1
_Source$ = 8						; size = 1
_Mask$ = 12						; size = 1
?GetBits@@YGEEE@Z PROC					; GetBits

; 236  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 237  :     BYTE Final = Source & Mask;

	movzx	eax, BYTE PTR _Source$[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	mov	BYTE PTR _Final$[ebp], al

; 238  :     Final >>= MaskOffset(Mask);

	movzx	edx, BYTE PTR _Mask$[ebp]
	push	edx
	call	?MaskOffset@@YGHE@Z			; MaskOffset
	mov	dl, BYTE PTR _Final$[ebp]
	mov	cl, al
	shr	dl, cl
	mov	BYTE PTR _Final$[ebp], dl

; 239  :     return Final;

	mov	al, BYTE PTR _Final$[ebp]

; 240  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GetBits@@YGEEE@Z ENDP					; GetBits
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Count$ = -4						; size = 4
_Mask$ = 8						; size = 1
?MaskOffset@@YGHE@Z PROC				; MaskOffset

; 211  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 212  :     int Count;
; 213  :     if (Mask)

	movzx	eax, BYTE PTR _Mask$[ebp]
	test	eax, eax
	je	SHORT $LN5@MaskOffset

; 214  :     {
; 215  :         Mask = (Mask ^ (Mask - 1)) >> 1;

	movzx	ecx, BYTE PTR _Mask$[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	sub	edx, 1
	xor	ecx, edx
	sar	ecx, 1
	mov	BYTE PTR _Mask$[ebp], cl

; 216  :         for (Count = 0; Mask; Count++)

	mov	DWORD PTR _Count$[ebp], 0
	jmp	SHORT $LN4@MaskOffset
$LN2@MaskOffset:
	mov	eax, DWORD PTR _Count$[ebp]
	add	eax, 1
	mov	DWORD PTR _Count$[ebp], eax
$LN4@MaskOffset:
	movzx	ecx, BYTE PTR _Mask$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@MaskOffset

; 217  :         {
; 218  :             Mask >>= 1;

	mov	dl, BYTE PTR _Mask$[ebp]
	shr	dl, 1
	mov	BYTE PTR _Mask$[ebp], dl

; 219  :         }

	jmp	SHORT $LN2@MaskOffset
$LN3@MaskOffset:

; 220  :     }
; 221  :     else

	jmp	SHORT $LN6@MaskOffset
$LN5@MaskOffset:

; 222  :     {
; 223  :         Count = 0;

	mov	DWORD PTR _Count$[ebp], 0
$LN6@MaskOffset:

; 224  :     }
; 225  :     return Count;

	mov	eax, DWORD PTR _Count$[ebp]

; 226  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MaskOffset@@YGHE@Z ENDP				; MaskOffset
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Final$ = -1						; size = 1
_Source$ = 8						; size = 1
_Mask$ = 12						; size = 1
_Data$ = 16						; size = 1
?SetBits@@YGEEEE@Z PROC					; SetBits

; 200  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 201  :     BYTE Final = Source ^ ((Source ^ Data) & Mask);

	movzx	eax, BYTE PTR _Source$[ebp]
	movzx	ecx, BYTE PTR _Source$[ebp]
	movzx	edx, BYTE PTR _Data$[ebp]
	xor	ecx, edx
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	xor	eax, ecx
	mov	BYTE PTR _Final$[ebp], al

; 202  :     return Final;

	mov	al, BYTE PTR _Final$[ebp]

; 203  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetBits@@YGEEEE@Z ENDP					; SetBits
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_First$ = 8						; size = 4
_Second$ = 12						; size = 4
?SwapBytes@@YGXAAE0@Z PROC				; SwapBytes

; 190  : {

	push	ebp
	mov	ebp, esp

; 191  :     if (First == Second)

	mov	eax, DWORD PTR _First$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _Second$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN2@SwapBytes

; 192  :         return;

	jmp	SHORT $LN1@SwapBytes
$LN2@SwapBytes:

; 193  :     First ^= Second;

	mov	ecx, DWORD PTR _Second$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _First$[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	ecx, edx
	mov	edx, DWORD PTR _First$[ebp]
	mov	BYTE PTR [edx], cl

; 194  :     Second ^= First;

	mov	eax, DWORD PTR _First$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _Second$[ebp]
	movzx	eax, BYTE PTR [edx]
	xor	eax, ecx
	mov	ecx, DWORD PTR _Second$[ebp]
	mov	BYTE PTR [ecx], al

; 195  :     First ^= Second;

	mov	edx, DWORD PTR _Second$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _First$[ebp]
	movzx	edx, BYTE PTR [ecx]
	xor	edx, eax
	mov	eax, DWORD PTR _First$[ebp]
	mov	BYTE PTR [eax], dl
$LN1@SwapBytes:

; 196  : }

	pop	ebp
	ret	8
?SwapBytes@@YGXAAE0@Z ENDP				; SwapBytes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_BAdditional$ = -12					; size = 8
_Bits$ = -4						; size = 4
_ChannelMask$ = 8					; size = 1
?BytePerCharacter@@YGHE@Z PROC				; BytePerCharacter

; 137  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 138  :     int Bits = BitCountTable2(ChannelMask);

	movzx	eax, BYTE PTR _ChannelMask$[ebp]
	push	eax
	call	?BitCountTable2@@YGHE@Z			; BitCountTable2
	mov	DWORD PTR _Bits$[ebp], eax

; 139  :     if (Bits <= 0)

	cmp	DWORD PTR _Bits$[ebp], 0
	jg	SHORT $LN2@BytePerCha

; 140  :         return -1;

	or	eax, -1
	jmp	SHORT $LN1@BytePerCha
$LN2@BytePerCha:

; 141  :     double BAdditional = 8 % Bits;

	mov	eax, 8
	cdq
	idiv	DWORD PTR _Bits$[ebp]
	cvtsi2sd xmm0, edx
	movsd	QWORD PTR _BAdditional$[ebp], xmm0

; 142  :     return (8 / Bits) + BAdditional;

	mov	eax, 8
	cdq
	idiv	DWORD PTR _Bits$[ebp]
	cvtsi2sd xmm0, eax
	addsd	xmm0, QWORD PTR _BAdditional$[ebp]
	cvttsd2si eax, xmm0
$LN1@BytePerCha:

; 143  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?BytePerCharacter@@YGHE@Z ENDP				; BytePerCharacter
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Result$ = -2						; size = 1
_RValue$ = -1						; size = 1
_Source$ = 8						; size = 1
_RandomizeMask$ = 12					; size = 1
_RandomSeed$ = 16					; size = 4
?RandomizeByte@@YGEEEI@Z PROC				; RandomizeByte

; 8    : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 9    :     srand(RandomSeed);

	mov	eax, DWORD PTR _RandomSeed$[ebp]
	push	eax
	call	DWORD PTR __imp__srand
	add	esp, 4

; 10   :     BYTE RValue = (BYTE)rand();

	call	DWORD PTR __imp__rand
	mov	BYTE PTR _RValue$[ebp], al

; 11   :     RValue = RValue & RandomizeMask;

	movzx	ecx, BYTE PTR _RValue$[ebp]
	movzx	edx, BYTE PTR _RandomizeMask$[ebp]
	and	ecx, edx
	mov	BYTE PTR _RValue$[ebp], cl

; 12   :     BYTE Result = (Source & ~RandomizeMask) | RValue;

	movzx	eax, BYTE PTR _Source$[ebp]
	movzx	ecx, BYTE PTR _RandomizeMask$[ebp]
	not	ecx
	and	eax, ecx
	movzx	edx, BYTE PTR _RValue$[ebp]
	or	eax, edx
	mov	BYTE PTR _Result$[ebp], al

; 13   :     return Result;

	mov	al, BYTE PTR _Result$[ebp]

; 14   : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?RandomizeByte@@YGEEEI@Z ENDP				; RandomizeByte
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
$T1 = -104						; size = 4
$T2 = -100						; size = 4
_RowOffset$3 = -96					; size = 4
_PixelSize$ = -92					; size = 4
$T4 = -88						; size = 4
$T5 = -84						; size = 4
$T6 = -80						; size = 4
_HeaderSize$ = -76					; size = 4
tv185 = -72						; size = 4
tv181 = -68						; size = 4
tv177 = -64						; size = 4
tv73 = -60						; size = 4
_Header$ = -56						; size = 4
_HeaderIndex$ = -52					; size = 4
_DataMultiplier$ = -48					; size = 4
_Column$7 = -44						; size = 4
_Row$8 = -40						; size = 4
_MergeBytes$ = -36					; size = 4
_Data$ = -32						; size = 4
_SplitBits$ = -28					; size = 4
_Src$ = -24						; size = 4
_Dest$ = -20						; size = 4
_DataIndex$ = -16					; size = 4
_SplitIndex$ = -12					; size = 4
_Index$9 = -8						; size = 4
_MergeMask$ = -2					; size = 1
_MergeValue$10 = -1					; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_DataBuffer$ = 28					; size = 4
_DataCount$ = 32					; size = 4
_ByTwo$ = 36						; size = 4
_IncludeAlpha$ = 40					; size = 4
_IncludeRed$ = 44					; size = 4
_IncludeGreen$ = 48					; size = 4
_IncludeBlue$ = 52					; size = 4
_DataMerge@48 PROC

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H

; 503  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN10@DataMerge

; 504  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@DataMerge
$LN10@DataMerge:

; 505  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN11@DataMerge

; 506  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@DataMerge
$LN11@DataMerge:

; 507  :     if (DataBuffer == NULL)

	cmp	DWORD PTR _DataBuffer$[ebp], 0
	jne	SHORT $LN12@DataMerge

; 508  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@DataMerge
$LN12@DataMerge:

; 509  :     if (!IncludeAlpha && !IncludeRed && !IncludeGreen && !IncludeBlue)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	jne	SHORT $LN13@DataMerge
	cmp	DWORD PTR _IncludeRed$[ebp], 0
	jne	SHORT $LN13@DataMerge
	cmp	DWORD PTR _IncludeGreen$[ebp], 0
	jne	SHORT $LN13@DataMerge
	cmp	DWORD PTR _IncludeBlue$[ebp], 0
	jne	SHORT $LN13@DataMerge

; 510  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@DataMerge
$LN13@DataMerge:

; 511  :     if (DataCount < 1)

	cmp	DWORD PTR _DataCount$[ebp], 1
	jae	SHORT $LN14@DataMerge

; 512  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@DataMerge
$LN14@DataMerge:

; 513  : 
; 514  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 515  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 516  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 517  :     BYTE *Data = (BYTE *)DataBuffer;

	mov	edx, DWORD PTR _DataBuffer$[ebp]
	mov	DWORD PTR _Data$[ebp], edx

; 518  : 
; 519  :     int DataMultiplier = ByTwo ? 4 : 2;

	cmp	DWORD PTR _ByTwo$[ebp], 0
	je	SHORT $LN41@DataMerge
	mov	DWORD PTR tv73[ebp], 4
	jmp	SHORT $LN42@DataMerge
$LN41@DataMerge:
	mov	DWORD PTR tv73[ebp], 2
$LN42@DataMerge:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR _DataMultiplier$[ebp], eax

; 520  :     BYTE *SplitBits = (BYTE *)new BYTE[DataCount * DataMultiplier];

	mov	ecx, DWORD PTR _DataCount$[ebp]
	imul	ecx, DWORD PTR _DataMultiplier$[ebp]
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	edx, DWORD PTR $T6[ebp]
	mov	DWORD PTR _SplitBits$[ebp], edx

; 521  :     unsigned DataIndex = 0;

	mov	DWORD PTR _DataIndex$[ebp], 0

; 522  :     int SplitIndex = 0;

	mov	DWORD PTR _SplitIndex$[ebp], 0
$LN2@DataMerge:

; 523  : 
; 524  :     while (TRUE)

	mov	eax, 1
	test	eax, eax
	je	$LN3@DataMerge

; 525  :     {
; 526  :         if (ByTwo)

	cmp	DWORD PTR _ByTwo$[ebp], 0
	je	SHORT $LN15@DataMerge

; 527  :         {
; 528  :             SplitBits[SplitIndex++] = (Data[DataIndex] & 0xf0) >> 4;

	mov	ecx, DWORD PTR _Data$[ebp]
	add	ecx, DWORD PTR _DataIndex$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 240				; 000000f0H
	sar	edx, 4
	mov	eax, DWORD PTR _SplitBits$[ebp]
	add	eax, DWORD PTR _SplitIndex$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _SplitIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _SplitIndex$[ebp], ecx

; 529  :             SplitBits[SplitIndex++] = (Data[DataIndex] & 0x0f);

	mov	edx, DWORD PTR _Data$[ebp]
	add	edx, DWORD PTR _DataIndex$[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, 15					; 0000000fH
	mov	ecx, DWORD PTR _SplitBits$[ebp]
	add	ecx, DWORD PTR _SplitIndex$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _SplitIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _SplitIndex$[ebp], edx

; 530  :             if (SplitIndex == (DataCount * DataMultiplier) - 1)

	mov	eax, DWORD PTR _DataCount$[ebp]
	imul	eax, DWORD PTR _DataMultiplier$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _SplitIndex$[ebp], eax
	jne	SHORT $LN17@DataMerge

; 531  :                 break;

	jmp	$LN3@DataMerge
$LN17@DataMerge:

; 532  :         }
; 533  :         else

	jmp	$LN16@DataMerge
$LN15@DataMerge:

; 534  :         {
; 535  :             SplitBits[SplitIndex++] = (Data[DataIndex] & 0xc0) >> 6;

	mov	ecx, DWORD PTR _Data$[ebp]
	add	ecx, DWORD PTR _DataIndex$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 192				; 000000c0H
	sar	edx, 6
	mov	eax, DWORD PTR _SplitBits$[ebp]
	add	eax, DWORD PTR _SplitIndex$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _SplitIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _SplitIndex$[ebp], ecx

; 536  :             SplitBits[SplitIndex++] = (Data[DataIndex] & 0x30) >> 4;

	mov	edx, DWORD PTR _Data$[ebp]
	add	edx, DWORD PTR _DataIndex$[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, 48					; 00000030H
	sar	eax, 4
	mov	ecx, DWORD PTR _SplitBits$[ebp]
	add	ecx, DWORD PTR _SplitIndex$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _SplitIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _SplitIndex$[ebp], edx

; 537  :             SplitBits[SplitIndex++] = (Data[DataIndex] & 0x0c) >> 2;

	mov	eax, DWORD PTR _Data$[ebp]
	add	eax, DWORD PTR _DataIndex$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 12					; 0000000cH
	sar	ecx, 2
	mov	edx, DWORD PTR _SplitBits$[ebp]
	add	edx, DWORD PTR _SplitIndex$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _SplitIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _SplitIndex$[ebp], eax

; 538  :             SplitBits[SplitIndex++] = (Data[DataIndex] & 0x03);

	mov	ecx, DWORD PTR _Data$[ebp]
	add	ecx, DWORD PTR _DataIndex$[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 3
	mov	eax, DWORD PTR _SplitBits$[ebp]
	add	eax, DWORD PTR _SplitIndex$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _SplitIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _SplitIndex$[ebp], ecx

; 539  :             if (SplitIndex == (DataCount * DataMultiplier) - 1)

	mov	edx, DWORD PTR _DataCount$[ebp]
	imul	edx, DWORD PTR _DataMultiplier$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _SplitIndex$[ebp], edx
	jne	SHORT $LN16@DataMerge

; 540  :                 break;

	jmp	SHORT $LN3@DataMerge
$LN16@DataMerge:

; 541  :         }
; 542  :         DataIndex++;

	mov	eax, DWORD PTR _DataIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _DataIndex$[ebp], eax

; 543  :     }

	jmp	$LN2@DataMerge
$LN3@DataMerge:

; 544  :     DataIndex = 0;

	mov	DWORD PTR _DataIndex$[ebp], 0

; 545  : 
; 546  :     BYTE *Header = NULL;

	mov	DWORD PTR _Header$[ebp], 0

; 547  :     int HeaderSize = MakeHeader(ByTwo ? 2 : 4, DataCount, Header);

	cmp	DWORD PTR _ByTwo$[ebp], 0
	je	SHORT $LN43@DataMerge
	mov	DWORD PTR tv177[ebp], 2
	jmp	SHORT $LN44@DataMerge
$LN43@DataMerge:
	mov	DWORD PTR tv177[ebp], 4
$LN44@DataMerge:
	mov	ecx, DWORD PTR _Header$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DataCount$[ebp]
	push	edx
	movzx	eax, BYTE PTR tv177[ebp]
	push	eax
	call	?MakeHeader@@YGHEIPAE@Z			; MakeHeader
	mov	DWORD PTR _HeaderSize$[ebp], eax

; 548  :     int HeaderIndex = 0;

	mov	DWORD PTR _HeaderIndex$[ebp], 0

; 549  :     BOOL MergeBytes = TRUE;

	mov	DWORD PTR _MergeBytes$[ebp], 1

; 550  :     BYTE MergeMask = ByTwo ? 0x03 : 0x07;

	cmp	DWORD PTR _ByTwo$[ebp], 0
	je	SHORT $LN45@DataMerge
	mov	DWORD PTR tv181[ebp], 3
	jmp	SHORT $LN46@DataMerge
$LN45@DataMerge:
	mov	DWORD PTR tv181[ebp], 7
$LN46@DataMerge:
	mov	cl, BYTE PTR tv181[ebp]
	mov	BYTE PTR _MergeMask$[ebp], cl

; 551  :     if (HeaderSize + (DataCount * ByTwo ? 4 : 2) >= (Height * Stride))

	mov	edx, DWORD PTR _DataCount$[ebp]
	imul	edx, DWORD PTR _ByTwo$[ebp]
	test	edx, edx
	je	SHORT $LN47@DataMerge
	mov	DWORD PTR tv185[ebp], 4
	jmp	SHORT $LN48@DataMerge
$LN47@DataMerge:
	mov	DWORD PTR tv185[ebp], 2
$LN48@DataMerge:
	mov	eax, DWORD PTR _HeaderSize$[ebp]
	add	eax, DWORD PTR tv185[ebp]
	mov	ecx, DWORD PTR _Height$[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	cmp	eax, ecx
	jl	SHORT $LN19@DataMerge

; 552  :     {
; 553  :         delete[] Header;

	mov	edx, DWORD PTR _Header$[ebp]
	mov	DWORD PTR $T5[ebp], edx
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 554  :         delete[] SplitBits;

	mov	ecx, DWORD PTR _SplitBits$[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 555  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@DataMerge
$LN19@DataMerge:

; 556  :     }
; 557  : 
; 558  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$8[ebp], 0
	jmp	SHORT $LN6@DataMerge
$LN4@DataMerge:
	mov	eax, DWORD PTR _Row$8[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$8[ebp], eax
$LN6@DataMerge:
	mov	ecx, DWORD PTR _Row$8[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN5@DataMerge

; 559  :     {
; 560  :         int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$8[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], edx

; 561  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$7[ebp], 0
	jmp	SHORT $LN9@DataMerge
$LN7@DataMerge:
	mov	eax, DWORD PTR _Column$7[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$7[ebp], eax
$LN9@DataMerge:
	mov	ecx, DWORD PTR _Column$7[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	$LN8@DataMerge

; 562  :         {
; 563  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$7[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$9[ebp], edx

; 564  : 
; 565  :             if (DataIndex >= (DataCount * DataMultiplier) - 1)

	mov	eax, DWORD PTR _DataCount$[ebp]
	imul	eax, DWORD PTR _DataMultiplier$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _DataIndex$[ebp], eax
	jb	SHORT $LN20@DataMerge

; 566  :                 MergeBytes = FALSE;

	mov	DWORD PTR _MergeBytes$[ebp], 0
$LN20@DataMerge:

; 567  :             BYTE MergeValue = 0;

	mov	BYTE PTR _MergeValue$10[ebp], 0

; 568  :             if (MergeBytes)

	cmp	DWORD PTR _MergeBytes$[ebp], 0
	je	SHORT $LN21@DataMerge

; 569  :             {
; 570  :                 if (HeaderIndex < HeaderSize)

	mov	ecx, DWORD PTR _HeaderIndex$[ebp]
	cmp	ecx, DWORD PTR _HeaderSize$[ebp]
	jge	SHORT $LN22@DataMerge

; 571  :                     MergeValue = Header[HeaderIndex++];

	mov	edx, DWORD PTR _Header$[ebp]
	add	edx, DWORD PTR _HeaderIndex$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _MergeValue$10[ebp], al
	mov	ecx, DWORD PTR _HeaderIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _HeaderIndex$[ebp], ecx

; 572  :                 else

	jmp	SHORT $LN21@DataMerge
$LN22@DataMerge:

; 573  :                     MergeValue = SplitBits[DataIndex++];

	mov	edx, DWORD PTR _SplitBits$[ebp]
	add	edx, DWORD PTR _DataIndex$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _MergeValue$10[ebp], al
	mov	ecx, DWORD PTR _DataIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _DataIndex$[ebp], ecx
$LN21@DataMerge:

; 574  :             }
; 575  : 
; 576  :             if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN24@DataMerge

; 577  :             {
; 578  :                 if (MergeBytes)

	cmp	DWORD PTR _MergeBytes$[ebp], 0
	je	SHORT $LN26@DataMerge

; 579  :                     Dest[Index + 3] = SetBits(Src[Index + 3], MergeMask, MergeValue);

	movzx	edx, BYTE PTR _MergeValue$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _MergeMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	push	edx
	call	?SetBits@@YGEEEE@Z			; SetBits
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	BYTE PTR [ecx+3], al

; 580  :                 else

	jmp	SHORT $LN27@DataMerge
$LN26@DataMerge:

; 581  :                     Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl
$LN27@DataMerge:

; 582  :             }
; 583  :             else

	jmp	SHORT $LN25@DataMerge
$LN24@DataMerge:

; 584  :                 Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl
$LN25@DataMerge:

; 585  :             if (IncludeRed)

	cmp	DWORD PTR _IncludeRed$[ebp], 0
	je	SHORT $LN28@DataMerge

; 586  :             {
; 587  :                 if (MergeBytes)

	cmp	DWORD PTR _MergeBytes$[ebp], 0
	je	SHORT $LN30@DataMerge

; 588  :                     Dest[Index + 2] = SetBits(Src[Index + 2], MergeMask, MergeValue);

	movzx	edx, BYTE PTR _MergeValue$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _MergeMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	call	?SetBits@@YGEEEE@Z			; SetBits
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	BYTE PTR [ecx+2], al

; 589  :                 else

	jmp	SHORT $LN31@DataMerge
$LN30@DataMerge:

; 590  :                     Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl
$LN31@DataMerge:

; 591  :             }
; 592  :             else

	jmp	SHORT $LN29@DataMerge
$LN28@DataMerge:

; 593  :                 Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl
$LN29@DataMerge:

; 594  :             if (IncludeGreen)

	cmp	DWORD PTR _IncludeGreen$[ebp], 0
	je	SHORT $LN32@DataMerge

; 595  :             {
; 596  :                 if (MergeBytes)

	cmp	DWORD PTR _MergeBytes$[ebp], 0
	je	SHORT $LN34@DataMerge

; 597  :                     Dest[Index + 1] = SetBits(Src[Index + 1], MergeMask, MergeValue);

	movzx	edx, BYTE PTR _MergeValue$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _MergeMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	call	?SetBits@@YGEEEE@Z			; SetBits
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	BYTE PTR [ecx+1], al

; 598  :                 else

	jmp	SHORT $LN35@DataMerge
$LN34@DataMerge:

; 599  :                     Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl
$LN35@DataMerge:

; 600  :             }
; 601  :             else

	jmp	SHORT $LN33@DataMerge
$LN32@DataMerge:

; 602  :                 Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl
$LN33@DataMerge:

; 603  :             if (IncludeBlue)

	cmp	DWORD PTR _IncludeBlue$[ebp], 0
	je	SHORT $LN36@DataMerge

; 604  :             {
; 605  :                 if (MergeBytes)

	cmp	DWORD PTR _MergeBytes$[ebp], 0
	je	SHORT $LN38@DataMerge

; 606  :                     Dest[Index + 0] = SetBits(Src[Index + 0], MergeMask, MergeValue);

	movzx	edx, BYTE PTR _MergeValue$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _MergeMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?SetBits@@YGEEEE@Z			; SetBits
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	BYTE PTR [ecx], al

; 607  :                 else

	jmp	SHORT $LN39@DataMerge
$LN38@DataMerge:

; 608  :                     Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
$LN39@DataMerge:

; 609  :             }
; 610  :             else

	jmp	SHORT $LN37@DataMerge
$LN36@DataMerge:

; 611  :                 Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
$LN37@DataMerge:

; 612  :         }

	jmp	$LN7@DataMerge
$LN8@DataMerge:

; 613  :     }

	jmp	$LN4@DataMerge
$LN5@DataMerge:

; 614  : 
; 615  :     delete[] Header;

	mov	edx, DWORD PTR _Header$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 616  :     delete[] SplitBits;

	mov	ecx, DWORD PTR _SplitBits$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 617  :     return Success;

	xor	eax, eax
$LN1@DataMerge:

; 618  : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_DataMerge@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_BytesAvailable$ = -36					; size = 4
_FinalHeight$ = -32					; size = 4
_FinalWidth$ = -28					; size = 4
_FinalTop$ = -24					; size = 4
_FinalLeft$ = -20					; size = 4
tv76 = -16						; size = 4
tv74 = -12						; size = 4
tv72 = -8						; size = 4
tv70 = -4						; size = 4
_Left$ = 8						; size = 4
_Top$ = 12						; size = 4
_Right$ = 16						; size = 4
_Bottom$ = 20						; size = 4
_RelativeXOffset$ = 24					; size = 4
_RelativeYOffset$ = 28					; size = 4
_IncludeAlpha$ = 32					; size = 4
_IncludeRed$ = 36					; size = 4
_IncludeGreen$ = 40					; size = 4
_IncludeBlue$ = 44					; size = 4
_ChannelMask$ = 48					; size = 1
_TextLength$ = 52					; size = 4
_CanFit@48 PROC

; 177  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 178  :     int FinalLeft = Left + RelativeXOffset;

	mov	eax, DWORD PTR _Left$[ebp]
	add	eax, DWORD PTR _RelativeXOffset$[ebp]
	mov	DWORD PTR _FinalLeft$[ebp], eax

; 179  :     int FinalTop = Top + RelativeYOffset;

	mov	ecx, DWORD PTR _Top$[ebp]
	add	ecx, DWORD PTR _RelativeYOffset$[ebp]
	mov	DWORD PTR _FinalTop$[ebp], ecx

; 180  :     int FinalWidth = Right - FinalLeft;

	mov	edx, DWORD PTR _Right$[ebp]
	sub	edx, DWORD PTR _FinalLeft$[ebp]
	mov	DWORD PTR _FinalWidth$[ebp], edx

; 181  :     int FinalHeight = Bottom - FinalTop;

	mov	eax, DWORD PTR _Bottom$[ebp]
	sub	eax, DWORD PTR _FinalTop$[ebp]
	mov	DWORD PTR _FinalHeight$[ebp], eax

; 182  :     int BytesAvailable = (FinalWidth * FinalHeight) *

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN10@CanFit
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN11@CanFit
$LN10@CanFit:
	cmp	DWORD PTR _IncludeRed$[ebp], 0
	je	SHORT $LN8@CanFit
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN9@CanFit
$LN8@CanFit:
	cmp	DWORD PTR _IncludeGreen$[ebp], 0
	je	SHORT $LN6@CanFit
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN7@CanFit
$LN6@CanFit:
	cmp	DWORD PTR _IncludeBlue$[ebp], 0
	je	SHORT $LN4@CanFit
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN5@CanFit
$LN4@CanFit:
	mov	DWORD PTR tv70[ebp], 0
$LN5@CanFit:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR tv72[ebp], ecx
$LN7@CanFit:
	mov	edx, DWORD PTR tv72[ebp]
	mov	DWORD PTR tv74[ebp], edx
$LN9@CanFit:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv76[ebp], eax
$LN11@CanFit:
	mov	ecx, DWORD PTR _FinalWidth$[ebp]
	imul	ecx, DWORD PTR _FinalHeight$[ebp]
	imul	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR _BytesAvailable$[ebp], ecx

; 183  :         (IncludeAlpha ? 1 : 0 + IncludeRed ? 1 : 0 + IncludeGreen ? 1 : 0 + IncludeBlue ? 1 : 0);
; 184  :     if (BytesRequiredToFit(ChannelMask, TextLength) > BytesAvailable)

	mov	edx, DWORD PTR _TextLength$[ebp]
	push	edx
	movzx	eax, BYTE PTR _ChannelMask$[ebp]
	push	eax
	call	_BytesRequiredToFit@8
	cmp	eax, DWORD PTR _BytesAvailable$[ebp]
	jle	SHORT $LN2@CanFit

; 185  :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@CanFit
$LN2@CanFit:

; 186  :     return TRUE;

	mov	eax, 1
$LN1@CanFit:

; 187  : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_CanFit@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_BytePerChar$ = -4					; size = 4
_ChannelMask$ = 8					; size = 1
_TextLength$ = 12					; size = 4
_BytesRequiredToFit@8 PROC

; 152  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 153  :     int BytePerChar = BytePerCharacter(ChannelMask);

	movzx	eax, BYTE PTR _ChannelMask$[ebp]
	push	eax
	call	?BytePerCharacter@@YGHE@Z		; BytePerCharacter
	mov	DWORD PTR _BytePerChar$[ebp], eax

; 154  :     if (BytePerChar <= 0)

	cmp	DWORD PTR _BytePerChar$[ebp], 0
	jg	SHORT $LN2@BytesRequi

; 155  :         return -1;

	or	eax, -1
	jmp	SHORT $LN1@BytesRequi
$LN2@BytesRequi:

; 156  :     return BytePerChar * TextLength;

	mov	eax, DWORD PTR _BytePerChar$[ebp]
	imul	eax, DWORD PTR _TextLength$[ebp]
$LN1@BytesRequi:

; 157  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_BytesRequiredToFit@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_ChannelMask$ = 28					; size = 1
_Text$ = 32						; size = 4
_TextLength$ = 36					; size = 4
_AddString3@32 PROC

; 311  : {

	push	ebp
	mov	ebp, esp

; 312  :     return AddStringToRegion(Source, Width, Height, Stride, Destination,

	mov	eax, DWORD PTR _TextLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Text$[ebp]
	push	ecx
	push	1
	push	1
	push	1
	push	1
	movzx	edx, BYTE PTR _ChannelMask$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_AddStringToRegion@72

; 313  :         0, 0, Width - 1, Height - 1, 0, 0,
; 314  :         ChannelMask, TRUE, TRUE, TRUE, TRUE,
; 315  :         Text, TextLength);
; 316  : }

	pop	ebp
	ret	32					; 00000020H
_AddString3@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_ChannelMask$ = 28					; size = 1
_IncludeAlpha$ = 32					; size = 4
_IncludeRed$ = 36					; size = 4
_IncludeGreen$ = 40					; size = 4
_IncludeBlue$ = 44					; size = 4
_Text$ = 48						; size = 4
_TextLength$ = 52					; size = 4
_AddString2@48 PROC

; 302  : {

	push	ebp
	mov	ebp, esp

; 303  :     return AddStringToRegion(Source, Width, Height, Stride, Destination,

	mov	eax, DWORD PTR _TextLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Text$[ebp]
	push	ecx
	mov	edx, DWORD PTR _IncludeBlue$[ebp]
	push	edx
	mov	eax, DWORD PTR _IncludeGreen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _IncludeRed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _IncludeAlpha$[ebp]
	push	edx
	movzx	eax, BYTE PTR _ChannelMask$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	sub	edx, 1
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_AddStringToRegion@72

; 304  :         0, 0, Width - 1, Height - 1, 0, 0,
; 305  :         ChannelMask, IncludeAlpha, IncludeRed, IncludeGreen, IncludeBlue,
; 306  :         Text, TextLength);
; 307  : }

	pop	ebp
	ret	48					; 00000030H
_AddString2@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RelativeXOffset$ = 28					; size = 4
_RelativeYOffset$ = 32					; size = 4
_ChannelMask$ = 36					; size = 1
_IncludeAlpha$ = 40					; size = 4
_IncludeRed$ = 44					; size = 4
_IncludeGreen$ = 48					; size = 4
_IncludeBlue$ = 52					; size = 4
_Text$ = 56						; size = 4
_TextLength$ = 60					; size = 4
_AddString1@56 PROC

; 292  : {

	push	ebp
	mov	ebp, esp

; 293  :     return AddStringToRegion(Source, Width, Height, Stride, Destination,

	mov	eax, DWORD PTR _TextLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Text$[ebp]
	push	ecx
	mov	edx, DWORD PTR _IncludeBlue$[ebp]
	push	edx
	mov	eax, DWORD PTR _IncludeGreen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _IncludeRed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _IncludeAlpha$[ebp]
	push	edx
	movzx	eax, BYTE PTR _ChannelMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RelativeYOffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _RelativeXOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_AddStringToRegion@72

; 294  :         0, 0, Width - 1, Height - 1, RelativeXOffset, RelativeYOffset,
; 295  :         ChannelMask, IncludeAlpha, IncludeRed, IncludeGreen, IncludeBlue,
; 296  :         Text, TextLength);
; 297  : }

	pop	ebp
	ret	56					; 00000038H
_AddString1@56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_PixelSize$ = -20					; size = 4
_Dest$ = -16						; size = 4
_Src$ = -12						; size = 4
tv75 = -8						; size = 4
tv73 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Left$ = 28						; size = 4
_Top$ = 32						; size = 4
_Right$ = 36						; size = 4
_Bottom$ = 40						; size = 4
_RelativeXOffset$ = 44					; size = 4
_RelativeYOffset$ = 48					; size = 4
_ChannelMask$ = 52					; size = 1
_IncludeAlpha$ = 56					; size = 4
_IncludeRed$ = 60					; size = 4
_IncludeGreen$ = 64					; size = 4
_IncludeBlue$ = 68					; size = 4
_Text$ = 72						; size = 4
_TextLength$ = 76					; size = 4
_AddStringToRegion@72 PROC

; 267  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 268  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@AddStringT

; 269  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AddStringT
$LN2@AddStringT:

; 270  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN3@AddStringT

; 271  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AddStringT
$LN3@AddStringT:

; 272  :     if (Text == NULL)

	cmp	DWORD PTR _Text$[ebp], 0
	jne	SHORT $LN4@AddStringT

; 273  :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@AddStringT
$LN4@AddStringT:

; 274  :     if (TextLength < 1)

	cmp	DWORD PTR _TextLength$[ebp], 1
	jge	SHORT $LN5@AddStringT

; 275  :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	SHORT $LN1@AddStringT
$LN5@AddStringT:

; 276  :     if (ChannelMask == 0x0)

	movzx	eax, BYTE PTR _ChannelMask$[ebp]
	test	eax, eax
	jne	SHORT $LN6@AddStringT

; 277  :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	SHORT $LN1@AddStringT
$LN6@AddStringT:

; 278  :     if (!IncludeAlpha && !IncludeRed && !IncludeGreen & !IncludeBlue)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	jne	SHORT $LN7@AddStringT
	cmp	DWORD PTR _IncludeRed$[ebp], 0
	jne	SHORT $LN7@AddStringT
	cmp	DWORD PTR _IncludeGreen$[ebp], 0
	jne	SHORT $LN9@AddStringT
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN10@AddStringT
$LN9@AddStringT:
	mov	DWORD PTR tv73[ebp], 0
$LN10@AddStringT:
	cmp	DWORD PTR _IncludeBlue$[ebp], 0
	jne	SHORT $LN11@AddStringT
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN12@AddStringT
$LN11@AddStringT:
	mov	DWORD PTR tv75[ebp], 0
$LN12@AddStringT:
	mov	ecx, DWORD PTR tv73[ebp]
	and	ecx, DWORD PTR tv75[ebp]
	je	SHORT $LN7@AddStringT

; 279  :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	SHORT $LN1@AddStringT
$LN7@AddStringT:

; 280  : 
; 281  :     BYTE *Src = (BYTE *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], edx

; 282  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 283  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 284  : 
; 285  :     return Success;

	xor	eax, eax
$LN1@AddStringT:

; 286  : }

	mov	esp, ebp
	pop	ebp
	ret	72					; 00000048H
_AddStringToRegion@72 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_ChannelMask$ = 28					; size = 1
_Text$ = 32						; size = 4
_TextLength$ = 36					; size = 4
_AddData3@32 PROC

; 421  : {

	push	ebp
	mov	ebp, esp

; 422  :     return AddDataToRegion(Source, Width, Height, Stride, Destination,

	mov	eax, DWORD PTR _TextLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Text$[ebp]
	push	ecx
	push	1
	push	1
	push	1
	push	1
	movzx	edx, BYTE PTR _ChannelMask$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_AddDataToRegion@72

; 423  :         0, 0, Width - 1, Height - 1, 0, 0,
; 424  :         ChannelMask, TRUE, TRUE, TRUE, TRUE,
; 425  :         Text, TextLength);
; 426  : }

	pop	ebp
	ret	32					; 00000020H
_AddData3@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_ChannelMask$ = 28					; size = 1
_IncludeAlpha$ = 32					; size = 4
_IncludeRed$ = 36					; size = 4
_IncludeGreen$ = 40					; size = 4
_IncludeBlue$ = 44					; size = 4
_Text$ = 48						; size = 4
_TextLength$ = 52					; size = 4
_AddData2@48 PROC

; 412  : {

	push	ebp
	mov	ebp, esp

; 413  :     return AddDataToRegion(Source, Width, Height, Stride, Destination,

	mov	eax, DWORD PTR _TextLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Text$[ebp]
	push	ecx
	mov	edx, DWORD PTR _IncludeBlue$[ebp]
	push	edx
	mov	eax, DWORD PTR _IncludeGreen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _IncludeRed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _IncludeAlpha$[ebp]
	push	edx
	movzx	eax, BYTE PTR _ChannelMask$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	sub	edx, 1
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_AddDataToRegion@72

; 414  :         0, 0, Width - 1, Height - 1, 0, 0,
; 415  :         ChannelMask, IncludeAlpha, IncludeRed, IncludeGreen, IncludeBlue,
; 416  :         Text, TextLength);
; 417  : }

	pop	ebp
	ret	48					; 00000030H
_AddData2@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RelativeXOffset$ = 28					; size = 4
_RelativeYOffset$ = 32					; size = 4
_ChannelMask$ = 36					; size = 1
_IncludeAlpha$ = 40					; size = 4
_IncludeRed$ = 44					; size = 4
_IncludeGreen$ = 48					; size = 4
_IncludeBlue$ = 52					; size = 4
_Text$ = 56						; size = 4
_TextLength$ = 60					; size = 4
_AddData1@56 PROC

; 402  : {

	push	ebp
	mov	ebp, esp

; 403  :     return AddDataToRegion(Source, Width, Height, Stride, Destination,

	mov	eax, DWORD PTR _TextLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Text$[ebp]
	push	ecx
	mov	edx, DWORD PTR _IncludeBlue$[ebp]
	push	edx
	mov	eax, DWORD PTR _IncludeGreen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _IncludeRed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _IncludeAlpha$[ebp]
	push	edx
	movzx	eax, BYTE PTR _ChannelMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RelativeYOffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _RelativeXOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_AddDataToRegion@72

; 404  :         0, 0, Width - 1, Height - 1, RelativeXOffset, RelativeYOffset,
; 405  :         ChannelMask, IncludeAlpha, IncludeRed, IncludeGreen, IncludeBlue,
; 406  :         Text, TextLength);
; 407  : }

	pop	ebp
	ret	56					; 00000038H
_AddData1@56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Index$1 = -52						; size = 4
_DataIndex$ = -48					; size = 4
_Dest$ = -44						; size = 4
_Src$ = -40						; size = 4
_RowOffset$2 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_DataStride$ = -28					; size = 4
tv77 = -24						; size = 4
tv75 = -20						; size = 4
tv73 = -16						; size = 4
tv71 = -12						; size = 4
_Column$3 = -8						; size = 4
_Row$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Left$ = 28						; size = 4
_Top$ = 32						; size = 4
_Right$ = 36						; size = 4
_Bottom$ = 40						; size = 4
_RelativeXOffset$ = 44					; size = 4
_RelativeYOffset$ = 48					; size = 4
_ChannelMask$ = 52					; size = 1
_IncludeAlpha$ = 56					; size = 4
_IncludeRed$ = 60					; size = 4
_IncludeGreen$ = 64					; size = 4
_IncludeBlue$ = 68					; size = 4
_DataSource$ = 72					; size = 4
_DataSourceLength$ = 76					; size = 4
_AddDataToRegion@72 PROC

; 358  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 359  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@AddDataToR

; 360  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AddDataToR
$LN8@AddDataToR:

; 361  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@AddDataToR

; 362  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AddDataToR
$LN9@AddDataToR:

; 363  :     if (DataSource == NULL)

	cmp	DWORD PTR _DataSource$[ebp], 0
	jne	SHORT $LN10@AddDataToR

; 364  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AddDataToR
$LN10@AddDataToR:

; 365  :     if (DataSourceLength < 1)

	cmp	DWORD PTR _DataSourceLength$[ebp], 1
	jge	SHORT $LN11@AddDataToR

; 366  :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@AddDataToR
$LN11@AddDataToR:

; 367  :     if (ChannelMask == 0x0)

	movzx	eax, BYTE PTR _ChannelMask$[ebp]
	test	eax, eax
	jne	SHORT $LN12@AddDataToR

; 368  :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@AddDataToR
$LN12@AddDataToR:

; 369  :     int DataStride = IncludeAlpha ? 1 : 0 + IncludeRed ? 1 : 0 + IncludeGreen ? 1 : 0 + IncludeBlue ? 1 : 0;

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN22@AddDataToR
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN23@AddDataToR
$LN22@AddDataToR:
	cmp	DWORD PTR _IncludeRed$[ebp], 0
	je	SHORT $LN20@AddDataToR
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN21@AddDataToR
$LN20@AddDataToR:
	cmp	DWORD PTR _IncludeGreen$[ebp], 0
	je	SHORT $LN18@AddDataToR
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN19@AddDataToR
$LN18@AddDataToR:
	cmp	DWORD PTR _IncludeBlue$[ebp], 0
	je	SHORT $LN16@AddDataToR
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN17@AddDataToR
$LN16@AddDataToR:
	mov	DWORD PTR tv71[ebp], 0
$LN17@AddDataToR:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR tv73[ebp], ecx
$LN19@AddDataToR:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv75[ebp], edx
$LN21@AddDataToR:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR tv77[ebp], eax
$LN23@AddDataToR:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _DataStride$[ebp], ecx

; 370  :     if (DataStride == 0)

	cmp	DWORD PTR _DataStride$[ebp], 0
	jne	SHORT $LN13@AddDataToR

; 371  :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@AddDataToR
$LN13@AddDataToR:

; 372  :     if (!CanFit(Left, Top, Right, Bottom, RelativeXOffset, RelativeYOffset, IncludeAlpha, IncludeRed, IncludeGreen, IncludeBlue,

	mov	edx, DWORD PTR _DataSourceLength$[ebp]
	push	edx
	movzx	eax, BYTE PTR _ChannelMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _IncludeBlue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _IncludeGreen$[ebp]
	push	edx
	mov	eax, DWORD PTR _IncludeRed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _IncludeAlpha$[ebp]
	push	ecx
	mov	edx, DWORD PTR _RelativeYOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _RelativeXOffset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Bottom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Right$[ebp]
	push	edx
	mov	eax, DWORD PTR _Top$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Left$[ebp]
	push	ecx
	call	_CanFit@48
	test	eax, eax
	jne	SHORT $LN14@AddDataToR

; 373  :         ChannelMask, DataSourceLength))
; 374  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@AddDataToR
$LN14@AddDataToR:

; 375  : 
; 376  :     BYTE *Src = (BYTE *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], edx

; 377  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 378  :     //BYTE *Data = (BYTE *)Data;
; 379  :     int DataIndex = 0;

	mov	DWORD PTR _DataIndex$[ebp], 0

; 380  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 381  : 
; 382  :     Left = Left + RelativeXOffset;

	mov	ecx, DWORD PTR _Left$[ebp]
	add	ecx, DWORD PTR _RelativeXOffset$[ebp]
	mov	DWORD PTR _Left$[ebp], ecx

; 383  :     Top = Top + RelativeYOffset;

	mov	edx, DWORD PTR _Top$[ebp]
	add	edx, DWORD PTR _RelativeYOffset$[ebp]
	mov	DWORD PTR _Top$[ebp], edx

; 384  : 
; 385  :     for (int Row = Top; Row < Bottom; Row++)

	mov	eax, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$4[ebp], eax
	jmp	SHORT $LN4@AddDataToR
$LN2@AddDataToR:
	mov	ecx, DWORD PTR _Row$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$4[ebp], ecx
$LN4@AddDataToR:
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _Bottom$[ebp]
	jge	SHORT $LN3@AddDataToR

; 386  :     {
; 387  :         int RowOffset = (Row * Stride);

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], eax

; 388  :         for (int Column = Left; Column < Right; Column++)

	mov	ecx, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$3[ebp], ecx
	jmp	SHORT $LN7@AddDataToR
$LN5@AddDataToR:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@AddDataToR:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _Right$[ebp]
	jge	SHORT $LN6@AddDataToR

; 389  :         {
; 390  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$1[ebp], ecx

; 391  : 
; 392  :         }

	jmp	SHORT $LN5@AddDataToR
$LN6@AddDataToR:

; 393  :     }

	jmp	SHORT $LN2@AddDataToR
$LN3@AddDataToR:

; 394  : 
; 395  :     return Success;

	xor	eax, eax
$LN1@AddDataToR:

; 396  : }

	mov	esp, ebp
	pop	ebp
	ret	72					; 00000048H
_AddDataToRegion@72 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RandomizeMask$ = 28					; size = 1
_RandomSeed$ = 32					; size = 4
_RandomizeImageBits2@28 PROC

; 126  : {

	push	ebp
	mov	ebp, esp

; 127  :     return RandomizeImageBitsRegion(Source, Width, Height, Stride, Destination, 0, 0, Width - 1, Height - 1,

	push	1
	push	1
	push	1
	push	1
	mov	eax, DWORD PTR _RandomSeed$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _RandomizeMask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	sub	edx, 1
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	sub	eax, 1
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _Destination$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stride$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Source$[ebp]
	push	edx
	call	_RandomizeImageBitsRegion@60

; 128  :         RandomizeMask, RandomSeed, TRUE, TRUE, TRUE, TRUE);
; 129  : }

	pop	ebp
	ret	28					; 0000001cH
_RandomizeImageBits2@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RandomizeMask$ = 28					; size = 1
_RandomSeed$ = 32					; size = 4
_IncludeAlpha$ = 36					; size = 4
_IncludeRed$ = 40					; size = 4
_IncludeGreen$ = 44					; size = 4
_IncludeBlue$ = 48					; size = 4
_RandomizeImageBits1@44 PROC

; 109  : {

	push	ebp
	mov	ebp, esp

; 110  :     return RandomizeImageBitsRegion(Source, Width, Height, Stride, Destination, 0, 0, Width - 1, Height - 1,

	mov	eax, DWORD PTR _IncludeBlue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _IncludeGreen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _IncludeRed$[ebp]
	push	edx
	mov	eax, DWORD PTR _IncludeAlpha$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RandomSeed$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _RandomizeMask$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_RandomizeImageBitsRegion@60

; 111  :         RandomizeMask, RandomSeed, IncludeAlpha, IncludeRed, IncludeGreen, IncludeBlue);
; 112  : }

	pop	ebp
	ret	44					; 0000002cH
_RandomizeImageBits1@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Src$ = -12						; size = 4
_Dest$ = -8						; size = 4
_Index$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Left$ = 28						; size = 4
_Top$ = 32						; size = 4
_Right$ = 36						; size = 4
_Bottom$ = 40						; size = 4
_RandomizeMask$ = 44					; size = 1
_RandomSeed$ = 48					; size = 4
_IncludeAlpha$ = 52					; size = 4
_IncludeRed$ = 56					; size = 4
_IncludeGreen$ = 60					; size = 4
_IncludeBlue$ = 64					; size = 4
_RandomizeImageBitsRegion@60 PROC

; 40   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 41   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RandomizeI

; 42   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RandomizeI
$LN8@RandomizeI:

; 43   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@RandomizeI

; 44   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RandomizeI
$LN9@RandomizeI:

; 45   :     if (!IncludeAlpha && !IncludeRed && !IncludeGreen && !IncludeBlue)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	jne	SHORT $LN10@RandomizeI
	cmp	DWORD PTR _IncludeRed$[ebp], 0
	jne	SHORT $LN10@RandomizeI
	cmp	DWORD PTR _IncludeGreen$[ebp], 0
	jne	SHORT $LN10@RandomizeI
	cmp	DWORD PTR _IncludeBlue$[ebp], 0
	jne	SHORT $LN10@RandomizeI

; 46   :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@RandomizeI
$LN10@RandomizeI:

; 47   :     if (RandomizeMask == 0x0)

	movzx	eax, BYTE PTR _RandomizeMask$[ebp]
	test	eax, eax
	jne	SHORT $LN11@RandomizeI

; 48   :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@RandomizeI
$LN11@RandomizeI:

; 49   :     if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN12@RandomizeI

; 50   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@RandomizeI
$LN12@RandomizeI:

; 51   :     if (Right >= Width)

	mov	ecx, DWORD PTR _Right$[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jl	SHORT $LN13@RandomizeI

; 52   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@RandomizeI
$LN13@RandomizeI:

; 53   :     if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN14@RandomizeI

; 54   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@RandomizeI
$LN14@RandomizeI:

; 55   :     if (Bottom >= Height)

	mov	edx, DWORD PTR _Bottom$[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN15@RandomizeI

; 56   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@RandomizeI
$LN15@RandomizeI:

; 57   : 
; 58   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 59   :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 60   :     BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 61   : 
; 62   :     for (int Row = Top; Row <= Bottom; Row++)

	mov	edx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$3[ebp], edx
	jmp	SHORT $LN4@RandomizeI
$LN2@RandomizeI:
	mov	eax, DWORD PTR _Row$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$3[ebp], eax
$LN4@RandomizeI:
	mov	ecx, DWORD PTR _Row$3[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	$LN3@RandomizeI

; 63   :     {
; 64   :         int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$3[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 65   :         for (int Column = Left; Column <= Right; Column++)

	mov	eax, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$2[ebp], eax
	jmp	SHORT $LN7@RandomizeI
$LN5@RandomizeI:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@RandomizeI:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	$LN6@RandomizeI

; 66   :         {
; 67   :             int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$2[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 68   :             if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN16@RandomizeI

; 69   :                 Dest[Index + 3] = RandomizeByte(Src[Index + 3], RandomizeMask, RandomSeed);

	mov	ecx, DWORD PTR _RandomSeed$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _RandomizeMask$[ebp]
	push	edx
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	push	ecx
	call	?RandomizeByte@@YGEEEI@Z		; RandomizeByte
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx+3], al

; 70   :             else

	jmp	SHORT $LN17@RandomizeI
$LN16@RandomizeI:

; 71   :                 Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl
$LN17@RandomizeI:

; 72   :             if (IncludeRed)

	cmp	DWORD PTR _IncludeRed$[ebp], 0
	je	SHORT $LN18@RandomizeI

; 73   :                 Dest[Index + 2] = RandomizeByte(Src[Index + 2], RandomizeMask, RandomSeed);

	mov	eax, DWORD PTR _RandomSeed$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _RandomizeMask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	call	?RandomizeByte@@YGEEEI@Z		; RandomizeByte
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx+2], al

; 74   :             else

	jmp	SHORT $LN19@RandomizeI
$LN18@RandomizeI:

; 75   :                 Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl
$LN19@RandomizeI:

; 76   :             if (IncludeGreen)

	cmp	DWORD PTR _IncludeGreen$[ebp], 0
	je	SHORT $LN20@RandomizeI

; 77   :                 Dest[Index + 1] = RandomizeByte(Src[Index + 1], RandomizeMask, RandomSeed);

	mov	edx, DWORD PTR _RandomSeed$[ebp]
	push	edx
	movzx	eax, BYTE PTR _RandomizeMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	call	?RandomizeByte@@YGEEEI@Z		; RandomizeByte
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx+1], al

; 78   :             else

	jmp	SHORT $LN21@RandomizeI
$LN20@RandomizeI:

; 79   :                 Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl
$LN21@RandomizeI:

; 80   :             if (IncludeBlue)

	cmp	DWORD PTR _IncludeBlue$[ebp], 0
	je	SHORT $LN22@RandomizeI

; 81   :                 Dest[Index + 0] = RandomizeByte(Src[Index + 0], RandomizeMask, RandomSeed);

	mov	edx, DWORD PTR _RandomSeed$[ebp]
	push	edx
	movzx	eax, BYTE PTR _RandomizeMask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?RandomizeByte@@YGEEEI@Z		; RandomizeByte
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx], al

; 82   :             else

	jmp	SHORT $LN23@RandomizeI
$LN22@RandomizeI:

; 83   :                 Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
$LN23@RandomizeI:

; 84   :         }

	jmp	$LN5@RandomizeI
$LN6@RandomizeI:

; 85   :     }

	jmp	$LN2@RandomizeI
$LN3@RandomizeI:

; 86   : 
; 87   :     return Success;

	xor	eax, eax
$LN1@RandomizeI:

; 88   : }

	mov	esp, ebp
	pop	ebp
	ret	60					; 0000003cH
_RandomizeImageBitsRegion@60 ENDP
_TEXT	ENDS
END
