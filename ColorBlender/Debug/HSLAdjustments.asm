; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\HSLAdjustments.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_floorf
PUBLIC	_GetHSLImage@20
PUBLIC	_MakeRGBFromHSL@24
PUBLIC	_ImageHueShift@24
PUBLIC	_AdjustImageHSLValues@44
PUBLIC	_Silly_SwapSaturationLuminance@20
PUBLIC	_RestrictHSL@44
PUBLIC	_HSLColorReduction@48
PUBLIC	_HSLBulkSet@56
PUBLIC	_HSLConditionalModify@28
PUBLIC	_RGBtoHSLtoRGB@20
PUBLIC	_RGBImageToHueImage@20
PUBLIC	_RGBImageToSaturationImage@20
PUBLIC	_RGBImageToLuminanceImage@20
PUBLIC	_RGBImageToSLImage@20
PUBLIC	_RestrictHues2@28
PUBLIC	_RestrictHueRange@36
PUBLIC	?DoRestrict@@YGNNNH@Z				; DoRestrict
PUBLIC	?RoundToClosest@@YGNNN@Z			; RoundToClosest
PUBLIC	?ModifyHSLValue@@YGNNNHNN@Z			; ModifyHSLValue
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fe6aaaaaaaaaaab
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@4076800000000000
EXTRN	_RGB8ToHSL@24:PROC
EXTRN	_HSLtoRGB8@36:PROC
EXTRN	_ShiftHue@16:PROC
EXTRN	__CIfmod:PROC
EXTRN	_floor:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe6aaaaaaaaaaab
CONST	SEGMENT
__real@3fe6aaaaaaaaaaab DQ 03fe6aaaaaaaaaaabr	; 0.708333
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_Result$ = -12						; size = 8
tv64 = -4						; size = 4
_Source$ = 8						; size = 8
_Operand$ = 16						; size = 8
_Operator$ = 24						; size = 4
_ClampLow$ = 28						; size = 8
_ClampHigh$ = 36					; size = 8
?ModifyHSLValue@@YGNNNHNN@Z PROC			; ModifyHSLValue

; 563  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 564  : 	double Result = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Result$[ebp], xmm0

; 565  : 	switch (Operator)

	mov	eax, DWORD PTR _Operator$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 4
	ja	SHORT $LN2@ModifyHSLV
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN14@ModifyHSLV[ecx*4]
$LN4@ModifyHSLV:

; 566  : 	{
; 567  : 	case HSLReplace:
; 568  : 		Result = Operand;

	movsd	xmm0, QWORD PTR _Operand$[ebp]
	movsd	QWORD PTR _Result$[ebp], xmm0

; 569  : 		break;

	jmp	SHORT $LN2@ModifyHSLV
$LN5@ModifyHSLV:

; 570  : 
; 571  : 	case HSLMultiple:
; 572  : 		Result = Source * Operand;

	movsd	xmm0, QWORD PTR _Source$[ebp]
	mulsd	xmm0, QWORD PTR _Operand$[ebp]
	movsd	QWORD PTR _Result$[ebp], xmm0

; 573  : 		break;

	jmp	SHORT $LN2@ModifyHSLV
$LN6@ModifyHSLV:

; 574  : 
; 575  : 	case HSLDivide:
; 576  : 		if (Operand == 0.0)

	movsd	xmm0, QWORD PTR _Operand$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN7@ModifyHSLV

; 577  : 			Result = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Result$[ebp], xmm0

; 578  : 		else

	jmp	SHORT $LN8@ModifyHSLV
$LN7@ModifyHSLV:

; 579  : 			Result = Source / Operand;

	movsd	xmm0, QWORD PTR _Source$[ebp]
	divsd	xmm0, QWORD PTR _Operand$[ebp]
	movsd	QWORD PTR _Result$[ebp], xmm0
$LN8@ModifyHSLV:

; 580  : 		break;

	jmp	SHORT $LN2@ModifyHSLV
$LN9@ModifyHSLV:

; 581  : 
; 582  : 	case HSLAdd:
; 583  : 		Result = Source + Operand;

	movsd	xmm0, QWORD PTR _Source$[ebp]
	addsd	xmm0, QWORD PTR _Operand$[ebp]
	movsd	QWORD PTR _Result$[ebp], xmm0

; 584  : 		break;

	jmp	SHORT $LN2@ModifyHSLV
$LN10@ModifyHSLV:

; 585  : 
; 586  : 	case HSLSubtract:
; 587  : 		Result = Source - Operand;

	movsd	xmm0, QWORD PTR _Source$[ebp]
	subsd	xmm0, QWORD PTR _Operand$[ebp]
	movsd	QWORD PTR _Result$[ebp], xmm0
$LN2@ModifyHSLV:

; 588  : 		break;
; 589  : 	}
; 590  : 
; 591  : 	if (Result < ClampLow)

	movsd	xmm0, QWORD PTR _ClampLow$[ebp]
	comisd	xmm0, QWORD PTR _Result$[ebp]
	jbe	SHORT $LN11@ModifyHSLV

; 592  : 		Result = ClampLow;

	movsd	xmm0, QWORD PTR _ClampLow$[ebp]
	movsd	QWORD PTR _Result$[ebp], xmm0
$LN11@ModifyHSLV:

; 593  : 	if (Result > ClampHigh)

	movsd	xmm0, QWORD PTR _Result$[ebp]
	comisd	xmm0, QWORD PTR _ClampHigh$[ebp]
	jbe	SHORT $LN12@ModifyHSLV

; 594  : 		Result = ClampHigh;

	movsd	xmm0, QWORD PTR _ClampHigh$[ebp]
	movsd	QWORD PTR _Result$[ebp], xmm0
$LN12@ModifyHSLV:

; 595  : 
; 596  : 	return Result;

	fld	QWORD PTR _Result$[ebp]

; 597  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
$LN14@ModifyHSLV:
	DD	$LN5@ModifyHSLV
	DD	$LN9@ModifyHSLV
	DD	$LN6@ModifyHSLV
	DD	$LN10@ModifyHSLV
	DD	$LN4@ModifyHSLV
?ModifyHSLValue@@YGNNNHNN@Z ENDP			; ModifyHSLValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
tv128 = -48						; size = 8
_R1$ = -40						; size = 8
_F1$ = -32						; size = 8
tv77 = -24						; size = 8
_I2$ = -16						; size = 4
_RoundUp$ = -12						; size = 4
_I1$ = -8						; size = 4
tv74 = -4						; size = 4
_ToRound$ = 8						; size = 8
_Multiple$ = 16						; size = 8
?RoundToClosest@@YGNNN@Z PROC				; RoundToClosest

; 347  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 348  : 	if (Multiple == 0.0)

	movsd	xmm0, QWORD PTR _Multiple$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN2@RoundToClo

; 349  : 		return ToRound;

	fld	QWORD PTR _ToRound$[ebp]
	jmp	$LN1@RoundToClo
$LN2@RoundToClo:

; 350  : 	double F1 = ToRound / Multiple;

	movsd	xmm0, QWORD PTR _ToRound$[ebp]
	divsd	xmm0, QWORD PTR _Multiple$[ebp]
	movsd	QWORD PTR _F1$[ebp], xmm0

; 351  : 	int I1 = (int)F1;

	cvttsd2si eax, QWORD PTR _F1$[ebp]
	mov	DWORD PTR _I1$[ebp], eax

; 352  : 	int I2 = I1 * (int)Multiple;

	cvttsd2si ecx, QWORD PTR _Multiple$[ebp]
	imul	ecx, DWORD PTR _I1$[ebp]
	mov	DWORD PTR _I2$[ebp], ecx

; 353  : 	double R1 = (double)fmod(ToRound, Multiple);

	fld	QWORD PTR _ToRound$[ebp]
	fld	QWORD PTR _Multiple$[ebp]
	call	__CIfmod
	fstp	QWORD PTR _R1$[ebp]

; 354  : 	BOOL RoundUp = R1 > (Multiple / 2.0) ? TRUE : FALSE;

	movsd	xmm0, QWORD PTR _Multiple$[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	xmm1, QWORD PTR _R1$[ebp]
	comisd	xmm1, xmm0
	jbe	SHORT $LN4@RoundToClo
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN5@RoundToClo
$LN4@RoundToClo:
	mov	DWORD PTR tv74[ebp], 0
$LN5@RoundToClo:
	mov	edx, DWORD PTR tv74[ebp]
	mov	DWORD PTR _RoundUp$[ebp], edx

; 355  : 	return (double)I2 + (RoundUp ? Multiple : 0.0);

	cmp	DWORD PTR _RoundUp$[ebp], 0
	je	SHORT $LN6@RoundToClo
	movsd	xmm0, QWORD PTR _Multiple$[ebp]
	movsd	QWORD PTR tv77[ebp], xmm0
	jmp	SHORT $LN7@RoundToClo
$LN6@RoundToClo:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv77[ebp], xmm0
$LN7@RoundToClo:
	cvtsi2sd xmm0, DWORD PTR _I2$[ebp]
	addsd	xmm0, QWORD PTR tv77[ebp]
	movsd	QWORD PTR tv128[ebp], xmm0
	fld	QWORD PTR tv128[ebp]
$LN1@RoundToClo:

; 356  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?RoundToClosest@@YGNNN@Z ENDP				; RoundToClosest
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_Result$ = -20						; size = 8
_SegmentSize$ = -12					; size = 8
_SegmentIndex$ = -4					; size = 4
_SourceValue$ = 8					; size = 8
_MaxRange$ = 16						; size = 8
_Segments$ = 24						; size = 4
?DoRestrict@@YGNNNH@Z PROC				; DoRestrict

; 218  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 219  : 	if (SourceValue > MaxRange)

	movsd	xmm0, QWORD PTR _SourceValue$[ebp]
	comisd	xmm0, QWORD PTR _MaxRange$[ebp]
	jbe	SHORT $LN2@DoRestrict

; 220  : 		SourceValue = MaxRange;

	movsd	xmm0, QWORD PTR _MaxRange$[ebp]
	movsd	QWORD PTR _SourceValue$[ebp], xmm0
$LN2@DoRestrict:

; 221  : 	double SegmentSize = MaxRange / (double)Segments;

	cvtsi2sd xmm0, DWORD PTR _Segments$[ebp]
	movsd	xmm1, QWORD PTR _MaxRange$[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _SegmentSize$[ebp], xmm1

; 222  : 	if (SegmentSize == 0.0)

	movsd	xmm0, QWORD PTR _SegmentSize$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@DoRestrict

; 223  : 		return SourceValue;

	fld	QWORD PTR _SourceValue$[ebp]
	jmp	SHORT $LN1@DoRestrict
$LN3@DoRestrict:

; 224  : 	int SegmentIndex = (int)(SourceValue / SegmentSize);

	movsd	xmm0, QWORD PTR _SourceValue$[ebp]
	divsd	xmm0, QWORD PTR _SegmentSize$[ebp]
	cvttsd2si eax, xmm0
	mov	DWORD PTR _SegmentIndex$[ebp], eax

; 225  : 	double Result = SegmentSize * (double)SegmentIndex;

	cvtsi2sd xmm0, DWORD PTR _SegmentIndex$[ebp]
	mulsd	xmm0, QWORD PTR _SegmentSize$[ebp]
	movsd	QWORD PTR _Result$[ebp], xmm0

; 226  : 	return Result;

	fld	QWORD PTR _Result$[ebp]
$LN1@DoRestrict:

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?DoRestrict@@YGNNNH@Z ENDP				; DoRestrict
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_S$1 = -72						; size = 8
_L$2 = -64						; size = 8
_RangeMultiplier$ = -56					; size = 8
_H$3 = -48						; size = 8
_HueRange$ = -40					; size = 8
_RowOffset$4 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Destination$ = -24					; size = 4
_Source$ = -20						; size = 4
_Column$5 = -16						; size = 4
_Row$6 = -12						; size = 4
_Index$7 = -8						; size = 4
_A$8 = -4						; size = 1
_B$9 = -3						; size = 1
_G$10 = -2						; size = 1
_R$11 = -1						; size = 1
_SourceBuffer$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_DestinationBuffer$ = 24				; size = 4
_LowHue$ = 28						; size = 8
_HighHue$ = 36						; size = 8
_RestrictHueRange@36 PROC

; 935  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 936  : 	if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN8@RestrictHu

; 937  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RestrictHu
$LN8@RestrictHu:

; 938  : 	if (DestinationBuffer == NULL)

	cmp	DWORD PTR _DestinationBuffer$[ebp], 0
	jne	SHORT $LN9@RestrictHu

; 939  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RestrictHu
$LN9@RestrictHu:

; 940  : 
; 941  : 	BYTE *Source = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 942  : 	BYTE *Destination = (BYTE *)DestinationBuffer;

	mov	ecx, DWORD PTR _DestinationBuffer$[ebp]
	mov	DWORD PTR _Destination$[ebp], ecx

; 943  : 	__int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 944  : 	if (LowHue > HighHue)

	movsd	xmm0, QWORD PTR _LowHue$[ebp]
	comisd	xmm0, QWORD PTR _HighHue$[ebp]
	jbe	SHORT $LN10@RestrictHu

; 945  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@RestrictHu
$LN10@RestrictHu:

; 946  : 	if (LowHue < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _LowHue$[ebp]
	jbe	SHORT $LN11@RestrictHu

; 947  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@RestrictHu
$LN11@RestrictHu:

; 948  : 	if (HighHue > 360.0)

	movsd	xmm0, QWORD PTR _HighHue$[ebp]
	comisd	xmm0, QWORD PTR __real@4076800000000000
	jbe	SHORT $LN12@RestrictHu

; 949  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@RestrictHu
$LN12@RestrictHu:

; 950  : 	double HueRange = HighHue - LowHue;

	movsd	xmm0, QWORD PTR _HighHue$[ebp]
	subsd	xmm0, QWORD PTR _LowHue$[ebp]
	movsd	QWORD PTR _HueRange$[ebp], xmm0

; 951  : 	if (HueRange > 360.0)

	movsd	xmm0, QWORD PTR _HueRange$[ebp]
	comisd	xmm0, QWORD PTR __real@4076800000000000
	jbe	SHORT $LN13@RestrictHu

; 952  : 		HueRange = 360.0;

	movsd	xmm0, QWORD PTR __real@4076800000000000
	movsd	QWORD PTR _HueRange$[ebp], xmm0
$LN13@RestrictHu:

; 953  : 	double RangeMultiplier = HueRange / 360.0;

	movsd	xmm0, QWORD PTR _HueRange$[ebp]
	divsd	xmm0, QWORD PTR __real@4076800000000000
	movsd	QWORD PTR _RangeMultiplier$[ebp], xmm0

; 954  : 
; 955  : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@RestrictHu
$LN2@RestrictHu:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@RestrictHu:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@RestrictHu

; 956  : 	{
; 957  : 		int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 958  : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@RestrictHu
$LN5@RestrictHu:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@RestrictHu:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@RestrictHu

; 959  : 		{
; 960  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 961  : 			BYTE A = Source[Index + 3];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 962  : 			BYTE R = Source[Index + 2];

	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$11[ebp], dl

; 963  : 			BYTE G = Source[Index + 1];

	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$10[ebp], cl

; 964  : 			BYTE B = Source[Index + 0];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$9[ebp], al

; 965  : 			double H, S, L;
; 966  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$1[ebp]
	push	edx
	lea	eax, DWORD PTR _H$3[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$9[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$11[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 967  : 
; 968  : 			H = (H * RangeMultiplier) + LowHue;

	movsd	xmm0, QWORD PTR _H$3[ebp]
	mulsd	xmm0, QWORD PTR _RangeMultiplier$[ebp]
	addsd	xmm0, QWORD PTR _LowHue$[ebp]
	movsd	QWORD PTR _H$3[ebp], xmm0

; 969  : 
; 970  : 			HSLtoRGB8(H, S, L, &R, &G, &B);

	lea	ecx, DWORD PTR _B$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _G$10[ebp]
	push	edx
	lea	eax, DWORD PTR _R$11[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB8@36

; 971  : 			Destination[Index + 3] = A;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 972  : 			Destination[Index + 2] = R;

	mov	eax, DWORD PTR _Destination$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [eax+2], cl

; 973  : 			Destination[Index + 1] = G;

	mov	edx, DWORD PTR _Destination$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [edx+1], al

; 974  : 			Destination[Index + 0] = B;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [ecx], dl

; 975  : 		}

	jmp	$LN5@RestrictHu
$LN6@RestrictHu:

; 976  : 	}

	jmp	$LN2@RestrictHu
$LN3@RestrictHu:

; 977  : 
; 978  : 	return Success;

	xor	eax, eax
$LN1@RestrictHu:

; 979  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_RestrictHueRange@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_S$1 = -80						; size = 8
_L$2 = -72						; size = 8
tv188 = -64						; size = 8
_VPercent$3 = -56					; size = 8
_RangeSize$ = -48					; size = 8
_H$4 = -40						; size = 8
_RowOffset$5 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Destination$ = -24					; size = 4
_Source$ = -20						; size = 4
_Column$6 = -16						; size = 4
_Row$7 = -12						; size = 4
_Index$8 = -8						; size = 4
_A$9 = -4						; size = 1
_B$10 = -3						; size = 1
_G$11 = -2						; size = 1
_R$12 = -1						; size = 1
_SourceBuffer$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_DestinationBuffer$ = 24				; size = 4
_HueCount$ = 28						; size = 8
_RestrictHues2@28 PROC

; 880  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 881  : 	if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN8@RestrictHu

; 882  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RestrictHu
$LN8@RestrictHu:

; 883  : 	if (DestinationBuffer == NULL)

	cmp	DWORD PTR _DestinationBuffer$[ebp], 0
	jne	SHORT $LN9@RestrictHu

; 884  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RestrictHu
$LN9@RestrictHu:

; 885  : 
; 886  : 	BYTE *Source = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 887  : 	BYTE *Destination = (BYTE *)DestinationBuffer;

	mov	ecx, DWORD PTR _DestinationBuffer$[ebp]
	mov	DWORD PTR _Destination$[ebp], ecx

; 888  : 	__int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 889  : 	if (HueCount <= 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _HueCount$[ebp]
	jb	SHORT $LN10@RestrictHu

; 890  : 		HueCount = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _HueCount$[ebp], xmm0
$LN10@RestrictHu:

; 891  : 	if (HueCount > 360.0)

	movsd	xmm0, QWORD PTR _HueCount$[ebp]
	comisd	xmm0, QWORD PTR __real@4076800000000000
	jbe	SHORT $LN11@RestrictHu

; 892  : 		HueCount = 360.0;

	movsd	xmm0, QWORD PTR __real@4076800000000000
	movsd	QWORD PTR _HueCount$[ebp], xmm0
$LN11@RestrictHu:

; 893  : 	double RangeSize = 360.0 / HueCount;

	movsd	xmm0, QWORD PTR __real@4076800000000000
	divsd	xmm0, QWORD PTR _HueCount$[ebp]
	movsd	QWORD PTR _RangeSize$[ebp], xmm0

; 894  : 
; 895  : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$7[ebp], 0
	jmp	SHORT $LN4@RestrictHu
$LN2@RestrictHu:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN4@RestrictHu:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@RestrictHu

; 896  : 	{
; 897  : 		int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$5[ebp], ecx

; 898  : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$6[ebp], 0
	jmp	SHORT $LN7@RestrictHu
$LN5@RestrictHu:
	mov	edx, DWORD PTR _Column$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$6[ebp], edx
$LN7@RestrictHu:
	mov	eax, DWORD PTR _Column$6[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@RestrictHu

; 899  : 		{
; 900  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$6[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$5[ebp]
	mov	DWORD PTR _Index$8[ebp], ecx

; 901  : 			BYTE A = Source[Index + 3];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$9[ebp], al

; 902  : 			BYTE R = Source[Index + 2];

	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$12[ebp], dl

; 903  : 			BYTE G = Source[Index + 1];

	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$11[ebp], cl

; 904  : 			BYTE B = Source[Index + 0];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$10[ebp], al

; 905  : 			double H, S, L;
; 906  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$1[ebp]
	push	edx
	lea	eax, DWORD PTR _H$4[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$10[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$11[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$12[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 907  : 
; 908  : 			double VPercent = H / RangeSize;

	movsd	xmm0, QWORD PTR _H$4[ebp]
	divsd	xmm0, QWORD PTR _RangeSize$[ebp]
	movsd	QWORD PTR _VPercent$3[ebp], xmm0

; 909  : 			H = floorf(VPercent) * RangeSize;

	cvtsd2ss xmm0, QWORD PTR _VPercent$3[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	_floorf
	add	esp, 4
	fstp	QWORD PTR tv188[ebp]
	movsd	xmm0, QWORD PTR tv188[ebp]
	mulsd	xmm0, QWORD PTR _RangeSize$[ebp]
	movsd	QWORD PTR _H$4[ebp], xmm0

; 910  : 
; 911  : 			HSLtoRGB8(H, S, L, &R, &G, &B);

	lea	ecx, DWORD PTR _B$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _G$11[ebp]
	push	edx
	lea	eax, DWORD PTR _R$12[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$4[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB8@36

; 912  : 			Destination[Index + 3] = A;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	dl, BYTE PTR _A$9[ebp]
	mov	BYTE PTR [ecx+3], dl

; 913  : 			Destination[Index + 2] = R;

	mov	eax, DWORD PTR _Destination$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR _R$12[ebp]
	mov	BYTE PTR [eax+2], cl

; 914  : 			Destination[Index + 1] = G;

	mov	edx, DWORD PTR _Destination$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR _G$11[ebp]
	mov	BYTE PTR [edx+1], al

; 915  : 			Destination[Index + 0] = B;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	dl, BYTE PTR _B$10[ebp]
	mov	BYTE PTR [ecx], dl

; 916  : 		}

	jmp	$LN5@RestrictHu
$LN6@RestrictHu:

; 917  : 	}

	jmp	$LN2@RestrictHu
$LN3@RestrictHu:

; 918  : 
; 919  : 	return Success;

	xor	eax, eax
$LN1@RestrictHu:

; 920  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_RestrictHues2@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_H$1 = -60						; size = 8
_S$2 = -52						; size = 8
_L$3 = -44						; size = 8
_RowOffset$4 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_Dest$ = -28						; size = 4
_Src$ = -24						; size = 4
_Column$5 = -20						; size = 4
_Row$6 = -16						; size = 4
_Index$7 = -12						; size = 4
_A$8 = -5						; size = 1
_R$9 = -4						; size = 1
_G$10 = -3						; size = 1
_B$11 = -2						; size = 1
_NewChannel$12 = -1					; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RGBImageToSLImage@20 PROC

; 833  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 834  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RGBImageTo

; 835  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBImageTo
$LN8@RGBImageTo:

; 836  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@RGBImageTo

; 837  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBImageTo
$LN9@RGBImageTo:

; 838  : 
; 839  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 840  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 841  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 842  : 
; 843  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@RGBImageTo
$LN2@RGBImageTo:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@RGBImageTo:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@RGBImageTo

; 844  : 	{
; 845  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 846  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@RGBImageTo
$LN5@RGBImageTo:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@RGBImageTo:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@RGBImageTo

; 847  : 		{
; 848  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 849  : 			BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 850  : 			BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$9[ebp], dl

; 851  : 			BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$10[ebp], cl

; 852  : 			BYTE B = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _B$11[ebp], al

; 853  : 			double H = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _H$1[ebp], xmm0

; 854  : 			double S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$2[ebp], xmm0

; 855  : 			double L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$3[ebp], xmm0

; 856  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$2[ebp]
	push	edx
	lea	eax, DWORD PTR _H$1[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$11[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$9[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 857  : 			BYTE NewChannel = (BYTE)(((L * 255.0) + (S * 255.0)) / 2.0);

	movsd	xmm0, QWORD PTR _L$3[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	xmm1, QWORD PTR _S$2[ebp]
	mulsd	xmm1, QWORD PTR __real@406fe00000000000
	addsd	xmm0, xmm1
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _NewChannel$12[ebp], cl

; 858  : 			Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [edx+3], al

; 859  : 			Dest[Index + 2] = NewChannel;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _NewChannel$12[ebp]
	mov	BYTE PTR [ecx+2], dl

; 860  : 			Dest[Index + 1] = NewChannel;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _NewChannel$12[ebp]
	mov	BYTE PTR [eax+1], cl

; 861  : 			Dest[Index + 0] = NewChannel;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _NewChannel$12[ebp]
	mov	BYTE PTR [edx], al

; 862  : 		}

	jmp	$LN5@RGBImageTo
$LN6@RGBImageTo:

; 863  : 	}

	jmp	$LN2@RGBImageTo
$LN3@RGBImageTo:

; 864  : 
; 865  : 	return Success;

	xor	eax, eax
$LN1@RGBImageTo:

; 866  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_RGBImageToSLImage@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_H$1 = -60						; size = 8
_S$2 = -52						; size = 8
_L$3 = -44						; size = 8
_RowOffset$4 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_Dest$ = -28						; size = 4
_Src$ = -24						; size = 4
_Column$5 = -20						; size = 4
_Row$6 = -16						; size = 4
_Index$7 = -12						; size = 4
_A$8 = -5						; size = 1
_R$9 = -4						; size = 1
_G$10 = -3						; size = 1
_B$11 = -2						; size = 1
_NewChannel$12 = -1					; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RGBImageToLuminanceImage@20 PROC

; 797  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 798  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RGBImageTo

; 799  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBImageTo
$LN8@RGBImageTo:

; 800  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@RGBImageTo

; 801  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBImageTo
$LN9@RGBImageTo:

; 802  : 
; 803  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 804  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 805  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 806  : 
; 807  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@RGBImageTo
$LN2@RGBImageTo:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@RGBImageTo:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@RGBImageTo

; 808  : 	{
; 809  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 810  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@RGBImageTo
$LN5@RGBImageTo:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@RGBImageTo:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@RGBImageTo

; 811  : 		{
; 812  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 813  : 			BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 814  : 			BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$9[ebp], dl

; 815  : 			BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$10[ebp], cl

; 816  : 			BYTE B = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _B$11[ebp], al

; 817  : 			double H = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _H$1[ebp], xmm0

; 818  : 			double S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$2[ebp], xmm0

; 819  : 			double L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$3[ebp], xmm0

; 820  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$2[ebp]
	push	edx
	lea	eax, DWORD PTR _H$1[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$11[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$9[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 821  : 			BYTE NewChannel = (BYTE)(L * 255.0);

	movsd	xmm0, QWORD PTR _L$3[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _NewChannel$12[ebp], cl

; 822  : 			Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [edx+3], al

; 823  : 			Dest[Index + 2] = NewChannel;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _NewChannel$12[ebp]
	mov	BYTE PTR [ecx+2], dl

; 824  : 			Dest[Index + 1] = NewChannel;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _NewChannel$12[ebp]
	mov	BYTE PTR [eax+1], cl

; 825  : 			Dest[Index + 0] = NewChannel;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _NewChannel$12[ebp]
	mov	BYTE PTR [edx], al

; 826  : 		}

	jmp	$LN5@RGBImageTo
$LN6@RGBImageTo:

; 827  : 	}

	jmp	$LN2@RGBImageTo
$LN3@RGBImageTo:

; 828  : 
; 829  : 	return Success;

	xor	eax, eax
$LN1@RGBImageTo:

; 830  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_RGBImageToLuminanceImage@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_H$1 = -60						; size = 8
_L$2 = -52						; size = 8
_S$3 = -44						; size = 8
_RowOffset$4 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_Dest$ = -28						; size = 4
_Src$ = -24						; size = 4
_Column$5 = -20						; size = 4
_Row$6 = -16						; size = 4
_Index$7 = -12						; size = 4
_A$8 = -5						; size = 1
_R$9 = -4						; size = 1
_G$10 = -3						; size = 1
_B$11 = -2						; size = 1
_NewChannel$12 = -1					; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RGBImageToSaturationImage@20 PROC

; 761  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 762  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RGBImageTo

; 763  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBImageTo
$LN8@RGBImageTo:

; 764  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@RGBImageTo

; 765  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBImageTo
$LN9@RGBImageTo:

; 766  : 
; 767  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 768  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 769  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 770  : 
; 771  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@RGBImageTo
$LN2@RGBImageTo:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@RGBImageTo:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@RGBImageTo

; 772  : 	{
; 773  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 774  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@RGBImageTo
$LN5@RGBImageTo:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@RGBImageTo:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@RGBImageTo

; 775  : 		{
; 776  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 777  : 			BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 778  : 			BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$9[ebp], dl

; 779  : 			BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$10[ebp], cl

; 780  : 			BYTE B = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _B$11[ebp], al

; 781  : 			double H = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _H$1[ebp], xmm0

; 782  : 			double S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$3[ebp], xmm0

; 783  : 			double L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$2[ebp], xmm0

; 784  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$3[ebp]
	push	edx
	lea	eax, DWORD PTR _H$1[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$11[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$9[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 785  : 			BYTE NewChannel = (BYTE)(S * 255.0);

	movsd	xmm0, QWORD PTR _S$3[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _NewChannel$12[ebp], cl

; 786  : 			Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [edx+3], al

; 787  : 			Dest[Index + 2] = NewChannel;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _NewChannel$12[ebp]
	mov	BYTE PTR [ecx+2], dl

; 788  : 			Dest[Index + 1] = NewChannel;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _NewChannel$12[ebp]
	mov	BYTE PTR [eax+1], cl

; 789  : 			Dest[Index + 0] = NewChannel;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _NewChannel$12[ebp]
	mov	BYTE PTR [edx], al

; 790  : 		}

	jmp	$LN5@RGBImageTo
$LN6@RGBImageTo:

; 791  : 	}

	jmp	$LN2@RGBImageTo
$LN3@RGBImageTo:

; 792  : 
; 793  : 	return Success;

	xor	eax, eax
$LN1@RGBImageTo:

; 794  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_RGBImageToSaturationImage@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_AH$1 = -76						; size = 8
_Adjustment$ = -68					; size = 8
_S$2 = -60						; size = 8
_L$3 = -52						; size = 8
_H$4 = -44						; size = 8
_RowOffset$5 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_Dest$ = -28						; size = 4
_Src$ = -24						; size = 4
_Column$6 = -20						; size = 4
_Row$7 = -16						; size = 4
_Index$8 = -12						; size = 4
_A$9 = -5						; size = 1
_R$10 = -4						; size = 1
_G$11 = -3						; size = 1
_B$12 = -2						; size = 1
_NewChannel$13 = -1					; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RGBImageToHueImage@20 PROC

; 723  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 724  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RGBImageTo

; 725  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBImageTo
$LN8@RGBImageTo:

; 726  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@RGBImageTo

; 727  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBImageTo
$LN9@RGBImageTo:

; 728  : 
; 729  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 730  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 731  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 732  : 	double Adjustment = 255.0 / 360.0;

	movsd	xmm0, QWORD PTR __real@3fe6aaaaaaaaaaab
	movsd	QWORD PTR _Adjustment$[ebp], xmm0

; 733  : 
; 734  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$7[ebp], 0
	jmp	SHORT $LN4@RGBImageTo
$LN2@RGBImageTo:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN4@RGBImageTo:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@RGBImageTo

; 735  : 	{
; 736  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$5[ebp], ecx

; 737  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$6[ebp], 0
	jmp	SHORT $LN7@RGBImageTo
$LN5@RGBImageTo:
	mov	edx, DWORD PTR _Column$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$6[ebp], edx
$LN7@RGBImageTo:
	mov	eax, DWORD PTR _Column$6[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@RGBImageTo

; 738  : 		{
; 739  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$6[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$5[ebp]
	mov	DWORD PTR _Index$8[ebp], ecx

; 740  : 			BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$9[ebp], al

; 741  : 			BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$10[ebp], dl

; 742  : 			BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$11[ebp], cl

; 743  : 			BYTE B = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _B$12[ebp], al

; 744  : 			double H = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _H$4[ebp], xmm0

; 745  : 			double S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$2[ebp], xmm0

; 746  : 			double L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$3[ebp], xmm0

; 747  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$2[ebp]
	push	edx
	lea	eax, DWORD PTR _H$4[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$12[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$11[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$10[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 748  : 			double AH = H * Adjustment;

	movsd	xmm0, QWORD PTR _H$4[ebp]
	mulsd	xmm0, QWORD PTR _Adjustment$[ebp]
	movsd	QWORD PTR _AH$1[ebp], xmm0

; 749  : 			BYTE NewChannel = (BYTE)AH;

	cvttsd2si ecx, QWORD PTR _AH$1[ebp]
	mov	BYTE PTR _NewChannel$13[ebp], cl

; 750  : 			Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR _A$9[ebp]
	mov	BYTE PTR [edx+3], al

; 751  : 			Dest[Index + 2] = NewChannel;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	dl, BYTE PTR _NewChannel$13[ebp]
	mov	BYTE PTR [ecx+2], dl

; 752  : 			Dest[Index + 1] = NewChannel;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR _NewChannel$13[ebp]
	mov	BYTE PTR [eax+1], cl

; 753  : 			Dest[Index + 0] = NewChannel;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR _NewChannel$13[ebp]
	mov	BYTE PTR [edx], al

; 754  : 		}

	jmp	$LN5@RGBImageTo
$LN6@RGBImageTo:

; 755  : 	}

	jmp	$LN2@RGBImageTo
$LN3@RGBImageTo:

; 756  : 
; 757  : 	return Success;

	xor	eax, eax
$LN1@RGBImageTo:

; 758  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_RGBImageToHueImage@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_H$1 = -56						; size = 8
_S$2 = -48						; size = 8
_L$3 = -40						; size = 8
_RowOffset$4 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Dest$ = -24						; size = 4
_Src$ = -20						; size = 4
_Column$5 = -16						; size = 4
_Row$6 = -12						; size = 4
_Index$7 = -8						; size = 4
_A$8 = -4						; size = 1
_B$9 = -3						; size = 1
_G$10 = -2						; size = 1
_R$11 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RGBtoHSLtoRGB@20 PROC

; 687  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 688  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RGBtoHSLto

; 689  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBtoHSLto
$LN8@RGBtoHSLto:

; 690  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@RGBtoHSLto

; 691  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBtoHSLto
$LN9@RGBtoHSLto:

; 692  : 
; 693  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 694  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 695  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 696  : 
; 697  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@RGBtoHSLto
$LN2@RGBtoHSLto:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@RGBtoHSLto:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@RGBtoHSLto

; 698  : 	{
; 699  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 700  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@RGBtoHSLto
$LN5@RGBtoHSLto:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@RGBtoHSLto:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@RGBtoHSLto

; 701  : 		{
; 702  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 703  : 			BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 704  : 			BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$11[ebp], dl

; 705  : 			BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$10[ebp], cl

; 706  : 			BYTE B = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _B$9[ebp], al

; 707  : 			double H = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _H$1[ebp], xmm0

; 708  : 			double S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$2[ebp], xmm0

; 709  : 			double L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$3[ebp], xmm0

; 710  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$2[ebp]
	push	edx
	lea	eax, DWORD PTR _H$1[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$9[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$11[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 711  : 			HSLtoRGB8(H, S, L, &R, &G, &B);

	lea	ecx, DWORD PTR _B$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _G$10[ebp]
	push	edx
	lea	eax, DWORD PTR _R$11[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB8@36

; 712  : 			Dest[Index + 3] = A;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 713  : 			Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [eax+2], cl

; 714  : 			Dest[Index + 1] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [edx+1], al

; 715  : 			Dest[Index + 0] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [ecx], dl

; 716  : 		}

	jmp	$LN5@RGBtoHSLto
$LN6@RGBtoHSLto:

; 717  : 	}

	jmp	$LN2@RGBtoHSLto
$LN3@RGBtoHSLto:

; 718  : 
; 719  : 	return Success;

	xor	eax, eax
$LN1@RGBtoHSLto:

; 720  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_RGBtoHSLtoRGB@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_S$1 = -64						; size = 8
_L$2 = -56						; size = 8
_H$3 = -48						; size = 8
_RowOffset$4 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_Dest$ = -32						; size = 4
_Src$ = -28						; size = 4
_Column$5 = -24						; size = 4
_Row$6 = -20						; size = 4
_Index$7 = -16						; size = 4
_Conditional$ = -12					; size = 4
_i$8 = -8						; size = 4
_A$9 = -4						; size = 1
_B$10 = -3						; size = 1
_G$11 = -2						; size = 1
_R$12 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Conditions$ = 28					; size = 4
_ConditionalCount$ = 32					; size = 4
_HSLConditionalModify@28 PROC

; 616  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 617  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN11@HSLConditi

; 618  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@HSLConditi
$LN11@HSLConditi:

; 619  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN12@HSLConditi

; 620  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@HSLConditi
$LN12@HSLConditi:

; 621  : 	if (Conditions == NULL)

	cmp	DWORD PTR _Conditions$[ebp], 0
	jne	SHORT $LN13@HSLConditi

; 622  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@HSLConditi
$LN13@HSLConditi:

; 623  : 	if (ConditionalCount <= 0)

	cmp	DWORD PTR _ConditionalCount$[ebp], 0
	jg	SHORT $LN14@HSLConditi

; 624  : 		return NoAction;

	xor	eax, eax
	jmp	$LN1@HSLConditi
$LN14@HSLConditi:

; 625  : 
; 626  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 627  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 628  : 	ConditionalHSLAdjustment *Conditional = (ConditionalHSLAdjustment *)Conditions;

	mov	edx, DWORD PTR _Conditions$[ebp]
	mov	DWORD PTR _Conditional$[ebp], edx

; 629  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 630  : 
; 631  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@HSLConditi
$LN2@HSLConditi:
	mov	eax, DWORD PTR _Row$6[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$6[ebp], eax
$LN4@HSLConditi:
	mov	ecx, DWORD PTR _Row$6[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN3@HSLConditi

; 632  : 	{
; 633  : 		int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$6[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], edx

; 634  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@HSLConditi
$LN5@HSLConditi:
	mov	eax, DWORD PTR _Column$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$5[ebp], eax
$LN7@HSLConditi:
	mov	ecx, DWORD PTR _Column$5[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	$LN6@HSLConditi

; 635  : 		{
; 636  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$5[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], edx

; 637  : 			BYTE A = Src[Index + 3];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR _A$9[ebp], cl

; 638  : 			BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$12[ebp], al

; 639  : 			BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$11[ebp], dl

; 640  : 			BYTE B = Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _B$10[ebp], cl

; 641  : 			double H = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _H$3[ebp], xmm0

; 642  : 			double S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$1[ebp], xmm0

; 643  : 			double L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$2[ebp], xmm0

; 644  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	edx, DWORD PTR _L$2[ebp]
	push	edx
	lea	eax, DWORD PTR _S$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _H$3[ebp]
	push	ecx
	movzx	edx, BYTE PTR _B$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _G$11[ebp]
	push	eax
	movzx	ecx, BYTE PTR _R$12[ebp]
	push	ecx
	call	_RGB8ToHSL@24

; 645  : 
; 646  : 			for (int i = 0; i < ConditionalCount; i++)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN10@HSLConditi
$LN8@HSLConditi:
	mov	edx, DWORD PTR _i$8[ebp]
	add	edx, 1
	mov	DWORD PTR _i$8[ebp], edx
$LN10@HSLConditi:
	mov	eax, DWORD PTR _i$8[ebp]
	cmp	eax, DWORD PTR _ConditionalCount$[ebp]
	jge	$LN9@HSLConditi

; 647  : 			{
; 648  : 				if (H < Conditional[i].RangeLow)

	imul	ecx, DWORD PTR _i$8[ebp], 72
	mov	edx, DWORD PTR _Conditional$[ebp]
	movsd	xmm0, QWORD PTR [edx+ecx]
	comisd	xmm0, QWORD PTR _H$3[ebp]
	jbe	SHORT $LN15@HSLConditi

; 649  : 					continue;

	jmp	SHORT $LN8@HSLConditi
$LN15@HSLConditi:

; 650  : 				if (H > Conditional[i].RangeHigh)

	imul	eax, DWORD PTR _i$8[ebp], 72
	mov	ecx, DWORD PTR _Conditional$[ebp]
	movsd	xmm0, QWORD PTR _H$3[ebp]
	comisd	xmm0, QWORD PTR [ecx+eax+8]
	jbe	SHORT $LN16@HSLConditi

; 651  : 					continue;

	jmp	SHORT $LN8@HSLConditi
$LN16@HSLConditi:

; 652  : 				if (Conditional[i].ModifyHue)

	imul	edx, DWORD PTR _i$8[ebp], 72
	mov	eax, DWORD PTR _Conditional$[ebp]
	cmp	DWORD PTR [eax+edx+16], 0
	je	SHORT $LN17@HSLConditi

; 653  : 				{
; 654  : 					H = ModifyHSLValue(H, Conditional[i].HueOperand, Conditional[i].HueOperation, 0.0, 360.0);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4076800000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	imul	ecx, DWORD PTR _i$8[ebp], 72
	mov	edx, DWORD PTR _Conditional$[ebp]
	mov	eax, DWORD PTR [edx+ecx+32]
	push	eax
	imul	ecx, DWORD PTR _i$8[ebp], 72
	mov	edx, DWORD PTR _Conditional$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [edx+ecx+24]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?ModifyHSLValue@@YGNNNHNN@Z		; ModifyHSLValue
	fstp	QWORD PTR _H$3[ebp]
$LN17@HSLConditi:

; 655  : 				}
; 656  : 				if (Conditional[i].ModifySaturation)

	imul	eax, DWORD PTR _i$8[ebp], 72
	mov	ecx, DWORD PTR _Conditional$[ebp]
	cmp	DWORD PTR [ecx+eax+36], 0
	je	SHORT $LN18@HSLConditi

; 657  : 				{
; 658  : 					S = ModifyHSLValue(S, Conditional[i].SaturationOperand, Conditional[i].SaturationOperation, 0.0, 1.0);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	imul	edx, DWORD PTR _i$8[ebp], 72
	mov	eax, DWORD PTR _Conditional$[ebp]
	mov	ecx, DWORD PTR [eax+edx+48]
	push	ecx
	imul	edx, DWORD PTR _i$8[ebp], 72
	mov	eax, DWORD PTR _Conditional$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+edx+40]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?ModifyHSLValue@@YGNNNHNN@Z		; ModifyHSLValue
	fstp	QWORD PTR _S$1[ebp]
$LN18@HSLConditi:

; 659  : 				}
; 660  : 				if (Conditional[i].ModifyLuminance)

	imul	ecx, DWORD PTR _i$8[ebp], 72
	mov	edx, DWORD PTR _Conditional$[ebp]
	cmp	DWORD PTR [edx+ecx+52], 0
	je	SHORT $LN19@HSLConditi

; 661  : 				{
; 662  : 					L = ModifyHSLValue(L, Conditional[i].LuminanceOperand, Conditional[i].LuminanceOperation, 0.0, 1.0);

	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	imul	eax, DWORD PTR _i$8[ebp], 72
	mov	ecx, DWORD PTR _Conditional$[ebp]
	mov	edx, DWORD PTR [ecx+eax+64]
	push	edx
	imul	eax, DWORD PTR _i$8[ebp], 72
	mov	ecx, DWORD PTR _Conditional$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx+eax+56]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?ModifyHSLValue@@YGNNNHNN@Z		; ModifyHSLValue
	fstp	QWORD PTR _L$2[ebp]
$LN19@HSLConditi:

; 663  : 				}
; 664  : 			}

	jmp	$LN8@HSLConditi
$LN9@HSLConditi:

; 665  : 
; 666  : 			HSLtoRGB8(H, S, L, &R, &G, &B);

	lea	edx, DWORD PTR _B$10[ebp]
	push	edx
	lea	eax, DWORD PTR _G$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _R$12[ebp]
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB8@36

; 667  : 			Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _A$9[ebp]
	mov	BYTE PTR [edx+3], al

; 668  : 			Dest[Index + 2] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _R$12[ebp]
	mov	BYTE PTR [ecx+2], dl

; 669  : 			Dest[Index + 1] = G;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _G$11[ebp]
	mov	BYTE PTR [eax+1], cl

; 670  : 			Dest[Index + 0] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _B$10[ebp]
	mov	BYTE PTR [edx], al

; 671  : 		}

	jmp	$LN5@HSLConditi
$LN6@HSLConditi:

; 672  : 	}

	jmp	$LN2@HSLConditi
$LN3@HSLConditi:

; 673  : 
; 674  : 	return Success;

	xor	eax, eax
$LN1@HSLConditi:

; 675  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_HSLConditionalModify@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_H$1 = -56						; size = 8
_S$2 = -48						; size = 8
_L$3 = -40						; size = 8
_RowOffset$4 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Dest$ = -24						; size = 4
_Src$ = -20						; size = 4
_Column$5 = -16						; size = 4
_Row$6 = -12						; size = 4
_Index$7 = -8						; size = 4
_A$8 = -4						; size = 1
_B$9 = -3						; size = 1
_G$10 = -2						; size = 1
_R$11 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SetHue$ = 28						; size = 4
_NewHue$ = 32						; size = 8
_SetSaturation$ = 40					; size = 4
_NewSaturation$ = 44					; size = 8
_SetLuminance$ = 52					; size = 4
_NewLuminance$ = 56					; size = 8
_HSLBulkSet@56 PROC

; 450  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 451  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@HSLBulkSet

; 452  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@HSLBulkSet
$LN8@HSLBulkSet:

; 453  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@HSLBulkSet

; 454  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@HSLBulkSet
$LN9@HSLBulkSet:

; 455  : 	/*
; 456  : 	if (!SetHue && !SetSaturation && !SetLuminance)
; 457  : 		return NoAction;
; 458  : 		*/
; 459  : 
; 460  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 461  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 462  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 463  : 
; 464  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@HSLBulkSet
$LN2@HSLBulkSet:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@HSLBulkSet:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@HSLBulkSet

; 465  : 	{
; 466  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 467  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@HSLBulkSet
$LN5@HSLBulkSet:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@HSLBulkSet:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@HSLBulkSet

; 468  : 		{
; 469  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 470  : 			BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 471  : 			BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$11[ebp], dl

; 472  : 			BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$10[ebp], cl

; 473  : 			BYTE B = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _B$9[ebp], al

; 474  : 			double H = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _H$1[ebp], xmm0

; 475  : 			double S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$2[ebp], xmm0

; 476  : 			double L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$3[ebp], xmm0

; 477  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$2[ebp]
	push	edx
	lea	eax, DWORD PTR _H$1[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$9[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$11[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 478  : 			if (SetHue)

	cmp	DWORD PTR _SetHue$[ebp], 0
	je	SHORT $LN10@HSLBulkSet

; 479  : 				H = NewHue;

	movsd	xmm0, QWORD PTR _NewHue$[ebp]
	movsd	QWORD PTR _H$1[ebp], xmm0
$LN10@HSLBulkSet:

; 480  : 			if (SetSaturation)

	cmp	DWORD PTR _SetSaturation$[ebp], 0
	je	SHORT $LN11@HSLBulkSet

; 481  : 				S = NewSaturation;

	movsd	xmm0, QWORD PTR _NewSaturation$[ebp]
	movsd	QWORD PTR _S$2[ebp], xmm0
$LN11@HSLBulkSet:

; 482  : 			if (SetLuminance)

	cmp	DWORD PTR _SetLuminance$[ebp], 0
	je	SHORT $LN12@HSLBulkSet

; 483  : 				L = NewLuminance;

	movsd	xmm0, QWORD PTR _NewLuminance$[ebp]
	movsd	QWORD PTR _L$3[ebp], xmm0
$LN12@HSLBulkSet:

; 484  : 			HSLtoRGB8(H, S, L, &R, &G, &B);

	lea	ecx, DWORD PTR _B$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _G$10[ebp]
	push	edx
	lea	eax, DWORD PTR _R$11[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB8@36

; 485  : 			Dest[Index + 3] = A;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 486  : 			Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [eax+2], cl

; 487  : 			Dest[Index + 1] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [edx+1], al

; 488  : 			Dest[Index + 0] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [ecx], dl

; 489  : 		}

	jmp	$LN5@HSLBulkSet
$LN6@HSLBulkSet:

; 490  : 	}

	jmp	$LN2@HSLBulkSet
$LN3@HSLBulkSet:

; 491  : 
; 492  : 	return Success;

	xor	eax, eax
$LN1@HSLBulkSet:

; 493  : }

	mov	esp, ebp
	pop	ebp
	ret	56					; 00000038H
_HSLBulkSet@56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_S$1 = -56						; size = 8
_L$2 = -48						; size = 8
_H$3 = -40						; size = 8
_RowOffset$4 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Dest$ = -24						; size = 4
_Src$ = -20						; size = 4
_Column$5 = -16						; size = 4
_Row$6 = -12						; size = 4
_Index$7 = -8						; size = 4
_A$8 = -4						; size = 1
_B$9 = -3						; size = 1
_G$10 = -2						; size = 1
_R$11 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_HueRanges$ = 28					; size = 4
_ReduceSaturation$ = 32					; size = 4
_SaturationValue$ = 36					; size = 8
_ReduceLuminance$ = 44					; size = 4
_LuminanceValue$ = 48					; size = 8
_HSLColorReduction@48 PROC

; 375  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 376  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@HSLColorRe

; 377  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@HSLColorRe
$LN8@HSLColorRe:

; 378  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@HSLColorRe

; 379  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@HSLColorRe
$LN9@HSLColorRe:

; 380  : 	if (HueRanges < 0)

	cmp	DWORD PTR _HueRanges$[ebp], 0
	jge	SHORT $LN10@HSLColorRe

; 381  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@HSLColorRe
$LN10@HSLColorRe:

; 382  : 
; 383  : 	if (HueRanges < 0)

	cmp	DWORD PTR _HueRanges$[ebp], 0
	jge	SHORT $LN11@HSLColorRe

; 384  : 		HueRanges = 0;

	mov	DWORD PTR _HueRanges$[ebp], 0
$LN11@HSLColorRe:

; 385  : 	if (HueRanges > 360)

	cmp	DWORD PTR _HueRanges$[ebp], 360		; 00000168H
	jle	SHORT $LN12@HSLColorRe

; 386  : 		HueRanges = 360;

	mov	DWORD PTR _HueRanges$[ebp], 360		; 00000168H
$LN12@HSLColorRe:

; 387  : 	if (SaturationValue < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _SaturationValue$[ebp]
	jbe	SHORT $LN13@HSLColorRe

; 388  : 		SaturationValue = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _SaturationValue$[ebp], xmm0
$LN13@HSLColorRe:

; 389  : 	if (SaturationValue > 1.0)

	movsd	xmm0, QWORD PTR _SaturationValue$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN14@HSLColorRe

; 390  : 		SaturationValue = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _SaturationValue$[ebp], xmm0
$LN14@HSLColorRe:

; 391  : 	if (LuminanceValue < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _LuminanceValue$[ebp]
	jbe	SHORT $LN15@HSLColorRe

; 392  : 		LuminanceValue = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _LuminanceValue$[ebp], xmm0
$LN15@HSLColorRe:

; 393  : 	if (LuminanceValue > 1.0)

	movsd	xmm0, QWORD PTR _LuminanceValue$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN16@HSLColorRe

; 394  : 		LuminanceValue = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _LuminanceValue$[ebp], xmm0
$LN16@HSLColorRe:

; 395  : 
; 396  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 397  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 398  : 	__int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 399  : 	//double HueMultiples = 360.0 / (double)HueRanges;
; 400  : 
; 401  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@HSLColorRe
$LN2@HSLColorRe:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@HSLColorRe:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@HSLColorRe

; 402  : 	{
; 403  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 404  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@HSLColorRe
$LN5@HSLColorRe:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@HSLColorRe:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@HSLColorRe

; 405  : 		{
; 406  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 407  : 			BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 408  : 			BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$11[ebp], dl

; 409  : 			BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$10[ebp], cl

; 410  : 			BYTE B = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _B$9[ebp], al

; 411  : 			double H = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _H$3[ebp], xmm0

; 412  : 			double S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$1[ebp], xmm0

; 413  : 			double L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$2[ebp], xmm0

; 414  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$1[ebp]
	push	edx
	lea	eax, DWORD PTR _H$3[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$9[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$11[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 415  : 			H = RoundToClosest(H, HueRanges);

	cvtsi2sd xmm0, DWORD PTR _HueRanges$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?RoundToClosest@@YGNNN@Z		; RoundToClosest
	fstp	QWORD PTR _H$3[ebp]

; 416  : 			//			H = RoundToClosest(H, HueMultiples);
; 417  : 			if (ReduceSaturation)

	cmp	DWORD PTR _ReduceSaturation$[ebp], 0
	je	SHORT $LN17@HSLColorRe

; 418  : 				S = SaturationValue;

	movsd	xmm0, QWORD PTR _SaturationValue$[ebp]
	movsd	QWORD PTR _S$1[ebp], xmm0
$LN17@HSLColorRe:

; 419  : 			if (ReduceLuminance)

	cmp	DWORD PTR _ReduceLuminance$[ebp], 0
	je	SHORT $LN18@HSLColorRe

; 420  : 				L = LuminanceValue;

	movsd	xmm0, QWORD PTR _LuminanceValue$[ebp]
	movsd	QWORD PTR _L$2[ebp], xmm0
$LN18@HSLColorRe:

; 421  : 			HSLtoRGB8(H, S, L, &R, &G, &B);

	lea	ecx, DWORD PTR _B$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _G$10[ebp]
	push	edx
	lea	eax, DWORD PTR _R$11[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB8@36

; 422  : 			Dest[Index + 3] = A;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 423  : 			Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [eax+2], cl

; 424  : 			Dest[Index + 1] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [edx+1], al

; 425  : 			Dest[Index + 0] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [ecx], dl

; 426  : 		}

	jmp	$LN5@HSLColorRe
$LN6@HSLColorRe:

; 427  : 	}

	jmp	$LN2@HSLColorRe
$LN3@HSLColorRe:

; 428  : 
; 429  : 	return Success;

	xor	eax, eax
$LN1@HSLColorRe:

; 430  : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_HSLColorReduction@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_H$1 = -56						; size = 8
_S$2 = -48						; size = 8
_L$3 = -40						; size = 8
_RowOffset$4 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Destination$ = -24					; size = 4
_Source$ = -20						; size = 4
_Column$5 = -16						; size = 4
_Row$6 = -12						; size = 4
_Index$7 = -8						; size = 4
_A$8 = -4						; size = 1
_B$9 = -3						; size = 1
_G$10 = -2						; size = 1
_R$11 = -1						; size = 1
_SourceBuffer$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_DestinationBuffer$ = 24				; size = 4
_HueRangeSize$ = 28					; size = 4
_SaturationRangeSize$ = 32				; size = 4
_LuminanceRangeSize$ = 36				; size = 4
_RestrictHue$ = 40					; size = 4
_RestrictSaturation$ = 44				; size = 4
_RestrictLuminance$ = 48				; size = 4
_RestrictHSL@44 PROC

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 248  : 	if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN8@RestrictHS

; 249  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RestrictHS
$LN8@RestrictHS:

; 250  : 	if (DestinationBuffer == NULL)

	cmp	DWORD PTR _DestinationBuffer$[ebp], 0
	jne	SHORT $LN9@RestrictHS

; 251  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RestrictHS
$LN9@RestrictHS:

; 252  : 
; 253  : 	BYTE *Source = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 254  : 	BYTE *Destination = (BYTE *)DestinationBuffer;

	mov	ecx, DWORD PTR _DestinationBuffer$[ebp]
	mov	DWORD PTR _Destination$[ebp], ecx

; 255  : 	__int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 256  : 
; 257  : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@RestrictHS
$LN2@RestrictHS:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@RestrictHS:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@RestrictHS

; 258  : 	{
; 259  : 		int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 260  : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@RestrictHS
$LN5@RestrictHS:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@RestrictHS:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@RestrictHS

; 261  : 		{
; 262  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 263  : 			BYTE A = Source[Index + 3];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 264  : 			BYTE R = Source[Index + 2];

	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$11[ebp], dl

; 265  : 			BYTE G = Source[Index + 1];

	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$10[ebp], cl

; 266  : 			BYTE B = Source[Index + 0];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$9[ebp], al

; 267  : 			double H, S, L;
; 268  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$2[ebp]
	push	edx
	lea	eax, DWORD PTR _H$1[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$9[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$11[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 269  : 
; 270  : 			if (RestrictHue)

	cmp	DWORD PTR _RestrictHue$[ebp], 0
	je	SHORT $LN10@RestrictHS

; 271  : 			{
; 272  : 				H = DoRestrict(H, 360.0, HueRangeSize);

	mov	ecx, DWORD PTR _HueRangeSize$[ebp]
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@4076800000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?DoRestrict@@YGNNNH@Z			; DoRestrict
	fstp	QWORD PTR _H$1[ebp]
$LN10@RestrictHS:

; 273  : 			}
; 274  : 			if (RestrictSaturation)

	cmp	DWORD PTR _RestrictSaturation$[ebp], 0
	je	SHORT $LN11@RestrictHS

; 275  : 			{
; 276  : 				S = DoRestrict(S, 1.0, SaturationRangeSize);

	mov	edx, DWORD PTR _SaturationRangeSize$[ebp]
	push	edx
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?DoRestrict@@YGNNNH@Z			; DoRestrict
	fstp	QWORD PTR _S$2[ebp]
$LN11@RestrictHS:

; 277  : 			}
; 278  : 			if (RestrictLuminance)

	cmp	DWORD PTR _RestrictLuminance$[ebp], 0
	je	SHORT $LN12@RestrictHS

; 279  : 			{
; 280  : 				L = DoRestrict(L, 1.0, LuminanceRangeSize);

	mov	eax, DWORD PTR _LuminanceRangeSize$[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?DoRestrict@@YGNNNH@Z			; DoRestrict
	fstp	QWORD PTR _L$3[ebp]
$LN12@RestrictHS:

; 281  : 			}
; 282  : 
; 283  : 			HSLtoRGB8(H, S, L, &R, &G, &B);

	lea	ecx, DWORD PTR _B$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _G$10[ebp]
	push	edx
	lea	eax, DWORD PTR _R$11[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB8@36

; 284  : 			Destination[Index + 3] = A;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 285  : 			Destination[Index + 2] = R;

	mov	eax, DWORD PTR _Destination$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [eax+2], cl

; 286  : 			Destination[Index + 1] = G;

	mov	edx, DWORD PTR _Destination$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [edx+1], al

; 287  : 			Destination[Index + 0] = B;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [ecx], dl

; 288  : 		}

	jmp	$LN5@RestrictHS
$LN6@RestrictHS:

; 289  : 	}

	jmp	$LN2@RestrictHS
$LN3@RestrictHS:

; 290  : 
; 291  : 	return Success;

	xor	eax, eax
$LN1@RestrictHS:

; 292  : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_RestrictHSL@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_H$1 = -64						; size = 8
_temp$2 = -56						; size = 8
_S$3 = -48						; size = 8
_L$4 = -40						; size = 8
_RowOffset$5 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Destination$ = -24					; size = 4
_Source$ = -20						; size = 4
_Column$6 = -16						; size = 4
_Row$7 = -12						; size = 4
_Index$8 = -8						; size = 4
_A$9 = -4						; size = 1
_B$10 = -3						; size = 1
_G$11 = -2						; size = 1
_R$12 = -1						; size = 1
_SourceBuffer$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_DestinationBuffer$ = 24				; size = 4
_Silly_SwapSaturationLuminance@20 PROC

; 305  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 306  : 	if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN8@Silly_Swap

; 307  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@Silly_Swap
$LN8@Silly_Swap:

; 308  : 	if (DestinationBuffer == NULL)

	cmp	DWORD PTR _DestinationBuffer$[ebp], 0
	jne	SHORT $LN9@Silly_Swap

; 309  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@Silly_Swap
$LN9@Silly_Swap:

; 310  : 
; 311  : 	BYTE *Source = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 312  : 	BYTE *Destination = (BYTE *)DestinationBuffer;

	mov	ecx, DWORD PTR _DestinationBuffer$[ebp]
	mov	DWORD PTR _Destination$[ebp], ecx

; 313  : 	__int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 314  : 
; 315  : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$7[ebp], 0
	jmp	SHORT $LN4@Silly_Swap
$LN2@Silly_Swap:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN4@Silly_Swap:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@Silly_Swap

; 316  : 	{
; 317  : 		int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$5[ebp], ecx

; 318  : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$6[ebp], 0
	jmp	SHORT $LN7@Silly_Swap
$LN5@Silly_Swap:
	mov	edx, DWORD PTR _Column$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$6[ebp], edx
$LN7@Silly_Swap:
	mov	eax, DWORD PTR _Column$6[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@Silly_Swap

; 319  : 		{
; 320  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$6[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$5[ebp]
	mov	DWORD PTR _Index$8[ebp], ecx

; 321  : 			BYTE A = Source[Index + 3];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$9[ebp], al

; 322  : 			BYTE R = Source[Index + 2];

	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$12[ebp], dl

; 323  : 			BYTE G = Source[Index + 1];

	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$11[ebp], cl

; 324  : 			BYTE B = Source[Index + 0];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$10[ebp], al

; 325  : 			double H, S, L;
; 326  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$3[ebp]
	push	edx
	lea	eax, DWORD PTR _H$1[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$10[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$11[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$12[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 327  : 			double temp = S;

	movsd	xmm0, QWORD PTR _S$3[ebp]
	movsd	QWORD PTR _temp$2[ebp], xmm0

; 328  : 			S = L;

	movsd	xmm0, QWORD PTR _L$4[ebp]
	movsd	QWORD PTR _S$3[ebp], xmm0

; 329  : 			L = temp;

	movsd	xmm0, QWORD PTR _temp$2[ebp]
	movsd	QWORD PTR _L$4[ebp], xmm0

; 330  : 			HSLtoRGB8(H, S, L, &R, &G, &B);

	lea	ecx, DWORD PTR _B$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _G$11[ebp]
	push	edx
	lea	eax, DWORD PTR _R$12[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$4[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB8@36

; 331  : 			Destination[Index + 3] = A;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	dl, BYTE PTR _A$9[ebp]
	mov	BYTE PTR [ecx+3], dl

; 332  : 			Destination[Index + 2] = R;

	mov	eax, DWORD PTR _Destination$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR _R$12[ebp]
	mov	BYTE PTR [eax+2], cl

; 333  : 			Destination[Index + 1] = G;

	mov	edx, DWORD PTR _Destination$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR _G$11[ebp]
	mov	BYTE PTR [edx+1], al

; 334  : 			Destination[Index + 0] = B;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	dl, BYTE PTR _B$10[ebp]
	mov	BYTE PTR [ecx], dl

; 335  : 		}

	jmp	$LN5@Silly_Swap
$LN6@Silly_Swap:

; 336  : 	}

	jmp	$LN2@Silly_Swap
$LN3@Silly_Swap:

; 337  : 	return Success;

	xor	eax, eax
$LN1@Silly_Swap:

; 338  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_Silly_SwapSaturationLuminance@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_S$1 = -56						; size = 8
_L$2 = -48						; size = 8
_H$3 = -40						; size = 8
_RowOffset$4 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Destination$ = -24					; size = 4
_Source$ = -20						; size = 4
_Column$5 = -16						; size = 4
_Row$6 = -12						; size = 4
_Index$7 = -8						; size = 4
_A$8 = -4						; size = 1
_B$9 = -3						; size = 1
_G$10 = -2						; size = 1
_R$11 = -1						; size = 1
_SourceBuffer$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_DestinationBuffer$ = 24				; size = 4
_HMultipler$ = 28					; size = 8
_SMultiplier$ = 36					; size = 8
_LMultiplier$ = 44					; size = 8
_AdjustImageHSLValues@44 PROC

; 117  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 118  : 	if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN8@AdjustImag

; 119  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AdjustImag
$LN8@AdjustImag:

; 120  : 	if (DestinationBuffer == NULL)

	cmp	DWORD PTR _DestinationBuffer$[ebp], 0
	jne	SHORT $LN9@AdjustImag

; 121  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AdjustImag
$LN9@AdjustImag:

; 122  : 
; 123  : 	BYTE *Source = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 124  : 	BYTE *Destination = (BYTE *)DestinationBuffer;

	mov	ecx, DWORD PTR _DestinationBuffer$[ebp]
	mov	DWORD PTR _Destination$[ebp], ecx

; 125  : 	__int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 126  : 
; 127  : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@AdjustImag
$LN2@AdjustImag:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@AdjustImag:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@AdjustImag

; 128  : 	{
; 129  : 		int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 130  : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@AdjustImag
$LN5@AdjustImag:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@AdjustImag:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@AdjustImag

; 131  : 		{
; 132  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 133  : 			BYTE A = Source[Index + 3];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 134  : 			BYTE R = Source[Index + 2];

	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$11[ebp], dl

; 135  : 			BYTE G = Source[Index + 1];

	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$10[ebp], cl

; 136  : 			BYTE B = Source[Index + 0];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$9[ebp], al

; 137  : 			double H, S, L;
; 138  : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	ecx, DWORD PTR _L$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _S$1[ebp]
	push	edx
	lea	eax, DWORD PTR _H$3[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$9[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$11[ebp]
	push	eax
	call	_RGB8ToHSL@24

; 139  : 			H = H * HMultipler;

	movsd	xmm0, QWORD PTR _H$3[ebp]
	mulsd	xmm0, QWORD PTR _HMultipler$[ebp]
	movsd	QWORD PTR _H$3[ebp], xmm0

; 140  : 			if (H < 0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _H$3[ebp]
	jbe	SHORT $LN10@AdjustImag

; 141  : 				H = H + 360.0;

	movsd	xmm0, QWORD PTR _H$3[ebp]
	addsd	xmm0, QWORD PTR __real@4076800000000000
	movsd	QWORD PTR _H$3[ebp], xmm0
$LN10@AdjustImag:

; 142  : 			if (H > 360)

	movsd	xmm0, QWORD PTR _H$3[ebp]
	comisd	xmm0, QWORD PTR __real@4076800000000000
	jbe	SHORT $LN11@AdjustImag

; 143  : 				H = H - 360;

	movsd	xmm0, QWORD PTR _H$3[ebp]
	subsd	xmm0, QWORD PTR __real@4076800000000000
	movsd	QWORD PTR _H$3[ebp], xmm0
$LN11@AdjustImag:

; 144  : 			S = S * SMultiplier;

	movsd	xmm0, QWORD PTR _S$1[ebp]
	mulsd	xmm0, QWORD PTR _SMultiplier$[ebp]
	movsd	QWORD PTR _S$1[ebp], xmm0

; 145  : 			if (S < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _S$1[ebp]
	jbe	SHORT $LN12@AdjustImag

; 146  : 				S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$1[ebp], xmm0
$LN12@AdjustImag:

; 147  : 			if (S > 1.0)

	movsd	xmm0, QWORD PTR _S$1[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN13@AdjustImag

; 148  : 				S = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _S$1[ebp], xmm0
$LN13@AdjustImag:

; 149  : 			L = L * LMultiplier;

	movsd	xmm0, QWORD PTR _L$2[ebp]
	mulsd	xmm0, QWORD PTR _LMultiplier$[ebp]
	movsd	QWORD PTR _L$2[ebp], xmm0

; 150  : 			if (L < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _L$2[ebp]
	jbe	SHORT $LN14@AdjustImag

; 151  : 				L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$2[ebp], xmm0
$LN14@AdjustImag:

; 152  : 			if (L > 1.0)

	movsd	xmm0, QWORD PTR _L$2[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN15@AdjustImag

; 153  : 				L = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _L$2[ebp], xmm0
$LN15@AdjustImag:

; 154  : 			HSLtoRGB8(H, S, L, &R, &G, &B);

	lea	ecx, DWORD PTR _B$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _G$10[ebp]
	push	edx
	lea	eax, DWORD PTR _R$11[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB8@36

; 155  : 			Destination[Index + 3] = A;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 156  : 			Destination[Index + 2] = R;

	mov	eax, DWORD PTR _Destination$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [eax+2], cl

; 157  : 			Destination[Index + 1] = G;

	mov	edx, DWORD PTR _Destination$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [edx+1], al

; 158  : 			Destination[Index + 0] = B;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [ecx], dl

; 159  : 		}

	jmp	$LN5@AdjustImag
$LN6@AdjustImag:

; 160  : 	}

	jmp	$LN2@AdjustImag
$LN3@AdjustImag:

; 161  : 	return Success;

	xor	eax, eax
$LN1@AdjustImag:

; 162  : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_AdjustImageHSLValues@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Destination$ = -24					; size = 4
_Source$ = -20						; size = 4
_Column$2 = -16						; size = 4
_Row$3 = -12						; size = 4
_Index$4 = -8						; size = 4
_A$5 = -4						; size = 1
_B$6 = -3						; size = 1
_G$7 = -2						; size = 1
_R$8 = -1						; size = 1
_SourceBuffer$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_DestinationBuffer$ = 24				; size = 4
_HueShiftValue$ = 28					; size = 4
_ImageHueShift@24 PROC

; 176  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 177  : 	if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN8@ImageHueSh

; 178  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageHueSh
$LN8@ImageHueSh:

; 179  : 	if (DestinationBuffer == NULL)

	cmp	DWORD PTR _DestinationBuffer$[ebp], 0
	jne	SHORT $LN9@ImageHueSh

; 180  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageHueSh
$LN9@ImageHueSh:

; 181  : 
; 182  : 	BYTE *Source = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 183  : 	BYTE *Destination = (BYTE *)DestinationBuffer;

	mov	ecx, DWORD PTR _DestinationBuffer$[ebp]
	mov	DWORD PTR _Destination$[ebp], ecx

; 184  : 	__int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 185  : 
; 186  : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ImageHueSh
$LN2@ImageHueSh:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@ImageHueSh:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@ImageHueSh

; 187  : 	{
; 188  : 		int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 189  : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ImageHueSh
$LN5@ImageHueSh:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@ImageHueSh:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@ImageHueSh

; 190  : 		{
; 191  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 192  : 			BYTE A = Source[Index + 3];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$5[ebp], al

; 193  : 			BYTE R = Source[Index + 2];

	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$8[ebp], dl

; 194  : 			BYTE G = Source[Index + 1];

	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$7[ebp], cl

; 195  : 			BYTE B = Source[Index + 0];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$6[ebp], al

; 196  : 			ShiftHue(&R, &G, &B, HueShiftValue);

	mov	ecx, DWORD PTR _HueShiftValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _B$6[ebp]
	push	edx
	lea	eax, DWORD PTR _G$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _R$8[ebp]
	push	ecx
	call	_ShiftHue@16

; 197  : 			Destination[Index + 3] = A;

	mov	edx, DWORD PTR _Destination$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _A$5[ebp]
	mov	BYTE PTR [edx+3], al

; 198  : 			Destination[Index + 2] = R;

	mov	ecx, DWORD PTR _Destination$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _R$8[ebp]
	mov	BYTE PTR [ecx+2], dl

; 199  : 			Destination[Index + 1] = G;

	mov	eax, DWORD PTR _Destination$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _G$7[ebp]
	mov	BYTE PTR [eax+1], cl

; 200  : 			Destination[Index + 0] = B;

	mov	edx, DWORD PTR _Destination$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _B$6[ebp]
	mov	BYTE PTR [edx], al

; 201  : 		}

	jmp	$LN5@ImageHueSh
$LN6@ImageHueSh:

; 202  : 	}

	jmp	$LN2@ImageHueSh
$LN3@ImageHueSh:

; 203  : 
; 204  : 	return Success;

	xor	eax, eax
$LN1@ImageHueSh:

; 205  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_ImageHueShift@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_H$1 = -60						; size = 8
_S$2 = -52						; size = 8
_L$3 = -44						; size = 8
_RowOffset$4 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_HSL$ = -28						; size = 4
_Index$5 = -24						; size = 4
_Dest$ = -20						; size = 4
_Column$6 = -16						; size = 4
_Row$7 = -12						; size = 4
_DoubleIndex$ = -8					; size = 4
_B$8 = -3						; size = 1
_G$9 = -2						; size = 1
_R$10 = -1						; size = 1
_HSLBuffer$ = 8						; size = 4
_DoubleCount$ = 12					; size = 4
_Destination$ = 16					; size = 4
_DestinationWidth$ = 20					; size = 4
_DestinationHeight$ = 24				; size = 4
_DestinationStride$ = 28				; size = 4
_MakeRGBFromHSL@24 PROC

; 64   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 65   : 	if (HSLBuffer == NULL)

	cmp	DWORD PTR _HSLBuffer$[ebp], 0
	jne	SHORT $LN8@MakeRGBFro

; 66   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@MakeRGBFro
$LN8@MakeRGBFro:

; 67   : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@MakeRGBFro

; 68   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@MakeRGBFro
$LN9@MakeRGBFro:

; 69   : 
; 70   : 	BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 71   : 	double *HSL = (double *)HSLBuffer;

	mov	ecx, DWORD PTR _HSLBuffer$[ebp]
	mov	DWORD PTR _HSL$[ebp], ecx

; 72   : 
; 73   : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 74   : 	int DoubleIndex = 0;

	mov	DWORD PTR _DoubleIndex$[ebp], 0

; 75   : 
; 76   : 	for (int Row = 0; Row < DestinationHeight; Row++)

	mov	DWORD PTR _Row$7[ebp], 0
	jmp	SHORT $LN4@MakeRGBFro
$LN2@MakeRGBFro:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN4@MakeRGBFro:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _DestinationHeight$[ebp]
	jge	$LN3@MakeRGBFro

; 77   : 	{
; 78   : 		int RowOffset = Row * DestinationStride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _DestinationStride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 79   : 		for (int Column = 0; Column < DestinationWidth; Column++)

	mov	DWORD PTR _Column$6[ebp], 0
	jmp	SHORT $LN7@MakeRGBFro
$LN5@MakeRGBFro:
	mov	edx, DWORD PTR _Column$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$6[ebp], edx
$LN7@MakeRGBFro:
	mov	eax, DWORD PTR _Column$6[ebp]
	cmp	eax, DWORD PTR _DestinationWidth$[ebp]
	jge	$LN6@MakeRGBFro

; 80   : 		{
; 81   : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$6[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 82   : 			double H = HSL[DoubleIndex++];

	mov	edx, DWORD PTR _DoubleIndex$[ebp]
	mov	eax, DWORD PTR _HSL$[ebp]
	movsd	xmm0, QWORD PTR [eax+edx*8]
	movsd	QWORD PTR _H$1[ebp], xmm0
	mov	ecx, DWORD PTR _DoubleIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _DoubleIndex$[ebp], ecx

; 83   : 			double S = HSL[DoubleIndex++];

	mov	edx, DWORD PTR _DoubleIndex$[ebp]
	mov	eax, DWORD PTR _HSL$[ebp]
	movsd	xmm0, QWORD PTR [eax+edx*8]
	movsd	QWORD PTR _S$2[ebp], xmm0
	mov	ecx, DWORD PTR _DoubleIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _DoubleIndex$[ebp], ecx

; 84   : 			double L = HSL[DoubleIndex++];

	mov	edx, DWORD PTR _DoubleIndex$[ebp]
	mov	eax, DWORD PTR _HSL$[ebp]
	movsd	xmm0, QWORD PTR [eax+edx*8]
	movsd	QWORD PTR _L$3[ebp], xmm0
	mov	ecx, DWORD PTR _DoubleIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _DoubleIndex$[ebp], ecx

; 85   : 			BYTE R = 0;

	mov	BYTE PTR _R$10[ebp], 0

; 86   : 			BYTE G = 0;

	mov	BYTE PTR _G$9[ebp], 0

; 87   : 			BYTE B = 0;

	mov	BYTE PTR _B$8[ebp], 0

; 88   : 			HSLtoRGB8(H, S, L, &R, &G, &B);

	lea	edx, DWORD PTR _B$8[ebp]
	push	edx
	lea	eax, DWORD PTR _G$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _R$10[ebp]
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB8@36

; 89   : 			Dest[Index + 3] = 0xff;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH

; 90   : 			Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _R$10[ebp]
	mov	BYTE PTR [eax+2], cl

; 91   : 			Dest[Index + 1] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _G$9[ebp]
	mov	BYTE PTR [edx+1], al

; 92   : 			Dest[Index + 0] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _B$8[ebp]
	mov	BYTE PTR [ecx], dl

; 93   : 		}

	jmp	$LN5@MakeRGBFro
$LN6@MakeRGBFro:

; 94   : 	}

	jmp	$LN2@MakeRGBFro
$LN3@MakeRGBFro:

; 95   : 
; 96   : 	return Success;

	xor	eax, eax
$LN1@MakeRGBFro:

; 97   : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_MakeRGBFromHSL@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\hsladjustments.cpp
_TEXT	SEGMENT
_L$1 = -60						; size = 8
_S$2 = -52						; size = 8
_H$3 = -44						; size = 8
_RowOffset$4 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_Destination$ = -28					; size = 4
_Index$5 = -24						; size = 4
_Source$ = -20						; size = 4
_Column$6 = -16						; size = 4
_Row$7 = -12						; size = 4
_DoubleIndex$ = -8					; size = 4
_R$8 = -3						; size = 1
_G$9 = -2						; size = 1
_B$10 = -1						; size = 1
_SourceBuffer$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_DoubleBuffer$ = 24					; size = 4
_GetHSLImage@20 PROC

; 21   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 22   : 	if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN8@GetHSLImag

; 23   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@GetHSLImag
$LN8@GetHSLImag:

; 24   : 	if (DoubleBuffer == NULL)

	cmp	DWORD PTR _DoubleBuffer$[ebp], 0
	jne	SHORT $LN9@GetHSLImag

; 25   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@GetHSLImag
$LN9@GetHSLImag:

; 26   : 
; 27   : 	BYTE *Source = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 28   : 	double *Destination = (double *)DoubleBuffer;

	mov	ecx, DWORD PTR _DoubleBuffer$[ebp]
	mov	DWORD PTR _Destination$[ebp], ecx

; 29   : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 30   : 	int DoubleIndex = 0;

	mov	DWORD PTR _DoubleIndex$[ebp], 0

; 31   : 
; 32   : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$7[ebp], 0
	jmp	SHORT $LN4@GetHSLImag
$LN2@GetHSLImag:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN4@GetHSLImag:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@GetHSLImag

; 33   : 	{
; 34   : 		int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 35   : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$6[ebp], 0
	jmp	SHORT $LN7@GetHSLImag
$LN5@GetHSLImag:
	mov	edx, DWORD PTR _Column$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$6[ebp], edx
$LN7@GetHSLImag:
	mov	eax, DWORD PTR _Column$6[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@GetHSLImag

; 36   : 		{
; 37   : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$6[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 38   : 			BYTE R = Source[Index + 2];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$8[ebp], al

; 39   : 			BYTE G = Source[Index + 1];

	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$9[ebp], dl

; 40   : 			BYTE B = Source[Index + 0];

	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$10[ebp], cl

; 41   : 			double H, S, L;
; 42   : 			RGB8ToHSL(R, G, B, &H, &S, &L);

	lea	edx, DWORD PTR _L$1[ebp]
	push	edx
	lea	eax, DWORD PTR _S$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _H$3[ebp]
	push	ecx
	movzx	edx, BYTE PTR _B$10[ebp]
	push	edx
	movzx	eax, BYTE PTR _G$9[ebp]
	push	eax
	movzx	ecx, BYTE PTR _R$8[ebp]
	push	ecx
	call	_RGB8ToHSL@24

; 43   : 			Destination[DoubleIndex++] = H;

	mov	edx, DWORD PTR _DoubleIndex$[ebp]
	mov	eax, DWORD PTR _Destination$[ebp]
	movsd	xmm0, QWORD PTR _H$3[ebp]
	movsd	QWORD PTR [eax+edx*8], xmm0
	mov	ecx, DWORD PTR _DoubleIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _DoubleIndex$[ebp], ecx

; 44   : 			Destination[DoubleIndex++] = S;

	mov	edx, DWORD PTR _DoubleIndex$[ebp]
	mov	eax, DWORD PTR _Destination$[ebp]
	movsd	xmm0, QWORD PTR _S$2[ebp]
	movsd	QWORD PTR [eax+edx*8], xmm0
	mov	ecx, DWORD PTR _DoubleIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _DoubleIndex$[ebp], ecx

; 45   : 			Destination[DoubleIndex++] = L;

	mov	edx, DWORD PTR _DoubleIndex$[ebp]
	mov	eax, DWORD PTR _Destination$[ebp]
	movsd	xmm0, QWORD PTR _L$1[ebp]
	movsd	QWORD PTR [eax+edx*8], xmm0
	mov	ecx, DWORD PTR _DoubleIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _DoubleIndex$[ebp], ecx

; 46   : 		}

	jmp	$LN5@GetHSLImag
$LN6@GetHSLImag:

; 47   : 	}

	jmp	$LN2@GetHSLImag
$LN3@GetHSLImag:

; 48   : 
; 49   : 	return Success;

	xor	eax, eax
$LN1@GetHSLImag:

; 50   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_GetHSLImage@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_math.h
;	COMDAT _floorf
_TEXT	SEGMENT
tv77 = -20						; size = 8
tv71 = -12						; size = 8
tv79 = -4						; size = 4
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 684  :         {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 685  :             return (float)floor(_X);

	cvtss2sd xmm0, DWORD PTR __X$[ebp]
	movsd	QWORD PTR tv71[ebp], xmm0
	fld	QWORD PTR tv71[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR tv77[ebp]
	movsd	xmm0, QWORD PTR tv77[ebp]
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR tv79[ebp], xmm0
	fld	DWORD PTR tv79[ebp]

; 686  :         }

	mov	esp, ebp
	pop	ebp
	ret	0
_floorf	ENDP
_TEXT	ENDS
END
