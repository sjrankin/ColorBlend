; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Distortion.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_HorizontalMirrorPixelRegion@32
PUBLIC	_HorizontalMirrorPixel@16
PUBLIC	_HorizontalMirrorByte@28
PUBLIC	_VerticalMirrorPixelRegion@32
PUBLIC	_VerticalMirrorPixel@16
PUBLIC	_VerticalMirrorByte@28
PUBLIC	_ULtoLRPixel@16
PUBLIC	_ULtoLRByte@28
PUBLIC	_SquishImage@40
PUBLIC	_ClearBufferRegion@36
PUBLIC	?ULtoLRRegion@@YGHPAXHH0HHHH@Z			; ULtoLRRegion
PUBLIC	?TranslateRegionInImage@@YGHPAXHHH0HHHHHHHI@Z	; TranslateRegionInImage
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_CopyRegion@36:PROC
EXTRN	_PasteRegion@40:PROC
EXTRN	_CopyBufferToBuffer@20:PROC
EXTRN	_ClearBufferRegion2@36:PROC
EXTRN	_SetAlphaChannelInPlace@20:PROC
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
$T1 = -48						; size = 4
_PixelSize$ = -44					; size = 4
_Region$ = -40						; size = 4
tv137 = -36						; size = 4
tv93 = -32						; size = 4
_RegionHeight$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_RegionWidth$ = -16					; size = 4
_RegionStride$ = -12					; size = 4
_UL$ = -8						; size = 4
_LR$ = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RegionLeft$ = 28					; size = 4
_RegionTop$ = 32					; size = 4
_RegionRight$ = 36					; size = 4
_RegionBottom$ = 40					; size = 4
_NewX$ = 44						; size = 4
_NewY$ = 48						; size = 4
_DoCopy$ = 52						; size = 4
_GapColor$ = 56						; size = 4
?TranslateRegionInImage@@YGHPAXHHH0HHHHHHHI@Z PROC	; TranslateRegionInImage

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 361  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@TranslateR

; 362  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@TranslateR
$LN2@TranslateR:

; 363  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN3@TranslateR

; 364  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@TranslateR
$LN3@TranslateR:

; 365  : 
; 366  : 	if (RegionLeft >= RegionRight)

	mov	eax, DWORD PTR _RegionLeft$[ebp]
	cmp	eax, DWORD PTR _RegionRight$[ebp]
	jl	SHORT $LN4@TranslateR

; 367  : 		return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@TranslateR
$LN4@TranslateR:

; 368  : 	if (RegionTop >= RegionBottom)

	mov	ecx, DWORD PTR _RegionTop$[ebp]
	cmp	ecx, DWORD PTR _RegionBottom$[ebp]
	jl	SHORT $LN5@TranslateR

; 369  : 		return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@TranslateR
$LN5@TranslateR:

; 370  : 
; 371  : 	RegionLeft += NewX;

	mov	edx, DWORD PTR _RegionLeft$[ebp]
	add	edx, DWORD PTR _NewX$[ebp]
	mov	DWORD PTR _RegionLeft$[ebp], edx

; 372  : 	RegionRight += NewX;

	mov	eax, DWORD PTR _RegionRight$[ebp]
	add	eax, DWORD PTR _NewX$[ebp]
	mov	DWORD PTR _RegionRight$[ebp], eax

; 373  : 	RegionTop += NewY;

	mov	ecx, DWORD PTR _RegionTop$[ebp]
	add	ecx, DWORD PTR _NewY$[ebp]
	mov	DWORD PTR _RegionTop$[ebp], ecx

; 374  : 	RegionBottom += NewY;

	mov	edx, DWORD PTR _RegionBottom$[ebp]
	add	edx, DWORD PTR _NewY$[ebp]
	mov	DWORD PTR _RegionBottom$[ebp], edx

; 375  : 
; 376  : 	if (RegionLeft > Width)

	mov	eax, DWORD PTR _RegionLeft$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jle	SHORT $LN6@TranslateR

; 377  : 		return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@TranslateR
$LN6@TranslateR:

; 378  : 	if (RegionTop > Height)

	mov	ecx, DWORD PTR _RegionTop$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jle	SHORT $LN7@TranslateR

; 379  : 		return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@TranslateR
$LN7@TranslateR:

; 380  : 	if (RegionBottom < 0)

	cmp	DWORD PTR _RegionBottom$[ebp], 0
	jge	SHORT $LN8@TranslateR

; 381  : 		return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@TranslateR
$LN8@TranslateR:

; 382  : 	if (RegionRight < 0)

	cmp	DWORD PTR _RegionRight$[ebp], 0
	jge	SHORT $LN9@TranslateR

; 383  : 		return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@TranslateR
$LN9@TranslateR:

; 384  : 
; 385  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 386  : 	int RegionWidth = RegionRight - RegionLeft + 1;

	mov	edx, DWORD PTR _RegionRight$[ebp]
	sub	edx, DWORD PTR _RegionLeft$[ebp]
	add	edx, 1
	mov	DWORD PTR _RegionWidth$[ebp], edx

; 387  : 	int RegionHeight = RegionBottom - RegionTop + 1;

	mov	eax, DWORD PTR _RegionBottom$[ebp]
	sub	eax, DWORD PTR _RegionTop$[ebp]
	add	eax, 1
	mov	DWORD PTR _RegionHeight$[ebp], eax

; 388  : 	int RegionStride = RegionWidth * PixelSize;

	mov	ecx, DWORD PTR _RegionWidth$[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	mov	DWORD PTR _RegionStride$[ebp], ecx

; 389  : 	BYTE *Region = new BYTE[RegionHeight * RegionStride];

	mov	edx, DWORD PTR _RegionHeight$[ebp]
	imul	edx, DWORD PTR _RegionStride$[ebp]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _Region$[ebp], eax

; 390  : 	AbsolutePointStruct *UL = new AbsolutePointStruct();

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN12@TranslateR
	xor	ecx, ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN13@TranslateR
$LN12@TranslateR:
	mov	DWORD PTR tv93[ebp], 0
$LN13@TranslateR:
	mov	ecx, DWORD PTR tv93[ebp]
	mov	DWORD PTR _UL$[ebp], ecx

; 391  : 	UL->X = RegionLeft;

	mov	edx, DWORD PTR _UL$[ebp]
	mov	eax, DWORD PTR _RegionLeft$[ebp]
	mov	DWORD PTR [edx], eax

; 392  : 	UL->Y = RegionTop;

	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR _RegionTop$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 393  : 	AbsolutePointStruct *LR = new AbsolutePointStruct();

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 0
	je	SHORT $LN14@TranslateR
	xor	eax, eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR tv137[ebp], edx
	jmp	SHORT $LN15@TranslateR
$LN14@TranslateR:
	mov	DWORD PTR tv137[ebp], 0
$LN15@TranslateR:
	mov	eax, DWORD PTR tv137[ebp]
	mov	DWORD PTR _LR$[ebp], eax

; 394  : 	LR->X = RegionRight;

	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _RegionRight$[ebp]
	mov	DWORD PTR [ecx], edx

; 395  : 	LR->Y = RegionBottom;

	mov	eax, DWORD PTR _LR$[ebp]
	mov	ecx, DWORD PTR _RegionBottom$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 396  : 
; 397  : 	CopyRegion(Source, Width, Height, Stride, Region, RegionWidth, RegionStride, UL, LR);

	mov	edx, DWORD PTR _LR$[ebp]
	push	edx
	mov	eax, DWORD PTR _UL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RegionStride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _RegionWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Region$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_CopyRegion@36

; 398  : 	CopyBufferToBuffer(Source, Width, Height, Stride, Destination);

	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_CopyBufferToBuffer@20

; 399  : 	if (!DoCopy)

	cmp	DWORD PTR _DoCopy$[ebp], 0
	jne	SHORT $LN10@TranslateR

; 400  : 		ClearBufferRegion2(Destination, RegionWidth, RegionHeight, RegionStride, GapColor, RegionLeft, RegionTop, RegionRight, RegionBottom);

	mov	ecx, DWORD PTR _RegionBottom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _RegionRight$[ebp]
	push	edx
	mov	eax, DWORD PTR _RegionTop$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RegionLeft$[ebp]
	push	ecx
	mov	edx, DWORD PTR _GapColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _RegionStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RegionHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _RegionWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	call	_ClearBufferRegion2@36
$LN10@TranslateR:

; 401  : 	PasteRegion(Destination, Width, Height, Stride, Region, RegionWidth, RegionHeight, RegionStride, UL, LR);

	mov	ecx, DWORD PTR _LR$[ebp]
	push	ecx
	mov	edx, DWORD PTR _UL$[ebp]
	push	edx
	mov	eax, DWORD PTR _RegionStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RegionHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _RegionWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Region$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Destination$[ebp]
	push	ecx
	call	_PasteRegion@40

; 402  : 
; 403  : 	return Success;

	xor	eax, eax
$LN1@TranslateR:

; 404  : }

	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
?TranslateRegionInImage@@YGHPAXHHH0HHHHHHHI@Z ENDP	; TranslateRegionInImage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_Result$ = -8						; size = 4
_Scratch$ = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_X1$ = 24						; size = 4
_Y1$ = 28						; size = 4
_X2$ = 32						; size = 4
_Y2$ = 36						; size = 4
?ULtoLRRegion@@YGHPAXHH0HHHH@Z PROC			; ULtoLRRegion

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 255  : 	byte *Scratch = new byte[Height * Width * 8];

	mov	eax, DWORD PTR _Height$[ebp]
	imul	eax, DWORD PTR _Width$[ebp]
	shl	eax, 3
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _Scratch$[ebp], ecx

; 256  : 	int Result = VerticalMirrorPixelRegion(Source, Width, Height, Scratch, X1, Y1, X2, Y2);

	mov	edx, DWORD PTR _Y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _X2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Y1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _X1$[ebp]
	push	edx
	mov	eax, DWORD PTR _Scratch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_VerticalMirrorPixelRegion@32
	mov	DWORD PTR _Result$[ebp], eax

; 257  : 	if (Result == Success)

	cmp	DWORD PTR _Result$[ebp], 0
	jne	SHORT $LN2@ULtoLRRegi

; 258  : 	{
; 259  : 		Result = HorizontalMirrorPixelRegion(Scratch, Width, Height, Destination, X1, Y1, X2, Y2);

	mov	ecx, DWORD PTR _Y2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _X2$[ebp]
	push	edx
	mov	eax, DWORD PTR _Y1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _X1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Scratch$[ebp]
	push	edx
	call	_HorizontalMirrorPixelRegion@32
	mov	DWORD PTR _Result$[ebp], eax
$LN2@ULtoLRRegi:

; 260  : 	}
; 261  : 	delete[] Scratch;

	mov	eax, DWORD PTR _Scratch$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 262  : 	return Result;

	mov	eax, DWORD PTR _Result$[ebp]

; 263  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?ULtoLRRegion@@YGHPAXHH0HHHH@Z ENDP			; ULtoLRRegion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Index$2 = -20						; size = 4
_Dest$ = -16						; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_B$ = -4						; size = 1
_G$ = -3						; size = 1
_R$ = -2						; size = 1
_A$ = -1						; size = 1
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_FillColor$ = 24					; size = 4
_Left$ = 28						; size = 4
_Top$ = 32						; size = 4
_Right$ = 36						; size = 4
_Bottom$ = 40						; size = 4
_ClearBufferRegion@36 PROC

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 309  : 	if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN8@ClearBuffe

; 310  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ClearBuffe
$LN8@ClearBuffe:

; 311  : 	if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN9@ClearBuffe

; 312  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ClearBuffe
$LN9@ClearBuffe:

; 313  : 	if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN10@ClearBuffe

; 314  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ClearBuffe
$LN10@ClearBuffe:

; 315  : 	if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN11@ClearBuffe

; 316  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ClearBuffe
$LN11@ClearBuffe:

; 317  : 
; 318  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 319  : 	BYTE *Dest = (BYTE *)Destination;

	mov	edx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], edx

; 320  : 	BYTE A = (FillColor & 0xff000000) >> 24;

	mov	eax, DWORD PTR _FillColor$[ebp]
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	BYTE PTR _A$[ebp], al

; 321  : 	BYTE R = (FillColor & 0x00ff0000) >> 16;

	mov	ecx, DWORD PTR _FillColor$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR _R$[ebp], cl

; 322  : 	BYTE G = (FillColor & 0x0000ff00) >> 8;

	mov	edx, DWORD PTR _FillColor$[ebp]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _G$[ebp], dl

; 323  : 	BYTE B = (FillColor & 0x000000ff) >> 0;

	mov	eax, DWORD PTR _FillColor$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _B$[ebp], al

; 324  : 
; 325  : 	for (int Row = Top; Row <= Bottom; Row++)

	mov	ecx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$4[ebp], ecx
	jmp	SHORT $LN4@ClearBuffe
$LN2@ClearBuffe:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@ClearBuffe:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN3@ClearBuffe

; 326  : 	{
; 327  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 328  : 		for (int Column = Left; Column <= Right; Column++)

	mov	edx, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$3[ebp], edx
	jmp	SHORT $LN7@ClearBuffe
$LN5@ClearBuffe:
	mov	eax, DWORD PTR _Column$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$3[ebp], eax
$LN7@ClearBuffe:
	mov	ecx, DWORD PTR _Column$3[ebp]
	cmp	ecx, DWORD PTR _Right$[ebp]
	jg	SHORT $LN6@ClearBuffe

; 329  : 		{
; 330  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$3[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], edx

; 331  : 			Dest[Index + 3] = A;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	cl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [eax+3], cl

; 332  : 			Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR _R$[ebp]
	mov	BYTE PTR [edx+2], al

; 333  : 			Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	mov	dl, BYTE PTR _G$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 334  : 			Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	cl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [eax], cl

; 335  : 		}

	jmp	SHORT $LN5@ClearBuffe
$LN6@ClearBuffe:

; 336  : 	}

	jmp	SHORT $LN2@ClearBuffe
$LN3@ClearBuffe:

; 337  : 	return Success;

	xor	eax, eax
$LN1@ClearBuffe:

; 338  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_ClearBufferRegion@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
_PixelSize$ = -44					; size = 4
_Src$ = -40						; size = 4
_SourceIndex$1 = -36					; size = 4
_Dest$ = -32						; size = 4
_DestIndex$2 = -28					; size = 4
_DestOffset$3 = -24					; size = 4
_RowOffset$4 = -20					; size = 4
_DestRow$ = -16						; size = 4
_DestColumn$ = -12					; size = 4
_Column$5 = -8						; size = 4
_Row$6 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_DestWidth$ = 28					; size = 4
_DestHeight$ = 32					; size = 4
_DestStride$ = 36					; size = 4
_HorizontalFrequency$ = 40				; size = 4
_VerticalFrequency$ = 44				; size = 4
_SquishImage@40 PROC

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi

; 424  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@SquishImag

; 425  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SquishImag
$LN8@SquishImag:

; 426  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@SquishImag

; 427  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SquishImag
$LN9@SquishImag:

; 428  : 	if (HorizontalFrequency < 1)

	cmp	DWORD PTR _HorizontalFrequency$[ebp], 1
	jge	SHORT $LN10@SquishImag

; 429  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@SquishImag
$LN10@SquishImag:

; 430  : 	if (VerticalFrequency < 1)

	cmp	DWORD PTR _VerticalFrequency$[ebp], 1
	jge	SHORT $LN11@SquishImag

; 431  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@SquishImag
$LN11@SquishImag:

; 432  : 
; 433  : 	UINT32 *Src = (UINT32 *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 434  : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 435  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 436  : 	int DestRow = 0;

	mov	DWORD PTR _DestRow$[ebp], 0

; 437  : 	int DestColumn = 0;

	mov	DWORD PTR _DestColumn$[ebp], 0

; 438  : 
; 439  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@SquishImag
$LN2@SquishImag:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@SquishImag:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@SquishImag

; 440  : 	{
; 441  : 		if (Row % VerticalFrequency != 0)

	mov	eax, DWORD PTR _Row$6[ebp]
	cdq
	idiv	DWORD PTR _VerticalFrequency$[ebp]
	test	edx, edx
	je	SHORT $LN12@SquishImag

; 442  : 			continue;

	jmp	SHORT $LN2@SquishImag
$LN12@SquishImag:

; 443  : 		int RowOffset = Row * Width;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 444  : 		int DestOffset = DestRow * DestWidth;

	mov	edx, DWORD PTR _DestRow$[ebp]
	imul	edx, DWORD PTR _DestWidth$[ebp]
	mov	DWORD PTR _DestOffset$3[ebp], edx

; 445  : 		DestRow++;

	mov	eax, DWORD PTR _DestRow$[ebp]
	add	eax, 1
	mov	DWORD PTR _DestRow$[ebp], eax

; 446  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@SquishImag
$LN5@SquishImag:
	mov	ecx, DWORD PTR _Column$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$5[ebp], ecx
$LN7@SquishImag:
	mov	edx, DWORD PTR _Column$5[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@SquishImag

; 447  : 		{
; 448  : 			if (Column % HorizontalFrequency != 0)

	mov	eax, DWORD PTR _Column$5[ebp]
	cdq
	idiv	DWORD PTR _HorizontalFrequency$[ebp]
	test	edx, edx
	je	SHORT $LN13@SquishImag

; 449  : 				continue;

	jmp	SHORT $LN5@SquishImag
$LN13@SquishImag:

; 450  : 
; 451  : 			int SourceIndex = RowOffset + Column;

	mov	eax, DWORD PTR _RowOffset$4[ebp]
	add	eax, DWORD PTR _Column$5[ebp]
	mov	DWORD PTR _SourceIndex$1[ebp], eax

; 452  : 			int DestIndex = DestOffset + DestColumn;

	mov	ecx, DWORD PTR _DestOffset$3[ebp]
	add	ecx, DWORD PTR _DestColumn$[ebp]
	mov	DWORD PTR _DestIndex$2[ebp], ecx

; 453  : 			DestColumn++;

	mov	edx, DWORD PTR _DestColumn$[ebp]
	add	edx, 1
	mov	DWORD PTR _DestColumn$[ebp], edx

; 454  : 			Dest[DestIndex] = Src[SourceIndex];

	mov	eax, DWORD PTR _DestIndex$2[ebp]
	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	edx, DWORD PTR _SourceIndex$1[ebp]
	mov	esi, DWORD PTR _Src$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 455  : 		}

	jmp	SHORT $LN5@SquishImag
$LN6@SquishImag:

; 456  : 		DestColumn = 0;

	mov	DWORD PTR _DestColumn$[ebp], 0

; 457  : 	}

	jmp	$LN2@SquishImag
$LN3@SquishImag:

; 458  : 
; 459  : 	return Success;

	xor	eax, eax
$LN1@SquishImag:

; 460  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_SquishImage@40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_Result$ = -8						; size = 4
_Scratch$ = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SetAlpha$ = 28						; size = 4
_AlphaValue$ = 32					; size = 1
_ULtoLRByte@28 PROC

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 296  : 	byte *Scratch = new byte[Height * Stride];

	mov	eax, DWORD PTR _Height$[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _Scratch$[ebp], ecx

; 297  : 	int Result = VerticalMirrorByte(Source, Width, Height, Stride, Scratch, SetAlpha, AlphaValue);

	movzx	edx, BYTE PTR _AlphaValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _SetAlpha$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Scratch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stride$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Source$[ebp]
	push	edx
	call	_VerticalMirrorByte@28
	mov	DWORD PTR _Result$[ebp], eax

; 298  : 	if (Result == Success)

	cmp	DWORD PTR _Result$[ebp], 0
	jne	SHORT $LN2@ULtoLRByte

; 299  : 	{
; 300  : 		Result = HorizontalMirrorByte(Scratch, Width, Height, Stride, Destination, SetAlpha, AlphaValue);

	movzx	eax, BYTE PTR _AlphaValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SetAlpha$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Scratch$[ebp]
	push	eax
	call	_HorizontalMirrorByte@28
	mov	DWORD PTR _Result$[ebp], eax
$LN2@ULtoLRByte:

; 301  : 	}
; 302  : 	delete[] Scratch;

	mov	ecx, DWORD PTR _Scratch$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 303  : 	return Result;

	mov	eax, DWORD PTR _Result$[ebp]

; 304  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_ULtoLRByte@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_Result$ = -8						; size = 4
_Scratch$ = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_ULtoLRPixel@16 PROC

; 274  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 275  : 	byte *Scratch = new byte[Height * Width * 8];

	mov	eax, DWORD PTR _Height$[ebp]
	imul	eax, DWORD PTR _Width$[ebp]
	shl	eax, 3
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _Scratch$[ebp], ecx

; 276  : 	int Result = VerticalMirrorPixel(Source, Width, Height, Scratch);

	mov	edx, DWORD PTR _Scratch$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Source$[ebp]
	push	edx
	call	_VerticalMirrorPixel@16
	mov	DWORD PTR _Result$[ebp], eax

; 277  : 	if (Result == Success)

	cmp	DWORD PTR _Result$[ebp], 0
	jne	SHORT $LN2@ULtoLRPixe

; 278  : 	{
; 279  : 		Result = HorizontalMirrorPixel(Scratch, Width, Height, Destination);

	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Scratch$[ebp]
	push	eax
	call	_HorizontalMirrorPixel@16
	mov	DWORD PTR _Result$[ebp], eax
$LN2@ULtoLRPixe:

; 280  : 	}
; 281  : 	delete[] Scratch;

	mov	ecx, DWORD PTR _Scratch$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 282  : 	return Result;

	mov	eax, DWORD PTR _Result$[ebp]

; 283  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_ULtoLRPixel@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
_ReturnValue$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_SourceIndex$2 = -24					; size = 4
_Src$ = -20						; size = 4
_DestIndex$3 = -16					; size = 4
_Dest$ = -12						; size = 4
_Column$4 = -8						; size = 4
_Row$5 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SetAlpha$ = 28						; size = 4
_AlphaValue$ = 32					; size = 1
_VerticalMirrorByte@28 PROC

; 220  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 221  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@VerticalMi

; 222  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@VerticalMi
$LN8@VerticalMi:

; 223  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@VerticalMi

; 224  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@VerticalMi
$LN9@VerticalMi:

; 225  : 
; 226  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 227  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 228  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 229  : 
; 230  : 	for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$4[ebp], 0
	jmp	SHORT $LN4@VerticalMi
$LN2@VerticalMi:
	mov	edx, DWORD PTR _Column$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$4[ebp], edx
$LN4@VerticalMi:
	mov	eax, DWORD PTR _Column$4[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN3@VerticalMi

; 231  : 	{
; 232  : 		for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN7@VerticalMi
$LN5@VerticalMi:
	mov	ecx, DWORD PTR _Row$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$5[ebp], ecx
$LN7@VerticalMi:
	mov	edx, DWORD PTR _Row$5[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN6@VerticalMi

; 233  : 		{
; 234  : 			int SourceIndex = (Row * Stride) + (Column * PixelSize);

	mov	eax, DWORD PTR _Row$5[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	ecx, DWORD PTR _Column$4[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	eax, ecx
	mov	DWORD PTR _SourceIndex$2[ebp], eax

; 235  : 			int DestIndex = ((Height - Row - 1) * Stride) + (Column * PixelSize);

	mov	edx, DWORD PTR _Height$[ebp]
	sub	edx, DWORD PTR _Row$5[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	eax, DWORD PTR _Column$4[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	edx, eax
	mov	DWORD PTR _DestIndex$3[ebp], edx

; 236  : 			Dest[DestIndex + 0] = Src[SourceIndex + 3];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _DestIndex$3[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _SourceIndex$2[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx], al

; 237  : 			Dest[DestIndex + 1] = Src[SourceIndex + 2];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _DestIndex$3[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _SourceIndex$2[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+1], al

; 238  : 			Dest[DestIndex + 2] = Src[SourceIndex + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _DestIndex$3[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _SourceIndex$2[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+2], al

; 239  : 			Dest[DestIndex + 3] = Src[SourceIndex + 0];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _DestIndex$3[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _SourceIndex$2[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+3], al

; 240  : 		}

	jmp	$LN5@VerticalMi
$LN6@VerticalMi:

; 241  : 	}

	jmp	$LN2@VerticalMi
$LN3@VerticalMi:

; 242  : 
; 243  : 	if (SetAlpha)

	cmp	DWORD PTR _SetAlpha$[ebp], 0
	je	SHORT $LN10@VerticalMi

; 244  : 	{
; 245  : 		int ReturnValue = SetAlphaChannelInPlace(Destination, Width, Height, Stride, AlphaValue);

	movzx	ecx, BYTE PTR _AlphaValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stride$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	call	_SetAlphaChannelInPlace@20
	mov	DWORD PTR _ReturnValue$1[ebp], eax

; 246  : 		if (ReturnValue != Success)

	cmp	DWORD PTR _ReturnValue$1[ebp], 0
	je	SHORT $LN10@VerticalMi

; 247  : 			return ReturnValue;

	mov	eax, DWORD PTR _ReturnValue$1[ebp]
	jmp	SHORT $LN1@VerticalMi
$LN10@VerticalMi:

; 248  : 	}
; 249  : 
; 250  : 	return Success;

	xor	eax, eax
$LN1@VerticalMi:

; 251  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_VerticalMirrorByte@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_VerticalMirrorPixel@16 PROC

; 182  : {

	push	ebp
	mov	ebp, esp

; 183  : 	return VerticalMirrorPixelRegion(Source, Width, Height, Destination, 0, 0, Width - 1, Height - 1);

	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Source$[ebp]
	push	edx
	call	_VerticalMirrorPixelRegion@32

; 184  : 	/*
; 185  : 	if (Source == NULL)
; 186  : 		return NullPointer;
; 187  : 	if (Destination == NULL)
; 188  : 		return NullPointer;
; 189  : 
; 190  : 	int PixelSize = 4;
; 191  : 	UINT32 *Src = (UINT32 *)Source;
; 192  : 	UINT32 *Dest = (UINT32 *)Destination;
; 193  : 
; 194  : 	for (int Column = 0; Column < Width; Column++)
; 195  : 	{
; 196  : 		for (int Row = 0; Row < Height; Row++)
; 197  : 		{
; 198  : 			int RowOffset = Row * Width;
; 199  : 			int SourceIndex = RowOffset + Column;
; 200  : 			int DestIndex = ((Height - Row - 1) * Width) + Column;
; 201  : 			Dest[DestIndex] = Src[SourceIndex];
; 202  : 		}
; 203  : 	}
; 204  : 
; 205  : 	return Success;
; 206  : 	*/
; 207  : }

	pop	ebp
	ret	16					; 00000010H
_VerticalMirrorPixel@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
_PixelSize$ = -32					; size = 4
_Src$ = -28						; size = 4
_SourceIndex$1 = -24					; size = 4
_Dest$ = -20						; size = 4
_DestIndex$2 = -16					; size = 4
_RowOffset$3 = -12					; size = 4
_Column$4 = -8						; size = 4
_Row$5 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_X1$ = 24						; size = 4
_Y1$ = 28						; size = 4
_X2$ = 32						; size = 4
_Y2$ = 36						; size = 4
_VerticalMirrorPixelRegion@32 PROC

; 145  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 146  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@VerticalMi

; 147  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@VerticalMi
$LN8@VerticalMi:

; 148  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@VerticalMi

; 149  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@VerticalMi
$LN9@VerticalMi:

; 150  : 
; 151  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 152  : 	UINT32 *Src = (UINT32 *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 153  : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 154  : 
; 155  : 	for (int Column = X1; Column <= X2; Column++)

	mov	edx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _Column$4[ebp], edx
	jmp	SHORT $LN4@VerticalMi
$LN2@VerticalMi:
	mov	eax, DWORD PTR _Column$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$4[ebp], eax
$LN4@VerticalMi:
	mov	ecx, DWORD PTR _Column$4[ebp]
	cmp	ecx, DWORD PTR _X2$[ebp]
	jg	SHORT $LN3@VerticalMi

; 156  : 	{
; 157  : 		for (int Row = Y1; Row <= Y2; Row++)

	mov	edx, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _Row$5[ebp], edx
	jmp	SHORT $LN7@VerticalMi
$LN5@VerticalMi:
	mov	eax, DWORD PTR _Row$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$5[ebp], eax
$LN7@VerticalMi:
	mov	ecx, DWORD PTR _Row$5[ebp]
	cmp	ecx, DWORD PTR _Y2$[ebp]
	jg	SHORT $LN6@VerticalMi

; 158  : 		{
; 159  : 			int RowOffset = Row * Width;

	mov	edx, DWORD PTR _Row$5[ebp]
	imul	edx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], edx

; 160  : 			int SourceIndex = RowOffset + Column;

	mov	eax, DWORD PTR _RowOffset$3[ebp]
	add	eax, DWORD PTR _Column$4[ebp]
	mov	DWORD PTR _SourceIndex$1[ebp], eax

; 161  : 			int DestIndex = ((Height - (Row - Y1) - 1) * Width) + (Column - X1);

	mov	ecx, DWORD PTR _Row$5[ebp]
	sub	ecx, DWORD PTR _Y1$[ebp]
	mov	edx, DWORD PTR _Height$[ebp]
	sub	edx, ecx
	sub	edx, 1
	imul	edx, DWORD PTR _Width$[ebp]
	mov	eax, DWORD PTR _Column$4[ebp]
	sub	eax, DWORD PTR _X1$[ebp]
	add	edx, eax
	mov	DWORD PTR _DestIndex$2[ebp], edx

; 162  : 			Dest[DestIndex] = Src[SourceIndex];

	mov	ecx, DWORD PTR _DestIndex$2[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _SourceIndex$1[ebp]
	mov	esi, DWORD PTR _Src$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax

; 163  : 		}

	jmp	SHORT $LN5@VerticalMi
$LN6@VerticalMi:

; 164  : 	}

	jmp	SHORT $LN2@VerticalMi
$LN3@VerticalMi:

; 165  : 
; 166  : 	return Success;

	xor	eax, eax
$LN1@VerticalMi:

; 167  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_VerticalMirrorPixelRegion@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
_PixelSize$ = -32					; size = 4
_Src$ = -28						; size = 4
_DestIndex$1 = -24					; size = 4
_Dest$ = -20						; size = 4
_ReturnValue$2 = -16					; size = 4
_RowOffset$3 = -12					; size = 4
_Row$4 = -8						; size = 4
_Column$5 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SetAlpha$ = 28						; size = 4
_AlphaValue$ = 32					; size = 1
_HorizontalMirrorByte@28 PROC

; 98   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 99   : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@Horizontal

; 100  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@Horizontal
$LN8@Horizontal:

; 101  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@Horizontal

; 102  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@Horizontal
$LN9@Horizontal:

; 103  : 
; 104  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 105  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 106  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 107  : 
; 108  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@Horizontal
$LN2@Horizontal:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@Horizontal:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@Horizontal

; 109  : 	{
; 110  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], ecx

; 111  : 		for (int Column = 0; Column < Stride; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@Horizontal
$LN5@Horizontal:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@Horizontal:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _Stride$[ebp]
	jge	SHORT $LN6@Horizontal

; 112  : 		{
; 113  : 			int DestIndex = (Stride - (Column + 1)) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _Stride$[ebp]
	sub	edx, ecx
	add	edx, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _DestIndex$1[ebp], edx

; 114  : 			Dest[DestIndex] = Src[Column + RowOffset];

	mov	eax, DWORD PTR _Column$5[ebp]
	add	eax, DWORD PTR _RowOffset$3[ebp]
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _DestIndex$1[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al

; 115  : 		}

	jmp	SHORT $LN5@Horizontal
$LN6@Horizontal:

; 116  : 	}

	jmp	SHORT $LN2@Horizontal
$LN3@Horizontal:

; 117  : 
; 118  : 	if (SetAlpha)

	cmp	DWORD PTR _SetAlpha$[ebp], 0
	je	SHORT $LN10@Horizontal

; 119  : 	{
; 120  : 		int ReturnValue = SetAlphaChannelInPlace(Destination, Width, Height, Stride, AlphaValue);

	movzx	ecx, BYTE PTR _AlphaValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stride$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	call	_SetAlphaChannelInPlace@20
	mov	DWORD PTR _ReturnValue$2[ebp], eax

; 121  : 		if (ReturnValue != Success)

	cmp	DWORD PTR _ReturnValue$2[ebp], 0
	je	SHORT $LN10@Horizontal

; 122  : 			return ReturnValue;

	mov	eax, DWORD PTR _ReturnValue$2[ebp]
	jmp	SHORT $LN1@Horizontal
$LN10@Horizontal:

; 123  : 	}
; 124  : 
; 125  : 	return Success;

	xor	eax, eax
$LN1@Horizontal:

; 126  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_HorizontalMirrorByte@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_HorizontalMirrorPixel@16 PROC

; 61   : {

	push	ebp
	mov	ebp, esp

; 62   : 	return HorizontalMirrorPixelRegion(Source, Width, Height, Destination, 0, 0, Width - 1, Height - 1);

	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Source$[ebp]
	push	edx
	call	_HorizontalMirrorPixelRegion@32

; 63   : 	/*
; 64   : 	if (Source == NULL)
; 65   : 		return NullPointer;
; 66   : 	if (Destination == NULL)
; 67   : 		return NullPointer;
; 68   : 
; 69   : 	UINT32 *Src = (UINT32 *)Source;
; 70   : 	UINT32 *Dest = (UINT32 *)Destination;
; 71   : 
; 72   : 	for (int Row = 0; Row < Height; Row++)
; 73   : 	{
; 74   : 		int RowOffset = Row * Width;
; 75   : 		for (int Column = 0; Column < Width; Column++)
; 76   : 		{
; 77   : 			int SrcIndex = Column + RowOffset;
; 78   : 			int DestIndex = (Width - Column - 1) + RowOffset;
; 79   : 			Dest[DestIndex] = Src[SrcIndex];
; 80   : 		}
; 81   : 	}
; 82   : 
; 83   : 	return Success;
; 84   : 	*/
; 85   : }

	pop	ebp
	ret	16					; 00000010H
_HorizontalMirrorPixel@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\distortion.cpp
_TEXT	SEGMENT
_Src$ = -32						; size = 4
_SrcIndex$1 = -28					; size = 4
_Dest$ = -24						; size = 4
_DestIndex$2 = -20					; size = 4
_DestRowOffset$3 = -16					; size = 4
_RowOffset$4 = -12					; size = 4
_Column$5 = -8						; size = 4
_Row$6 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_X1$ = 24						; size = 4
_Y1$ = 28						; size = 4
_X2$ = 32						; size = 4
_Y2$ = 36						; size = 4
_HorizontalMirrorPixelRegion@32 PROC

; 24   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 25   : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@Horizontal

; 26   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@Horizontal
$LN8@Horizontal:

; 27   : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@Horizontal

; 28   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@Horizontal
$LN9@Horizontal:

; 29   : 
; 30   : 	UINT32 *Src = (UINT32 *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 31   : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 32   : 
; 33   : 	for (int Row = Y1; Row <= Y2; Row++)

	mov	edx, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _Row$6[ebp], edx
	jmp	SHORT $LN4@Horizontal
$LN2@Horizontal:
	mov	eax, DWORD PTR _Row$6[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$6[ebp], eax
$LN4@Horizontal:
	mov	ecx, DWORD PTR _Row$6[ebp]
	cmp	ecx, DWORD PTR _Y2$[ebp]
	jg	SHORT $LN3@Horizontal

; 34   : 	{
; 35   : 		int RowOffset = Row * Width;

	mov	edx, DWORD PTR _Row$6[ebp]
	imul	edx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], edx

; 36   : 		int DestRowOffset = (Row - Y1) * Width;

	mov	eax, DWORD PTR _Row$6[ebp]
	sub	eax, DWORD PTR _Y1$[ebp]
	imul	eax, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _DestRowOffset$3[ebp], eax

; 37   : 		for (int Column = X1; Column <= X2; Column++)

	mov	ecx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _Column$5[ebp], ecx
	jmp	SHORT $LN7@Horizontal
$LN5@Horizontal:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@Horizontal:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _X2$[ebp]
	jg	SHORT $LN6@Horizontal

; 38   : 		{
; 39   : 			int SrcIndex = Column + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _SrcIndex$1[ebp], ecx

; 40   : 			int DestIndex = (Width - (Column - X1) - 1) + DestRowOffset;

	mov	edx, DWORD PTR _Column$5[ebp]
	sub	edx, DWORD PTR _X1$[ebp]
	mov	eax, DWORD PTR _Width$[ebp]
	sub	eax, edx
	mov	ecx, DWORD PTR _DestRowOffset$3[ebp]
	lea	edx, DWORD PTR [eax+ecx-1]
	mov	DWORD PTR _DestIndex$2[ebp], edx

; 41   : 			Dest[DestIndex] = Src[SrcIndex];

	mov	eax, DWORD PTR _DestIndex$2[ebp]
	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	edx, DWORD PTR _SrcIndex$1[ebp]
	mov	esi, DWORD PTR _Src$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 42   : 		}

	jmp	SHORT $LN5@Horizontal
$LN6@Horizontal:

; 43   : 	}

	jmp	SHORT $LN2@Horizontal
$LN3@Horizontal:

; 44   : 
; 45   : 	return Success;

	xor	eax, eax
$LN1@Horizontal:

; 46   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_HorizontalMirrorPixelRegion@32 ENDP
_TEXT	ENDS
END
