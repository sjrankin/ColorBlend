; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\ImageMangling.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_ShuffleRows@28
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp___errno:PROC
EXTRN	_memmove:PROC
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemangling.cpp
_TEXT	SEGMENT
_PixelSize$ = -40					; size = 4
_DestIndex$1 = -36					; size = 4
_Dest$ = -32						; size = 4
_SourceIndex$2 = -28					; size = 4
_Src$ = -24						; size = 4
_DestRow$3 = -20					; size = 4
_SourceRow$4 = -16					; size = 4
_Row$5 = -12						; size = 4
_Rows$ = -8						; size = 4
_RowIndex$6 = -4					; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RowDescriptions$ = 28					; size = 4
_RowDescriptionCount$ = 32				; size = 4
_ShuffleRows@28 PROC

; 47   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 48   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ShuffleRow

; 49   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ShuffleRow
$LN8@ShuffleRow:

; 50   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ShuffleRow

; 51   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ShuffleRow
$LN9@ShuffleRow:

; 52   :     if (RowDescriptions == NULL)

	cmp	DWORD PTR _RowDescriptions$[ebp], 0
	jne	SHORT $LN10@ShuffleRow

; 53   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ShuffleRow
$LN10@ShuffleRow:

; 54   :     if (RowDescriptionCount < 1)

	cmp	DWORD PTR _RowDescriptionCount$[ebp], 1
	jge	SHORT $LN11@ShuffleRow

; 55   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ShuffleRow
$LN11@ShuffleRow:

; 56   : 
; 57   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 58   :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 59   :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 60   :     RowDescription *Rows = (RowDescription *)RowDescriptions;

	mov	edx, DWORD PTR _RowDescriptions$[ebp]
	mov	DWORD PTR _Rows$[ebp], edx

; 61   : 
; 62   :     for (int RowIndex = 0; RowIndex < RowDescriptionCount; RowIndex++)

	mov	DWORD PTR _RowIndex$6[ebp], 0
	jmp	SHORT $LN4@ShuffleRow
$LN2@ShuffleRow:
	mov	eax, DWORD PTR _RowIndex$6[ebp]
	add	eax, 1
	mov	DWORD PTR _RowIndex$6[ebp], eax
$LN4@ShuffleRow:
	mov	ecx, DWORD PTR _RowIndex$6[ebp]
	cmp	ecx, DWORD PTR _RowDescriptionCount$[ebp]
	jge	$LN3@ShuffleRow

; 63   :     {
; 64   :         int SourceRow = Rows[RowIndex].SourceRowStart;

	imul	edx, DWORD PTR _RowIndex$6[ebp], 12
	mov	eax, DWORD PTR _Rows$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR _SourceRow$4[ebp], ecx

; 65   :         int DestRow = Rows[RowIndex].DestinationRowStart;

	imul	edx, DWORD PTR _RowIndex$6[ebp], 12
	mov	eax, DWORD PTR _Rows$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	mov	DWORD PTR _DestRow$3[ebp], ecx

; 66   :         for (unsigned Row = 0; Row < Rows[RowIndex].RowHeight; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN7@ShuffleRow
$LN5@ShuffleRow:
	mov	edx, DWORD PTR _Row$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$5[ebp], edx
$LN7@ShuffleRow:
	imul	eax, DWORD PTR _RowIndex$6[ebp], 12
	mov	ecx, DWORD PTR _Rows$[ebp]
	mov	edx, DWORD PTR _Row$5[ebp]
	cmp	edx, DWORD PTR [ecx+eax+8]
	jae	SHORT $LN6@ShuffleRow

; 67   :         {
; 68   :             int SourceIndex = SourceRow * Stride;

	mov	eax, DWORD PTR _SourceRow$4[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _SourceIndex$2[ebp], eax

; 69   :             SourceRow++;

	mov	ecx, DWORD PTR _SourceRow$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _SourceRow$4[ebp], ecx

; 70   :             int DestIndex = DestRow * Stride;

	mov	edx, DWORD PTR _DestRow$3[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _DestIndex$1[ebp], edx

; 71   :             DestRow++;

	mov	eax, DWORD PTR _DestRow$3[ebp]
	add	eax, 1
	mov	DWORD PTR _DestRow$3[ebp], eax

; 72   :             memmove_s(Dest + DestIndex, Stride, Src + SourceIndex, Stride);

	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _SourceIndex$2[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _DestIndex$1[ebp]
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H

; 73   :         }

	jmp	SHORT $LN5@ShuffleRow
$LN6@ShuffleRow:

; 74   :     }

	jmp	$LN2@ShuffleRow
$LN3@ShuffleRow:

; 75   : 
; 76   :     return Success;

	xor	eax, eax
$LN1@ShuffleRow:

; 77   : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_ShuffleRows@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
_TEXT	SEGMENT
__Expr_val$1 = -24					; size = 4
__Expr_val$2 = -20					; size = 4
__Expr_val$3 = -16					; size = 4
tv74 = -12						; size = 4
tv70 = -8						; size = 4
tv66 = -4						; size = 4
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memmove_s PROC

; 70   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 71   :         if (_SourceSize == 0)

	cmp	DWORD PTR __SourceSize$[ebp], 0
	jne	SHORT $LN2@memmove_s

; 72   :         {
; 73   :             return 0;

	xor	eax, eax
	jmp	$LN1@memmove_s
$LN2@memmove_s:

; 74   :         }
; 75   : 
; 76   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL,            EINVAL);

	cmp	DWORD PTR __Destination$[ebp], 0
	je	SHORT $LN7@memmove_s
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN8@memmove_s
$LN7@memmove_s:
	mov	DWORD PTR tv66[ebp], 0
$LN8@memmove_s:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR __Expr_val$3[ebp], eax
	cmp	DWORD PTR __Expr_val$3[ebp], 0
	jne	SHORT $LN3@memmove_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 22					; 00000016H
	jmp	$LN1@memmove_s
$LN3@memmove_s:

; 77   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

	cmp	DWORD PTR __Source$[ebp], 0
	je	SHORT $LN9@memmove_s
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN10@memmove_s
$LN9@memmove_s:
	mov	DWORD PTR tv70[ebp], 0
$LN10@memmove_s:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR __Expr_val$2[ebp], ecx
	cmp	DWORD PTR __Expr_val$2[ebp], 0
	jne	SHORT $LN4@memmove_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 22					; 00000016H
	jmp	SHORT $LN1@memmove_s
$LN4@memmove_s:

; 78   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

	mov	edx, DWORD PTR __DestinationSize$[ebp]
	cmp	edx, DWORD PTR __SourceSize$[ebp]
	jb	SHORT $LN11@memmove_s
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN12@memmove_s
$LN11@memmove_s:
	mov	DWORD PTR tv74[ebp], 0
$LN12@memmove_s:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR __Expr_val$1[ebp], eax
	cmp	DWORD PTR __Expr_val$1[ebp], 0
	jne	SHORT $LN5@memmove_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 34			; 00000022H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 34					; 00000022H
	jmp	SHORT $LN1@memmove_s
$LN5@memmove_s:

; 79   : 
; 80   :         memmove(_Destination, _Source, _SourceSize);

	mov	ecx, DWORD PTR __SourceSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Source$[ebp]
	push	edx
	mov	eax, DWORD PTR __Destination$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 81   :         return 0;

	xor	eax, eax
$LN1@memmove_s:

; 82   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_memmove_s ENDP
_TEXT	ENDS
END
