; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Border.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG110251 DB	'Source is null', 00H
	ORG $+1
$SG110252 DB	'AddBorder', 00H
	ORG $+2
$SG110254 DB	'Destination is null', 00H
$SG110255 DB	'AddBorder', 00H
	ORG $+2
$SG110257 DB	'LeftBorder < 0', 00H
	ORG $+1
$SG110258 DB	'AddBorder', 00H
	ORG $+2
$SG110260 DB	'TopBorder < 0', 00H
	ORG $+2
$SG110261 DB	'AddBorder', 00H
	ORG $+2
$SG110263 DB	'RightBorder < 0', 00H
$SG110264 DB	'AddBorder', 00H
	ORG $+2
$SG110266 DB	'BottomBorder < 0', 00H
	ORG $+3
$SG110267 DB	'AddBorder', 00H
	ORG $+2
$SG110268 DB	'AddBorder', 00H
CONST	ENDS
PUBLIC	_AddBorder@40
EXTRN	_ErrorStackPushReturn@8:PROC
EXTRN	_ErrorStackPushReturn2@12:PROC
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\border.cpp
_TEXT	SEGMENT
_DestRowOffset$1 = -68					; size = 4
_RowOffset$2 = -64					; size = 4
_RowOffset$3 = -60					; size = 4
_DestHeight$ = -56					; size = 4
_DestStride$ = -52					; size = 4
_DestWidth$ = -48					; size = 4
_PixelSize$ = -44					; size = 4
_SourceIndex$4 = -40					; size = 4
_Src$ = -36						; size = 4
_DestIndex$5 = -32					; size = 4
_Index$6 = -28						; size = 4
_Column$7 = -24						; size = 4
_Row$8 = -20						; size = 4
_Column$9 = -16						; size = 4
_Row$10 = -12						; size = 4
_Dest$ = -8						; size = 4
_B$ = -4						; size = 1
_G$ = -3						; size = 1
_R$ = -2						; size = 1
_A$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_LeftBorder$ = 24					; size = 4
_TopBorder$ = 28					; size = 4
_RightBorder$ = 32					; size = 4
_BottomBorder$ = 36					; size = 4
_Destination$ = 40					; size = 4
_BGColor$ = 44						; size = 4
_AddBorder@40 PROC

; 14   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 15   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN14@AddBorder

; 16   :         return ErrorStackPushReturn2(NullPointer, "AddBorder", "Source is null");

	push	OFFSET $SG110251
	push	OFFSET $SG110252
	push	3
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@AddBorder
$LN14@AddBorder:

; 17   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN15@AddBorder

; 18   :         return ErrorStackPushReturn2(NullPointer, "AddBorder", "Destination is null");

	push	OFFSET $SG110254
	push	OFFSET $SG110255
	push	3
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@AddBorder
$LN15@AddBorder:

; 19   :     if (LeftBorder < 0)

	cmp	DWORD PTR _LeftBorder$[ebp], 0
	jge	SHORT $LN16@AddBorder

; 20   :         return ErrorStackPushReturn2(ValueTooSmall, "AddBorder", "LeftBorder < 0");

	push	OFFSET $SG110257
	push	OFFSET $SG110258
	push	25					; 00000019H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@AddBorder
$LN16@AddBorder:

; 21   :     if (TopBorder < 0)

	cmp	DWORD PTR _TopBorder$[ebp], 0
	jge	SHORT $LN17@AddBorder

; 22   :         return ErrorStackPushReturn2(ValueTooSmall, "AddBorder", "TopBorder < 0");

	push	OFFSET $SG110260
	push	OFFSET $SG110261
	push	25					; 00000019H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@AddBorder
$LN17@AddBorder:

; 23   :     if (RightBorder < 0)

	cmp	DWORD PTR _RightBorder$[ebp], 0
	jge	SHORT $LN18@AddBorder

; 24   :         return ErrorStackPushReturn2(ValueTooSmall, "AddBorder", "RightBorder < 0");

	push	OFFSET $SG110263
	push	OFFSET $SG110264
	push	25					; 00000019H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@AddBorder
$LN18@AddBorder:

; 25   :     if (BottomBorder < 0)

	cmp	DWORD PTR _BottomBorder$[ebp], 0
	jge	SHORT $LN19@AddBorder

; 26   :         return ErrorStackPushReturn2(ValueTooSmall, "AddBorder", "BottomBorder < 0");

	push	OFFSET $SG110266
	push	OFFSET $SG110267
	push	25					; 00000019H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@AddBorder
$LN19@AddBorder:

; 27   : 
; 28   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 29   :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 30   :     BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 31   :     BYTE A = (BGColor & 0xff000000) >> 24;

	mov	edx, DWORD PTR _BGColor$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _A$[ebp], dl

; 32   :     BYTE R = (BGColor & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _BGColor$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _R$[ebp], al

; 33   :     BYTE G = (BGColor & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _BGColor$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _G$[ebp], cl

; 34   :     BYTE B = (BGColor & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _BGColor$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _B$[ebp], dl

; 35   : 
; 36   :     //Draw the new image's background.
; 37   :     __int32 DestHeight = Height + TopBorder + BottomBorder;

	mov	eax, DWORD PTR _Height$[ebp]
	add	eax, DWORD PTR _TopBorder$[ebp]
	add	eax, DWORD PTR _BottomBorder$[ebp]
	mov	DWORD PTR _DestHeight$[ebp], eax

; 38   :     __int32 DestWidth = Width + LeftBorder + RightBorder;

	mov	ecx, DWORD PTR _Width$[ebp]
	add	ecx, DWORD PTR _LeftBorder$[ebp]
	add	ecx, DWORD PTR _RightBorder$[ebp]
	mov	DWORD PTR _DestWidth$[ebp], ecx

; 39   :     __int32 DestStride = DestWidth * 4;

	mov	edx, DWORD PTR _DestWidth$[ebp]
	shl	edx, 2
	mov	DWORD PTR _DestStride$[ebp], edx

; 40   :     for (int Row = 0; Row < DestHeight; Row++)

	mov	DWORD PTR _Row$8[ebp], 0
	jmp	SHORT $LN4@AddBorder
$LN2@AddBorder:
	mov	eax, DWORD PTR _Row$8[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$8[ebp], eax
$LN4@AddBorder:
	mov	ecx, DWORD PTR _Row$8[ebp]
	cmp	ecx, DWORD PTR _DestHeight$[ebp]
	jge	SHORT $LN3@AddBorder

; 41   :     {
; 42   :         int RowOffset = Row * DestStride;

	mov	edx, DWORD PTR _Row$8[ebp]
	imul	edx, DWORD PTR _DestStride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], edx

; 43   :         for (int Column = 0; Column < DestWidth; Column++)

	mov	DWORD PTR _Column$7[ebp], 0
	jmp	SHORT $LN7@AddBorder
$LN5@AddBorder:
	mov	eax, DWORD PTR _Column$7[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$7[ebp], eax
$LN7@AddBorder:
	mov	ecx, DWORD PTR _Column$7[ebp]
	cmp	ecx, DWORD PTR _DestWidth$[ebp]
	jge	SHORT $LN6@AddBorder

; 44   :         {
; 45   :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$7[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$6[ebp], edx

; 46   :             Dest[Index + 3] = A;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [eax+3], cl

; 47   :             Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _R$[ebp]
	mov	BYTE PTR [edx+2], al

; 48   :             Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _G$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 49   :             Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [eax], cl

; 50   :         }

	jmp	SHORT $LN5@AddBorder
$LN6@AddBorder:

; 51   :     }

	jmp	SHORT $LN2@AddBorder
$LN3@AddBorder:

; 52   : 
; 53   :     //Blit the old image onto the new image.
; 54   :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$10[ebp], 0
	jmp	SHORT $LN10@AddBorder
$LN8@AddBorder:
	mov	edx, DWORD PTR _Row$10[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$10[ebp], edx
$LN10@AddBorder:
	mov	eax, DWORD PTR _Row$10[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN9@AddBorder

; 55   :     {
; 56   :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$10[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 57   :         int DestRowOffset = (Row + TopBorder) * DestStride;

	mov	edx, DWORD PTR _Row$10[ebp]
	add	edx, DWORD PTR _TopBorder$[ebp]
	imul	edx, DWORD PTR _DestStride$[ebp]
	mov	DWORD PTR _DestRowOffset$1[ebp], edx

; 58   :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$9[ebp], 0
	jmp	SHORT $LN13@AddBorder
$LN11@AddBorder:
	mov	eax, DWORD PTR _Column$9[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$9[ebp], eax
$LN13@AddBorder:
	mov	ecx, DWORD PTR _Column$9[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN12@AddBorder

; 59   :         {
; 60   :             int SourceIndex = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$9[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _SourceIndex$4[ebp], edx

; 61   :             int DestIndex = ((Column + LeftBorder) * PixelSize) + DestRowOffset;

	mov	eax, DWORD PTR _Column$9[ebp]
	add	eax, DWORD PTR _LeftBorder$[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _DestRowOffset$1[ebp]
	mov	DWORD PTR _DestIndex$5[ebp], eax

; 62   :             Dest[DestIndex + 3] = Src[SourceIndex + 3];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _DestIndex$5[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _SourceIndex$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 63   :             Dest[DestIndex + 2] = Src[SourceIndex + 2];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _DestIndex$5[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _SourceIndex$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 64   :             Dest[DestIndex + 1] = Src[SourceIndex + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _DestIndex$5[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _SourceIndex$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 65   :             Dest[DestIndex + 0] = Src[SourceIndex + 0];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _DestIndex$5[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _SourceIndex$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 66   :         }

	jmp	SHORT $LN11@AddBorder
$LN12@AddBorder:

; 67   :     }

	jmp	$LN8@AddBorder
$LN9@AddBorder:

; 68   : 
; 69   :     return ErrorStackPushReturn(Success, "AddBorder");

	push	OFFSET $SG110268
	push	0
	call	_ErrorStackPushReturn@8
$LN1@AddBorder:

; 70   : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_AddBorder@40 ENDP
_TEXT	ENDS
END
