; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\SIMD_ChannelAlign.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_AlignChannels@28
PUBLIC	_AlignChannels2@32
PUBLIC	_AssembleFromChannels@28
PUBLIC	_AssembleFromChannels2@32
PUBLIC	_LinearizeChannelsIntoImage@36
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\simd_channelalign.cpp
_TEXT	SEGMENT
$T1 = -68						; size = 4
_RowOffset$2 = -64					; size = 4
_PixelSize$ = -60					; size = 4
_Blue$ = -56						; size = 4
_Green$ = -52						; size = 4
_Red$ = -48						; size = 4
$T3 = -44						; size = 4
_TotalCount$ = -40					; size = 4
_Index$4 = -36						; size = 4
_Dest$ = -32						; size = 4
_Column$5 = -28						; size = 4
_Row$6 = -24						; size = 4
_i$7 = -20						; size = 4
_i$8 = -16						; size = 4
_i$9 = -12						; size = 4
_AllChannels$ = -8					; size = 4
_ChannelIndex$ = -4					; size = 4
_RedChannel$ = 8					; size = 4
_GreenChannel$ = 12					; size = 4
_BlueChannel$ = 16					; size = 4
_ChannelSize$ = 20					; size = 4
_Destination$ = 24					; size = 4
_Width$ = 28						; size = 4
_Height$ = 32						; size = 4
_Stride$ = 36						; size = 4
_ChannelOrder$ = 40					; size = 4
_LinearizeChannelsIntoImage@36 PROC

; 180  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 181  : 	if (RedChannel == NULL)

	cmp	DWORD PTR _RedChannel$[ebp], 0
	jne	SHORT $LN17@LinearizeC

; 182  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@LinearizeC
$LN17@LinearizeC:

; 183  : 	if (GreenChannel == NULL)

	cmp	DWORD PTR _GreenChannel$[ebp], 0
	jne	SHORT $LN18@LinearizeC

; 184  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@LinearizeC
$LN18@LinearizeC:

; 185  : 	if (BlueChannel == NULL)

	cmp	DWORD PTR _BlueChannel$[ebp], 0
	jne	SHORT $LN19@LinearizeC

; 186  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@LinearizeC
$LN19@LinearizeC:

; 187  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN20@LinearizeC

; 188  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@LinearizeC
$LN20@LinearizeC:

; 189  : 
; 190  : 	BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 191  : 	BYTE *Red = (BYTE *)RedChannel;

	mov	ecx, DWORD PTR _RedChannel$[ebp]
	mov	DWORD PTR _Red$[ebp], ecx

; 192  : 	BYTE *Green = (BYTE *)GreenChannel;

	mov	edx, DWORD PTR _GreenChannel$[ebp]
	mov	DWORD PTR _Green$[ebp], edx

; 193  : 	BYTE *Blue = (BYTE *)BlueChannel;

	mov	eax, DWORD PTR _BlueChannel$[ebp]
	mov	DWORD PTR _Blue$[ebp], eax

; 194  : 	__int32 TotalCount = ChannelSize * 3;

	imul	ecx, DWORD PTR _ChannelSize$[ebp], 3
	mov	DWORD PTR _TotalCount$[ebp], ecx

; 195  : 	BYTE* AllChannels = (BYTE *)new BYTE[TotalCount];

	mov	edx, DWORD PTR _TotalCount$[ebp]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _AllChannels$[ebp], eax

; 196  : 	__int32 ChannelIndex = 0;

	mov	DWORD PTR _ChannelIndex$[ebp], 0

; 197  : 	for (int i = 0; i < ChannelSize; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN4@LinearizeC
$LN2@LinearizeC:
	mov	ecx, DWORD PTR _i$9[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$9[ebp], ecx
$LN4@LinearizeC:
	mov	edx, DWORD PTR _i$9[ebp]
	cmp	edx, DWORD PTR _ChannelSize$[ebp]
	jge	SHORT $LN3@LinearizeC

; 198  : 		AllChannels[ChannelIndex++] = Red[i];

	mov	eax, DWORD PTR _AllChannels$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	ecx, DWORD PTR _Red$[ebp]
	add	ecx, DWORD PTR _i$9[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _ChannelIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _ChannelIndex$[ebp], eax
	jmp	SHORT $LN2@LinearizeC
$LN3@LinearizeC:

; 199  : 	for (int i = 0; i < ChannelSize; i++)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN7@LinearizeC
$LN5@LinearizeC:
	mov	ecx, DWORD PTR _i$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$8[ebp], ecx
$LN7@LinearizeC:
	mov	edx, DWORD PTR _i$8[ebp]
	cmp	edx, DWORD PTR _ChannelSize$[ebp]
	jge	SHORT $LN6@LinearizeC

; 200  : 		AllChannels[ChannelIndex++] = Green[i];

	mov	eax, DWORD PTR _AllChannels$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	ecx, DWORD PTR _Green$[ebp]
	add	ecx, DWORD PTR _i$8[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _ChannelIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _ChannelIndex$[ebp], eax
	jmp	SHORT $LN5@LinearizeC
$LN6@LinearizeC:

; 201  : 	for (int i = 0; i < ChannelSize; i++)

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN10@LinearizeC
$LN8@LinearizeC:
	mov	ecx, DWORD PTR _i$7[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$7[ebp], ecx
$LN10@LinearizeC:
	mov	edx, DWORD PTR _i$7[ebp]
	cmp	edx, DWORD PTR _ChannelSize$[ebp]
	jge	SHORT $LN9@LinearizeC

; 202  : 		AllChannels[ChannelIndex++] = Blue[i];

	mov	eax, DWORD PTR _AllChannels$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	ecx, DWORD PTR _Blue$[ebp]
	add	ecx, DWORD PTR _i$7[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _ChannelIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _ChannelIndex$[ebp], eax
	jmp	SHORT $LN8@LinearizeC
$LN9@LinearizeC:

; 203  : 	ChannelIndex = 0;

	mov	DWORD PTR _ChannelIndex$[ebp], 0

; 204  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 205  : 
; 206  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN13@LinearizeC
$LN11@LinearizeC:
	mov	ecx, DWORD PTR _Row$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$6[ebp], ecx
$LN13@LinearizeC:
	mov	edx, DWORD PTR _Row$6[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	$LN12@LinearizeC

; 207  : 	{
; 208  : 		int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$6[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], eax

; 209  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN16@LinearizeC
$LN14@LinearizeC:
	mov	ecx, DWORD PTR _Column$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$5[ebp], ecx
$LN16@LinearizeC:
	mov	edx, DWORD PTR _Column$5[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN15@LinearizeC

; 210  : 		{
; 211  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$5[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 212  : 			Dest[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH

; 213  : 			Dest[Index + 2] = AllChannels[ChannelIndex++];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _AllChannels$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+2], cl
	mov	edx, DWORD PTR _ChannelIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _ChannelIndex$[ebp], edx

; 214  : 			Dest[Index + 1] = AllChannels[ChannelIndex++];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _AllChannels$[ebp]
	add	ecx, DWORD PTR _ChannelIndex$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+1], dl
	mov	eax, DWORD PTR _ChannelIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _ChannelIndex$[ebp], eax

; 215  : 			Dest[Index + 0] = AllChannels[ChannelIndex++];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _AllChannels$[ebp]
	add	edx, DWORD PTR _ChannelIndex$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _ChannelIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ChannelIndex$[ebp], ecx

; 216  : 		}

	jmp	SHORT $LN14@LinearizeC
$LN15@LinearizeC:

; 217  : 	}

	jmp	$LN11@LinearizeC
$LN12@LinearizeC:

; 218  : 
; 219  : 	delete[] AllChannels;

	mov	edx, DWORD PTR _AllChannels$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 220  : 
; 221  : 	return Success;

	xor	eax, eax
$LN1@LinearizeC:

; 222  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_LinearizeChannelsIntoImage@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\simd_channelalign.cpp
_TEXT	SEGMENT
_Blue$ = -44						; size = 4
_Green$ = -40						; size = 4
_Red$ = -36						; size = 4
_Alpha$ = -32						; size = 4
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Index$2 = -20						; size = 4
_Dest$ = -16						; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_ChannelIndex$ = -4					; size = 4
_Destination$ = 8					; size = 4
_DestinationWidth$ = 12					; size = 4
_DestinationHeight$ = 16				; size = 4
_DestinationStride$ = 20				; size = 4
_AlphaChannel$ = 24					; size = 4
_RedChannel$ = 28					; size = 4
_GreenChannel$ = 32					; size = 4
_BlueChannel$ = 36					; size = 4
_AssembleFromChannels2@32 PROC

; 133  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 134  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@AssembleFr

; 135  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AssembleFr
$LN8@AssembleFr:

; 136  : 	if (AlphaChannel == NULL)

	cmp	DWORD PTR _AlphaChannel$[ebp], 0
	jne	SHORT $LN9@AssembleFr

; 137  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AssembleFr
$LN9@AssembleFr:

; 138  : 	if (RedChannel == NULL)

	cmp	DWORD PTR _RedChannel$[ebp], 0
	jne	SHORT $LN10@AssembleFr

; 139  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AssembleFr
$LN10@AssembleFr:

; 140  : 	if (GreenChannel == NULL)

	cmp	DWORD PTR _GreenChannel$[ebp], 0
	jne	SHORT $LN11@AssembleFr

; 141  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AssembleFr
$LN11@AssembleFr:

; 142  : 	if (BlueChannel == NULL)

	cmp	DWORD PTR _BlueChannel$[ebp], 0
	jne	SHORT $LN12@AssembleFr

; 143  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AssembleFr
$LN12@AssembleFr:

; 144  : 
; 145  : 	BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 146  : 	BYTE *Alpha = (BYTE *)AlphaChannel;

	mov	ecx, DWORD PTR _AlphaChannel$[ebp]
	mov	DWORD PTR _Alpha$[ebp], ecx

; 147  : 	BYTE *Red = (BYTE *)RedChannel;

	mov	edx, DWORD PTR _RedChannel$[ebp]
	mov	DWORD PTR _Red$[ebp], edx

; 148  : 	BYTE *Green = (BYTE *)GreenChannel;

	mov	eax, DWORD PTR _GreenChannel$[ebp]
	mov	DWORD PTR _Green$[ebp], eax

; 149  : 	BYTE *Blue = (BYTE *)BlueChannel;

	mov	ecx, DWORD PTR _BlueChannel$[ebp]
	mov	DWORD PTR _Blue$[ebp], ecx

; 150  : 
; 151  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 152  : 	UINT32 ChannelIndex = 0;

	mov	DWORD PTR _ChannelIndex$[ebp], 0

; 153  : 
; 154  : 	for (int Row = 0; Row < DestinationHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@AssembleFr
$LN2@AssembleFr:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@AssembleFr:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _DestinationHeight$[ebp]
	jge	$LN3@AssembleFr

; 155  : 	{
; 156  : 		int RowOffset = Row * DestinationStride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _DestinationStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 157  : 		for (int Column = 0; Column < DestinationWidth; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@AssembleFr
$LN5@AssembleFr:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@AssembleFr:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _DestinationWidth$[ebp]
	jge	SHORT $LN6@AssembleFr

; 158  : 		{
; 159  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], ecx

; 160  : 			Dest[Index + 3] = Alpha[ChannelIndex];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	eax, DWORD PTR _Alpha$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+3], cl

; 161  : 			Dest[Index + 2] = Red[ChannelIndex];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	eax, DWORD PTR _Red$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+2], cl

; 162  : 			Dest[Index + 1] = Green[ChannelIndex];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	eax, DWORD PTR _Green$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+1], cl

; 163  : 			Dest[Index + 0] = Blue[ChannelIndex];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	eax, DWORD PTR _Blue$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 164  : 			ChannelIndex++;

	mov	edx, DWORD PTR _ChannelIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _ChannelIndex$[ebp], edx

; 165  : 		}

	jmp	SHORT $LN5@AssembleFr
$LN6@AssembleFr:

; 166  : 	}

	jmp	$LN2@AssembleFr
$LN3@AssembleFr:

; 167  : 
; 168  : 	return Success;

	xor	eax, eax
$LN1@AssembleFr:

; 169  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_AssembleFromChannels2@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\simd_channelalign.cpp
_TEXT	SEGMENT
_Blue$ = -40						; size = 4
_Green$ = -36						; size = 4
_Red$ = -32						; size = 4
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Index$2 = -20						; size = 4
_Dest$ = -16						; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_ChannelIndex$ = -4					; size = 4
_Destination$ = 8					; size = 4
_DestinationWidth$ = 12					; size = 4
_DestinationHeight$ = 16				; size = 4
_DestinationStride$ = 20				; size = 4
_RedChannel$ = 24					; size = 4
_GreenChannel$ = 28					; size = 4
_BlueChannel$ = 32					; size = 4
_AssembleFromChannels@28 PROC

; 96   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 97   : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@AssembleFr

; 98   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AssembleFr
$LN8@AssembleFr:

; 99   : 	if (RedChannel == NULL)

	cmp	DWORD PTR _RedChannel$[ebp], 0
	jne	SHORT $LN9@AssembleFr

; 100  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AssembleFr
$LN9@AssembleFr:

; 101  : 	if (GreenChannel == NULL)

	cmp	DWORD PTR _GreenChannel$[ebp], 0
	jne	SHORT $LN10@AssembleFr

; 102  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AssembleFr
$LN10@AssembleFr:

; 103  : 	if (BlueChannel == NULL)

	cmp	DWORD PTR _BlueChannel$[ebp], 0
	jne	SHORT $LN11@AssembleFr

; 104  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AssembleFr
$LN11@AssembleFr:

; 105  : 
; 106  : 	BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 107  : 	BYTE *Red = (BYTE *)RedChannel;

	mov	ecx, DWORD PTR _RedChannel$[ebp]
	mov	DWORD PTR _Red$[ebp], ecx

; 108  : 	BYTE *Green = (BYTE *)GreenChannel;

	mov	edx, DWORD PTR _GreenChannel$[ebp]
	mov	DWORD PTR _Green$[ebp], edx

; 109  : 	BYTE *Blue = (BYTE *)BlueChannel;

	mov	eax, DWORD PTR _BlueChannel$[ebp]
	mov	DWORD PTR _Blue$[ebp], eax

; 110  : 
; 111  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 112  : 	UINT32 ChannelIndex = 0;

	mov	DWORD PTR _ChannelIndex$[ebp], 0

; 113  : 
; 114  : 	for (int Row = 0; Row < DestinationHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@AssembleFr
$LN2@AssembleFr:
	mov	ecx, DWORD PTR _Row$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$4[ebp], ecx
$LN4@AssembleFr:
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _DestinationHeight$[ebp]
	jge	SHORT $LN3@AssembleFr

; 115  : 	{
; 116  : 		int RowOffset = Row * DestinationStride;

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _DestinationStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 117  : 		for (int Column = 0; Column < DestinationWidth; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@AssembleFr
$LN5@AssembleFr:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@AssembleFr:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _DestinationWidth$[ebp]
	jge	SHORT $LN6@AssembleFr

; 118  : 		{
; 119  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$3[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], eax

; 120  : 			Dest[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH

; 121  : 			Dest[Index + 2] = Red[ChannelIndex];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	eax, DWORD PTR _Red$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+2], cl

; 122  : 			Dest[Index + 1] = Green[ChannelIndex];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	eax, DWORD PTR _Green$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+1], cl

; 123  : 			Dest[Index + 0] = Blue[ChannelIndex];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	eax, DWORD PTR _Blue$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 124  : 			ChannelIndex++;

	mov	edx, DWORD PTR _ChannelIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _ChannelIndex$[ebp], edx

; 125  : 		}

	jmp	SHORT $LN5@AssembleFr
$LN6@AssembleFr:

; 126  : 	}

	jmp	$LN2@AssembleFr
$LN3@AssembleFr:

; 127  : 
; 128  : 	return Success;

	xor	eax, eax
$LN1@AssembleFr:

; 129  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_AssembleFromChannels@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\simd_channelalign.cpp
_TEXT	SEGMENT
_Blue$ = -48						; size = 4
_Green$ = -44						; size = 4
_Red$ = -40						; size = 4
_Alpha$ = -36						; size = 4
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Index$2 = -24						; size = 4
_Src$ = -20						; size = 4
_Column$3 = -16						; size = 4
_Row$4 = -12						; size = 4
_ChannelIndex$ = -8					; size = 4
_B$5 = -4						; size = 1
_G$6 = -3						; size = 1
_R$7 = -2						; size = 1
_A$8 = -1						; size = 1
_SourceBuffer$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_AlphaChannel$ = 24					; size = 4
_RedChannel$ = 28					; size = 4
_GreenChannel$ = 32					; size = 4
_BlueChannel$ = 36					; size = 4
_AlignChannels2@32 PROC

; 52   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 53   : 	if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN8@AlignChann

; 54   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlignChann
$LN8@AlignChann:

; 55   : 	if (AlphaChannel == NULL)

	cmp	DWORD PTR _AlphaChannel$[ebp], 0
	jne	SHORT $LN9@AlignChann

; 56   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlignChann
$LN9@AlignChann:

; 57   : 	if (RedChannel == NULL)

	cmp	DWORD PTR _RedChannel$[ebp], 0
	jne	SHORT $LN10@AlignChann

; 58   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlignChann
$LN10@AlignChann:

; 59   : 	if (GreenChannel == NULL)

	cmp	DWORD PTR _GreenChannel$[ebp], 0
	jne	SHORT $LN11@AlignChann

; 60   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlignChann
$LN11@AlignChann:

; 61   : 	if (BlueChannel == NULL)

	cmp	DWORD PTR _BlueChannel$[ebp], 0
	jne	SHORT $LN12@AlignChann

; 62   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlignChann
$LN12@AlignChann:

; 63   : 
; 64   : 	BYTE *Src = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 65   : 	BYTE *Alpha = (BYTE *)AlphaChannel;

	mov	ecx, DWORD PTR _AlphaChannel$[ebp]
	mov	DWORD PTR _Alpha$[ebp], ecx

; 66   : 	BYTE *Red = (BYTE *)RedChannel;

	mov	edx, DWORD PTR _RedChannel$[ebp]
	mov	DWORD PTR _Red$[ebp], edx

; 67   : 	BYTE *Green = (BYTE *)GreenChannel;

	mov	eax, DWORD PTR _GreenChannel$[ebp]
	mov	DWORD PTR _Green$[ebp], eax

; 68   : 	BYTE *Blue = (BYTE *)BlueChannel;

	mov	ecx, DWORD PTR _BlueChannel$[ebp]
	mov	DWORD PTR _Blue$[ebp], ecx

; 69   : 
; 70   : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 71   : 	UINT32 ChannelIndex = 0;

	mov	DWORD PTR _ChannelIndex$[ebp], 0

; 72   : 
; 73   : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@AlignChann
$LN2@AlignChann:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@AlignChann:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@AlignChann

; 74   : 	{
; 75   : 		int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 76   : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@AlignChann
$LN5@AlignChann:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@AlignChann:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	SHORT $LN6@AlignChann

; 77   : 		{
; 78   : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], ecx

; 79   : 			BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 80   : 			BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$7[ebp], dl

; 81   : 			BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$6[ebp], cl

; 82   : 			BYTE B = Src[Index + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$5[ebp], al

; 83   : 			Alpha[ChannelIndex] = A;

	mov	ecx, DWORD PTR _Alpha$[ebp]
	add	ecx, DWORD PTR _ChannelIndex$[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx], dl

; 84   : 			Red[ChannelIndex] = R;

	mov	eax, DWORD PTR _Red$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	cl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [eax], cl

; 85   : 			Green[ChannelIndex] = G;

	mov	edx, DWORD PTR _Green$[ebp]
	add	edx, DWORD PTR _ChannelIndex$[ebp]
	mov	al, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [edx], al

; 86   : 			Blue[ChannelIndex] = B;

	mov	ecx, DWORD PTR _Blue$[ebp]
	add	ecx, DWORD PTR _ChannelIndex$[ebp]
	mov	dl, BYTE PTR _B$5[ebp]
	mov	BYTE PTR [ecx], dl

; 87   : 			ChannelIndex++;

	mov	eax, DWORD PTR _ChannelIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _ChannelIndex$[ebp], eax

; 88   : 		}

	jmp	$LN5@AlignChann
$LN6@AlignChann:

; 89   : 	}

	jmp	$LN2@AlignChann
$LN3@AlignChann:

; 90   : 
; 91   : 	return Success;

	xor	eax, eax
$LN1@AlignChann:

; 92   : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_AlignChannels2@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\simd_channelalign.cpp
_TEXT	SEGMENT
_Blue$ = -44						; size = 4
_Green$ = -40						; size = 4
_Red$ = -36						; size = 4
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Index$2 = -24						; size = 4
_Src$ = -20						; size = 4
_Column$3 = -16						; size = 4
_Row$4 = -12						; size = 4
_ChannelIndex$ = -8					; size = 4
_B$5 = -3						; size = 1
_G$6 = -2						; size = 1
_R$7 = -1						; size = 1
_SourceBuffer$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_RedChannel$ = 24					; size = 4
_GreenChannel$ = 28					; size = 4
_BlueChannel$ = 32					; size = 4
_AlignChannels@28 PROC

; 13   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 14   : 	if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN8@AlignChann

; 15   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlignChann
$LN8@AlignChann:

; 16   : 	if (RedChannel == NULL)

	cmp	DWORD PTR _RedChannel$[ebp], 0
	jne	SHORT $LN9@AlignChann

; 17   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlignChann
$LN9@AlignChann:

; 18   : 	if (GreenChannel == NULL)

	cmp	DWORD PTR _GreenChannel$[ebp], 0
	jne	SHORT $LN10@AlignChann

; 19   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlignChann
$LN10@AlignChann:

; 20   : 	if (BlueChannel == NULL)

	cmp	DWORD PTR _BlueChannel$[ebp], 0
	jne	SHORT $LN11@AlignChann

; 21   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlignChann
$LN11@AlignChann:

; 22   : 
; 23   : 	BYTE *Src = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 24   : 	BYTE *Red = (BYTE *)RedChannel;

	mov	ecx, DWORD PTR _RedChannel$[ebp]
	mov	DWORD PTR _Red$[ebp], ecx

; 25   : 	BYTE *Green = (BYTE *)GreenChannel;

	mov	edx, DWORD PTR _GreenChannel$[ebp]
	mov	DWORD PTR _Green$[ebp], edx

; 26   : 	BYTE *Blue = (BYTE *)BlueChannel;

	mov	eax, DWORD PTR _BlueChannel$[ebp]
	mov	DWORD PTR _Blue$[ebp], eax

; 27   : 
; 28   : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 29   : 	UINT32 ChannelIndex = 0;

	mov	DWORD PTR _ChannelIndex$[ebp], 0

; 30   : 
; 31   : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@AlignChann
$LN2@AlignChann:
	mov	ecx, DWORD PTR _Row$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$4[ebp], ecx
$LN4@AlignChann:
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@AlignChann

; 32   : 	{
; 33   : 		int RowOffset = Row * SourceStride;

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 34   : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@AlignChann
$LN5@AlignChann:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@AlignChann:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _SourceWidth$[ebp]
	jge	SHORT $LN6@AlignChann

; 35   : 		{
; 36   : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$3[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], eax

; 37   : 			BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$7[ebp], dl

; 38   : 			BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$6[ebp], cl

; 39   : 			BYTE B = Src[Index + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$5[ebp], al

; 40   : 			Red[ChannelIndex] = R;

	mov	ecx, DWORD PTR _Red$[ebp]
	add	ecx, DWORD PTR _ChannelIndex$[ebp]
	mov	dl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [ecx], dl

; 41   : 			Green[ChannelIndex] = G;

	mov	eax, DWORD PTR _Green$[ebp]
	add	eax, DWORD PTR _ChannelIndex$[ebp]
	mov	cl, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [eax], cl

; 42   : 			Blue[ChannelIndex] = B;

	mov	edx, DWORD PTR _Blue$[ebp]
	add	edx, DWORD PTR _ChannelIndex$[ebp]
	mov	al, BYTE PTR _B$5[ebp]
	mov	BYTE PTR [edx], al

; 43   : 			ChannelIndex++;

	mov	ecx, DWORD PTR _ChannelIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ChannelIndex$[ebp], ecx

; 44   : 		}

	jmp	SHORT $LN5@AlignChann
$LN6@AlignChann:

; 45   : 	}

	jmp	$LN2@AlignChann
$LN3@AlignChann:

; 46   : 
; 47   : 	return Success;

	xor	eax, eax
$LN1@AlignChann:

; 48   : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_AlignChannels@28 ENDP
_TEXT	ENDS
END
