; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Deinterlace.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Deinterlace@24
PUBLIC	?PixelIsColor@@YGHPAXHEEE@Z			; PixelIsColor
PUBLIC	?PixelIsCloseToColor@@YGHPAXHEEEE@Z		; PixelIsCloseToColor
PUBLIC	?MeanOfTwoPixels@@YGHPAXHHPAE111@Z		; MeanOfTwoPixels
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\deinterlace.cpp
_TEXT	SEGMENT
_Src$ = -12						; size = 4
_B2$ = -8						; size = 1
_B1$ = -7						; size = 1
_G2$ = -6						; size = 1
_G1$ = -5						; size = 1
_R2$ = -4						; size = 1
_R1$ = -3						; size = 1
_A2$ = -2						; size = 1
_A1$ = -1						; size = 1
_Source$ = 8						; size = 4
_Address1$ = 12						; size = 4
_Address2$ = 16						; size = 4
_FinalA$ = 20						; size = 4
_FinalR$ = 24						; size = 4
_FinalG$ = 28						; size = 4
_FinalB$ = 32						; size = 4
?MeanOfTwoPixels@@YGHPAXHHPAE111@Z PROC			; MeanOfTwoPixels

; 72   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 73   :     *FinalA = 0;

	mov	eax, DWORD PTR _FinalA$[ebp]
	mov	BYTE PTR [eax], 0

; 74   :     *FinalR = 0;

	mov	ecx, DWORD PTR _FinalR$[ebp]
	mov	BYTE PTR [ecx], 0

; 75   :     *FinalG = 0;

	mov	edx, DWORD PTR _FinalG$[ebp]
	mov	BYTE PTR [edx], 0

; 76   :     *FinalB = 0;

	mov	eax, DWORD PTR _FinalB$[ebp]
	mov	BYTE PTR [eax], 0

; 77   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@MeanOfTwoP

; 78   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MeanOfTwoP
$LN2@MeanOfTwoP:

; 79   :     BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 80   :     BYTE A1 = Src[Address1 + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Address1$[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A1$[ebp], al

; 81   :     BYTE R1 = Src[Address1 + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Address1$[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R1$[ebp], dl

; 82   :     BYTE G1 = Src[Address1 + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Address1$[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G1$[ebp], cl

; 83   :     BYTE B1 = Src[Address1 + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Address1$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B1$[ebp], al

; 84   :     BYTE A2 = Src[Address2 + 3];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Address2$[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR _A2$[ebp], dl

; 85   :     BYTE R2 = Src[Address2 + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Address2$[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _R2$[ebp], cl

; 86   :     BYTE G2 = Src[Address2 + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Address2$[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _G2$[ebp], al

; 87   :     BYTE B2 = Src[Address2 + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Address2$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _B2$[ebp], dl

; 88   :     *FinalA = (BYTE)(((int)A1 + (int)A2) / 2);

	movzx	eax, BYTE PTR _A1$[ebp]
	movzx	ecx, BYTE PTR _A2$[ebp]
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _FinalA$[ebp]
	mov	BYTE PTR [edx], al

; 89   :     *FinalR = (BYTE)(((int)R1 + (int)R2) / 2);

	movzx	eax, BYTE PTR _R1$[ebp]
	movzx	ecx, BYTE PTR _R2$[ebp]
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _FinalR$[ebp]
	mov	BYTE PTR [edx], al

; 90   :     *FinalG = (BYTE)(((int)G1 + (int)G2) / 2);

	movzx	eax, BYTE PTR _G1$[ebp]
	movzx	ecx, BYTE PTR _G2$[ebp]
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _FinalG$[ebp]
	mov	BYTE PTR [edx], al

; 91   :     *FinalB = (BYTE)(((int)B1 + (int)B2) / 2);

	movzx	eax, BYTE PTR _B1$[ebp]
	movzx	ecx, BYTE PTR _B2$[ebp]
	add	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _FinalB$[ebp]
	mov	BYTE PTR [edx], al

; 92   :     return Success;

	xor	eax, eax
$LN1@MeanOfTwoP:

; 93   : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?MeanOfTwoPixels@@YGHPAXHHPAE111@Z ENDP			; MeanOfTwoPixels
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\deinterlace.cpp
_TEXT	SEGMENT
_BDelta$ = -16						; size = 4
_GDelta$ = -12						; size = 4
_RDelta$ = -8						; size = 4
_Src$ = -4						; size = 4
_Source$ = 8						; size = 4
_PixelLocation$ = 12					; size = 4
_R$ = 16						; size = 1
_G$ = 20						; size = 1
_B$ = 24						; size = 1
_Range$ = 28						; size = 1
?PixelIsCloseToColor@@YGHPAXHEEEE@Z PROC		; PixelIsCloseToColor

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 46   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@PixelIsClo

; 47   :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@PixelIsClo
$LN2@PixelIsClo:

; 48   :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 49   :     int RDelta = abs((int)Src[PixelLocation + 2] - (int)R);

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _PixelLocation$[ebp]
	movzx	eax, BYTE PTR [ecx+2]
	movzx	edx, BYTE PTR _R$[ebp]
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _RDelta$[ebp], eax

; 50   :     int GDelta = abs((int)Src[PixelLocation + 1] - (int)G);

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _PixelLocation$[ebp]
	movzx	eax, BYTE PTR [eax+1]
	movzx	ecx, BYTE PTR _G$[ebp]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _GDelta$[ebp], eax

; 51   :     int BDelta = abs((int)Src[PixelLocation + 0] - (int)B);

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _PixelLocation$[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _B$[ebp]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _BDelta$[ebp], eax

; 52   :     if (
; 53   :         (RDelta <= Range) &&
; 54   :         (GDelta <= Range) &&

	movzx	edx, BYTE PTR _Range$[ebp]
	cmp	DWORD PTR _RDelta$[ebp], edx
	jg	SHORT $LN3@PixelIsClo
	movzx	eax, BYTE PTR _Range$[ebp]
	cmp	DWORD PTR _GDelta$[ebp], eax
	jg	SHORT $LN3@PixelIsClo
	movzx	ecx, BYTE PTR _Range$[ebp]
	cmp	DWORD PTR _BDelta$[ebp], ecx
	jg	SHORT $LN3@PixelIsClo

; 55   :         (BDelta <= Range)
; 56   :        )
; 57   :         return TRUE;

	mov	eax, 1
	jmp	SHORT $LN1@PixelIsClo
$LN3@PixelIsClo:

; 58   :     return FALSE;

	xor	eax, eax
$LN1@PixelIsClo:

; 59   : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?PixelIsCloseToColor@@YGHPAXHEEEE@Z ENDP		; PixelIsCloseToColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\deinterlace.cpp
_TEXT	SEGMENT
_Src$ = -4						; size = 4
_Source$ = 8						; size = 4
_PixelLocation$ = 12					; size = 4
_R$ = 16						; size = 1
_G$ = 20						; size = 1
_B$ = 24						; size = 1
?PixelIsColor@@YGHPAXHEEE@Z PROC			; PixelIsColor

; 21   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 22   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@PixelIsCol

; 23   :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@PixelIsCol
$LN2@PixelIsCol:

; 24   :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 25   :     if (
; 26   :         (Src[PixelLocation + 2] == R) &&
; 27   :         (Src[PixelLocation + 1] == G) &&

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _PixelLocation$[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	movzx	eax, BYTE PTR _R$[ebp]
	cmp	edx, eax
	jne	SHORT $LN3@PixelIsCol
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _PixelLocation$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	movzx	eax, BYTE PTR _G$[ebp]
	cmp	edx, eax
	jne	SHORT $LN3@PixelIsCol
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _PixelLocation$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _B$[ebp]
	cmp	edx, eax
	jne	SHORT $LN3@PixelIsCol

; 28   :         (Src[PixelLocation + 0] == B)
; 29   :        )
; 30   :         return TRUE;

	mov	eax, 1
	jmp	SHORT $LN1@PixelIsCol
$LN3@PixelIsCol:

; 31   :     return FALSE;

	xor	eax, eax
$LN1@PixelIsCol:

; 32   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?PixelIsColor@@YGHPAXHEEE@Z ENDP			; PixelIsColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\deinterlace.cpp
_TEXT	SEGMENT
_PreviousIndex$1 = -92					; size = 4
_NextIndex$2 = -88					; size = 4
_TargetRow$3 = -84					; size = 4
_BlackPixel$4 = -80					; size = 4
_NextRowOffset$5 = -76					; size = 4
_PreviousRowOffset$6 = -72				; size = 4
_Result$7 = -68						; size = 4
_RowOffset$8 = -64					; size = 4
tv145 = -60						; size = 4
tv144 = -56						; size = 4
_IsEven$ = -52						; size = 4
tv142 = -48						; size = 4
tv71 = -44						; size = 4
_Start$ = -40						; size = 4
_PixelSize$ = -36					; size = 4
_C$9 = -32						; size = 4
_Column$10 = -28					; size = 4
_Src$ = -24						; size = 4
_I$11 = -20						; size = 4
_Row$12 = -16						; size = 4
_Dest$ = -12						; size = 4
_Index$13 = -8						; size = 4
_FinalB$14 = -4						; size = 1
_FinalG$15 = -3						; size = 1
_FinalR$16 = -2						; size = 1
_FinalA$17 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_StartingLine$ = 28					; size = 4
_Deinterlace@24 PROC

; 106  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 107  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN11@Deinterlac

; 108  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@Deinterlac
$LN11@Deinterlac:

; 109  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN12@Deinterlac

; 110  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@Deinterlac
$LN12@Deinterlac:

; 111  : 
; 112  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 113  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 114  :     BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 115  :     int Start = abs(StartingLine);

	mov	eax, DWORD PTR _StartingLine$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _Start$[ebp], eax

; 116  :     if (Start >= Height)

	mov	edx, DWORD PTR _Start$[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN13@Deinterlac

; 117  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@Deinterlac
$LN13@Deinterlac:

; 118  :     BOOL IsEven = Start % 2 == 0 ? TRUE : FALSE;

	mov	eax, DWORD PTR _Start$[ebp]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN28@Deinterlac
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN28@Deinterlac:
	test	eax, eax
	jne	SHORT $LN20@Deinterlac
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN21@Deinterlac
$LN20@Deinterlac:
	mov	DWORD PTR tv71[ebp], 0
$LN21@Deinterlac:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR _IsEven$[ebp], ecx

; 119  : 
; 120  :     for (int Row = Start; Row < Height; Row++)

	mov	edx, DWORD PTR _Start$[ebp]
	mov	DWORD PTR _Row$12[ebp], edx
	jmp	SHORT $LN4@Deinterlac
$LN2@Deinterlac:
	mov	eax, DWORD PTR _Row$12[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$12[ebp], eax
$LN4@Deinterlac:
	mov	ecx, DWORD PTR _Row$12[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN3@Deinterlac

; 121  :     {
; 122  :         int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$12[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$8[ebp], edx

; 123  : 
; 124  :         if ((Row - 1 < 0) || (Row + 1 >= Height))

	mov	eax, DWORD PTR _Row$12[ebp]
	sub	eax, 1
	js	SHORT $LN15@Deinterlac
	mov	ecx, DWORD PTR _Row$12[ebp]
	add	ecx, 1
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN14@Deinterlac
$LN15@Deinterlac:

; 125  :         {
; 126  :             //Copy the source to the destination without modification.
; 127  :             for (int C = 0; C < Width; C++)

	mov	DWORD PTR _C$9[ebp], 0
	jmp	SHORT $LN7@Deinterlac
$LN5@Deinterlac:
	mov	edx, DWORD PTR _C$9[ebp]
	add	edx, 1
	mov	DWORD PTR _C$9[ebp], edx
$LN7@Deinterlac:
	mov	eax, DWORD PTR _C$9[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@Deinterlac

; 128  :             {
; 129  :                 int I = (C * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _C$9[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$8[ebp]
	mov	DWORD PTR _I$11[ebp], ecx

; 130  :                 Dest[I + 3] = Src[I + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _I$11[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _I$11[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 131  :                 Dest[I + 2] = Src[I + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _I$11[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _I$11[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 132  :                 Dest[I + 1] = Src[I + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _I$11[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _I$11[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 133  :                 Dest[I + 0] = Src[I + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _I$11[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _I$11[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 134  :             }

	jmp	SHORT $LN5@Deinterlac
$LN6@Deinterlac:

; 135  :             continue;

	jmp	$LN2@Deinterlac
$LN14@Deinterlac:

; 136  :         }
; 137  : 
; 138  :         BOOL TargetRow = ((Row) & (0x1)) == 1 ? (IsEven ? FALSE : TRUE) : (IsEven ? TRUE : FALSE);

	mov	edx, DWORD PTR _Row$12[ebp]
	and	edx, 1
	je	SHORT $LN26@Deinterlac
	cmp	DWORD PTR _IsEven$[ebp], 0
	je	SHORT $LN22@Deinterlac
	mov	DWORD PTR tv142[ebp], 0
	jmp	SHORT $LN23@Deinterlac
$LN22@Deinterlac:
	mov	DWORD PTR tv142[ebp], 1
$LN23@Deinterlac:
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR tv145[ebp], eax
	jmp	SHORT $LN27@Deinterlac
$LN26@Deinterlac:
	cmp	DWORD PTR _IsEven$[ebp], 0
	je	SHORT $LN24@Deinterlac
	mov	DWORD PTR tv144[ebp], 1
	jmp	SHORT $LN25@Deinterlac
$LN24@Deinterlac:
	mov	DWORD PTR tv144[ebp], 0
$LN25@Deinterlac:
	mov	ecx, DWORD PTR tv144[ebp]
	mov	DWORD PTR tv145[ebp], ecx
$LN27@Deinterlac:
	mov	edx, DWORD PTR tv145[ebp]
	mov	DWORD PTR _TargetRow$3[ebp], edx

; 139  :         int PreviousRowOffset = (Row - 1) * Stride;

	mov	eax, DWORD PTR _Row$12[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _PreviousRowOffset$6[ebp], eax

; 140  :         int NextRowOffset = (Row + 1) * Stride;

	mov	ecx, DWORD PTR _Row$12[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _NextRowOffset$5[ebp], ecx

; 141  : 
; 142  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$10[ebp], 0
	jmp	SHORT $LN10@Deinterlac
$LN8@Deinterlac:
	mov	edx, DWORD PTR _Column$10[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$10[ebp], edx
$LN10@Deinterlac:
	mov	eax, DWORD PTR _Column$10[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN9@Deinterlac

; 143  :         {
; 144  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$10[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$8[ebp]
	mov	DWORD PTR _Index$13[ebp], ecx

; 145  :             int PreviousIndex = (Column * PixelSize) + PreviousRowOffset;

	mov	edx, DWORD PTR _Column$10[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _PreviousRowOffset$6[ebp]
	mov	DWORD PTR _PreviousIndex$1[ebp], edx

; 146  :             int NextIndex = (Column * PixelSize) + NextRowOffset;

	mov	eax, DWORD PTR _Column$10[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _NextRowOffset$5[ebp]
	mov	DWORD PTR _NextIndex$2[ebp], eax

; 147  : 
; 148  :             BOOL BlackPixel = PixelIsCloseToColor(Source, Index, 0, 0, 0, 16);

	push	16					; 00000010H
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _Index$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _Source$[ebp]
	push	edx
	call	?PixelIsCloseToColor@@YGHPAXHEEEE@Z	; PixelIsCloseToColor
	mov	DWORD PTR _BlackPixel$4[ebp], eax

; 149  :             if (BlackPixel && TargetRow)

	cmp	DWORD PTR _BlackPixel$4[ebp], 0
	je	SHORT $LN16@Deinterlac
	cmp	DWORD PTR _TargetRow$3[ebp], 0
	je	SHORT $LN16@Deinterlac

; 150  :             {
; 151  :                 BYTE FinalA = 0;

	mov	BYTE PTR _FinalA$17[ebp], 0

; 152  :                 BYTE FinalR = 0;

	mov	BYTE PTR _FinalR$16[ebp], 0

; 153  :                 BYTE FinalG = 0;

	mov	BYTE PTR _FinalG$15[ebp], 0

; 154  :                 BYTE FinalB = 0;

	mov	BYTE PTR _FinalB$14[ebp], 0

; 155  :                 int Result = MeanOfTwoPixels(Source, PreviousIndex, NextIndex, &FinalA, &FinalR, &FinalG, &FinalB);

	lea	eax, DWORD PTR _FinalB$14[ebp]
	push	eax
	lea	ecx, DWORD PTR _FinalG$15[ebp]
	push	ecx
	lea	edx, DWORD PTR _FinalR$16[ebp]
	push	edx
	lea	eax, DWORD PTR _FinalA$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _NextIndex$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _PreviousIndex$1[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	?MeanOfTwoPixels@@YGHPAXHHPAE111@Z	; MeanOfTwoPixels
	mov	DWORD PTR _Result$7[ebp], eax

; 156  :                 if (Result != Success)

	cmp	DWORD PTR _Result$7[ebp], 0
	je	SHORT $LN18@Deinterlac

; 157  :                     return Result;

	mov	eax, DWORD PTR _Result$7[ebp]
	jmp	$LN1@Deinterlac
$LN18@Deinterlac:

; 158  :                 Dest[Index + 3] = FinalA;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$13[ebp]
	mov	dl, BYTE PTR _FinalA$17[ebp]
	mov	BYTE PTR [ecx+3], dl

; 159  :                 Dest[Index + 2] = FinalR;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$13[ebp]
	mov	cl, BYTE PTR _FinalR$16[ebp]
	mov	BYTE PTR [eax+2], cl

; 160  :                 Dest[Index + 1] = FinalG;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$13[ebp]
	mov	al, BYTE PTR _FinalG$15[ebp]
	mov	BYTE PTR [edx+1], al

; 161  :                 Dest[Index + 0] = FinalB;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$13[ebp]
	mov	dl, BYTE PTR _FinalB$14[ebp]
	mov	BYTE PTR [ecx], dl

; 162  :             }
; 163  :             else

	jmp	SHORT $LN17@Deinterlac
$LN16@Deinterlac:

; 164  :             {
; 165  :                 Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$13[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$13[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 166  :                 Dest[Index + 2] = Src[Index + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$13[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$13[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 167  :                 Dest[Index + 1] = Src[Index + 1];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$13[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$13[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 168  :                 Dest[Index + 0] = Src[Index + 0];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$13[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$13[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
$LN17@Deinterlac:

; 169  :             }
; 170  :         }

	jmp	$LN8@Deinterlac
$LN9@Deinterlac:

; 171  : 
; 172  :     }

	jmp	$LN2@Deinterlac
$LN3@Deinterlac:

; 173  : 
; 174  :     return Success;

	xor	eax, eax
$LN1@Deinterlac:

; 175  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_Deinterlace@24 ENDP
_TEXT	ENDS
END
