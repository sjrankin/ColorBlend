; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\TestImageRenderer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_RenderRandomColorRectangle@52
PUBLIC	_RenderRampingColorRectangle@80
PUBLIC	_RenderRandomSubBlockRectangle@28
PUBLIC	_RenderRampingGradientColorRectangle@32
PUBLIC	_RenderLinearGradients@32
PUBLIC	?random_at_most@@YGJJ@Z				; random_at_most
PUBLIC	?rrand2@@YGHHH@Z				; rrand2
PUBLIC	?RandomColor@@YGXPAE000@Z			; RandomColor
PUBLIC	?ConstrainedRandomColor@@YGXPAEEE0EE0EE0EE@Z	; ConstrainedRandomColor
PUBLIC	?ColorInterval@@YGXIINHPAI@Z			; ColorInterval
PUBLIC	?GradientIndexFromGradientRange@@YGHPAXHH@Z	; GradientIndexFromGradientRange
PUBLIC	__real@3ff0000000000000
EXTRN	__imp__srand:PROC
EXTRN	__imp__rand:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\testimagerenderer.cpp
_TEXT	SEGMENT
_Gradients$ = -8					; size = 4
_i$1 = -4						; size = 4
_Stops$ = 8						; size = 4
_StopCount$ = 12					; size = 4
_Index$ = 16						; size = 4
?GradientIndexFromGradientRange@@YGHPAXHH@Z PROC	; GradientIndexFromGradientRange

; 246  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 247  :     if (Stops == NULL)

	cmp	DWORD PTR _Stops$[ebp], 0
	jne	SHORT $LN5@GradientIn

; 248  :         return -1;

	or	eax, -1
	jmp	SHORT $LN1@GradientIn
$LN5@GradientIn:

; 249  :     GradientStop *Gradients = (GradientStop *)Stops;

	mov	eax, DWORD PTR _Stops$[ebp]
	mov	DWORD PTR _Gradients$[ebp], eax

; 250  :     for (int i = 0; i < StopCount; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GradientIn
$LN2@GradientIn:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN4@GradientIn:
	mov	edx, DWORD PTR _i$1[ebp]
	cmp	edx, DWORD PTR _StopCount$[ebp]
	jge	SHORT $LN3@GradientIn

; 251  :     {
; 252  :         if ((Index >= Gradients[i].AbsStart) && (Index <= Gradients[i].AbsEnd))

	imul	eax, DWORD PTR _i$1[ebp], 20
	mov	ecx, DWORD PTR _Gradients$[ebp]
	mov	edx, DWORD PTR _Index$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+8]
	jl	SHORT $LN6@GradientIn
	imul	eax, DWORD PTR _i$1[ebp], 20
	mov	ecx, DWORD PTR _Gradients$[ebp]
	mov	edx, DWORD PTR _Index$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+12]
	jg	SHORT $LN6@GradientIn

; 253  :             return i;

	mov	eax, DWORD PTR _i$1[ebp]
	jmp	SHORT $LN1@GradientIn
$LN6@GradientIn:

; 254  :     }

	jmp	SHORT $LN2@GradientIn
$LN3@GradientIn:

; 255  :     return  -1;

	or	eax, -1
$LN1@GradientIn:

; 256  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GradientIndexFromGradientRange@@YGHPAXHH@Z ENDP	; GradientIndexFromGradientRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\testimagerenderer.cpp
_TEXT	SEGMENT
_StartA$ = -12						; size = 1
_EndA$ = -11						; size = 1
_FinalB$ = -10						; size = 1
_FinalG$ = -9						; size = 1
_FinalR$ = -8						; size = 1
_FinalA$ = -7						; size = 1
_StartB$ = -6						; size = 1
_StartG$ = -5						; size = 1
_StartR$ = -4						; size = 1
_EndB$ = -3						; size = 1
_EndG$ = -2						; size = 1
_EndR$ = -1						; size = 1
_StartColor$ = 8					; size = 4
_EndColor$ = 12						; size = 4
_NormalizedDistance$ = 16				; size = 8
_IgnoreAlpha$ = 24					; size = 4
_FinalColor$ = 28					; size = 4
?ColorInterval@@YGXIINHPAI@Z PROC			; ColorInterval

; 153  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 154  :     BYTE StartA = (StartColor & 0xff000000) >> 24;

	mov	eax, DWORD PTR _StartColor$[ebp]
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	BYTE PTR _StartA$[ebp], al

; 155  :     BYTE StartR = (StartColor & 0x00ff0000) >> 16;

	mov	ecx, DWORD PTR _StartColor$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR _StartR$[ebp], cl

; 156  :     BYTE StartG = (StartColor & 0x0000ff00) >> 8;

	mov	edx, DWORD PTR _StartColor$[ebp]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _StartG$[ebp], dl

; 157  :     BYTE StartB = (StartColor & 0x000000ff) >> 0;

	mov	eax, DWORD PTR _StartColor$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _StartB$[ebp], al

; 158  :     BYTE EndA = (EndColor & 0xff000000) >> 24;

	mov	ecx, DWORD PTR _EndColor$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _EndA$[ebp], cl

; 159  :     BYTE EndR = (EndColor & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _EndColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _EndR$[ebp], dl

; 160  :     BYTE EndG = (EndColor & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _EndColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _EndG$[ebp], al

; 161  :     BYTE EndB = (EndColor & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _EndColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _EndB$[ebp], cl

; 162  : 
; 163  :     BYTE FinalA;
; 164  :     if (IgnoreAlpha)

	cmp	DWORD PTR _IgnoreAlpha$[ebp], 0
	je	SHORT $LN2@ColorInter

; 165  :         FinalA = 0xff;

	mov	BYTE PTR _FinalA$[ebp], 255		; 000000ffH

; 166  :     else

	jmp	SHORT $LN3@ColorInter
$LN2@ColorInter:

; 167  :         FinalA = (BYTE)((double)(abs(EndA - StartA)) * NormalizedDistance);

	movzx	eax, BYTE PTR _EndA$[ebp]
	movzx	edx, BYTE PTR _StartA$[ebp]
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _NormalizedDistance$[ebp]
	cvttsd2si eax, xmm0
	mov	BYTE PTR _FinalA$[ebp], al
$LN3@ColorInter:

; 168  : 
; 169  :     BYTE FinalR;
; 170  :     if (EndR == StartR)

	movzx	ecx, BYTE PTR _EndR$[ebp]
	movzx	edx, BYTE PTR _StartR$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN4@ColorInter

; 171  :         FinalR = EndR;

	mov	al, BYTE PTR _EndR$[ebp]
	mov	BYTE PTR _FinalR$[ebp], al

; 172  :     else

	jmp	SHORT $LN5@ColorInter
$LN4@ColorInter:

; 173  :         FinalR = (BYTE)((double)(abs(EndR - StartR)) * NormalizedDistance);

	movzx	eax, BYTE PTR _EndR$[ebp]
	movzx	ecx, BYTE PTR _StartR$[ebp]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _NormalizedDistance$[ebp]
	cvttsd2si edx, xmm0
	mov	BYTE PTR _FinalR$[ebp], dl
$LN5@ColorInter:

; 174  : 
; 175  :     BYTE FinalG;
; 176  :     if (EndG == StartG)

	movzx	eax, BYTE PTR _EndG$[ebp]
	movzx	ecx, BYTE PTR _StartG$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN6@ColorInter

; 177  :         FinalG = EndG;

	mov	dl, BYTE PTR _EndG$[ebp]
	mov	BYTE PTR _FinalG$[ebp], dl

; 178  :     else

	jmp	SHORT $LN7@ColorInter
$LN6@ColorInter:

; 179  :         FinalG = (BYTE)((double)(abs(EndG - StartG)) * NormalizedDistance);

	movzx	eax, BYTE PTR _EndG$[ebp]
	movzx	ecx, BYTE PTR _StartG$[ebp]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _NormalizedDistance$[ebp]
	cvttsd2si edx, xmm0
	mov	BYTE PTR _FinalG$[ebp], dl
$LN7@ColorInter:

; 180  : 
; 181  :     BYTE FinalB;
; 182  :     if (EndB == StartB)

	movzx	eax, BYTE PTR _EndB$[ebp]
	movzx	ecx, BYTE PTR _StartB$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN8@ColorInter

; 183  :         FinalB = EndB;

	mov	dl, BYTE PTR _EndB$[ebp]
	mov	BYTE PTR _FinalB$[ebp], dl

; 184  :     else

	jmp	SHORT $LN9@ColorInter
$LN8@ColorInter:

; 185  :         FinalB = (BYTE)((double)(abs(EndB - StartB)) * NormalizedDistance);

	movzx	eax, BYTE PTR _EndB$[ebp]
	movzx	ecx, BYTE PTR _StartB$[ebp]
	sub	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _NormalizedDistance$[ebp]
	cvttsd2si edx, xmm0
	mov	BYTE PTR _FinalB$[ebp], dl
$LN9@ColorInter:

; 186  : 
; 187  :     *FinalColor = (FinalA << 24) | (FinalR << 16) | (FinalG << 8) | FinalB;

	movzx	eax, BYTE PTR _FinalA$[ebp]
	shl	eax, 24					; 00000018H
	movzx	ecx, BYTE PTR _FinalR$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	movzx	edx, BYTE PTR _FinalG$[ebp]
	shl	edx, 8
	or	eax, edx
	movzx	ecx, BYTE PTR _FinalB$[ebp]
	or	eax, ecx
	mov	edx, DWORD PTR _FinalColor$[ebp]
	mov	DWORD PTR [edx], eax

; 188  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?ColorInterval@@YGXIINHPAI@Z ENDP			; ColorInterval
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\testimagerenderer.cpp
_TEXT	SEGMENT
_Alpha$ = 8						; size = 4
_MinAlpha$ = 12						; size = 1
_MaxAlpha$ = 16						; size = 1
_Red$ = 20						; size = 4
_MinRed$ = 24						; size = 1
_MaxRed$ = 28						; size = 1
_Green$ = 32						; size = 4
_MinGreen$ = 36						; size = 1
_MaxGreen$ = 40						; size = 1
_Blue$ = 44						; size = 4
_MinBlue$ = 48						; size = 1
_MaxBlue$ = 52						; size = 1
?ConstrainedRandomColor@@YGXPAEEE0EE0EE0EE@Z PROC	; ConstrainedRandomColor

; 55   : {

	push	ebp
	mov	ebp, esp

; 56   :     *Alpha = rrand2(MinAlpha, MaxAlpha);

	movzx	eax, BYTE PTR _MaxAlpha$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _MinAlpha$[ebp]
	push	ecx
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	edx, DWORD PTR _Alpha$[ebp]
	mov	BYTE PTR [edx], al

; 57   :     *Red = rrand2(MinRed, MaxRed);

	movzx	eax, BYTE PTR _MaxRed$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _MinRed$[ebp]
	push	ecx
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	edx, DWORD PTR _Red$[ebp]
	mov	BYTE PTR [edx], al

; 58   :     *Green = rrand2(MinGreen, MaxGreen);

	movzx	eax, BYTE PTR _MaxGreen$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _MinGreen$[ebp]
	push	ecx
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	edx, DWORD PTR _Green$[ebp]
	mov	BYTE PTR [edx], al

; 59   :     *Blue = rrand2(MinBlue, MaxBlue);

	movzx	eax, BYTE PTR _MaxBlue$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _MinBlue$[ebp]
	push	ecx
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	edx, DWORD PTR _Blue$[ebp]
	mov	BYTE PTR [edx], al

; 60   : }

	pop	ebp
	ret	48					; 00000030H
?ConstrainedRandomColor@@YGXPAEEE0EE0EE0EE@Z ENDP	; ConstrainedRandomColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\testimagerenderer.cpp
_TEXT	SEGMENT
_Alpha$ = 8						; size = 4
_Red$ = 12						; size = 4
_Green$ = 16						; size = 4
_Blue$ = 20						; size = 4
?RandomColor@@YGXPAE000@Z PROC				; RandomColor

; 46   : {

	push	ebp
	mov	ebp, esp

; 47   :     *Alpha = rrand2(0, 255);

	push	255					; 000000ffH
	push	0
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	ecx, DWORD PTR _Alpha$[ebp]
	mov	BYTE PTR [ecx], al

; 48   :     *Red = rrand2(0, 255);

	push	255					; 000000ffH
	push	0
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	edx, DWORD PTR _Red$[ebp]
	mov	BYTE PTR [edx], al

; 49   :     *Green = rrand2(0, 255);

	push	255					; 000000ffH
	push	0
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	ecx, DWORD PTR _Green$[ebp]
	mov	BYTE PTR [ecx], al

; 50   :     *Blue = rrand2(0, 255);

	push	255					; 000000ffH
	push	0
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	edx, DWORD PTR _Blue$[ebp]
	mov	BYTE PTR [edx], al

; 51   : }

	pop	ebp
	ret	16					; 00000010H
?RandomColor@@YGXPAE000@Z ENDP				; RandomColor
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\testimagerenderer.cpp
_TEXT	SEGMENT
_r$ = -8						; size = 4
_range$ = -4						; size = 4
_Low$ = 8						; size = 4
_High$ = 12						; size = 4
?rrand2@@YGHHH@Z PROC					; rrand2

; 32   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 33   :     int range = High - Low;

	mov	eax, DWORD PTR _High$[ebp]
	sub	eax, DWORD PTR _Low$[ebp]
	mov	DWORD PTR _range$[ebp], eax

; 34   :     long r = random_at_most((long)range);

	mov	ecx, DWORD PTR _range$[ebp]
	push	ecx
	call	?random_at_most@@YGJJ@Z			; random_at_most
	mov	DWORD PTR _r$[ebp], eax

; 35   :     return r + Low;

	mov	eax, DWORD PTR _r$[ebp]
	add	eax, DWORD PTR _Low$[ebp]

; 36   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?rrand2@@YGHHH@Z ENDP					; rrand2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\testimagerenderer.cpp
_TEXT	SEGMENT
_bin_size$ = -20					; size = 4
_defect$ = -16						; size = 4
_x$ = -12						; size = 4
_num_bins$ = -8						; size = 4
_num_rand$ = -4						; size = 4
_max$ = 8						; size = 4
?random_at_most@@YGJJ@Z PROC				; random_at_most

; 9    : long random_at_most(long max) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 10   :     unsigned long
; 11   :         // max <= RAND_MAX < ULONG_MAX, so this is okay.
; 12   :         num_bins = (unsigned long)max + 1,

	mov	eax, DWORD PTR _max$[ebp]
	add	eax, 1
	mov	DWORD PTR _num_bins$[ebp], eax

; 13   :         num_rand = (unsigned long)RAND_MAX + 1,

	mov	DWORD PTR _num_rand$[ebp], 32768	; 00008000H

; 14   :         bin_size = num_rand / num_bins,

	mov	eax, DWORD PTR _num_rand$[ebp]
	xor	edx, edx
	div	DWORD PTR _num_bins$[ebp]
	mov	DWORD PTR _bin_size$[ebp], eax

; 15   :         defect = num_rand % num_bins;

	mov	eax, DWORD PTR _num_rand$[ebp]
	xor	edx, edx
	div	DWORD PTR _num_bins$[ebp]
	mov	DWORD PTR _defect$[ebp], edx
$LN2@random_at_:

; 16   : 
; 17   :     long x;
; 18   :     // This is carefully written not to overflow
; 19   :     while (num_rand - defect <= (unsigned long)(x = rand()));

	call	DWORD PTR __imp__rand
	mov	DWORD PTR _x$[ebp], eax
	mov	ecx, DWORD PTR _num_rand$[ebp]
	sub	ecx, DWORD PTR _defect$[ebp]
	cmp	ecx, DWORD PTR _x$[ebp]
	ja	SHORT $LN3@random_at_
	jmp	SHORT $LN2@random_at_
$LN3@random_at_:

; 20   : 
; 21   :     // Truncated division is intentional
; 22   :     return x / bin_size;

	mov	eax, DWORD PTR _x$[ebp]
	xor	edx, edx
	div	DWORD PTR _bin_size$[ebp]

; 23   : }

	mov	esp, ebp
	pop	ebp
	ret	4
?random_at_most@@YGJJ@Z ENDP				; random_at_most
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\testimagerenderer.cpp
_TEXT	SEGMENT
_RangeNormal$1 = -68					; size = 8
_Final$2 = -60						; size = 4
_RowOffset$3 = -56					; size = 4
_PixelSize$ = -52					; size = 4
_RangeIndex$4 = -48					; size = 4
tv83 = -44						; size = 4
tv76 = -40						; size = 4
_Index$5 = -36						; size = 4
_Buffer$ = -32						; size = 4
_Row$6 = -28						; size = 4
_Column$7 = -24						; size = 4
_Gradients$ = -20					; size = 4
_GradientIndex$8 = -16					; size = 4
_eB$9 = -12						; size = 1
_eG$10 = -11						; size = 1
_eR$11 = -10						; size = 1
_eA$12 = -9						; size = 1
_fR$13 = -8						; size = 1
_fG$14 = -7						; size = 1
_fB$15 = -6						; size = 1
_fA$16 = -5						; size = 1
_sB$17 = -4						; size = 1
_sG$18 = -3						; size = 1
_sR$19 = -2						; size = 1
_sA$20 = -1						; size = 1
_Destination$ = 8					; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_IgnoreAlpha$ = 24					; size = 4
_DoHorizontal$ = 28					; size = 4
_Stops$ = 32						; size = 4
_StopCount$ = 36					; size = 4
_RenderLinearGradients@32 PROC

; 272  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 273  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@RenderLine

; 274  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderLine
$LN8@RenderLine:

; 275  :     if (Stops == NULL)

	cmp	DWORD PTR _Stops$[ebp], 0
	jne	SHORT $LN9@RenderLine

; 276  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderLine
$LN9@RenderLine:

; 277  :     if (StopCount < 2)

	cmp	DWORD PTR _StopCount$[ebp], 2
	jge	SHORT $LN10@RenderLine

; 278  :         return IndexOutOfRange;

	mov	eax, 6
	jmp	$LN1@RenderLine
$LN10@RenderLine:

; 279  : 
; 280  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 281  :     BYTE *Buffer = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 282  :     GradientStop *Gradients = (GradientStop *)Stops;

	mov	ecx, DWORD PTR _Stops$[ebp]
	mov	DWORD PTR _Gradients$[ebp], ecx

; 283  : 
; 284  :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@RenderLine
$LN2@RenderLine:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@RenderLine:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _BufferHeight$[ebp]
	jge	$LN3@RenderLine

; 285  :     {
; 286  :         int RowOffset = Row * BufferStride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], ecx

; 287  :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$7[ebp], 0
	jmp	SHORT $LN7@RenderLine
$LN5@RenderLine:
	mov	edx, DWORD PTR _Column$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$7[ebp], edx
$LN7@RenderLine:
	mov	eax, DWORD PTR _Column$7[ebp]
	cmp	eax, DWORD PTR _BufferWidth$[ebp]
	jge	$LN6@RenderLine

; 288  :         {
; 289  :             int Index = RowOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$7[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 290  :             UINT32 Final = 0x0;

	mov	DWORD PTR _Final$2[ebp], 0

; 291  :             int GradientIndex = GradientIndexFromGradientRange(Stops, StopCount, DoHorizontal ? Column : Row);

	cmp	DWORD PTR _DoHorizontal$[ebp], 0
	je	SHORT $LN28@RenderLine
	mov	edx, DWORD PTR _Column$7[ebp]
	mov	DWORD PTR tv76[ebp], edx
	jmp	SHORT $LN29@RenderLine
$LN28@RenderLine:
	mov	eax, DWORD PTR _Row$6[ebp]
	mov	DWORD PTR tv76[ebp], eax
$LN29@RenderLine:
	mov	ecx, DWORD PTR tv76[ebp]
	push	ecx
	mov	edx, DWORD PTR _StopCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stops$[ebp]
	push	eax
	call	?GradientIndexFromGradientRange@@YGHPAXHH@Z ; GradientIndexFromGradientRange
	mov	DWORD PTR _GradientIndex$8[ebp], eax

; 292  :             if (GradientIndex < 0)

	cmp	DWORD PTR _GradientIndex$8[ebp], 0
	jge	SHORT $LN11@RenderLine

; 293  :                 return IndexOutOfRange;

	mov	eax, 6
	jmp	$LN1@RenderLine
$LN11@RenderLine:

; 294  :             if (GradientIndex >= StopCount)

	mov	ecx, DWORD PTR _GradientIndex$8[ebp]
	cmp	ecx, DWORD PTR _StopCount$[ebp]
	jl	SHORT $LN12@RenderLine

; 295  :                 return IndexOutOfRange;

	mov	eax, 6
	jmp	$LN1@RenderLine
$LN12@RenderLine:

; 296  : 
; 297  :             int RangeIndex = (DoHorizontal ? Column : Row) - Gradients[GradientIndex].AbsStart;

	cmp	DWORD PTR _DoHorizontal$[ebp], 0
	je	SHORT $LN30@RenderLine
	mov	edx, DWORD PTR _Column$7[ebp]
	mov	DWORD PTR tv83[ebp], edx
	jmp	SHORT $LN31@RenderLine
$LN30@RenderLine:
	mov	eax, DWORD PTR _Row$6[ebp]
	mov	DWORD PTR tv83[ebp], eax
$LN31@RenderLine:
	imul	ecx, DWORD PTR _GradientIndex$8[ebp], 20
	mov	edx, DWORD PTR _Gradients$[ebp]
	mov	eax, DWORD PTR tv83[ebp]
	sub	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _RangeIndex$4[ebp], eax

; 298  :             if (RangeIndex < 0)

	jns	SHORT $LN13@RenderLine

; 299  :                 return IndexOutOfRange;

	mov	eax, 6
	jmp	$LN1@RenderLine
$LN13@RenderLine:

; 300  :             double RangeNormal = (double)(RangeIndex) / (double)Gradients[GradientIndex].AbsGap;

	cvtsi2sd xmm0, DWORD PTR _RangeIndex$4[ebp]
	imul	ecx, DWORD PTR _GradientIndex$8[ebp], 20
	mov	edx, DWORD PTR _Gradients$[ebp]
	cvtsi2sd xmm1, DWORD PTR [edx+ecx+16]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _RangeNormal$1[ebp], xmm0

; 301  : 
; 302  :             BYTE sA, sR, sG, sB;
; 303  :             BYTE eA, eR, eG, eB;
; 304  :             sA = (BYTE)((Gradients[GradientIndex].StartColor & 0xff000000) >> 24);

	imul	eax, DWORD PTR _GradientIndex$8[ebp], 20
	mov	ecx, DWORD PTR _Gradients$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _sA$20[ebp], dl

; 305  :             sR = (BYTE)((Gradients[GradientIndex].StartColor & 0x00ff0000) >> 16);

	imul	eax, DWORD PTR _GradientIndex$8[ebp], 20
	mov	ecx, DWORD PTR _Gradients$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _sR$19[ebp], dl

; 306  :             sG = (BYTE)((Gradients[GradientIndex].StartColor & 0x0000ff00) >> 8);

	imul	eax, DWORD PTR _GradientIndex$8[ebp], 20
	mov	ecx, DWORD PTR _Gradients$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _sG$18[ebp], dl

; 307  :             sB = (BYTE)((Gradients[GradientIndex].StartColor & 0x000000ff) >> 0);

	imul	eax, DWORD PTR _GradientIndex$8[ebp], 20
	mov	ecx, DWORD PTR _Gradients$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _sB$17[ebp], dl

; 308  :             eA = (BYTE)((Gradients[GradientIndex].EndColor & 0xff000000) >> 24);

	imul	eax, DWORD PTR _GradientIndex$8[ebp], 20
	mov	ecx, DWORD PTR _Gradients$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _eA$12[ebp], dl

; 309  :             eR = (BYTE)((Gradients[GradientIndex].EndColor & 0x00ff0000) >> 16);

	imul	eax, DWORD PTR _GradientIndex$8[ebp], 20
	mov	ecx, DWORD PTR _Gradients$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _eR$11[ebp], dl

; 310  :             eG = (BYTE)((Gradients[GradientIndex].EndColor & 0x0000ff00) >> 8);

	imul	eax, DWORD PTR _GradientIndex$8[ebp], 20
	mov	ecx, DWORD PTR _Gradients$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _eG$10[ebp], dl

; 311  :             eB = (BYTE)((Gradients[GradientIndex].EndColor & 0x000000ff) >> 0);

	imul	eax, DWORD PTR _GradientIndex$8[ebp], 20
	mov	ecx, DWORD PTR _Gradients$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _eB$9[ebp], dl

; 312  : 
; 313  :             BYTE fA, fR, fG, fB;
; 314  :             if (RangeNormal >= 1.0)

	movsd	xmm0, QWORD PTR _RangeNormal$1[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jb	SHORT $LN14@RenderLine

; 315  :             {
; 316  :                 //At or past the end of the current gradient range.
; 317  :                 fA = eA;

	mov	al, BYTE PTR _eA$12[ebp]
	mov	BYTE PTR _fA$16[ebp], al

; 318  :                 fR = eR;

	mov	cl, BYTE PTR _eR$11[ebp]
	mov	BYTE PTR _fR$13[ebp], cl

; 319  :                 fG = eG;

	mov	dl, BYTE PTR _eG$10[ebp]
	mov	BYTE PTR _fG$14[ebp], dl

; 320  :                 fB = eB;

	mov	al, BYTE PTR _eB$9[ebp]
	mov	BYTE PTR _fB$15[ebp], al

; 321  :             }
; 322  :             else

	jmp	$LN25@RenderLine
$LN14@RenderLine:

; 323  :                 if (RangeNormal <= 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _RangeNormal$1[ebp]
	jb	SHORT $LN16@RenderLine

; 324  :                 {
; 325  :                     //At or earlier than the start of the current gradient range.
; 326  :                     fA = sA;

	mov	cl, BYTE PTR _sA$20[ebp]
	mov	BYTE PTR _fA$16[ebp], cl

; 327  :                     fR = sR;

	mov	dl, BYTE PTR _sR$19[ebp]
	mov	BYTE PTR _fR$13[ebp], dl

; 328  :                     fG = sG;

	mov	al, BYTE PTR _sG$18[ebp]
	mov	BYTE PTR _fG$14[ebp], al

; 329  :                     fB = sB;

	mov	cl, BYTE PTR _sB$17[ebp]
	mov	BYTE PTR _fB$15[ebp], cl

; 330  :                 }
; 331  :                 else

	jmp	$LN25@RenderLine
$LN16@RenderLine:

; 332  :                 {
; 333  :                     //Somewhere in the gradient range.
; 334  :                     if (sA == eA)

	movzx	edx, BYTE PTR _sA$20[ebp]
	movzx	eax, BYTE PTR _eA$12[ebp]
	cmp	edx, eax
	jne	SHORT $LN18@RenderLine

; 335  :                         fA = sA;

	mov	cl, BYTE PTR _sA$20[ebp]
	mov	BYTE PTR _fA$16[ebp], cl

; 336  :                     else

	jmp	SHORT $LN19@RenderLine
$LN18@RenderLine:

; 337  :                         fA = (BYTE)((double)(eA - sA) * RangeNormal) + sA;

	movzx	edx, BYTE PTR _eA$12[ebp]
	movzx	eax, BYTE PTR _sA$20[ebp]
	sub	edx, eax
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR _RangeNormal$1[ebp]
	cvttsd2si ecx, xmm0
	movzx	edx, cl
	movzx	eax, BYTE PTR _sA$20[ebp]
	add	edx, eax
	mov	BYTE PTR _fA$16[ebp], dl
$LN19@RenderLine:

; 338  :                     if (sR == eR)

	movzx	ecx, BYTE PTR _sR$19[ebp]
	movzx	edx, BYTE PTR _eR$11[ebp]
	cmp	ecx, edx
	jne	SHORT $LN20@RenderLine

; 339  :                         fR = sR;

	mov	al, BYTE PTR _sR$19[ebp]
	mov	BYTE PTR _fR$13[ebp], al

; 340  :                     else

	jmp	SHORT $LN21@RenderLine
$LN20@RenderLine:

; 341  :                         fR = (BYTE)((double)(eR - sR) * RangeNormal) + sR;

	movzx	ecx, BYTE PTR _eR$11[ebp]
	movzx	edx, BYTE PTR _sR$19[ebp]
	sub	ecx, edx
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR _RangeNormal$1[ebp]
	cvttsd2si eax, xmm0
	movzx	ecx, al
	movzx	edx, BYTE PTR _sR$19[ebp]
	add	ecx, edx
	mov	BYTE PTR _fR$13[ebp], cl
$LN21@RenderLine:

; 342  :                     if (sG == eG)

	movzx	eax, BYTE PTR _sG$18[ebp]
	movzx	ecx, BYTE PTR _eG$10[ebp]
	cmp	eax, ecx
	jne	SHORT $LN22@RenderLine

; 343  :                         fG = sG;

	mov	dl, BYTE PTR _sG$18[ebp]
	mov	BYTE PTR _fG$14[ebp], dl

; 344  :                     else

	jmp	SHORT $LN23@RenderLine
$LN22@RenderLine:

; 345  :                         fG = (BYTE)((double)(eG - sG) * RangeNormal) + sG;

	movzx	eax, BYTE PTR _eG$10[ebp]
	movzx	ecx, BYTE PTR _sG$18[ebp]
	sub	eax, ecx
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _RangeNormal$1[ebp]
	cvttsd2si edx, xmm0
	movzx	eax, dl
	movzx	ecx, BYTE PTR _sG$18[ebp]
	add	eax, ecx
	mov	BYTE PTR _fG$14[ebp], al
$LN23@RenderLine:

; 346  :                     if (sB == eB)

	movzx	edx, BYTE PTR _sB$17[ebp]
	movzx	eax, BYTE PTR _eB$9[ebp]
	cmp	edx, eax
	jne	SHORT $LN24@RenderLine

; 347  :                         fB = sB;

	mov	cl, BYTE PTR _sB$17[ebp]
	mov	BYTE PTR _fB$15[ebp], cl

; 348  :                     else

	jmp	SHORT $LN25@RenderLine
$LN24@RenderLine:

; 349  :                         fB = (BYTE)((double)(eB - sB) * RangeNormal) + sB;

	movzx	edx, BYTE PTR _eB$9[ebp]
	movzx	eax, BYTE PTR _sB$17[ebp]
	sub	edx, eax
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR _RangeNormal$1[ebp]
	cvttsd2si ecx, xmm0
	movzx	edx, cl
	movzx	eax, BYTE PTR _sB$17[ebp]
	add	edx, eax
	mov	BYTE PTR _fB$15[ebp], dl
$LN25@RenderLine:

; 350  :                 }
; 351  :             if (IgnoreAlpha)

	cmp	DWORD PTR _IgnoreAlpha$[ebp], 0
	je	SHORT $LN26@RenderLine

; 352  :                 fA = 0xff;

	mov	BYTE PTR _fA$16[ebp], 255		; 000000ffH
$LN26@RenderLine:

; 353  : 
; 354  :             Buffer[Index + 0] = fB;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _fB$15[ebp]
	mov	BYTE PTR [ecx], dl

; 355  :             Buffer[Index + 1] = fG;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _fG$14[ebp]
	mov	BYTE PTR [eax+1], cl

; 356  :             Buffer[Index + 2] = fR;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _fR$13[ebp]
	mov	BYTE PTR [edx+2], al

; 357  :             Buffer[Index + 3] = fA;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _fA$16[ebp]
	mov	BYTE PTR [ecx+3], dl

; 358  :         }

	jmp	$LN5@RenderLine
$LN6@RenderLine:

; 359  :     }

	jmp	$LN2@RenderLine
$LN3@RenderLine:

; 360  : 
; 361  :     return Success;

	xor	eax, eax
$LN1@RenderLine:

; 362  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_RenderLinearGradients@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\testimagerenderer.cpp
_TEXT	SEGMENT
_VNormal$1 = -44					; size = 8
_HNormal$2 = -36					; size = 8
_RowOffset$3 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Index$4 = -20						; size = 4
_Buffer$ = -16						; size = 4
_Row$5 = -12						; size = 4
_Column$6 = -8						; size = 4
_Final$7 = -4						; size = 4
_Destination$ = 8					; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_PackedStartColor$ = 24					; size = 4
_PackedEndColor$ = 28					; size = 4
_IgnoreAlpha$ = 32					; size = 4
_DoHorizontal$ = 36					; size = 4
_RenderRampingGradientColorRectangle@32 PROC

; 204  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 205  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@RenderRamp

; 206  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderRamp
$LN8@RenderRamp:

; 207  : 
; 208  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 209  :     BYTE *Buffer = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 210  : 
; 211  :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN4@RenderRamp
$LN2@RenderRamp:
	mov	ecx, DWORD PTR _Row$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$5[ebp], ecx
$LN4@RenderRamp:
	mov	edx, DWORD PTR _Row$5[ebp]
	cmp	edx, DWORD PTR _BufferHeight$[ebp]
	jge	$LN3@RenderRamp

; 212  :     {
; 213  :         int RowOffset = Row * BufferStride;

	mov	eax, DWORD PTR _Row$5[ebp]
	imul	eax, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], eax

; 214  :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$6[ebp], 0
	jmp	SHORT $LN7@RenderRamp
$LN5@RenderRamp:
	mov	ecx, DWORD PTR _Column$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$6[ebp], ecx
$LN7@RenderRamp:
	mov	edx, DWORD PTR _Column$6[ebp]
	cmp	edx, DWORD PTR _BufferWidth$[ebp]
	jge	$LN6@RenderRamp

; 215  :         {
; 216  :             int Index = RowOffset + (Column * PixelSize);

	mov	eax, DWORD PTR _Column$6[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 217  :             UINT32 Final = 0x0;

	mov	DWORD PTR _Final$7[ebp], 0

; 218  :             if (DoHorizontal)

	cmp	DWORD PTR _DoHorizontal$[ebp], 0
	je	SHORT $LN9@RenderRamp

; 219  :             {
; 220  :                 double HNormal = (double)(Column + 1) / (double)BufferWidth;

	mov	ecx, DWORD PTR _Column$6[ebp]
	add	ecx, 1
	cvtsi2sd xmm0, ecx
	cvtsi2sd xmm1, DWORD PTR _BufferWidth$[ebp]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _HNormal$2[ebp], xmm0

; 221  :                 ColorInterval(PackedStartColor, PackedEndColor, HNormal, IgnoreAlpha, &Final);

	lea	edx, DWORD PTR _Final$7[ebp]
	push	edx
	mov	eax, DWORD PTR _IgnoreAlpha$[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _HNormal$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _PackedEndColor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _PackedStartColor$[ebp]
	push	edx
	call	?ColorInterval@@YGXIINHPAI@Z		; ColorInterval

; 222  :             }
; 223  :             else

	jmp	SHORT $LN10@RenderRamp
$LN9@RenderRamp:

; 224  :             {
; 225  :                 double VNormal = (double)(Row + 1) / (double)BufferHeight;

	mov	eax, DWORD PTR _Row$5[ebp]
	add	eax, 1
	cvtsi2sd xmm0, eax
	cvtsi2sd xmm1, DWORD PTR _BufferHeight$[ebp]
	divsd	xmm0, xmm1
	movsd	QWORD PTR _VNormal$1[ebp], xmm0

; 226  :                 ColorInterval(PackedStartColor, PackedEndColor, VNormal, IgnoreAlpha, &Final);

	lea	ecx, DWORD PTR _Final$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _IgnoreAlpha$[ebp]
	push	edx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _VNormal$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _PackedEndColor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _PackedStartColor$[ebp]
	push	ecx
	call	?ColorInterval@@YGXIINHPAI@Z		; ColorInterval
$LN10@RenderRamp:

; 227  :             }
; 228  :             Buffer[Index + 3] = (Final & 0xff000000) >> 24;

	mov	edx, DWORD PTR _Final$7[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [eax+3], dl

; 229  :             Buffer[Index + 2] = (Final & 0x00ff0000) >> 16;

	mov	ecx, DWORD PTR _Final$7[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx+2], cl

; 230  :             Buffer[Index + 1] = (Final & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _Final$7[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx+1], al

; 231  :             Buffer[Index + 0] = (Final & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _Final$7[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [eax], dl

; 232  :         }

	jmp	$LN5@RenderRamp
$LN6@RenderRamp:

; 233  :     }

	jmp	$LN2@RenderRamp
$LN3@RenderRamp:

; 234  : 
; 235  :     return Success;

	xor	eax, eax
$LN1@RenderRamp:

; 236  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_RenderRampingGradientColorRectangle@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\testimagerenderer.cpp
_TEXT	SEGMENT
_Index$1 = -24						; size = 4
_Buffer$ = -20						; size = 4
_RowOffset$2 = -16					; size = 4
_PixelSize$ = -12					; size = 4
_Column$3 = -8						; size = 4
_Row$4 = -4						; size = 4
_Destination$ = 8					; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_BlockWidth$ = 24					; size = 4
_BlockHeight$ = 28					; size = 4
_Seed$ = 32						; size = 4
_RenderRandomSubBlockRectangle@28 PROC

; 122  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 123  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@RenderRand

; 124  :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@RenderRand
$LN8@RenderRand:

; 125  : 
; 126  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 127  :     BYTE *Buffer = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 128  :     srand(Seed);

	mov	ecx, DWORD PTR _Seed$[ebp]
	push	ecx
	call	DWORD PTR __imp__srand
	add	esp, 4

; 129  : 
; 130  :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@RenderRand
$LN2@RenderRand:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@RenderRand:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _BufferHeight$[ebp]
	jge	SHORT $LN3@RenderRand

; 131  :     {
; 132  :         int RowOffset = Row * BufferStride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 133  :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@RenderRand
$LN5@RenderRand:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@RenderRand:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _BufferWidth$[ebp]
	jge	SHORT $LN6@RenderRand

; 134  :         {
; 135  :             int Index = RowOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$1[ebp], ecx

; 136  : 
; 137  : 
; 138  :         }

	jmp	SHORT $LN5@RenderRand
$LN6@RenderRand:

; 139  :     }

	jmp	SHORT $LN2@RenderRand
$LN3@RenderRand:

; 140  : 
; 141  :     return Success;

	xor	eax, eax
$LN1@RenderRand:

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_RenderRandomSubBlockRectangle@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\testimagerenderer.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Index$4 = -12						; size = 4
_Buffer$ = -8						; size = 4
_RampingBlue$ = -4					; size = 1
_RampingGreen$ = -3					; size = 1
_RampingRed$ = -2					; size = 1
_RampingAlpha$ = -1					; size = 1
_Destination$ = 8					; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_RampAlpha$ = 24					; size = 4
_AlphaStart$ = 28					; size = 1
_AlphaIncrement$ = 32					; size = 1
_NonRampAlpha$ = 36					; size = 1
_RampRed$ = 40						; size = 4
_RedStart$ = 44						; size = 1
_RedIncrement$ = 48					; size = 1
_NonRampRed$ = 52					; size = 1
_RampGreen$ = 56					; size = 4
_GreenStart$ = 60					; size = 1
_GreenIncrement$ = 64					; size = 1
_NonRampGreen$ = 68					; size = 1
_RampBlue$ = 72						; size = 4
_BlueStart$ = 76					; size = 1
_BlueIncrement$ = 80					; size = 1
_NonRampBlue$ = 84					; size = 1
_RenderRampingColorRectangle@80 PROC

; 396  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 397  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@RenderRamp

; 398  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderRamp
$LN8@RenderRamp:

; 399  : 
; 400  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 401  :     BYTE *Buffer = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 402  :     BYTE RampingAlpha = AlphaStart;

	mov	cl, BYTE PTR _AlphaStart$[ebp]
	mov	BYTE PTR _RampingAlpha$[ebp], cl

; 403  :     BYTE RampingRed = RedStart;

	mov	dl, BYTE PTR _RedStart$[ebp]
	mov	BYTE PTR _RampingRed$[ebp], dl

; 404  :     BYTE RampingGreen = GreenStart;

	mov	al, BYTE PTR _GreenStart$[ebp]
	mov	BYTE PTR _RampingGreen$[ebp], al

; 405  :     BYTE RampingBlue = BlueStart;

	mov	cl, BYTE PTR _BlueStart$[ebp]
	mov	BYTE PTR _RampingBlue$[ebp], cl

; 406  : 
; 407  :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@RenderRamp
$LN2@RenderRamp:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@RenderRamp:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _BufferHeight$[ebp]
	jge	$LN3@RenderRamp

; 408  :     {
; 409  :         int RowOffset = Row * BufferStride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 410  :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@RenderRamp
$LN5@RenderRamp:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@RenderRamp:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _BufferWidth$[ebp]
	jge	$LN6@RenderRamp

; 411  :         {
; 412  :             int Index = RowOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 413  :             if (RampAlpha)

	cmp	DWORD PTR _RampAlpha$[ebp], 0
	je	SHORT $LN9@RenderRamp

; 414  :             {
; 415  :                 Buffer[Index + 3] = RampingAlpha;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _RampingAlpha$[ebp]
	mov	BYTE PTR [edx+3], al

; 416  :                 RampingAlpha += AlphaIncrement;

	movzx	ecx, BYTE PTR _AlphaIncrement$[ebp]
	movzx	edx, BYTE PTR _RampingAlpha$[ebp]
	add	edx, ecx
	mov	BYTE PTR _RampingAlpha$[ebp], dl

; 417  :             }
; 418  :             else

	jmp	SHORT $LN10@RenderRamp
$LN9@RenderRamp:

; 419  :             {
; 420  :                 Buffer[Index + 3] = NonRampAlpha;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _NonRampAlpha$[ebp]
	mov	BYTE PTR [eax+3], cl
$LN10@RenderRamp:

; 421  :             }
; 422  :             if (RampRed)

	cmp	DWORD PTR _RampRed$[ebp], 0
	je	SHORT $LN11@RenderRamp

; 423  :             {
; 424  :                 Buffer[Index + 2] = RampingRed;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _RampingRed$[ebp]
	mov	BYTE PTR [edx+2], al

; 425  :                 RampingRed += RedIncrement;

	movzx	ecx, BYTE PTR _RedIncrement$[ebp]
	movzx	edx, BYTE PTR _RampingRed$[ebp]
	add	edx, ecx
	mov	BYTE PTR _RampingRed$[ebp], dl

; 426  :             }
; 427  :             else

	jmp	SHORT $LN12@RenderRamp
$LN11@RenderRamp:

; 428  :             {
; 429  :                 Buffer[Index + 2] = NonRampRed;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _NonRampRed$[ebp]
	mov	BYTE PTR [eax+2], cl
$LN12@RenderRamp:

; 430  :             }
; 431  :             if (RampGreen)

	cmp	DWORD PTR _RampGreen$[ebp], 0
	je	SHORT $LN13@RenderRamp

; 432  :             {
; 433  :                 Buffer[Index + 1] = RampingGreen;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _RampingGreen$[ebp]
	mov	BYTE PTR [edx+1], al

; 434  :                 RampingGreen += GreenIncrement;

	movzx	ecx, BYTE PTR _GreenIncrement$[ebp]
	movzx	edx, BYTE PTR _RampingGreen$[ebp]
	add	edx, ecx
	mov	BYTE PTR _RampingGreen$[ebp], dl

; 435  :             }
; 436  :             else

	jmp	SHORT $LN14@RenderRamp
$LN13@RenderRamp:

; 437  :             {
; 438  :                 Buffer[Index + 1] = NonRampGreen;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _NonRampGreen$[ebp]
	mov	BYTE PTR [eax+1], cl
$LN14@RenderRamp:

; 439  :             }
; 440  :             if (RampBlue)

	cmp	DWORD PTR _RampBlue$[ebp], 0
	je	SHORT $LN15@RenderRamp

; 441  :             {
; 442  :                 Buffer[Index + 0] = RampingBlue;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _RampingBlue$[ebp]
	mov	BYTE PTR [edx], al

; 443  :                 RampingBlue += BlueIncrement;

	movzx	ecx, BYTE PTR _BlueIncrement$[ebp]
	movzx	edx, BYTE PTR _RampingBlue$[ebp]
	add	edx, ecx
	mov	BYTE PTR _RampingBlue$[ebp], dl

; 444  :             }
; 445  :             else

	jmp	SHORT $LN16@RenderRamp
$LN15@RenderRamp:

; 446  :             {
; 447  :                 Buffer[Index + 0] = NonRampBlue;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _NonRampBlue$[ebp]
	mov	BYTE PTR [eax], cl
$LN16@RenderRamp:

; 448  :             }
; 449  :         }

	jmp	$LN5@RenderRamp
$LN6@RenderRamp:

; 450  :     }

	jmp	$LN2@RenderRamp
$LN3@RenderRamp:

; 451  : 
; 452  :     return Success;

	xor	eax, eax
$LN1@RenderRamp:

; 453  : }

	mov	esp, ebp
	pop	ebp
	ret	80					; 00000050H
_RenderRampingColorRectangle@80 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\testimagerenderer.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Index$2 = -20						; size = 4
_Buffer$ = -16						; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_BRand$5 = -4						; size = 1
_GRand$6 = -3						; size = 1
_RRand$7 = -2						; size = 1
_ARand$8 = -1						; size = 1
_Destination$ = 8					; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_LowAlpha$ = 24						; size = 1
_HighAlpha$ = 28					; size = 1
_LowRed$ = 32						; size = 1
_HighRed$ = 36						; size = 1
_LowGreen$ = 40						; size = 1
_HighGreen$ = 44					; size = 1
_LowBlue$ = 48						; size = 1
_HighBlue$ = 52						; size = 1
_Seed$ = 56						; size = 4
_RenderRandomColorRectangle@52 PROC

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 82   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@RenderRand

; 83   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderRand
$LN8@RenderRand:

; 84   : 
; 85   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 86   :     BYTE *Buffer = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 87   :     srand(Seed);

	mov	ecx, DWORD PTR _Seed$[ebp]
	push	ecx
	call	DWORD PTR __imp__srand
	add	esp, 4

; 88   : 
; 89   :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@RenderRand
$LN2@RenderRand:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@RenderRand:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _BufferHeight$[ebp]
	jge	$LN3@RenderRand

; 90   :     {
; 91   :         int RowOffset = Row * BufferStride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 92   :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@RenderRand
$LN5@RenderRand:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@RenderRand:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _BufferWidth$[ebp]
	jge	$LN6@RenderRand

; 93   :         {
; 94   :             int Index = RowOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], ecx

; 95   :             BYTE ARand = rrand2(LowAlpha, HighAlpha);

	movzx	edx, BYTE PTR _HighAlpha$[ebp]
	push	edx
	movzx	eax, BYTE PTR _LowAlpha$[ebp]
	push	eax
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	BYTE PTR _ARand$8[ebp], al

; 96   :             BYTE RRand = rrand2(LowRed, HighRed);

	movzx	ecx, BYTE PTR _HighRed$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _LowRed$[ebp]
	push	edx
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	BYTE PTR _RRand$7[ebp], al

; 97   :             BYTE GRand = rrand2(LowGreen, HighGreen);

	movzx	eax, BYTE PTR _HighGreen$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _LowGreen$[ebp]
	push	ecx
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	BYTE PTR _GRand$6[ebp], al

; 98   :             BYTE BRand = rrand2(LowBlue, HighBlue);

	movzx	edx, BYTE PTR _HighBlue$[ebp]
	push	edx
	movzx	eax, BYTE PTR _LowBlue$[ebp]
	push	eax
	call	?rrand2@@YGHHH@Z			; rrand2
	mov	BYTE PTR _BRand$5[ebp], al

; 99   :             Buffer[Index + 3] = ARand;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	mov	dl, BYTE PTR _ARand$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 100  :             Buffer[Index + 2] = RRand;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	cl, BYTE PTR _RRand$7[ebp]
	mov	BYTE PTR [eax+2], cl

; 101  :             Buffer[Index + 1] = GRand;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR _GRand$6[ebp]
	mov	BYTE PTR [edx+1], al

; 102  :             Buffer[Index + 0] = BRand;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	mov	dl, BYTE PTR _BRand$5[ebp]
	mov	BYTE PTR [ecx], dl

; 103  :         }

	jmp	$LN5@RenderRand
$LN6@RenderRand:

; 104  :     }

	jmp	$LN2@RenderRand
$LN3@RenderRand:

; 105  : 
; 106  :     return Success;

	xor	eax, eax
$LN1@RenderRand:

; 107  : }

	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
_RenderRandomColorRectangle@52 ENDP
_TEXT	ENDS
END
