; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Compositor.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Compositor@24
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@406fe00000000000
EXTRN	__fltused:DWORD
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\compositor.cpp
_TEXT	SEGMENT
_InvertedAlpha$1 = -72					; size = 8
_FAlpha$2 = -64						; size = 8
_PlaneOffset$3 = -56					; size = 4
_BufferRowOffset$4 = -52				; size = 4
_PixelSize$ = -48					; size = 4
_PlaneIndex$5 = -44					; size = 4
_PlaneBuffer$6 = -40					; size = 4
_BufferIndex$7 = -36					; size = 4
_Buffer$ = -32						; size = 4
_Column$8 = -28						; size = 4
_Row$9 = -24						; size = 4
_Objects$ = -20						; size = 4
_ObjectIndex$10 = -16					; size = 4
_FinalRed$11 = -10					; size = 1
_FinalGreen$12 = -9					; size = 1
_FinalBlue$13 = -8					; size = 1
_BGRed$14 = -7						; size = 1
_FGRed$15 = -6						; size = 1
_BGGreen$16 = -5					; size = 1
_FGGreen$17 = -4					; size = 1
_BGBlue$18 = -3						; size = 1
_FGBlue$19 = -2						; size = 1
_FGAlpha$20 = -1					; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_CommonObjectSet$ = 24					; size = 4
_ObjectCount$ = 28					; size = 4
_Compositor@24 PROC

; 20   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 21   :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN11@Compositor

; 22   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@Compositor
$LN11@Compositor:

; 23   :     if (CommonObjectSet == NULL)

	cmp	DWORD PTR _CommonObjectSet$[ebp], 0
	jne	SHORT $LN12@Compositor

; 24   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@Compositor
$LN12@Compositor:

; 25   :     if (ObjectCount < 1)

	cmp	DWORD PTR _ObjectCount$[ebp], 1
	jge	SHORT $LN13@Compositor

; 26   :         return Error;

	mov	eax, 1
	jmp	$LN1@Compositor
$LN13@Compositor:

; 27   : 
; 28   :     BYTE* Buffer = (BYTE*)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 29   :     CommonObject *Objects = (CommonObject *)CommonObjectSet;

	mov	ecx, DWORD PTR _CommonObjectSet$[ebp]
	mov	DWORD PTR _Objects$[ebp], ecx

; 30   :     __int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 31   : 
; 32   :     for (int ObjectIndex = 0; ObjectIndex < ObjectCount; ObjectIndex++)

	mov	DWORD PTR _ObjectIndex$10[ebp], 0
	jmp	SHORT $LN4@Compositor
$LN2@Compositor:
	mov	edx, DWORD PTR _ObjectIndex$10[ebp]
	add	edx, 1
	mov	DWORD PTR _ObjectIndex$10[ebp], edx
$LN4@Compositor:
	mov	eax, DWORD PTR _ObjectIndex$10[ebp]
	cmp	eax, DWORD PTR _ObjectCount$[ebp]
	jge	$LN3@Compositor

; 33   :     {
; 34   :         //Get a pointer to the plane's bits.
; 35   :         BYTE *PlaneBuffer = (BYTE *)Objects[ObjectIndex].ObjectBuffer;

	imul	ecx, DWORD PTR _ObjectIndex$10[ebp], 36
	mov	edx, DWORD PTR _Objects$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _PlaneBuffer$6[ebp], eax

; 36   : 
; 37   :         for (int Row = 0; Row < Objects[ObjectIndex].ObjectHeight; Row++)

	mov	DWORD PTR _Row$9[ebp], 0
	jmp	SHORT $LN7@Compositor
$LN5@Compositor:
	mov	ecx, DWORD PTR _Row$9[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$9[ebp], ecx
$LN7@Compositor:
	imul	edx, DWORD PTR _ObjectIndex$10[ebp], 36
	mov	eax, DWORD PTR _Objects$[ebp]
	mov	ecx, DWORD PTR _Row$9[ebp]
	cmp	ecx, DWORD PTR [eax+edx+12]
	jge	$LN6@Compositor

; 38   :         {
; 39   :             if (Row + Objects[ObjectIndex].Top < 0)

	imul	edx, DWORD PTR _ObjectIndex$10[ebp], 36
	mov	eax, DWORD PTR _Objects$[ebp]
	mov	ecx, DWORD PTR _Row$9[ebp]
	add	ecx, DWORD PTR [eax+edx+24]
	jns	SHORT $LN14@Compositor

; 40   :                 continue;

	jmp	SHORT $LN5@Compositor
$LN14@Compositor:

; 41   :             if (Row + Objects[ObjectIndex].Top > TargetHeight - 1)

	imul	edx, DWORD PTR _ObjectIndex$10[ebp], 36
	mov	eax, DWORD PTR _Objects$[ebp]
	mov	ecx, DWORD PTR _Row$9[ebp]
	add	ecx, DWORD PTR [eax+edx+24]
	mov	edx, DWORD PTR _TargetHeight$[ebp]
	sub	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN15@Compositor

; 42   :                 continue;

	jmp	SHORT $LN5@Compositor
$LN15@Compositor:

; 43   : 
; 44   :             UINT32 BufferRowOffset = (Row + Objects[ObjectIndex].Top) * TargetStride;

	imul	eax, DWORD PTR _ObjectIndex$10[ebp], 36
	mov	ecx, DWORD PTR _Objects$[ebp]
	mov	edx, DWORD PTR _Row$9[ebp]
	add	edx, DWORD PTR [ecx+eax+24]
	imul	edx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _BufferRowOffset$4[ebp], edx

; 45   :             UINT32 PlaneOffset = (Row * Objects[ObjectIndex].ObjectStride);

	imul	eax, DWORD PTR _ObjectIndex$10[ebp], 36
	mov	ecx, DWORD PTR _Objects$[ebp]
	mov	edx, DWORD PTR _Row$9[ebp]
	imul	edx, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR _PlaneOffset$3[ebp], edx

; 46   :             for (int Column = 0; Column < Objects[ObjectIndex].ObjectWidth; Column++)

	mov	DWORD PTR _Column$8[ebp], 0
	jmp	SHORT $LN10@Compositor
$LN8@Compositor:
	mov	eax, DWORD PTR _Column$8[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$8[ebp], eax
$LN10@Compositor:
	imul	ecx, DWORD PTR _ObjectIndex$10[ebp], 36
	mov	edx, DWORD PTR _Objects$[ebp]
	mov	eax, DWORD PTR _Column$8[ebp]
	cmp	eax, DWORD PTR [edx+ecx+8]
	jge	$LN9@Compositor

; 47   :             {
; 48   :                 if (Column + Objects[ObjectIndex].Left > TargetWidth - 1)

	imul	ecx, DWORD PTR _ObjectIndex$10[ebp], 36
	mov	edx, DWORD PTR _Objects$[ebp]
	mov	eax, DWORD PTR _Column$8[ebp]
	add	eax, DWORD PTR [edx+ecx+20]
	mov	ecx, DWORD PTR _TargetWidth$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN16@Compositor

; 49   :                     continue;

	jmp	SHORT $LN8@Compositor
$LN16@Compositor:

; 50   :                 if (Column + Objects[ObjectIndex].Left < 0)

	imul	edx, DWORD PTR _ObjectIndex$10[ebp], 36
	mov	eax, DWORD PTR _Objects$[ebp]
	mov	ecx, DWORD PTR _Column$8[ebp]
	add	ecx, DWORD PTR [eax+edx+20]
	jns	SHORT $LN17@Compositor

; 51   :                     continue;

	jmp	SHORT $LN8@Compositor
$LN17@Compositor:

; 52   : 
; 53   :                 UINT32 BufferIndex = BufferRowOffset + ((Column + Objects[ObjectIndex].Left) * PixelSize);

	imul	edx, DWORD PTR _ObjectIndex$10[ebp], 36
	mov	eax, DWORD PTR _Objects$[ebp]
	mov	ecx, DWORD PTR _Column$8[ebp]
	add	ecx, DWORD PTR [eax+edx+20]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _BufferRowOffset$4[ebp]
	mov	DWORD PTR _BufferIndex$7[ebp], ecx

; 54   :                 UINT32 PlaneIndex = PlaneOffset + (Column * PixelSize);

	mov	edx, DWORD PTR _Column$8[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _PlaneOffset$3[ebp]
	mov	DWORD PTR _PlaneIndex$5[ebp], edx

; 55   : 
; 56   :                 BYTE FGBlue = PlaneBuffer[PlaneIndex + 0];

	mov	eax, DWORD PTR _PlaneBuffer$6[ebp]
	add	eax, DWORD PTR _PlaneIndex$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _FGBlue$19[ebp], cl

; 57   :                 BYTE FGGreen = PlaneBuffer[PlaneIndex + 1];

	mov	edx, DWORD PTR _PlaneBuffer$6[ebp]
	add	edx, DWORD PTR _PlaneIndex$5[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _FGGreen$17[ebp], al

; 58   :                 BYTE FGRed = PlaneBuffer[PlaneIndex + 2];

	mov	ecx, DWORD PTR _PlaneBuffer$6[ebp]
	add	ecx, DWORD PTR _PlaneIndex$5[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _FGRed$15[ebp], dl

; 59   :                 BYTE FGAlpha = PlaneBuffer[PlaneIndex + 3];

	mov	eax, DWORD PTR _PlaneBuffer$6[ebp]
	add	eax, DWORD PTR _PlaneIndex$5[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR _FGAlpha$20[ebp], cl

; 60   :                 //If there's nothing to draw skip calculations and buffer assignment and move to the next pixel.
; 61   :                 if (FGAlpha == 0x0)

	movzx	edx, BYTE PTR _FGAlpha$20[ebp]
	test	edx, edx
	jne	SHORT $LN18@Compositor

; 62   :                     continue;

	jmp	$LN8@Compositor
$LN18@Compositor:

; 63   :                 BYTE BGBlue = Buffer[BufferIndex + 0];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _BufferIndex$7[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _BGBlue$18[ebp], cl

; 64   :                 BYTE BGGreen = Buffer[BufferIndex + 1];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _BufferIndex$7[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _BGGreen$16[ebp], al

; 65   :                 BYTE BGRed = Buffer[BufferIndex + 2];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _BufferIndex$7[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _BGRed$14[ebp], dl

; 66   :                 //BYTE BGAlpha = Buffer[BufferIndex + 3];
; 67   :                 double FAlpha = (double)FGAlpha / 255.0;

	movzx	eax, BYTE PTR _FGAlpha$20[ebp]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _FAlpha$2[ebp], xmm0

; 68   :                 double InvertedAlpha = 1.0 - FAlpha;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _FAlpha$2[ebp]
	movsd	QWORD PTR _InvertedAlpha$1[ebp], xmm0

; 69   :                 BYTE FinalBlue = (BYTE)(FAlpha * FGBlue) + (BYTE)(InvertedAlpha * BGBlue);

	movzx	ecx, BYTE PTR _FGBlue$19[ebp]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR _FAlpha$2[ebp]
	cvttsd2si edx, xmm0
	movzx	eax, dl
	movzx	ecx, BYTE PTR _BGBlue$18[ebp]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR _InvertedAlpha$1[ebp]
	cvttsd2si edx, xmm0
	movzx	ecx, dl
	add	eax, ecx
	mov	BYTE PTR _FinalBlue$13[ebp], al

; 70   :                 BYTE FinalGreen = (BYTE)(FAlpha * FGGreen) + (BYTE)(InvertedAlpha * BGGreen);

	movzx	edx, BYTE PTR _FGGreen$17[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR _FAlpha$2[ebp]
	cvttsd2si eax, xmm0
	movzx	ecx, al
	movzx	edx, BYTE PTR _BGGreen$16[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR _InvertedAlpha$1[ebp]
	cvttsd2si eax, xmm0
	movzx	edx, al
	add	ecx, edx
	mov	BYTE PTR _FinalGreen$12[ebp], cl

; 71   :                 BYTE FinalRed = (BYTE)(FAlpha * FGRed) + (BYTE)(InvertedAlpha * BGRed);

	movzx	eax, BYTE PTR _FGRed$15[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _FAlpha$2[ebp]
	cvttsd2si ecx, xmm0
	movzx	edx, cl
	movzx	eax, BYTE PTR _BGRed$14[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _InvertedAlpha$1[ebp]
	cvttsd2si ecx, xmm0
	movzx	eax, cl
	add	edx, eax
	mov	BYTE PTR _FinalRed$11[ebp], dl

; 72   :                 Buffer[BufferIndex + 0] = FinalBlue;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _BufferIndex$7[ebp]
	mov	dl, BYTE PTR _FinalBlue$13[ebp]
	mov	BYTE PTR [ecx], dl

; 73   :                 Buffer[BufferIndex + 1] = FinalGreen;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _BufferIndex$7[ebp]
	mov	cl, BYTE PTR _FinalGreen$12[ebp]
	mov	BYTE PTR [eax+1], cl

; 74   :                 Buffer[BufferIndex + 2] = FinalRed;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _BufferIndex$7[ebp]
	mov	al, BYTE PTR _FinalRed$11[ebp]
	mov	BYTE PTR [edx+2], al

; 75   :                 Buffer[BufferIndex + 3] = 0xff;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _BufferIndex$7[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH

; 76   :             }

	jmp	$LN8@Compositor
$LN9@Compositor:

; 77   :         }

	jmp	$LN5@Compositor
$LN6@Compositor:

; 78   :     }

	jmp	$LN2@Compositor
$LN3@Compositor:

; 79   : 
; 80   :     return Success;

	xor	eax, eax
$LN1@Compositor:

; 81   : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_Compositor@24 ENDP
_TEXT	ENDS
END
