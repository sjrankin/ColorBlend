; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\ColorBlender.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG111407 DB	'`', 00H
CONST	ENDS
PUBLIC	_ColorLuminance@12
PUBLIC	?Distance@@YGNHHHH@Z				; Distance
PUBLIC	?PixelLuminance@@YGNEEE@Z			; PixelLuminance
PUBLIC	?PixelLuminanceSc@@YGNNNN@Z			; PixelLuminanceSc
PUBLIC	_PixelChannelRollingLogicalOperation@36
PUBLIC	_ApplyChannelMasks2@56
PUBLIC	_ApplyChannelMasks@44
PUBLIC	_BlendColors@28
PUBLIC	_MergePlanes@24
PUBLIC	_MergePlanes2@24
PUBLIC	_MergePlanes3@24
PUBLIC	_MergePlanes4@28
PUBLIC	_SetAlpha@20
PUBLIC	_SetAlphaByBrightness@24
PUBLIC	_BufferInverter4@68
PUBLIC	_BufferInverter3@24
PUBLIC	_BufferInverter2@52
PUBLIC	_BufferInverter@40
PUBLIC	_CropBuffer@36
PUBLIC	_CropBuffer2@36
PUBLIC	_CopyBufferRegion@36
PUBLIC	_CreateBitMask@36
PUBLIC	_CreateMask@44
PUBLIC	_CreateMaskFromLuminance@48
PUBLIC	_CreateAlphaMaskFromLuminance@36
PUBLIC	_ClearBuffer@80
PUBLIC	_FillBufferWithBuffer@36
PUBLIC	_CopySubRegion@40
PUBLIC	?ColorPointIndex@@YGHHHPAUAbsolutePointStruct@@H@Z ; ColorPointIndex
PUBLIC	?ColorPercent2@@YGXNEEEEPAE000NN_N@Z		; ColorPercent2
PUBLIC	?InRange@@YGHHHHHN@Z				; InRange
PUBLIC	?AlphaBlend@@YGXXZ				; AlphaBlend
PUBLIC	?MakeColor2@@YGXHHHHHPAUPureColorType@@PAE111@Z	; MakeColor2
PUBLIC	?ColorPointIndex2@@YGHHHPAUPureColorType@@H@Z	; ColorPointIndex2
PUBLIC	?DrawPointIndicator@@YGXPAEHHHHPAUPureColorType@@@Z ; DrawPointIndicator
PUBLIC	?BlendColors2@@YG_NPAXHHHH0@Z			; BlendColors2
PUBLIC	?MakeDotIndices@@YGHHHHHHHHPAUAbsolutePointStruct@@H@Z ; MakeDotIndices
PUBLIC	?PointInPlane@@YGHHHPAUPlaneSetStruct@@@Z	; PointInPlane
PUBLIC	?ProcessInitialize@@YGXXZ			; ProcessInitialize
PUBLIC	_DllMain@12
PUBLIC	__real@3fb27bb2fec56d5d
PUBLIC	__real@3fcb367a0f9096bc
PUBLIC	__real@3fe6e2eb1c432ca5
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp___errno:PROC
EXTRN	_memmove:PROC
EXTRN	?MakeColor@@YGXHHHHNHPAUPureColorStruct@@PAUAbsolutePointStruct@@PAE22@Z:PROC ; MakeColor
EXTRN	_InitializeErrorStack@4:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	__fltused:DWORD
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe6e2eb1c432ca5
CONST	SEGMENT
__real@3fe6e2eb1c432ca5 DQ 03fe6e2eb1c432ca5r	; 0.7152
CONST	ENDS
;	COMDAT __real@3fcb367a0f9096bc
CONST	SEGMENT
__real@3fcb367a0f9096bc DQ 03fcb367a0f9096bcr	; 0.2126
CONST	ENDS
;	COMDAT __real@3fb27bb2fec56d5d
CONST	SEGMENT
__real@3fb27bb2fec56d5d DQ 03fb27bb2fec56d5dr	; 0.0722
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
tv64 = -4						; size = 4
_DLLHandle$ = 8						; size = 4
_Reason$ = 12						; size = 4
_NotUsed$ = 16						; size = 4
_DllMain@12 PROC

; 2167 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2168 :     switch (Reason)

	mov	eax, DWORD PTR _Reason$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 1
	je	SHORT $LN4@DllMain
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN5@DllMain
	jmp	SHORT $LN2@DllMain
$LN4@DllMain:

; 2169 :     {
; 2170 :         case DLL_PROCESS_ATTACH:
; 2171 :             //Initialize for each new attached process.
; 2172 :             ProcessInitialize();

	call	?ProcessInitialize@@YGXXZ		; ProcessInitialize

; 2173 :             break;

	jmp	SHORT $LN2@DllMain
$LN5@DllMain:

; 2174 : 
; 2175 :         case DLL_THREAD_ATTACH:
; 2176 :             //Initialize for each new attached thread.
; 2177 :             ProcessInitialize();

	call	?ProcessInitialize@@YGXXZ		; ProcessInitialize
$LN2@DllMain:

; 2178 :             break;
; 2179 : 
; 2180 :         case DLL_THREAD_DETACH:
; 2181 :             //Thread-specific clean-up.
; 2182 :             break;
; 2183 : 
; 2184 :         case DLL_PROCESS_DETACH:
; 2185 :             //Process-specific clean-up.
; 2186 :             break;
; 2187 :     }
; 2188 : 
; 2189 :     return TRUE;

	mov	eax, 1

; 2190 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
?ProcessInitialize@@YGXXZ PROC				; ProcessInitialize

; 2161 : {

	push	ebp
	mov	ebp, esp

; 2162 :     InitializeErrorStack("`");

	push	OFFSET $SG111407
	call	_InitializeErrorStack@4

; 2163 : }

	pop	ebp
	ret	0
?ProcessInitialize@@YGXXZ ENDP				; ProcessInitialize
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Plane$ = 16						; size = 4
?PointInPlane@@YGHHHPAUPlaneSetStruct@@@Z PROC		; PointInPlane

; 590  : {

	push	ebp
	mov	ebp, esp

; 591  :     if (Plane == NULL)

	cmp	DWORD PTR _Plane$[ebp], 0
	jne	SHORT $LN2@PointInPla

; 592  :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@PointInPla
$LN2@PointInPla:

; 593  :     if ((X<Plane->Left) || (X>Plane->Right))

	mov	eax, DWORD PTR _Plane$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jl	SHORT $LN4@PointInPla
	mov	edx, DWORD PTR _Plane$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	cmp	eax, DWORD PTR [edx+36]
	jle	SHORT $LN3@PointInPla
$LN4@PointInPla:

; 594  :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@PointInPla
$LN3@PointInPla:

; 595  :     if ((Y<Plane->Top) || (Y>Plane->Bottom))

	mov	ecx, DWORD PTR _Plane$[ebp]
	mov	edx, DWORD PTR _Y$[ebp]
	cmp	edx, DWORD PTR [ecx+32]
	jl	SHORT $LN6@PointInPla
	mov	eax, DWORD PTR _Plane$[ebp]
	mov	ecx, DWORD PTR _Y$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	jle	SHORT $LN5@PointInPla
$LN6@PointInPla:

; 596  :         return FALSE;

	xor	eax, eax
	jmp	SHORT $LN1@PointInPla
$LN5@PointInPla:

; 597  :     return TRUE;

	mov	eax, 1
$LN1@PointInPla:

; 598  : }

	pop	ebp
	ret	12					; 0000000cH
?PointInPlane@@YGHHHPAUPlaneSetStruct@@@Z ENDP		; PointInPlane
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Index$ = -12						; size = 4
_Y$1 = -8						; size = 4
_X$2 = -4						; size = 4
_Left$ = 8						; size = 4
_Top$ = 12						; size = 4
_Right$ = 16						; size = 4
_Bottom$ = 20						; size = 4
_Width$ = 24						; size = 4
_Height$ = 28						; size = 4
_Stride$ = 32						; size = 4
_PointList$ = 36					; size = 4
_DotCount$ = 40						; size = 4
?MakeDotIndices@@YGHHHHHHHHPAUAbsolutePointStruct@@H@Z PROC ; MakeDotIndices

; 557  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 558  :     if (PointList == NULL)

	cmp	DWORD PTR _PointList$[ebp], 0
	jne	SHORT $LN8@MakeDotInd

; 559  :         return 0;

	xor	eax, eax
	jmp	$LN1@MakeDotInd
$LN8@MakeDotInd:

; 560  : 
; 561  :     int Index = 0;

	mov	DWORD PTR _Index$[ebp], 0

; 562  :     for (int Y = Top; Y <= Bottom; Y++)

	mov	eax, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Y$1[ebp], eax
	jmp	SHORT $LN4@MakeDotInd
$LN2@MakeDotInd:
	mov	ecx, DWORD PTR _Y$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _Y$1[ebp], ecx
$LN4@MakeDotInd:
	mov	edx, DWORD PTR _Y$1[ebp]
	cmp	edx, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN3@MakeDotInd

; 563  :     {
; 564  :         if (Y < 0)

	cmp	DWORD PTR _Y$1[ebp], 0
	jge	SHORT $LN9@MakeDotInd

; 565  :             continue;

	jmp	SHORT $LN2@MakeDotInd
$LN9@MakeDotInd:

; 566  :         if (Y >= Height)

	mov	eax, DWORD PTR _Y$1[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jl	SHORT $LN10@MakeDotInd

; 567  :             continue;

	jmp	SHORT $LN2@MakeDotInd
$LN10@MakeDotInd:

; 568  :         for (int X = Left; X <= Right; X++)

	mov	ecx, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _X$2[ebp], ecx
	jmp	SHORT $LN7@MakeDotInd
$LN5@MakeDotInd:
	mov	edx, DWORD PTR _X$2[ebp]
	add	edx, 1
	mov	DWORD PTR _X$2[ebp], edx
$LN7@MakeDotInd:
	mov	eax, DWORD PTR _X$2[ebp]
	cmp	eax, DWORD PTR _Right$[ebp]
	jg	SHORT $LN6@MakeDotInd

; 569  :         {
; 570  :             if (X < 0)

	cmp	DWORD PTR _X$2[ebp], 0
	jge	SHORT $LN11@MakeDotInd

; 571  :                 continue;

	jmp	SHORT $LN5@MakeDotInd
$LN11@MakeDotInd:

; 572  :             if (X >= Width)

	mov	ecx, DWORD PTR _X$2[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jl	SHORT $LN12@MakeDotInd

; 573  :                 continue;

	jmp	SHORT $LN5@MakeDotInd
$LN12@MakeDotInd:

; 574  :             PointList[Index].X = X;

	mov	edx, DWORD PTR _Index$[ebp]
	mov	eax, DWORD PTR _PointList$[ebp]
	mov	ecx, DWORD PTR _X$2[ebp]
	mov	DWORD PTR [eax+edx*8], ecx

; 575  :             PointList[Index].Y = Y;

	mov	edx, DWORD PTR _Index$[ebp]
	mov	eax, DWORD PTR _PointList$[ebp]
	mov	ecx, DWORD PTR _Y$1[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 576  :             Index++;

	mov	edx, DWORD PTR _Index$[ebp]
	add	edx, 1
	mov	DWORD PTR _Index$[ebp], edx

; 577  :         }

	jmp	SHORT $LN5@MakeDotInd
$LN6@MakeDotInd:

; 578  :     }

	jmp	SHORT $LN2@MakeDotInd
$LN3@MakeDotInd:

; 579  :     return Index;

	mov	eax, DWORD PTR _Index$[ebp]
$LN1@MakeDotInd:

; 580  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?MakeDotIndices@@YGHHHHHHHHPAUAbsolutePointStruct@@H@Z ENDP ; MakeDotIndices
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_ColorSet$ = -36					; size = 4
_MaxValidIndex$ = -32					; size = 4
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Buffer$ = -20						; size = 4
_Index$2 = -16						; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_iA$5 = -4						; size = 1
_iR$6 = -3						; size = 1
_iG$7 = -2						; size = 1
_iB$8 = -1						; size = 1
_Target$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_PureColorCount$ = 24					; size = 4
_PureColors$ = 28					; size = 4
?BlendColors2@@YG_NPAXHHHH0@Z PROC			; BlendColors2

; 491  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 492  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@BlendColor

; 493  :         return FALSE;

	xor	al, al
	jmp	$LN1@BlendColor
$LN8@BlendColor:

; 494  :     if (PureColors == NULL)

	cmp	DWORD PTR _PureColors$[ebp], 0
	jne	SHORT $LN9@BlendColor

; 495  :         return FALSE;

	xor	al, al
	jmp	$LN1@BlendColor
$LN9@BlendColor:

; 496  :     if (PureColorCount < 1)

	cmp	DWORD PTR _PureColorCount$[ebp], 1
	jge	SHORT $LN10@BlendColor

; 497  :         return FALSE;

	xor	al, al
	jmp	$LN1@BlendColor
$LN10@BlendColor:

; 498  : 
; 499  :     __int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 500  :     BYTE* Buffer = (BYTE*)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 501  :     PureColorType* ColorSet = (PureColorType*)PureColors;

	mov	ecx, DWORD PTR _PureColors$[ebp]
	mov	DWORD PTR _ColorSet$[ebp], ecx

; 502  :     UINT32 MaxValidIndex = ((Width * Stride) * Height) - 1;

	mov	edx, DWORD PTR _Width$[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	imul	edx, DWORD PTR _Height$[ebp]
	sub	edx, 1
	mov	DWORD PTR _MaxValidIndex$[ebp], edx

; 503  : 
; 504  :     for (__int32 Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@BlendColor
$LN2@BlendColor:
	mov	eax, DWORD PTR _Row$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$4[ebp], eax
$LN4@BlendColor:
	mov	ecx, DWORD PTR _Row$4[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN3@BlendColor

; 505  :     {
; 506  :         __int32 RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$4[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 507  :         for (__int32 Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@BlendColor
$LN5@BlendColor:
	mov	eax, DWORD PTR _Column$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$3[ebp], eax
$LN7@BlendColor:
	mov	ecx, DWORD PTR _Column$3[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	$LN6@BlendColor

; 508  :         {
; 509  :             __int32 Index = RowOffset + (Column * PixelSize);

	mov	edx, DWORD PTR _Column$3[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], edx

; 510  :             if ((UINT32)(Index + 3) > MaxValidIndex)

	mov	eax, DWORD PTR _Index$2[ebp]
	add	eax, 3
	cmp	eax, DWORD PTR _MaxValidIndex$[ebp]
	jbe	SHORT $LN11@BlendColor

; 511  :                 return FALSE;

	xor	al, al
	jmp	SHORT $LN1@BlendColor
$LN11@BlendColor:

; 512  :             byte iR = 0;

	mov	BYTE PTR _iR$6[ebp], 0

; 513  :             byte iG = 0;

	mov	BYTE PTR _iG$7[ebp], 0

; 514  :             byte iB = 0;

	mov	BYTE PTR _iB$8[ebp], 0

; 515  :             byte iA = 0xff;

	mov	BYTE PTR _iA$5[ebp], 255		; 000000ffH

; 516  :             MakeColor2(Column, Row, Width, Height, PureColorCount, ColorSet, &iA, &iR, &iG, &iB);

	lea	ecx, DWORD PTR _iB$8[ebp]
	push	ecx
	lea	edx, DWORD PTR _iG$7[ebp]
	push	edx
	lea	eax, DWORD PTR _iR$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _iA$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _ColorSet$[ebp]
	push	edx
	mov	eax, DWORD PTR _PureColorCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Row$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _Column$3[ebp]
	push	ecx
	call	?MakeColor2@@YGXHHHHHPAUPureColorType@@PAE111@Z ; MakeColor2

; 517  : 
; 518  :             //            SetPixel (Buffer, Index, iA, iR, iG, iB);
; 519  : 
; 520  :             Buffer[Index + 0] = iB;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR _iB$8[ebp]
	mov	BYTE PTR [edx], al

; 521  :             Buffer[Index + 1] = iG;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	mov	dl, BYTE PTR _iG$7[ebp]
	mov	BYTE PTR [ecx+1], dl

; 522  :             Buffer[Index + 2] = iR;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	cl, BYTE PTR _iR$6[ebp]
	mov	BYTE PTR [eax+2], cl

; 523  :             Buffer[Index + 3] = iA;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR _iA$5[ebp]
	mov	BYTE PTR [edx+3], al

; 524  :         }

	jmp	$LN5@BlendColor
$LN6@BlendColor:

; 525  :     }

	jmp	$LN2@BlendColor
$LN3@BlendColor:

; 526  : 
; 527  :     /*
; 528  :     for (__int32 PointIndex = 0; PointIndex < PureColorCount; PointIndex++)
; 529  :     {
; 530  :     if (ColorSet[PointIndex].DrawHorizontalIndicator)
; 531  :     DrawHorizontalLine (Buffer, Width, Height, Stride, PointIndex, ColorSet);
; 532  :     if (ColorSet[PointIndex].DrawVerticalIndicator)
; 533  :     DrawVerticalLine (Buffer, Width, Height, Stride, PointIndex, ColorSet);
; 534  :     if (ColorSet[PointIndex].DrawPointIndicator)
; 535  :     DrawPointIndicator (Buffer, Width, Height, Stride, PointIndex, ColorSet);
; 536  :     }
; 537  :     */
; 538  : 
; 539  :     return TRUE;

	mov	al, 1
$LN1@BlendColor:

; 540  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?BlendColors2@@YG_NPAXHHHH0@Z ENDP			; BlendColors2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Points$ = -84						; size = 72
_MaxValidIndex$ = -12					; size = 4
_PixelIndex$1 = -8					; size = 4
_PointIndex$2 = -4					; size = 4
_Buffer$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_ColorIndex$ = 24					; size = 4
_ColorSet$ = 28						; size = 4
?DrawPointIndicator@@YGXPAEHHHHPAUPureColorType@@@Z PROC ; DrawPointIndicator

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 440  :     UINT32 MaxValidIndex = ((Width * Stride) * Height) - 1;

	mov	eax, DWORD PTR _Width$[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	imul	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	mov	DWORD PTR _MaxValidIndex$[ebp], eax

; 441  :     AbsolutePointStruct Points[9];
; 442  :     //Center row.
; 443  :     Points[0].X = ColorSet[ColorIndex].X;

	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, 8
	imul	eax, edx, 0
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	mov	DWORD PTR _Points$[ebp+eax], ecx

; 444  :     Points[0].Y = ColorSet[ColorIndex].Y;

	imul	edx, DWORD PTR _ColorIndex$[ebp], 72
	mov	eax, 8
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	edx, DWORD PTR [eax+edx+4]
	mov	DWORD PTR _Points$[ebp+ecx+4], edx

; 445  :     Points[1].X = ColorSet[ColorIndex].X - 1;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	sub	edx, 1
	mov	eax, 8
	shl	eax, 0
	mov	DWORD PTR _Points$[ebp+eax], edx

; 446  :     Points[1].Y = ColorSet[ColorIndex].Y;

	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, 8
	shl	edx, 0
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+4]
	mov	DWORD PTR _Points$[ebp+edx+4], ecx

; 447  :     Points[2].X = ColorSet[ColorIndex].X + 1;

	imul	edx, DWORD PTR _ColorIndex$[ebp], 72
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	add	ecx, 1
	mov	edx, 8
	shl	edx, 1
	mov	DWORD PTR _Points$[ebp+edx], ecx

; 448  :     Points[2].Y = ColorSet[ColorIndex].Y;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, 8
	shl	ecx, 1
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR _Points$[ebp+ecx+4], eax

; 449  :     //Top row.
; 450  :     Points[3].X = ColorSet[ColorIndex].X - 1;

	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	sub	eax, 1
	mov	ecx, 8
	imul	edx, ecx, 3
	mov	DWORD PTR _Points$[ebp+edx], eax

; 451  :     Points[3].Y = ColorSet[ColorIndex].Y - 1;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	sub	edx, 1
	mov	eax, 8
	imul	ecx, eax, 3
	mov	DWORD PTR _Points$[ebp+ecx+4], edx

; 452  :     Points[4].X = ColorSet[ColorIndex].X;

	imul	edx, DWORD PTR _ColorIndex$[ebp], 72
	mov	eax, 8
	shl	eax, 2
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	DWORD PTR _Points$[ebp+eax], edx

; 453  :     Points[4].Y = ColorSet[ColorIndex].Y - 1;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	sub	edx, 1
	mov	eax, 8
	shl	eax, 2
	mov	DWORD PTR _Points$[ebp+eax+4], edx

; 454  :     Points[5].X = ColorSet[ColorIndex].X + 1;

	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	add	eax, 1
	mov	ecx, 8
	imul	edx, ecx, 5
	mov	DWORD PTR _Points$[ebp+edx], eax

; 455  :     Points[5].Y = ColorSet[ColorIndex].Y - 1;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	sub	edx, 1
	mov	eax, 8
	imul	ecx, eax, 5
	mov	DWORD PTR _Points$[ebp+ecx+4], edx

; 456  :     //Bottom row.
; 457  :     Points[6].X = ColorSet[ColorIndex].X - 1;

	imul	edx, DWORD PTR _ColorIndex$[ebp], 72
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	sub	ecx, 1
	mov	edx, 8
	imul	eax, edx, 6
	mov	DWORD PTR _Points$[ebp+eax], ecx

; 458  :     Points[6].Y = ColorSet[ColorIndex].Y + 1;

	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	add	eax, 1
	mov	ecx, 8
	imul	edx, ecx, 6
	mov	DWORD PTR _Points$[ebp+edx+4], eax

; 459  :     Points[7].X = ColorSet[ColorIndex].X;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, 8
	imul	edx, ecx, 7
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	eax, DWORD PTR [ecx+eax]
	mov	DWORD PTR _Points$[ebp+edx], eax

; 460  :     Points[7].Y = ColorSet[ColorIndex].Y + 1;

	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	add	eax, 1
	mov	ecx, 8
	imul	edx, ecx, 7
	mov	DWORD PTR _Points$[ebp+edx+4], eax

; 461  :     Points[8].X = ColorSet[ColorIndex].X + 1;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	add	edx, 1
	mov	eax, 8
	shl	eax, 3
	mov	DWORD PTR _Points$[ebp+eax], edx

; 462  :     Points[8].Y = ColorSet[ColorIndex].Y + 1;

	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	add	eax, 1
	mov	ecx, 8
	shl	ecx, 3
	mov	DWORD PTR _Points$[ebp+ecx+4], eax

; 463  : 
; 464  :     for (int PointIndex = 0; PointIndex < 9; PointIndex++)

	mov	DWORD PTR _PointIndex$2[ebp], 0
	jmp	SHORT $LN4@DrawPointI
$LN2@DrawPointI:
	mov	edx, DWORD PTR _PointIndex$2[ebp]
	add	edx, 1
	mov	DWORD PTR _PointIndex$2[ebp], edx
$LN4@DrawPointI:
	cmp	DWORD PTR _PointIndex$2[ebp], 9
	jge	SHORT $LN1@DrawPointI

; 465  :     {
; 466  :         __int32 PixelIndex = (Points[PointIndex].Y * Stride) + (Points[PointIndex].X * 4);

	mov	eax, DWORD PTR _PointIndex$2[ebp]
	mov	ecx, DWORD PTR _Points$[ebp+eax*8+4]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	edx, DWORD PTR _PointIndex$2[ebp]
	mov	eax, DWORD PTR _Points$[ebp+edx*8]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _PixelIndex$1[ebp], ecx

; 467  :         if ((UINT32)(PixelIndex + 3) > MaxValidIndex)

	mov	edx, DWORD PTR _PixelIndex$1[ebp]
	add	edx, 3
	cmp	edx, DWORD PTR _MaxValidIndex$[ebp]
	jbe	SHORT $LN5@DrawPointI

; 468  :             continue;

	jmp	SHORT $LN2@DrawPointI
$LN5@DrawPointI:

; 469  :         Buffer[PixelIndex + 0] = ColorSet[ColorIndex].Blue;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _PixelIndex$1[ebp]
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	al, BYTE PTR [edx+eax+11]
	mov	BYTE PTR [ecx], al

; 470  :         Buffer[PixelIndex + 1] = ColorSet[ColorIndex].Green;

	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _PixelIndex$1[ebp]
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	cl, BYTE PTR [eax+ecx+10]
	mov	BYTE PTR [edx+1], cl

; 471  :         Buffer[PixelIndex + 2] = ColorSet[ColorIndex].Red;

	imul	edx, DWORD PTR _ColorIndex$[ebp], 72
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _PixelIndex$1[ebp]
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	dl, BYTE PTR [ecx+edx+9]
	mov	BYTE PTR [eax+2], dl

; 472  :         Buffer[PixelIndex + 3] = ColorSet[ColorIndex].Alpha;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _PixelIndex$1[ebp]
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	al, BYTE PTR [edx+eax+8]
	mov	BYTE PTR [ecx+3], al

; 473  :     }

	jmp	$LN2@DrawPointI
$LN1@DrawPointI:

; 474  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DrawPointIndicator@@YGXPAEHHHHPAUPureColorType@@@Z ENDP ; DrawPointIndicator
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_ColorSet$ = 16						; size = 4
_PurePointCount$ = 20					; size = 4
?ColorPointIndex2@@YGHHHPAUPureColorType@@H@Z PROC	; ColorPointIndex2

; 420  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 421  :     for (int i = 0; i < PurePointCount; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@ColorPoint
$LN2@ColorPoint:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@ColorPoint:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _PurePointCount$[ebp]
	jge	SHORT $LN3@ColorPoint

; 422  :     {
; 423  :         if ((ColorSet[i].X == X) && (ColorSet[i].Y == Y))

	imul	edx, DWORD PTR _i$1[ebp], 72
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	cmp	ecx, DWORD PTR _X$[ebp]
	jne	SHORT $LN5@ColorPoint
	imul	edx, DWORD PTR _i$1[ebp], 72
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	cmp	ecx, DWORD PTR _Y$[ebp]
	jne	SHORT $LN5@ColorPoint

; 424  :             return i;

	mov	eax, DWORD PTR _i$1[ebp]
	jmp	SHORT $LN1@ColorPoint
$LN5@ColorPoint:

; 425  :     }

	jmp	SHORT $LN2@ColorPoint
$LN3@ColorPoint:

; 426  :     return -1;

	or	eax, -1
$LN1@ColorPoint:

; 427  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ColorPointIndex2@@YGHHHPAUPureColorType@@H@Z ENDP	; ColorPointIndex2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Dist$1 = -44						; size = 8
_DistPercent$2 = -36					; size = 8
_BAccumulator$ = -28					; size = 4
_GAccumulator$ = -24					; size = 4
_RAccumulator$ = -20					; size = 4
_AACcumulator$ = -16					; size = 4
_i$3 = -12						; size = 4
_cB$4 = -5						; size = 1
_cG$5 = -4						; size = 1
_cR$6 = -3						; size = 1
_cA$7 = -2						; size = 1
tv136 = -1						; size = 1
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_PurePointCount$ = 24					; size = 4
_Colors$ = 28						; size = 4
_FinalA$ = 32						; size = 4
_FinalR$ = 36						; size = 4
_FinalG$ = 40						; size = 4
_FinalB$ = 44						; size = 4
?MakeColor2@@YGXHHHHHPAUPureColorType@@PAE111@Z PROC	; MakeColor2

; 362  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 363  :     int AACcumulator = 0;

	mov	DWORD PTR _AACcumulator$[ebp], 0

; 364  :     int RAccumulator = 0;

	mov	DWORD PTR _RAccumulator$[ebp], 0

; 365  :     int GAccumulator = 0;

	mov	DWORD PTR _GAccumulator$[ebp], 0

; 366  :     int BAccumulator = 0;

	mov	DWORD PTR _BAccumulator$[ebp], 0

; 367  :     for (int i = 0; i < PurePointCount; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@MakeColor2
$LN2@MakeColor2:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@MakeColor2:
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR _PurePointCount$[ebp]
	jge	$LN3@MakeColor2

; 368  :     {
; 369  :         double Dist = Distance(X, Y, Colors[i].X, Colors[i].Y);

	imul	edx, DWORD PTR _i$3[ebp], 72
	mov	eax, DWORD PTR _Colors$[ebp]
	mov	ecx, DWORD PTR [eax+edx+4]
	push	ecx
	imul	edx, DWORD PTR _i$3[ebp], 72
	mov	eax, DWORD PTR _Colors$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _Y$[ebp]
	push	edx
	mov	eax, DWORD PTR _X$[ebp]
	push	eax
	call	?Distance@@YGNHHHH@Z			; Distance
	fstp	QWORD PTR _Dist$1[ebp]

; 370  :         double DistPercent = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _DistPercent$2[ebp], xmm0

; 371  :         if (Colors[i].UseRadius)

	imul	ecx, DWORD PTR _i$3[ebp], 72
	mov	edx, DWORD PTR _Colors$[ebp]
	cmp	DWORD PTR [edx+ecx+48], 0
	je	SHORT $LN5@MakeColor2

; 372  :         {
; 373  :             //if (!InRange (Colors[i].X, Colors[i].Y, Colors[i].Radius, X, Y))
; 374  :             //    continue;
; 375  :             DistPercent = (fabs(Dist - Colors[i].Radius)) / Colors[i].Radius;

	imul	eax, DWORD PTR _i$3[ebp], 72
	mov	ecx, DWORD PTR _Colors$[ebp]
	movsd	xmm0, QWORD PTR _Dist$1[ebp]
	subsd	xmm0, QWORD PTR [ecx+eax+24]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	imul	edx, DWORD PTR _i$3[ebp], 72
	mov	eax, DWORD PTR _Colors$[ebp]
	divsd	xmm0, QWORD PTR [eax+edx+24]
	movsd	QWORD PTR _DistPercent$2[ebp], xmm0

; 376  :             if (DistPercent > 1.0)

	movsd	xmm0, QWORD PTR _DistPercent$2[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN7@MakeColor2

; 377  :                 continue;

	jmp	$LN2@MakeColor2
$LN7@MakeColor2:

; 378  :             /*
; 379  :             //            DistPercent = (Colors[i].Radius - Dist) / Colors[i].Radius;
; 380  :             DistPercent = (delta (Dist, Colors[i].Radius)) / Colors[i].Radius;
; 381  :             //            DistPercent = (abs(Dist - Colors[i].Radius)) / Colors[i].Radius;
; 382  :             if (DistPercent > 1.0)
; 383  :             continue;
; 384  :             */
; 385  :         }
; 386  :         else

	jmp	SHORT $LN6@MakeColor2
$LN5@MakeColor2:

; 387  :         {
; 388  :             //            DistPercent = (Colors[i].Hypotenuse - Dist) / Colors[i].Hypotenuse;
; 389  :             DistPercent = (Dist - Colors[i].Hypotenuse) / Colors[i].Hypotenuse;

	imul	ecx, DWORD PTR _i$3[ebp], 72
	mov	edx, DWORD PTR _Colors$[ebp]
	movsd	xmm0, QWORD PTR _Dist$1[ebp]
	subsd	xmm0, QWORD PTR [edx+ecx+16]
	imul	eax, DWORD PTR _i$3[ebp], 72
	mov	ecx, DWORD PTR _Colors$[ebp]
	divsd	xmm0, QWORD PTR [ecx+eax+16]
	movsd	QWORD PTR _DistPercent$2[ebp], xmm0
$LN6@MakeColor2:

; 390  :         }
; 391  :         byte cA = 0;

	mov	BYTE PTR _cA$7[ebp], 0

; 392  :         byte cR = 0;

	mov	BYTE PTR _cR$6[ebp], 0

; 393  :         byte cG = 0;

	mov	BYTE PTR _cG$5[ebp], 0

; 394  :         byte cB = 0;

	mov	BYTE PTR _cB$4[ebp], 0

; 395  :         ColorPercent2(DistPercent, Colors[i].Alpha, Colors[i].Red, Colors[i].Green, Colors[i].Blue, &cA, &cR, &cG, &cB,

	imul	edx, DWORD PTR _i$3[ebp], 72
	mov	eax, DWORD PTR _Colors$[ebp]
	cmp	DWORD PTR [eax+edx+52], 0
	je	SHORT $LN11@MakeColor2
	mov	BYTE PTR tv136[ebp], 1
	jmp	SHORT $LN12@MakeColor2
$LN11@MakeColor2:
	mov	BYTE PTR tv136[ebp], 0
$LN12@MakeColor2:
	movzx	ecx, BYTE PTR tv136[ebp]
	push	ecx
	imul	edx, DWORD PTR _i$3[ebp], 72
	mov	eax, DWORD PTR _Colors$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [eax+edx+40]
	movsd	QWORD PTR [esp], xmm0
	imul	ecx, DWORD PTR _i$3[ebp], 72
	mov	edx, DWORD PTR _Colors$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [edx+ecx+32]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _cB$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _cG$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _cR$6[ebp]
	push	edx
	lea	eax, DWORD PTR _cA$7[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$3[ebp], 72
	mov	edx, DWORD PTR _Colors$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+11]
	push	eax
	imul	ecx, DWORD PTR _i$3[ebp], 72
	mov	edx, DWORD PTR _Colors$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+10]
	push	eax
	imul	ecx, DWORD PTR _i$3[ebp], 72
	mov	edx, DWORD PTR _Colors$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+9]
	push	eax
	imul	ecx, DWORD PTR _i$3[ebp], 72
	mov	edx, DWORD PTR _Colors$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+8]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _DistPercent$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?ColorPercent2@@YGXNEEEEPAE000NN_N@Z	; ColorPercent2

; 396  :             Colors[i].AlphaStart, Colors[i].AlphaEnd, Colors[i].UseAlpha);
; 397  :         if (Colors[i].UseAlpha)

	imul	ecx, DWORD PTR _i$3[ebp], 72
	mov	edx, DWORD PTR _Colors$[ebp]
	cmp	DWORD PTR [edx+ecx+52], 0
	je	SHORT $LN8@MakeColor2

; 398  :             AACcumulator += cA;

	movzx	eax, BYTE PTR _cA$7[ebp]
	add	eax, DWORD PTR _AACcumulator$[ebp]
	mov	DWORD PTR _AACcumulator$[ebp], eax

; 399  :         else

	jmp	SHORT $LN9@MakeColor2
$LN8@MakeColor2:

; 400  :             AACcumulator += 0xff;

	mov	ecx, DWORD PTR _AACcumulator$[ebp]
	add	ecx, 255				; 000000ffH
	mov	DWORD PTR _AACcumulator$[ebp], ecx
$LN9@MakeColor2:

; 401  :         RAccumulator += cR;

	movzx	edx, BYTE PTR _cR$6[ebp]
	add	edx, DWORD PTR _RAccumulator$[ebp]
	mov	DWORD PTR _RAccumulator$[ebp], edx

; 402  :         GAccumulator += cG;

	movzx	eax, BYTE PTR _cG$5[ebp]
	add	eax, DWORD PTR _GAccumulator$[ebp]
	mov	DWORD PTR _GAccumulator$[ebp], eax

; 403  :         BAccumulator += cB;

	movzx	ecx, BYTE PTR _cB$4[ebp]
	add	ecx, DWORD PTR _BAccumulator$[ebp]
	mov	DWORD PTR _BAccumulator$[ebp], ecx

; 404  :     }

	jmp	$LN2@MakeColor2
$LN3@MakeColor2:

; 405  :     *FinalA = (byte)(AACcumulator / PurePointCount);

	mov	eax, DWORD PTR _AACcumulator$[ebp]
	cdq
	idiv	DWORD PTR _PurePointCount$[ebp]
	mov	edx, DWORD PTR _FinalA$[ebp]
	mov	BYTE PTR [edx], al

; 406  :     *FinalR = (byte)(RAccumulator / PurePointCount);

	mov	eax, DWORD PTR _RAccumulator$[ebp]
	cdq
	idiv	DWORD PTR _PurePointCount$[ebp]
	mov	ecx, DWORD PTR _FinalR$[ebp]
	mov	BYTE PTR [ecx], al

; 407  :     *FinalG = (byte)(GAccumulator / PurePointCount);

	mov	eax, DWORD PTR _GAccumulator$[ebp]
	cdq
	idiv	DWORD PTR _PurePointCount$[ebp]
	mov	edx, DWORD PTR _FinalG$[ebp]
	mov	BYTE PTR [edx], al

; 408  :     *FinalB = (byte)(BAccumulator / PurePointCount);

	mov	eax, DWORD PTR _BAccumulator$[ebp]
	cdq
	idiv	DWORD PTR _PurePointCount$[ebp]
	mov	ecx, DWORD PTR _FinalB$[ebp]
	mov	BYTE PTR [ecx], al

; 409  : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
?MakeColor2@@YGXHHHHHPAUPureColorType@@PAE111@Z ENDP	; MakeColor2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
?AlphaBlend@@YGXXZ PROC					; AlphaBlend

; 343  : {

	push	ebp
	mov	ebp, esp

; 344  : 
; 345  : }

	pop	ebp
	ret	0
?AlphaBlend@@YGXXZ ENDP					; AlphaBlend
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Dist$ = -12						; size = 8
tv66 = -1						; size = 1
_X1$ = 8						; size = 4
_Y1$ = 12						; size = 4
_X2$ = 16						; size = 4
_Y2$ = 20						; size = 4
_Radius$ = 24						; size = 8
?InRange@@YGHHHHHN@Z PROC				; InRange

; 336  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 337  :     double Dist = (X1, Y1, X2, Y2);

	cvtsi2sd xmm0, DWORD PTR _Y2$[ebp]
	movsd	QWORD PTR _Dist$[ebp], xmm0

; 338  :     return Dist <= Radius ? true : false;

	movsd	xmm0, QWORD PTR _Radius$[ebp]
	comisd	xmm0, QWORD PTR _Dist$[ebp]
	jb	SHORT $LN3@InRange
	mov	BYTE PTR tv66[ebp], 1
	jmp	SHORT $LN4@InRange
$LN3@InRange:
	mov	BYTE PTR tv66[ebp], 0
$LN4@InRange:
	movzx	eax, BYTE PTR tv66[ebp]

; 339  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?InRange@@YGHHHHHN@Z ENDP				; InRange
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_AlphaRange$1 = -8					; size = 8
_Percent$ = 8						; size = 8
_inA$ = 16						; size = 1
_inR$ = 20						; size = 1
_inG$ = 24						; size = 1
_inB$ = 28						; size = 1
_outA$ = 32						; size = 4
_outR$ = 36						; size = 4
_outG$ = 40						; size = 4
_outB$ = 44						; size = 4
_AlphaStart$ = 48					; size = 8
_AlphaEnd$ = 56						; size = 8
_UseAlpha$ = 64						; size = 1
?ColorPercent2@@YGXNEEEEPAE000NN_N@Z PROC		; ColorPercent2

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 309  :     if (UseAlpha)

	movzx	eax, BYTE PTR _UseAlpha$[ebp]
	test	eax, eax
	je	SHORT $LN2@ColorPerce

; 310  :     {
; 311  :         if (Percent > 1.0)

	movsd	xmm0, QWORD PTR _Percent$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN4@ColorPerce

; 312  :         {
; 313  :             *outA = (byte)(AlphaEnd * 0xff);

	movsd	xmm0, QWORD PTR _AlphaEnd$[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _outA$[ebp]
	mov	BYTE PTR [edx], cl

; 314  :         }
; 315  :         else

	jmp	SHORT $LN7@ColorPerce
$LN4@ColorPerce:

; 316  :         {
; 317  :             if (Percent <= 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _Percent$[ebp]
	jb	SHORT $LN6@ColorPerce

; 318  :             {
; 319  :                 *outA = (byte)(AlphaStart * 0xff);

	movsd	xmm0, QWORD PTR _AlphaStart$[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si eax, xmm0
	mov	ecx, DWORD PTR _outA$[ebp]
	mov	BYTE PTR [ecx], al

; 320  :             }
; 321  :             else

	jmp	SHORT $LN7@ColorPerce
$LN6@ColorPerce:

; 322  :             {
; 323  :                 double AlphaRange = AlphaEnd - AlphaStart;

	movsd	xmm0, QWORD PTR _AlphaEnd$[ebp]
	subsd	xmm0, QWORD PTR _AlphaStart$[ebp]
	movsd	QWORD PTR _AlphaRange$1[ebp], xmm0

; 324  :                 *outA = (byte)(Percent * AlphaRange);

	movsd	xmm0, QWORD PTR _Percent$[ebp]
	mulsd	xmm0, QWORD PTR _AlphaRange$1[ebp]
	cvttsd2si edx, xmm0
	mov	eax, DWORD PTR _outA$[ebp]
	mov	BYTE PTR [eax], dl
$LN7@ColorPerce:

; 325  :             }
; 326  :         }
; 327  :     }
; 328  :     else

	jmp	SHORT $LN3@ColorPerce
$LN2@ColorPerce:

; 329  :         *outA = 0xff;

	mov	ecx, DWORD PTR _outA$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH
$LN3@ColorPerce:

; 330  :     *outR = (byte)(Percent*(double)inR);

	movzx	edx, BYTE PTR _inR$[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR _Percent$[ebp]
	cvttsd2si eax, xmm0
	mov	ecx, DWORD PTR _outR$[ebp]
	mov	BYTE PTR [ecx], al

; 331  :     *outG = (byte)(Percent*(double)inG);

	movzx	edx, BYTE PTR _inG$[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR _Percent$[ebp]
	cvttsd2si eax, xmm0
	mov	ecx, DWORD PTR _outG$[ebp]
	mov	BYTE PTR [ecx], al

; 332  :     *outB = (byte)(Percent*(double)inB);

	movzx	edx, BYTE PTR _inB$[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR _Percent$[ebp]
	cvttsd2si eax, xmm0
	mov	ecx, DWORD PTR _outB$[ebp]
	mov	BYTE PTR [ecx], al

; 333  : }

	mov	esp, ebp
	pop	ebp
	ret	60					; 0000003cH
?ColorPercent2@@YGXNEEEEPAE000NN_N@Z ENDP		; ColorPercent2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Points$ = 16						; size = 4
_PointCount$ = 20					; size = 4
?ColorPointIndex@@YGHHHPAUAbsolutePointStruct@@H@Z PROC	; ColorPointIndex

; 108  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 109  :     for (int i = 0; i < PointCount; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@ColorPoint
$LN2@ColorPoint:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@ColorPoint:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _PointCount$[ebp]
	jge	SHORT $LN3@ColorPoint

; 110  :     {
; 111  :         if ((Points[i].X == X) && (Points[i].Y == Y))

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _Points$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	cmp	ecx, DWORD PTR _X$[ebp]
	jne	SHORT $LN5@ColorPoint
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _Points$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	cmp	ecx, DWORD PTR _Y$[ebp]
	jne	SHORT $LN5@ColorPoint

; 112  :             return i;

	mov	eax, DWORD PTR _i$1[ebp]
	jmp	SHORT $LN1@ColorPoint
$LN5@ColorPoint:

; 113  :     }

	jmp	SHORT $LN2@ColorPoint
$LN3@ColorPoint:

; 114  :     return -1;

	or	eax, -1
$LN1@ColorPoint:

; 115  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ColorPointIndex@@YGHHHPAUAbsolutePointStruct@@H@Z ENDP	; ColorPointIndex
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Destination$ = 24					; size = 4
_DestinationWidth$ = 28					; size = 4
_DestinationHeight$ = 32				; size = 4
_DestinationStride$ = 36				; size = 4
_X1$ = 40						; size = 4
_Y1$ = 44						; size = 4
_CopySubRegion@40 PROC

; 2139 : {

	push	ebp
	mov	ebp, esp

; 2140 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@CopySubReg

; 2141 :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@CopySubReg
$LN2@CopySubReg:

; 2142 :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN3@CopySubReg

; 2143 :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@CopySubReg
$LN3@CopySubReg:

; 2144 :     if (X1 < 0)

	cmp	DWORD PTR _X1$[ebp], 0
	jge	SHORT $LN4@CopySubReg

; 2145 :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopySubReg
$LN4@CopySubReg:

; 2146 :     if (Y1 < 0)

	cmp	DWORD PTR _Y1$[ebp], 0
	jge	SHORT $LN5@CopySubReg

; 2147 :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopySubReg
$LN5@CopySubReg:

; 2148 :     if (X1 >= SourceWidth)

	mov	eax, DWORD PTR _X1$[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jl	SHORT $LN6@CopySubReg

; 2149 :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopySubReg
$LN6@CopySubReg:

; 2150 :     if (Y1 >= SourceHeight)

	mov	ecx, DWORD PTR _Y1$[ebp]
	cmp	ecx, DWORD PTR _SourceHeight$[ebp]
	jl	SHORT $LN7@CopySubReg

; 2151 :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopySubReg
$LN7@CopySubReg:

; 2152 :     if (X1 + DestinationWidth >= SourceWidth)

	mov	edx, DWORD PTR _X1$[ebp]
	add	edx, DWORD PTR _DestinationWidth$[ebp]
	cmp	edx, DWORD PTR _SourceWidth$[ebp]
	jl	SHORT $LN8@CopySubReg

; 2153 :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopySubReg
$LN8@CopySubReg:

; 2154 :     if (Y1 + DestinationHeight >= SourceHeight)

	mov	eax, DWORD PTR _Y1$[ebp]
	add	eax, DWORD PTR _DestinationHeight$[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jl	SHORT $LN9@CopySubReg

; 2155 :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopySubReg
$LN9@CopySubReg:

; 2156 : 
; 2157 :     return Success;

	xor	eax, eax
$LN1@CopySubReg:

; 2158 : }

	pop	ebp
	ret	40					; 00000028H
_CopySubRegion@40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_SourceRowIndex$1 = -40					; size = 4
_TargetRowIndex$2 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_SourceIndex$3 = -28					; size = 4
_SourceBuffer$ = -24					; size = 4
_Row$4 = -20						; size = 4
_Column$5 = -16						; size = 4
_TargetIndex$6 = -12					; size = 4
_TargetBuffer$ = -8					; size = 4
_DefaultA$ = -4						; size = 1
_DefaultR$ = -3						; size = 1
_DefaultG$ = -2						; size = 1
_DefaultB$ = -1						; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_Source$ = 24						; size = 4
_SourceWidth$ = 28					; size = 4
_SourceHeight$ = 32					; size = 4
_SourceStride$ = 36					; size = 4
_PackedBGColor$ = 40					; size = 4
_FillBufferWithBuffer@36 PROC

; 1237 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1238 :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@FillBuffer

; 1239 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@FillBuffer
$LN8@FillBuffer:

; 1240 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN9@FillBuffer

; 1241 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@FillBuffer
$LN9@FillBuffer:

; 1242 : 
; 1243 :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1244 :     BYTE * TargetBuffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _TargetBuffer$[ebp], eax

; 1245 :     BYTE * SourceBuffer = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _SourceBuffer$[ebp], ecx

; 1246 :     BYTE DefaultA = (PackedBGColor & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedBGColor$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _DefaultA$[ebp], dl

; 1247 :     BYTE DefaultR = (PackedBGColor & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedBGColor$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _DefaultR$[ebp], al

; 1248 :     BYTE DefaultG = (PackedBGColor & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedBGColor$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _DefaultG$[ebp], cl

; 1249 :     BYTE DefaultB = (PackedBGColor & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedBGColor$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _DefaultB$[ebp], dl

; 1250 : 
; 1251 :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@FillBuffer
$LN2@FillBuffer:
	mov	eax, DWORD PTR _Row$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$4[ebp], eax
$LN4@FillBuffer:
	mov	ecx, DWORD PTR _Row$4[ebp]
	cmp	ecx, DWORD PTR _TargetHeight$[ebp]
	jge	$LN3@FillBuffer

; 1252 :     {
; 1253 :         int TargetRowIndex = Row * TargetStride;

	mov	edx, DWORD PTR _Row$4[ebp]
	imul	edx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _TargetRowIndex$2[ebp], edx

; 1254 :         int SourceRowIndex = Row * SourceStride;

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _SourceRowIndex$1[ebp], eax

; 1255 :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@FillBuffer
$LN5@FillBuffer:
	mov	ecx, DWORD PTR _Column$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$5[ebp], ecx
$LN7@FillBuffer:
	mov	edx, DWORD PTR _Column$5[ebp]
	cmp	edx, DWORD PTR _TargetWidth$[ebp]
	jge	$LN6@FillBuffer

; 1256 :         {
; 1257 :             int TargetIndex = TargetRowIndex + (Column * PixelSize);

	mov	eax, DWORD PTR _Column$5[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _TargetRowIndex$2[ebp]
	mov	DWORD PTR _TargetIndex$6[ebp], eax

; 1258 :             if (Column > SourceWidth - 1)

	mov	ecx, DWORD PTR _SourceWidth$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Column$5[ebp], ecx
	jle	SHORT $LN10@FillBuffer

; 1259 :             {
; 1260 :                 TargetBuffer[TargetIndex + 0] = DefaultB;

	mov	edx, DWORD PTR _TargetBuffer$[ebp]
	add	edx, DWORD PTR _TargetIndex$6[ebp]
	mov	al, BYTE PTR _DefaultB$[ebp]
	mov	BYTE PTR [edx], al

; 1261 :                 TargetBuffer[TargetIndex + 1] = DefaultG;

	mov	ecx, DWORD PTR _TargetBuffer$[ebp]
	add	ecx, DWORD PTR _TargetIndex$6[ebp]
	mov	dl, BYTE PTR _DefaultG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1262 :                 TargetBuffer[TargetIndex + 2] = DefaultR;

	mov	eax, DWORD PTR _TargetBuffer$[ebp]
	add	eax, DWORD PTR _TargetIndex$6[ebp]
	mov	cl, BYTE PTR _DefaultR$[ebp]
	mov	BYTE PTR [eax+2], cl

; 1263 :                 TargetBuffer[TargetIndex + 3] = DefaultA;

	mov	edx, DWORD PTR _TargetBuffer$[ebp]
	add	edx, DWORD PTR _TargetIndex$6[ebp]
	mov	al, BYTE PTR _DefaultA$[ebp]
	mov	BYTE PTR [edx+3], al

; 1264 :             }
; 1265 :             else

	jmp	SHORT $LN11@FillBuffer
$LN10@FillBuffer:

; 1266 :             {
; 1267 :                 int SourceIndex = SourceRowIndex + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _SourceRowIndex$1[ebp]
	mov	DWORD PTR _SourceIndex$3[ebp], ecx

; 1268 :                 TargetBuffer[TargetIndex + 0] = SourceBuffer[SourceIndex + 0];

	mov	edx, DWORD PTR _TargetBuffer$[ebp]
	add	edx, DWORD PTR _TargetIndex$6[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	add	eax, DWORD PTR _SourceIndex$3[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 1269 :                 TargetBuffer[TargetIndex + 1] = SourceBuffer[SourceIndex + 1];

	mov	edx, DWORD PTR _TargetBuffer$[ebp]
	add	edx, DWORD PTR _TargetIndex$6[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	add	eax, DWORD PTR _SourceIndex$3[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 1270 :                 TargetBuffer[TargetIndex + 2] = SourceBuffer[SourceIndex + 2];

	mov	edx, DWORD PTR _TargetBuffer$[ebp]
	add	edx, DWORD PTR _TargetIndex$6[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	add	eax, DWORD PTR _SourceIndex$3[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 1271 :                 TargetBuffer[TargetIndex + 3] = SourceBuffer[SourceIndex + 3];

	mov	edx, DWORD PTR _TargetBuffer$[ebp]
	add	edx, DWORD PTR _TargetIndex$6[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	add	eax, DWORD PTR _SourceIndex$3[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl
$LN11@FillBuffer:

; 1272 :             }
; 1273 :         }

	jmp	$LN5@FillBuffer
$LN6@FillBuffer:

; 1274 :     }

	jmp	$LN2@FillBuffer
$LN3@FillBuffer:

; 1275 : 
; 1276 :     return Success;

	xor	eax, eax
$LN1@FillBuffer:

; 1277 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_FillBufferWithBuffer@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_RowOffset$1 = -24					; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Index$4 = -12						; size = 4
_Buffer$ = -8						; size = 4
_PixelSize$ = -1					; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_ClearA$ = 24						; size = 1
_ClearR$ = 28						; size = 1
_ClearG$ = 32						; size = 1
_ClearB$ = 36						; size = 1
_DrawGrid$ = 40						; size = 4
_GridA$ = 44						; size = 1
_GridR$ = 48						; size = 1
_GridG$ = 52						; size = 1
_GridB$ = 56						; size = 1
_GridCellWidth$ = 60					; size = 4
_GridCellHeight$ = 64					; size = 4
_DrawOutline$ = 68					; size = 4
_OutA$ = 72						; size = 1
_OutR$ = 76						; size = 1
_OutG$ = 80						; size = 1
_OutB$ = 84						; size = 1
_ClearBuffer@80 PROC

; 1185 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1186 :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@ClearBuffe

; 1187 :         return FALSE;

	xor	eax, eax
	jmp	$LN1@ClearBuffe
$LN8@ClearBuffe:

; 1188 : 
; 1189 :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 1190 :     BYTE* Buffer = (BYTE*)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 1191 : 
; 1192 :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ClearBuffe
$LN2@ClearBuffe:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@ClearBuffe:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _TargetHeight$[ebp]
	jge	$LN3@ClearBuffe

; 1193 :     {
; 1194 :         int RowOffset = Row * TargetStride;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 1195 :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ClearBuffe
$LN5@ClearBuffe:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@ClearBuffe:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _TargetWidth$[ebp]
	jge	$LN6@ClearBuffe

; 1196 :         {
; 1197 :             int Index = RowOffset + (Column * PixelSize);

	movzx	eax, BYTE PTR _PixelSize$[ebp]
	imul	eax, DWORD PTR _Column$2[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 1198 :             if (DrawOutline)

	cmp	DWORD PTR _DrawOutline$[ebp], 0
	je	SHORT $LN9@ClearBuffe

; 1199 :             {
; 1200 :                 if (Row == 0 || Row == TargetHeight - 1 || Column == 0 || Column == TargetWidth - 1)

	cmp	DWORD PTR _Row$3[ebp], 0
	je	SHORT $LN11@ClearBuffe
	mov	ecx, DWORD PTR _TargetHeight$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Row$3[ebp], ecx
	je	SHORT $LN11@ClearBuffe
	cmp	DWORD PTR _Column$2[ebp], 0
	je	SHORT $LN11@ClearBuffe
	mov	edx, DWORD PTR _TargetWidth$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _Column$2[ebp], edx
	jne	SHORT $LN9@ClearBuffe
$LN11@ClearBuffe:

; 1201 :                 {
; 1202 :                     Buffer[Index + 0] = OutB;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _OutB$[ebp]
	mov	BYTE PTR [eax], cl

; 1203 :                     Buffer[Index + 1] = OutG;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _OutG$[ebp]
	mov	BYTE PTR [edx+1], al

; 1204 :                     Buffer[Index + 2] = OutR;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _OutR$[ebp]
	mov	BYTE PTR [ecx+2], dl

; 1205 :                     Buffer[Index + 3] = OutA;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _OutA$[ebp]
	mov	BYTE PTR [eax+3], cl

; 1206 :                     continue;

	jmp	SHORT $LN5@ClearBuffe
$LN9@ClearBuffe:

; 1207 :                 }
; 1208 :             }
; 1209 :             if (DrawGrid)

	cmp	DWORD PTR _DrawGrid$[ebp], 0
	je	SHORT $LN12@ClearBuffe

; 1210 :             {
; 1211 :                 if (
; 1212 :                     (Row % GridCellHeight == 0) ||

	mov	eax, DWORD PTR _Row$3[ebp]
	cdq
	idiv	DWORD PTR _GridCellHeight$[ebp]
	test	edx, edx
	je	SHORT $LN14@ClearBuffe
	mov	eax, DWORD PTR _Column$2[ebp]
	cdq
	idiv	DWORD PTR _GridCellWidth$[ebp]
	test	edx, edx
	jne	SHORT $LN12@ClearBuffe
$LN14@ClearBuffe:

; 1213 :                     (Column % GridCellWidth == 0)
; 1214 :                     )
; 1215 :                 {
; 1216 :                     Buffer[Index + 0] = GridB;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _GridB$[ebp]
	mov	BYTE PTR [edx], al

; 1217 :                     Buffer[Index + 1] = GridG;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _GridG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1218 :                     Buffer[Index + 2] = GridR;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _GridR$[ebp]
	mov	BYTE PTR [eax+2], cl

; 1219 :                     Buffer[Index + 3] = GridA;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _GridA$[ebp]
	mov	BYTE PTR [edx+3], al

; 1220 :                     continue;

	jmp	$LN5@ClearBuffe
$LN12@ClearBuffe:

; 1221 :                 }
; 1222 :             }
; 1223 : 
; 1224 :             Buffer[Index + 0] = ClearB;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _ClearB$[ebp]
	mov	BYTE PTR [ecx], dl

; 1225 :             Buffer[Index + 1] = ClearG;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _ClearG$[ebp]
	mov	BYTE PTR [eax+1], cl

; 1226 :             Buffer[Index + 2] = ClearR;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _ClearR$[ebp]
	mov	BYTE PTR [edx+2], al

; 1227 :             Buffer[Index + 3] = ClearA;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _ClearA$[ebp]
	mov	BYTE PTR [ecx+3], dl

; 1228 :         }

	jmp	$LN5@ClearBuffe
$LN6@ClearBuffe:

; 1229 :     }

	jmp	$LN2@ClearBuffe
$LN3@ClearBuffe:

; 1230 : 
; 1231 :     return TRUE;

	mov	eax, 1
$LN1@ClearBuffe:

; 1232 : }

	mov	esp, ebp
	pop	ebp
	ret	80					; 00000050H
_ClearBuffer@80 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_PixLuminance$1 = -40					; size = 8
_RowOffset$2 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Column$3 = -24						; size = 4
_Row$4 = -20						; size = 4
_Src$ = -16						; size = 4
_Dest$ = -12						; size = 4
_Index$5 = -8						; size = 4
_mB$ = -3						; size = 1
_mG$ = -2						; size = 1
_mR$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Luminance$ = 28					; size = 8
_UseMaskedPixel$ = 36					; size = 4
_MaskedPixelColor$ = 40					; size = 4
_CreateAlphaMaskFromLuminance@36 PROC

; 1112 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1113 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@CreateAlph

; 1114 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CreateAlph
$LN8@CreateAlph:

; 1115 :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@CreateAlph

; 1116 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CreateAlph
$LN9@CreateAlph:

; 1117 : 
; 1118 :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1119 :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1120 :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1121 :     BYTE mR = (MaskedPixelColor & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _MaskedPixelColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _mR$[ebp], dl

; 1122 :     BYTE mG = (MaskedPixelColor & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _MaskedPixelColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _mG$[ebp], al

; 1123 :     BYTE mB = (MaskedPixelColor & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _MaskedPixelColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _mB$[ebp], cl

; 1124 : 
; 1125 :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@CreateAlph
$LN2@CreateAlph:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@CreateAlph:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@CreateAlph

; 1126 :     {
; 1127 :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 1128 :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@CreateAlph
$LN5@CreateAlph:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@CreateAlph:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@CreateAlph

; 1129 :         {
; 1130 :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 1131 :             double PixLuminance = ColorLuminance(Src[Index + 2], Src[Index + 1], Src[Index + 0]);

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_ColorLuminance@12
	fstp	QWORD PTR _PixLuminance$1[ebp]

; 1132 :             if (PixLuminance > Luminance)

	movsd	xmm0, QWORD PTR _PixLuminance$1[ebp]
	comisd	xmm0, QWORD PTR _Luminance$[ebp]
	jbe	$LN10@CreateAlph

; 1133 :             {
; 1134 :                 if (UseMaskedPixel)

	cmp	DWORD PTR _UseMaskedPixel$[ebp], 0
	je	SHORT $LN12@CreateAlph

; 1135 :                 {
; 1136 :                     Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1137 :                     Dest[Index + 2] = mR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _mR$[ebp]
	mov	BYTE PTR [edx+2], al

; 1138 :                     Dest[Index + 1] = mG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _mG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1139 :                     Dest[Index + 0] = mB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _mB$[ebp]
	mov	BYTE PTR [eax], cl

; 1140 :                 }
; 1141 :                 else

	jmp	SHORT $LN13@CreateAlph
$LN12@CreateAlph:

; 1142 :                 {
; 1143 :                     Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1144 :                     Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 1145 :                     Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 1146 :                     Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
$LN13@CreateAlph:

; 1147 :                 }
; 1148 :             }
; 1149 :             else

	jmp	SHORT $LN11@CreateAlph
$LN10@CreateAlph:

; 1150 :             {
; 1151 :                 Dest[Index + 3] = 0x0;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+3], 0

; 1152 :                 Dest[Index + 2] = 0xff;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+2], 255			; 000000ffH

; 1153 :                 Dest[Index + 1] = 0xff;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [ecx+1], 255			; 000000ffH

; 1154 :                 Dest[Index + 0] = 0xff;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx], 255			; 000000ffH
$LN11@CreateAlph:

; 1155 :             }
; 1156 :         }

	jmp	$LN5@CreateAlph
$LN6@CreateAlph:

; 1157 :     }

	jmp	$LN2@CreateAlph
$LN3@CreateAlph:

; 1158 : 
; 1159 :     return Success;

	xor	eax, eax
$LN1@CreateAlph:

; 1160 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_CreateAlphaMaskFromLuminance@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_SourceLuminance$1 = -36				; size = 8
_RowOffset$2 = -28					; size = 4
_Column$3 = -24						; size = 4
_Row$4 = -20						; size = 4
_Source$ = -16						; size = 4
_Buffer$ = -12						; size = 4
_Index$5 = -8						; size = 4
_PixelSize$ = -1					; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_ImageSource$ = 24					; size = 4
_Threshold$ = 28					; size = 8
_AlphaToo$ = 36						; size = 4
_MaskA$ = 40						; size = 1
_MaskR$ = 44						; size = 1
_MaskG$ = 48						; size = 1
_MaskB$ = 52						; size = 1
_CreateMaskFromLuminance@48 PROC

; 1057 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1058 :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@CreateMask

; 1059 :         return FALSE;

	xor	eax, eax
	jmp	$LN1@CreateMask
$LN8@CreateMask:

; 1060 :     if (ImageSource == NULL)

	cmp	DWORD PTR _ImageSource$[ebp], 0
	jne	SHORT $LN9@CreateMask

; 1061 :         return FALSE;

	xor	eax, eax
	jmp	$LN1@CreateMask
$LN9@CreateMask:

; 1062 : 
; 1063 :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 1064 :     BYTE *Buffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 1065 :     BYTE *Source = (BYTE *)ImageSource;

	mov	ecx, DWORD PTR _ImageSource$[ebp]
	mov	DWORD PTR _Source$[ebp], ecx

; 1066 : 
; 1067 :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@CreateMask
$LN2@CreateMask:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@CreateMask:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _TargetHeight$[ebp]
	jge	$LN3@CreateMask

; 1068 :     {
; 1069 :         int RowOffset = Row * TargetStride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 1070 :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@CreateMask
$LN5@CreateMask:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@CreateMask:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _TargetWidth$[ebp]
	jge	$LN6@CreateMask

; 1071 :         {
; 1072 :             int Index = RowOffset + Column * PixelSize;

	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 1073 :             double SourceLuminance = PixelLuminance(Source[Index + 2], Source[Index + 1], Source[Index + 0]);

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	?PixelLuminance@@YGNEEE@Z		; PixelLuminance
	fstp	QWORD PTR _SourceLuminance$1[ebp]

; 1074 :             if (SourceLuminance < Threshold)

	movsd	xmm0, QWORD PTR _Threshold$[ebp]
	comisd	xmm0, QWORD PTR _SourceLuminance$1[ebp]
	jbe	SHORT $LN10@CreateMask

; 1075 :             {
; 1076 :                 Buffer[Index + 0] = MaskB;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _MaskB$[ebp]
	mov	BYTE PTR [edx], al

; 1077 :                 Buffer[Index + 1] = MaskG;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _MaskG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1078 :                 Buffer[Index + 2] = MaskR;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _MaskR$[ebp]
	mov	BYTE PTR [eax+2], cl

; 1079 :                 if (AlphaToo)

	cmp	DWORD PTR _AlphaToo$[ebp], 0
	je	SHORT $LN12@CreateMask

; 1080 :                     Buffer[Index + 3] = MaskA;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _MaskA$[ebp]
	mov	BYTE PTR [edx+3], al

; 1081 :                 else

	jmp	SHORT $LN13@CreateMask
$LN12@CreateMask:

; 1082 :                     Buffer[Index + 3] = 0x0;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [ecx+3], 0
$LN13@CreateMask:

; 1083 :             }
; 1084 :             else

	jmp	SHORT $LN11@CreateMask
$LN10@CreateMask:

; 1085 :             {
; 1086 :                 Buffer[Index + 0] = Source[Index + 0];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 1087 :                 Buffer[Index + 1] = Source[Index + 1];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 1088 :                 Buffer[Index + 2] = Source[Index + 2];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 1089 :                 Buffer[Index + 3] = Source[Index + 3];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl
$LN11@CreateMask:

; 1090 :             }
; 1091 :         }

	jmp	$LN5@CreateMask
$LN6@CreateMask:

; 1092 :     }

	jmp	$LN2@CreateMask
$LN3@CreateMask:

; 1093 : 
; 1094 :     return TRUE;

	mov	eax, 1
$LN1@CreateMask:

; 1095 : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_CreateMaskFromLuminance@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_RowOffset$1 = -32					; size = 4
_Column$2 = -28						; size = 4
_Row$3 = -24						; size = 4
_Source$ = -20						; size = 4
_Buffer$ = -16						; size = 4
_Index$4 = -12						; size = 4
_AThreshold$ = -5					; size = 1
_RThreshold$ = -4					; size = 1
_GThreshold$ = -3					; size = 1
_BThreshold$ = -2					; size = 1
_PixelSize$ = -1					; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_ImageSource$ = 24					; size = 4
_Threshold$ = 28					; size = 4
_AlphaToo$ = 32						; size = 4
_MaskA$ = 36						; size = 1
_MaskR$ = 40						; size = 1
_MaskG$ = 44						; size = 1
_MaskB$ = 48						; size = 1
_CreateMask@44 PROC

; 984  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 985  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@CreateMask

; 986  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@CreateMask
$LN8@CreateMask:

; 987  :     if (ImageSource == NULL)

	cmp	DWORD PTR _ImageSource$[ebp], 0
	jne	SHORT $LN9@CreateMask

; 988  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@CreateMask
$LN9@CreateMask:

; 989  : 
; 990  :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 991  :     BYTE *Buffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 992  :     BYTE *Source = (BYTE *)ImageSource;

	mov	ecx, DWORD PTR _ImageSource$[ebp]
	mov	DWORD PTR _Source$[ebp], ecx

; 993  :     BYTE AThreshold = (Threshold & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _Threshold$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _AThreshold$[ebp], dl

; 994  :     BYTE RThreshold = (Threshold & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _Threshold$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _RThreshold$[ebp], al

; 995  :     BYTE GThreshold = (Threshold & 0x00ff0000) >> 16;

	mov	ecx, DWORD PTR _Threshold$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR _GThreshold$[ebp], cl

; 996  :     BYTE BThreshold = (Threshold & 0xff000000) >> 24;

	mov	edx, DWORD PTR _Threshold$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _BThreshold$[ebp], dl

; 997  : 
; 998  :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@CreateMask
$LN2@CreateMask:
	mov	eax, DWORD PTR _Row$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$3[ebp], eax
$LN4@CreateMask:
	mov	ecx, DWORD PTR _Row$3[ebp]
	cmp	ecx, DWORD PTR _TargetHeight$[ebp]
	jge	$LN3@CreateMask

; 999  :     {
; 1000 :         int RowOffset = Row * TargetStride;

	mov	edx, DWORD PTR _Row$3[ebp]
	imul	edx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 1001 :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@CreateMask
$LN5@CreateMask:
	mov	eax, DWORD PTR _Column$2[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$2[ebp], eax
$LN7@CreateMask:
	mov	ecx, DWORD PTR _Column$2[ebp]
	cmp	ecx, DWORD PTR _TargetWidth$[ebp]
	jge	$LN6@CreateMask

; 1002 :         {
; 1003 :             int Index = RowOffset + Column * PixelSize;

	movzx	edx, BYTE PTR _PixelSize$[ebp]
	imul	edx, DWORD PTR _Column$2[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], edx

; 1004 :             if (
; 1005 :                 (Source[Index + 0] < BThreshold) ||
; 1006 :                 (Source[Index + 1] < GThreshold) ||
; 1007 :                 (Source[Index + 2] < RThreshold) ||

	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _BThreshold$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN12@CreateMask
	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	movzx	edx, BYTE PTR _GThreshold$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN12@CreateMask
	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	movzx	edx, BYTE PTR _RThreshold$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN12@CreateMask
	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	movzx	edx, BYTE PTR _AThreshold$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN10@CreateMask
	cmp	DWORD PTR _AlphaToo$[ebp], 0
	je	SHORT $LN10@CreateMask
$LN12@CreateMask:

; 1008 :                 ((Source[Index + 3] < AThreshold) && AlphaToo)
; 1009 :                 )
; 1010 :             {
; 1011 :                 Buffer[Index + 0] = MaskB;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _MaskB$[ebp]
	mov	BYTE PTR [eax], cl

; 1012 :                 Buffer[Index + 1] = MaskG;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _MaskG$[ebp]
	mov	BYTE PTR [edx+1], al

; 1013 :                 Buffer[Index + 2] = MaskR;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _MaskR$[ebp]
	mov	BYTE PTR [ecx+2], dl

; 1014 :                 if (AlphaToo)

	cmp	DWORD PTR _AlphaToo$[ebp], 0
	je	SHORT $LN13@CreateMask

; 1015 :                     Buffer[Index + 3] = MaskA;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _MaskA$[ebp]
	mov	BYTE PTR [eax+3], cl

; 1016 :                 else

	jmp	SHORT $LN14@CreateMask
$LN13@CreateMask:

; 1017 :                     Buffer[Index + 3] = 0x0;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx+3], 0
$LN14@CreateMask:

; 1018 :             }
; 1019 :             else

	jmp	SHORT $LN11@CreateMask
$LN10@CreateMask:

; 1020 :             {
; 1021 :                 Buffer[Index + 0] = Source[Index + 0];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 1022 :                 Buffer[Index + 1] = Source[Index + 1];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 1023 :                 Buffer[Index + 2] = Source[Index + 2];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 1024 :                 Buffer[Index + 3] = Source[Index + 3];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl
$LN11@CreateMask:

; 1025 :             }
; 1026 :         }

	jmp	$LN5@CreateMask
$LN6@CreateMask:

; 1027 :     }

	jmp	$LN2@CreateMask
$LN3@CreateMask:

; 1028 : 
; 1029 :     return TRUE;

	mov	eax, 1
$LN1@CreateMask:

; 1030 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_CreateMask@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Index$1 = -20						; size = 4
_Buffer$ = -16						; size = 4
_Column$2 = -12						; size = 4
_Row$3 = -8						; size = 4
_MaskValue$4 = -1					; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_Left$ = 20						; size = 4
_Top$ = 24						; size = 4
_Width$ = 28						; size = 4
_Height$ = 32						; size = 4
_BitOnValue$ = 36					; size = 1
_BitOffValue$ = 40					; size = 1
_CreateBitMask@36 PROC

; 930  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 931  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@CreateBitM

; 932  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@CreateBitM
$LN8@CreateBitM:

; 933  : 
; 934  :     BYTE* Buffer = (BYTE*)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 935  : 
; 936  :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@CreateBitM
$LN2@CreateBitM:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@CreateBitM:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _TargetHeight$[ebp]
	jge	SHORT $LN3@CreateBitM

; 937  :     {
; 938  :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@CreateBitM
$LN5@CreateBitM:
	mov	eax, DWORD PTR _Column$2[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$2[ebp], eax
$LN7@CreateBitM:
	mov	ecx, DWORD PTR _Column$2[ebp]
	cmp	ecx, DWORD PTR _TargetWidth$[ebp]
	jge	SHORT $LN6@CreateBitM

; 939  :         {
; 940  :             BYTE MaskValue = BitOnValue;

	mov	dl, BYTE PTR _BitOnValue$[ebp]
	mov	BYTE PTR _MaskValue$4[ebp], dl

; 941  :             if (Column < Left)

	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Left$[ebp]
	jge	SHORT $LN9@CreateBitM

; 942  :                 MaskValue = BitOffValue;

	mov	cl, BYTE PTR _BitOffValue$[ebp]
	mov	BYTE PTR _MaskValue$4[ebp], cl
$LN9@CreateBitM:

; 943  :             if (Column > Left + Width)

	mov	edx, DWORD PTR _Left$[ebp]
	add	edx, DWORD PTR _Width$[ebp]
	cmp	DWORD PTR _Column$2[ebp], edx
	jle	SHORT $LN10@CreateBitM

; 944  :                 MaskValue = BitOffValue;

	mov	al, BYTE PTR _BitOffValue$[ebp]
	mov	BYTE PTR _MaskValue$4[ebp], al
$LN10@CreateBitM:

; 945  :             if (Row < Top)

	mov	ecx, DWORD PTR _Row$3[ebp]
	cmp	ecx, DWORD PTR _Top$[ebp]
	jge	SHORT $LN11@CreateBitM

; 946  :                 MaskValue = BitOffValue;

	mov	dl, BYTE PTR _BitOffValue$[ebp]
	mov	BYTE PTR _MaskValue$4[ebp], dl
$LN11@CreateBitM:

; 947  :             if (Row > Top + Height)

	mov	eax, DWORD PTR _Top$[ebp]
	add	eax, DWORD PTR _Height$[ebp]
	cmp	DWORD PTR _Row$3[ebp], eax
	jle	SHORT $LN12@CreateBitM

; 948  :                 MaskValue = BitOffValue;

	mov	cl, BYTE PTR _BitOffValue$[ebp]
	mov	BYTE PTR _MaskValue$4[ebp], cl
$LN12@CreateBitM:

; 949  :             int Index = (Row * TargetHeight) + Column;

	mov	edx, DWORD PTR _Row$3[ebp]
	imul	edx, DWORD PTR _TargetHeight$[ebp]
	add	edx, DWORD PTR _Column$2[ebp]
	mov	DWORD PTR _Index$1[ebp], edx

; 950  :             Buffer[Index] = MaskValue;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$1[ebp]
	mov	cl, BYTE PTR _MaskValue$4[ebp]
	mov	BYTE PTR [eax], cl

; 951  : 
; 952  :         }

	jmp	SHORT $LN5@CreateBitM
$LN6@CreateBitM:

; 953  :     }

	jmp	$LN2@CreateBitM
$LN3@CreateBitM:

; 954  :     return TRUE;

	mov	eax, 1
$LN1@CreateBitM:

; 955  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_CreateBitMask@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_SourceBuffer$ = 8					; size = 4
_DestinationBuffer$ = 12				; size = 4
_BufferWidth$ = 16					; size = 4
_BufferHeight$ = 20					; size = 4
_BufferStride$ = 24					; size = 4
_X1$ = 28						; size = 4
_Y1$ = 32						; size = 4
_X2$ = 36						; size = 4
_Y2$ = 40						; size = 4
_CopyBufferRegion@36 PROC

; 2112 : {

	push	ebp
	mov	ebp, esp

; 2113 :     return CropBuffer2(SourceBuffer, DestinationBuffer, BufferWidth, BufferHeight, BufferStride, X1, Y1, X2, Y2);

	mov	eax, DWORD PTR _Y2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _X2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Y1$[ebp]
	push	edx
	mov	eax, DWORD PTR _X1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _BufferStride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _BufferHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _BufferWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _DestinationBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	push	edx
	call	_CropBuffer2@36

; 2114 : }

	pop	ebp
	ret	36					; 00000024H
_CopyBufferRegion@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_RowCount$ = -36					; size = 4
_Destination$ = -32					; size = 4
_SourceIndex$1 = -28					; size = 4
_Source$ = -24						; size = 4
_ElementWidth$ = -20					; size = 4
_PixelSize$ = -16					; size = 4
_DestRow$ = -12						; size = 4
_LineSize$ = -8						; size = 4
_Row$2 = -4						; size = 4
_SourceBuffer$ = 8					; size = 4
_DestinationBuffer$ = 12				; size = 4
_BufferWidth$ = 16					; size = 4
_BufferHeight$ = 20					; size = 4
_BufferStride$ = 24					; size = 4
_X1$ = 28						; size = 4
_Y1$ = 32						; size = 4
_X2$ = 36						; size = 4
_Y2$ = 40						; size = 4
_CropBuffer2@36 PROC

; 2052 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2053 :     if (SourceBuffer == NULL)

	cmp	DWORD PTR _SourceBuffer$[ebp], 0
	jne	SHORT $LN5@CropBuffer

; 2054 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CropBuffer
$LN5@CropBuffer:

; 2055 :     if (DestinationBuffer == NULL)

	cmp	DWORD PTR _DestinationBuffer$[ebp], 0
	jne	SHORT $LN6@CropBuffer

; 2056 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CropBuffer
$LN6@CropBuffer:

; 2057 :     if (X1 >= X2)

	mov	eax, DWORD PTR _X1$[ebp]
	cmp	eax, DWORD PTR _X2$[ebp]
	jl	SHORT $LN7@CropBuffer

; 2058 :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@CropBuffer
$LN7@CropBuffer:

; 2059 :     if (Y1 >= Y2)

	mov	ecx, DWORD PTR _Y1$[ebp]
	cmp	ecx, DWORD PTR _Y2$[ebp]
	jl	SHORT $LN8@CropBuffer

; 2060 :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@CropBuffer
$LN8@CropBuffer:

; 2061 :     if ((X1 < 0) || (Y1 < 0) || (X2 < 0) || (Y2 < 0))

	cmp	DWORD PTR _X1$[ebp], 0
	jl	SHORT $LN10@CropBuffer
	cmp	DWORD PTR _Y1$[ebp], 0
	jl	SHORT $LN10@CropBuffer
	cmp	DWORD PTR _X2$[ebp], 0
	jl	SHORT $LN10@CropBuffer
	cmp	DWORD PTR _Y2$[ebp], 0
	jge	SHORT $LN9@CropBuffer
$LN10@CropBuffer:

; 2062 :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@CropBuffer
$LN9@CropBuffer:

; 2063 :     if ((X1 > BufferWidth - 1) || (X2 > BufferWidth - 1))

	mov	edx, DWORD PTR _BufferWidth$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _X1$[ebp], edx
	jg	SHORT $LN12@CropBuffer
	mov	eax, DWORD PTR _BufferWidth$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _X2$[ebp], eax
	jle	SHORT $LN11@CropBuffer
$LN12@CropBuffer:

; 2064 :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@CropBuffer
$LN11@CropBuffer:

; 2065 :     if ((Y1 > BufferHeight - 1) || (Y2 > BufferHeight - 1))

	mov	ecx, DWORD PTR _BufferHeight$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Y1$[ebp], ecx
	jg	SHORT $LN14@CropBuffer
	mov	edx, DWORD PTR _BufferHeight$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _Y2$[ebp], edx
	jle	SHORT $LN13@CropBuffer
$LN14@CropBuffer:

; 2066 :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@CropBuffer
$LN13@CropBuffer:

; 2067 : 
; 2068 :     BYTE *Source = (BYTE *)SourceBuffer;

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 2069 :     BYTE *Destination = (BYTE *)DestinationBuffer;

	mov	ecx, DWORD PTR _DestinationBuffer$[ebp]
	mov	DWORD PTR _Destination$[ebp], ecx

; 2070 :     int RowCount = Y2 - Y1 + 1;

	mov	edx, DWORD PTR _Y2$[ebp]
	sub	edx, DWORD PTR _Y1$[ebp]
	add	edx, 1
	mov	DWORD PTR _RowCount$[ebp], edx

; 2071 :     int ElementWidth = X2 - X1 + 1;

	mov	eax, DWORD PTR _X2$[ebp]
	sub	eax, DWORD PTR _X1$[ebp]
	add	eax, 1
	mov	DWORD PTR _ElementWidth$[ebp], eax

; 2072 :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 2073 :     int LineSize = PixelSize * ElementWidth;

	mov	ecx, DWORD PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _ElementWidth$[ebp]
	mov	DWORD PTR _LineSize$[ebp], ecx

; 2074 :     if (LineSize > BufferStride)

	mov	edx, DWORD PTR _LineSize$[ebp]
	cmp	edx, DWORD PTR _BufferStride$[ebp]
	jle	SHORT $LN15@CropBuffer

; 2075 :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	SHORT $LN1@CropBuffer
$LN15@CropBuffer:

; 2076 : 
; 2077 : #if FALSE
; 2078 :     int DRow = 0;
; 2079 :     int DCol = 0;
; 2080 :     for (int Row = Y1; Row < Y1 + Y2; Row++)
; 2081 :     {
; 2082 :         int RowOffset = Row * BufferStride;
; 2083 :         int DestOffset = (Row + DRow) * BufferStride;
; 2084 :         for (int Column = X1; Column < X1 + X2; Column++)
; 2085 :         {
; 2086 :             int SourceIndex = (Column*PixelSize) + RowOffset;
; 2087 :             int DestIndex = (DCol*PixelSize) + DestOffset;
; 2088 :             DCol++;
; 2089 :             Destination[DestIndex + 0] = Source[SourceIndex + 0];
; 2090 :             Destination[DestIndex + 1] = Source[SourceIndex + 1];
; 2091 :             Destination[DestIndex + 2] = Source[SourceIndex + 2];
; 2092 :             Destination[DestIndex + 3] = Source[SourceIndex + 3];
; 2093 : }
; 2094 :         DCol++;
; 2095 :     }
; 2096 : #else
; 2097 :     int DestRow = 0;

	mov	DWORD PTR _DestRow$[ebp], 0

; 2098 :     for (int Row = Y1; Row < Y2 + 1; Row++)

	mov	eax, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _Row$2[ebp], eax
	jmp	SHORT $LN4@CropBuffer
$LN2@CropBuffer:
	mov	ecx, DWORD PTR _Row$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$2[ebp], ecx
$LN4@CropBuffer:
	mov	edx, DWORD PTR _Y2$[ebp]
	add	edx, 1
	cmp	DWORD PTR _Row$2[ebp], edx
	jge	SHORT $LN3@CropBuffer

; 2099 :     {
; 2100 :         int SourceIndex = (X1 * PixelSize) + (Row * BufferStride);

	mov	eax, DWORD PTR _X1$[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	mov	ecx, DWORD PTR _Row$2[ebp]
	imul	ecx, DWORD PTR _BufferStride$[ebp]
	add	eax, ecx
	mov	DWORD PTR _SourceIndex$1[ebp], eax

; 2101 :         memmove_s(Destination + (LineSize * DestRow), LineSize,

	mov	edx, DWORD PTR _LineSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _SourceIndex$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _LineSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _LineSize$[ebp]
	imul	edx, DWORD PTR _DestRow$[ebp]
	add	edx, DWORD PTR _Destination$[ebp]
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H

; 2102 :             Source + SourceIndex, LineSize);
; 2103 :         DestRow++;

	mov	eax, DWORD PTR _DestRow$[ebp]
	add	eax, 1
	mov	DWORD PTR _DestRow$[ebp], eax

; 2104 :     }

	jmp	SHORT $LN2@CropBuffer
$LN3@CropBuffer:

; 2105 : #endif
; 2106 : 
; 2107 :     return Success;

	xor	eax, eax
$LN1@CropBuffer:

; 2108 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_CropBuffer2@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_MaxValidTargetIndex$ = -44				; size = 4
_MaxValidSourceIndex$ = -40				; size = 4
_RowOffset$1 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_SourceBuffer$ = -28					; size = 4
_TargetBuffer$ = -24					; size = 4
_Column$2 = -20						; size = 4
_Region$ = -16						; size = 4
_Row$3 = -12						; size = 4
_Index$4 = -8						; size = 4
_TargetIndex$ = -4					; size = 4
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_Source$ = 24						; size = 4
_SourceWidth$ = 28					; size = 4
_SourceHeight$ = 32					; size = 4
_SourceStride$ = 36					; size = 4
_RegionPtr$ = 40					; size = 4
_CropBuffer@36 PROC

; 1323 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1324 :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@CropBuffer

; 1325 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CropBuffer
$LN8@CropBuffer:

; 1326 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN9@CropBuffer

; 1327 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CropBuffer
$LN9@CropBuffer:

; 1328 :     if (RegionPtr == NULL)

	cmp	DWORD PTR _RegionPtr$[ebp], 0
	jne	SHORT $LN10@CropBuffer

; 1329 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CropBuffer
$LN10@CropBuffer:

; 1330 : 
; 1331 :     RegionStruct* Region = (RegionStruct*)RegionPtr;

	mov	eax, DWORD PTR _RegionPtr$[ebp]
	mov	DWORD PTR _Region$[ebp], eax

; 1332 :     BYTE* TargetBuffer = (BYTE *)Target;

	mov	ecx, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _TargetBuffer$[ebp], ecx

; 1333 :     BYTE* SourceBuffer = (BYTE *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _SourceBuffer$[ebp], edx

; 1334 :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1335 :     UINT32 MaxValidTargetIndex = ((TargetWidth * TargetStride) * TargetHeight) - 1;

	mov	eax, DWORD PTR _TargetWidth$[ebp]
	imul	eax, DWORD PTR _TargetStride$[ebp]
	imul	eax, DWORD PTR _TargetHeight$[ebp]
	sub	eax, 1
	mov	DWORD PTR _MaxValidTargetIndex$[ebp], eax

; 1336 :     UINT32 MaxValidSourceIndex = ((SourceWidth * SourceHeight) * SourceStride) - 1;

	mov	ecx, DWORD PTR _SourceWidth$[ebp]
	imul	ecx, DWORD PTR _SourceHeight$[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _MaxValidSourceIndex$[ebp], ecx

; 1337 : 
; 1338 :     int TargetIndex = 0;

	mov	DWORD PTR _TargetIndex$[ebp], 0

; 1339 :     for (int Row = Region->Left; Row >= Region->Right; Row++)

	mov	edx, DWORD PTR _Region$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _Row$3[ebp], eax
	jmp	SHORT $LN4@CropBuffer
$LN2@CropBuffer:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@CropBuffer:
	mov	edx, DWORD PTR _Region$[ebp]
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jl	$LN3@CropBuffer

; 1340 :     {
; 1341 :         int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 1342 :         for (int Column = Region->Top; Column >= Region->Bottom; Column++)

	mov	edx, DWORD PTR _Region$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _Column$2[ebp], eax
	jmp	SHORT $LN7@CropBuffer
$LN5@CropBuffer:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@CropBuffer:
	mov	edx, DWORD PTR _Region$[ebp]
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jl	$LN6@CropBuffer

; 1343 :         {
; 1344 :             int Index = RowOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 1345 :             if ((UINT32)(Index + 3) > MaxValidSourceIndex)

	mov	edx, DWORD PTR _Index$4[ebp]
	add	edx, 3
	cmp	edx, DWORD PTR _MaxValidSourceIndex$[ebp]
	jbe	SHORT $LN11@CropBuffer

; 1346 :                 return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CropBuffer
$LN11@CropBuffer:

; 1347 :             if ((UINT32)(TargetIndex + 3) > MaxValidTargetIndex)

	mov	eax, DWORD PTR _TargetIndex$[ebp]
	add	eax, 3
	cmp	eax, DWORD PTR _MaxValidTargetIndex$[ebp]
	jbe	SHORT $LN12@CropBuffer

; 1348 :                 return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CropBuffer
$LN12@CropBuffer:

; 1349 :             TargetBuffer[TargetIndex++] = SourceBuffer[Index + 0];

	mov	ecx, DWORD PTR _TargetBuffer$[ebp]
	add	ecx, DWORD PTR _TargetIndex$[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _TargetIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _TargetIndex$[ebp], ecx

; 1350 :             TargetBuffer[TargetIndex++] = SourceBuffer[Index + 1];

	mov	edx, DWORD PTR _TargetBuffer$[ebp]
	add	edx, DWORD PTR _TargetIndex$[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _TargetIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _TargetIndex$[ebp], edx

; 1351 :             TargetBuffer[TargetIndex++] = SourceBuffer[Index + 2];

	mov	eax, DWORD PTR _TargetBuffer$[ebp]
	add	eax, DWORD PTR _TargetIndex$[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _TargetIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _TargetIndex$[ebp], eax

; 1352 :             TargetBuffer[TargetIndex++] = SourceBuffer[Index + 3];

	mov	ecx, DWORD PTR _TargetBuffer$[ebp]
	add	ecx, DWORD PTR _TargetIndex$[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _TargetIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _TargetIndex$[ebp], ecx

; 1353 :         }

	jmp	$LN5@CropBuffer
$LN6@CropBuffer:

; 1354 :     }

	jmp	$LN2@CropBuffer
$LN3@CropBuffer:

; 1355 : 
; 1356 :     return Success;

	xor	eax, eax
$LN1@CropBuffer:

; 1357 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_CropBuffer@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Luminance$1 = -80					; size = 8
tv68 = -72						; size = 8
_InvertBlue$ = -64					; size = 4
_InvertGreen$ = -60					; size = 4
_InvertRed$ = -56					; size = 4
_RowOffset$2 = -52					; size = 4
tv85 = -48						; size = 4
tv81 = -44						; size = 4
tv77 = -40						; size = 4
tv73 = -36						; size = 4
_InvertAlpha$ = -32					; size = 4
tv138 = -28						; size = 4
_Column$3 = -24						; size = 4
_Row$4 = -20						; size = 4
_Index$5 = -16						; size = 4
_Buffer$ = -12						; size = 4
_FinalLuminance$ = -6					; size = 1
_PixelSize$ = -5					; size = 1
_A$6 = -4						; size = 1
_B$7 = -3						; size = 1
_R$8 = -2						; size = 1
_G$9 = -1						; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_InversionOperation$ = 24				; size = 4
_LuminanceThreshold$ = 28				; size = 8
_InvertThreshold$ = 36					; size = 1
_AllowInvertAlpha$ = 40					; size = 1
_InversionChannels$ = 44				; size = 1
_BufferInverter@40 PROC

; 1965 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 1966 :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN10@BufferInve

; 1967 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@BufferInve
$LN10@BufferInve:

; 1968 : 
; 1969 :     BYTE* Buffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 1970 :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 1971 :     BYTE FinalLuminance = InvertThreshold ? 1.0 - LuminanceThreshold : LuminanceThreshold;

	movzx	ecx, BYTE PTR _InvertThreshold$[ebp]
	test	ecx, ecx
	je	SHORT $LN23@BufferInve
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _LuminanceThreshold$[ebp]
	movsd	QWORD PTR tv68[ebp], xmm0
	jmp	SHORT $LN24@BufferInve
$LN23@BufferInve:
	movsd	xmm0, QWORD PTR _LuminanceThreshold$[ebp]
	movsd	QWORD PTR tv68[ebp], xmm0
$LN24@BufferInve:
	cvttsd2si edx, QWORD PTR tv68[ebp]
	mov	BYTE PTR _FinalLuminance$[ebp], dl

; 1972 :     BOOL InvertAlpha = (InversionChannels & AlphaChannel) > 0 ? TRUE : FALSE;

	movzx	eax, BYTE PTR _InversionChannels$[ebp]
	and	eax, 1
	jle	SHORT $LN25@BufferInve
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN26@BufferInve
$LN25@BufferInve:
	mov	DWORD PTR tv73[ebp], 0
$LN26@BufferInve:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR _InvertAlpha$[ebp], ecx

; 1973 :     BOOL InvertRed = (InversionChannels & RedChannel) > 0 ? TRUE : FALSE;

	movzx	edx, BYTE PTR _InversionChannels$[ebp]
	and	edx, 2
	jle	SHORT $LN27@BufferInve
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN28@BufferInve
$LN27@BufferInve:
	mov	DWORD PTR tv77[ebp], 0
$LN28@BufferInve:
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR _InvertRed$[ebp], eax

; 1974 :     BOOL InvertGreen = (InversionChannels & GreenChannel) > 0 ? TRUE : FALSE;

	movzx	ecx, BYTE PTR _InversionChannels$[ebp]
	and	ecx, 4
	jle	SHORT $LN29@BufferInve
	mov	DWORD PTR tv81[ebp], 1
	jmp	SHORT $LN30@BufferInve
$LN29@BufferInve:
	mov	DWORD PTR tv81[ebp], 0
$LN30@BufferInve:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _InvertGreen$[ebp], edx

; 1975 :     BOOL InvertBlue = (InversionChannels & BlueChannel) > 0 ? TRUE : FALSE;

	movzx	eax, BYTE PTR _InversionChannels$[ebp]
	and	eax, 8
	jle	SHORT $LN31@BufferInve
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN32@BufferInve
$LN31@BufferInve:
	mov	DWORD PTR tv85[ebp], 0
$LN32@BufferInve:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR _InvertBlue$[ebp], ecx

; 1976 : 
; 1977 :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@BufferInve
$LN2@BufferInve:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@BufferInve:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _TargetHeight$[ebp]
	jge	$LN3@BufferInve

; 1978 :     {
; 1979 :         int RowOffset = Row * TargetStride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 1980 :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@BufferInve
$LN5@BufferInve:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@BufferInve:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _TargetWidth$[ebp]
	jge	$LN6@BufferInve

; 1981 :         {
; 1982 :             int Index = RowOffset + (Column * PixelSize);

	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 1983 :             BYTE A = Buffer[Index + 3];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$6[ebp], al

; 1984 :             BYTE R = Buffer[Index + 2];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$8[ebp], dl

; 1985 :             BYTE G = Buffer[Index + 1];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$9[ebp], cl

; 1986 :             BYTE B = Buffer[Index + 0];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$7[ebp], al

; 1987 :             double Luminance = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Luminance$1[ebp], xmm0

; 1988 :             switch (InversionOperation)

	mov	ecx, DWORD PTR _InversionOperation$[ebp]
	mov	DWORD PTR tv138[ebp], ecx
	cmp	DWORD PTR tv138[ebp], 0
	je	SHORT $LN11@BufferInve
	cmp	DWORD PTR tv138[ebp], 1
	je	$LN18@BufferInve
	cmp	DWORD PTR tv138[ebp], 2
	je	SHORT $LN13@BufferInve
	jmp	$LN21@BufferInve
$LN11@BufferInve:

; 1989 :             {
; 1990 :                 case SimpleInvertOperation:
; 1991 :                     R = 255 - R;

	movzx	edx, BYTE PTR _R$8[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _R$8[ebp], al

; 1992 :                     G = 255 - G;

	movzx	ecx, BYTE PTR _G$9[ebp]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	BYTE PTR _G$9[ebp], dl

; 1993 :                     B = 255 - G;

	movzx	eax, BYTE PTR _G$9[ebp]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	BYTE PTR _B$7[ebp], cl

; 1994 :                     if (InvertAlpha)

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN12@BufferInve

; 1995 :                         A = 255 - A;

	movzx	edx, BYTE PTR _A$6[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _A$6[ebp], al
$LN12@BufferInve:

; 1996 :                     break;

	jmp	$LN8@BufferInve
$LN13@BufferInve:

; 1997 : 
; 1998 :                 case ChannelInversionOperation:
; 1999 :                     if ((InvertAlpha) && (AllowInvertAlpha))

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN14@BufferInve
	movzx	ecx, BYTE PTR _AllowInvertAlpha$[ebp]
	test	ecx, ecx
	je	SHORT $LN14@BufferInve

; 2000 :                         A = 255 - A;

	movzx	edx, BYTE PTR _A$6[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _A$6[ebp], al
$LN14@BufferInve:

; 2001 :                     if (InvertRed)

	cmp	DWORD PTR _InvertRed$[ebp], 0
	je	SHORT $LN15@BufferInve

; 2002 :                         R = 255 - R;

	movzx	ecx, BYTE PTR _R$8[ebp]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	BYTE PTR _R$8[ebp], dl
$LN15@BufferInve:

; 2003 :                     if (InvertGreen)

	cmp	DWORD PTR _InvertGreen$[ebp], 0
	je	SHORT $LN16@BufferInve

; 2004 :                         G = 255 - G;

	movzx	eax, BYTE PTR _G$9[ebp]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	BYTE PTR _G$9[ebp], cl
$LN16@BufferInve:

; 2005 :                     if (InvertBlue)

	cmp	DWORD PTR _InvertBlue$[ebp], 0
	je	SHORT $LN17@BufferInve

; 2006 :                         B = 255 - B;

	movzx	edx, BYTE PTR _B$7[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _B$7[ebp], al
$LN17@BufferInve:

; 2007 :                     break;

	jmp	SHORT $LN8@BufferInve
$LN18@BufferInve:

; 2008 : 
; 2009 :                 case VariableInvertOperation:
; 2010 :                     Luminance = PixelLuminance(R, G, B);

	movzx	ecx, BYTE PTR _B$7[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$9[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$8[ebp]
	push	eax
	call	?PixelLuminance@@YGNEEE@Z		; PixelLuminance
	fstp	QWORD PTR _Luminance$1[ebp]

; 2011 :                     if (Luminance > FinalLuminance)

	movzx	ecx, BYTE PTR _FinalLuminance$[ebp]
	cvtsi2sd xmm0, ecx
	movsd	xmm1, QWORD PTR _Luminance$1[ebp]
	comisd	xmm1, xmm0
	jbe	SHORT $LN20@BufferInve

; 2012 :                     {
; 2013 :                         R = 255 - R;

	movzx	edx, BYTE PTR _R$8[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _R$8[ebp], al

; 2014 :                         G = 255 - G;

	movzx	ecx, BYTE PTR _G$9[ebp]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	BYTE PTR _G$9[ebp], dl

; 2015 :                         B = 255 - B;

	movzx	eax, BYTE PTR _B$7[ebp]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	BYTE PTR _B$7[ebp], cl

; 2016 :                         if (InvertAlpha)

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN20@BufferInve

; 2017 :                             A = 255 - A;

	movzx	edx, BYTE PTR _A$6[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _A$6[ebp], al
$LN20@BufferInve:

; 2018 :                     }
; 2019 :                     break;

	jmp	SHORT $LN8@BufferInve
$LN21@BufferInve:

; 2020 : 
; 2021 :                 default:
; 2022 :                     return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@BufferInve
$LN8@BufferInve:

; 2023 :             }
; 2024 :             Buffer[Index + 0] = B;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR [ecx], dl

; 2025 :             Buffer[Index + 1] = G;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR [eax+1], cl

; 2026 :             Buffer[Index + 2] = R;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _R$8[ebp]
	mov	BYTE PTR [edx+2], al

; 2027 :             Buffer[Index + 3] = A;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _A$6[ebp]
	mov	BYTE PTR [ecx+3], dl

; 2028 :         }

	jmp	$LN5@BufferInve
$LN6@BufferInve:

; 2029 :     }

	jmp	$LN2@BufferInve
$LN3@BufferInve:

; 2030 : 
; 2031 :     return Success;

	xor	eax, eax
$LN1@BufferInve:

; 2032 : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_BufferInverter@40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Luminance$1 = -52					; size = 8
tv69 = -44						; size = 8
_RowOffset$2 = -36					; size = 4
tv91 = -32						; size = 4
_Dest$ = -28						; size = 4
_Src$ = -24						; size = 4
_Column$3 = -20						; size = 4
_Row$4 = -16						; size = 4
_Index$5 = -12						; size = 4
_FinalLuminance$ = -6					; size = 1
_PixelSize$ = -5					; size = 1
_A$6 = -4						; size = 1
_R$7 = -3						; size = 1
_G$8 = -2						; size = 1
_B$9 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_InversionOperation$ = 28				; size = 4
_LuminanceThreshold$ = 32				; size = 8
_InvertThreshold$ = 40					; size = 1
_InvertAlpha$ = 44					; size = 4
_InvertRed$ = 48					; size = 4
_InvertGreen$ = 52					; size = 4
_InvertBlue$ = 56					; size = 4
_BufferInverter2@52 PROC

; 1880 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 1881 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN10@BufferInve

; 1882 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@BufferInve
$LN10@BufferInve:

; 1883 :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN11@BufferInve

; 1884 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@BufferInve
$LN11@BufferInve:

; 1885 : 
; 1886 :     BYTE* Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1887 :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1888 :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 1889 :     BYTE FinalLuminance = InvertThreshold ? 1.0 - LuminanceThreshold : LuminanceThreshold;

	movzx	edx, BYTE PTR _InvertThreshold$[ebp]
	test	edx, edx
	je	SHORT $LN24@BufferInve
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _LuminanceThreshold$[ebp]
	movsd	QWORD PTR tv69[ebp], xmm0
	jmp	SHORT $LN25@BufferInve
$LN24@BufferInve:
	movsd	xmm0, QWORD PTR _LuminanceThreshold$[ebp]
	movsd	QWORD PTR tv69[ebp], xmm0
$LN25@BufferInve:
	cvttsd2si eax, QWORD PTR tv69[ebp]
	mov	BYTE PTR _FinalLuminance$[ebp], al

; 1890 : 
; 1891 :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@BufferInve
$LN2@BufferInve:
	mov	ecx, DWORD PTR _Row$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$4[ebp], ecx
$LN4@BufferInve:
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	$LN3@BufferInve

; 1892 :     {
; 1893 :         int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], eax

; 1894 :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@BufferInve
$LN5@BufferInve:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@BufferInve:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	$LN6@BufferInve

; 1895 :         {
; 1896 :             int Index = RowOffset + (Column * PixelSize);

	movzx	eax, BYTE PTR _PixelSize$[ebp]
	imul	eax, DWORD PTR _Column$3[ebp]
	add	eax, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], eax

; 1897 :             BYTE A = Src[Index + 3];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR _A$6[ebp], dl

; 1898 :             BYTE R = Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _R$7[ebp], cl

; 1899 :             BYTE G = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _G$8[ebp], al

; 1900 :             BYTE B = Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _B$9[ebp], dl

; 1901 : 
; 1902 :             switch (InversionOperation)

	mov	eax, DWORD PTR _InversionOperation$[ebp]
	mov	DWORD PTR tv91[ebp], eax
	cmp	DWORD PTR tv91[ebp], 0
	je	SHORT $LN12@BufferInve
	cmp	DWORD PTR tv91[ebp], 1
	je	SHORT $LN19@BufferInve
	cmp	DWORD PTR tv91[ebp], 2
	je	SHORT $LN14@BufferInve
	jmp	$LN22@BufferInve
$LN12@BufferInve:

; 1903 :             {
; 1904 :                 case SimpleInvertOperation:
; 1905 :                     R = ~R;

	movzx	ecx, BYTE PTR _R$7[ebp]
	not	ecx
	mov	BYTE PTR _R$7[ebp], cl

; 1906 :                     G = ~G;

	movzx	edx, BYTE PTR _G$8[ebp]
	not	edx
	mov	BYTE PTR _G$8[ebp], dl

; 1907 :                     B = ~B;

	movzx	eax, BYTE PTR _B$9[ebp]
	not	eax
	mov	BYTE PTR _B$9[ebp], al

; 1908 :                     if (InvertAlpha)

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN13@BufferInve

; 1909 :                         A = ~A;

	movzx	ecx, BYTE PTR _A$6[ebp]
	not	ecx
	mov	BYTE PTR _A$6[ebp], cl
$LN13@BufferInve:

; 1910 :                     break;

	jmp	$LN8@BufferInve
$LN14@BufferInve:

; 1911 : 
; 1912 :                 case ChannelInversionOperation:
; 1913 :                     if (InvertAlpha)

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN15@BufferInve

; 1914 :                         A = ~A;

	movzx	edx, BYTE PTR _A$6[ebp]
	not	edx
	mov	BYTE PTR _A$6[ebp], dl
$LN15@BufferInve:

; 1915 :                     if (InvertRed)

	cmp	DWORD PTR _InvertRed$[ebp], 0
	je	SHORT $LN16@BufferInve

; 1916 :                         R = ~R;

	movzx	eax, BYTE PTR _R$7[ebp]
	not	eax
	mov	BYTE PTR _R$7[ebp], al
$LN16@BufferInve:

; 1917 :                     if (InvertGreen)

	cmp	DWORD PTR _InvertGreen$[ebp], 0
	je	SHORT $LN17@BufferInve

; 1918 :                         G = ~G;

	movzx	ecx, BYTE PTR _G$8[ebp]
	not	ecx
	mov	BYTE PTR _G$8[ebp], cl
$LN17@BufferInve:

; 1919 :                     if (InvertBlue)

	cmp	DWORD PTR _InvertBlue$[ebp], 0
	je	SHORT $LN18@BufferInve

; 1920 :                         B = ~B;

	movzx	edx, BYTE PTR _B$9[ebp]
	not	edx
	mov	BYTE PTR _B$9[ebp], dl
$LN18@BufferInve:

; 1921 :                     break;

	jmp	SHORT $LN8@BufferInve
$LN19@BufferInve:

; 1922 : 
; 1923 :                 case VariableInvertOperation:
; 1924 :                 {
; 1925 :                     //Functionally same as solarization
; 1926 :                     double Luminance = PixelLuminance(R, G, B);

	movzx	eax, BYTE PTR _B$9[ebp]
	push	eax
	movzx	ecx, BYTE PTR _G$8[ebp]
	push	ecx
	movzx	edx, BYTE PTR _R$7[ebp]
	push	edx
	call	?PixelLuminance@@YGNEEE@Z		; PixelLuminance
	fstp	QWORD PTR _Luminance$1[ebp]

; 1927 :                     if (Luminance > FinalLuminance)

	movzx	eax, BYTE PTR _FinalLuminance$[ebp]
	cvtsi2sd xmm0, eax
	movsd	xmm1, QWORD PTR _Luminance$1[ebp]
	comisd	xmm1, xmm0
	jbe	SHORT $LN21@BufferInve

; 1928 :                     {
; 1929 :                         R = ~R;

	movzx	ecx, BYTE PTR _R$7[ebp]
	not	ecx
	mov	BYTE PTR _R$7[ebp], cl

; 1930 :                         G = ~G;

	movzx	edx, BYTE PTR _G$8[ebp]
	not	edx
	mov	BYTE PTR _G$8[ebp], dl

; 1931 :                         B = ~B;

	movzx	eax, BYTE PTR _B$9[ebp]
	not	eax
	mov	BYTE PTR _B$9[ebp], al

; 1932 :                         if (InvertAlpha)

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN21@BufferInve

; 1933 :                             A = ~A;

	movzx	ecx, BYTE PTR _A$6[ebp]
	not	ecx
	mov	BYTE PTR _A$6[ebp], cl
$LN21@BufferInve:

; 1934 :                     }
; 1935 :                 }
; 1936 :                 break;

	jmp	SHORT $LN8@BufferInve
$LN22@BufferInve:

; 1937 : 
; 1938 :                 default:
; 1939 :                     return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@BufferInve
$LN8@BufferInve:

; 1940 :             }
; 1941 :             Dest[Index + 0] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [edx], al

; 1942 :             Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1943 :             Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [eax+2], cl

; 1944 :             Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _A$6[ebp]
	mov	BYTE PTR [edx+3], al

; 1945 :         }

	jmp	$LN5@BufferInve
$LN6@BufferInve:

; 1946 :     }

	jmp	$LN2@BufferInve
$LN3@BufferInve:

; 1947 : 
; 1948 :     return Success;

	xor	eax, eax
$LN1@BufferInve:

; 1949 : }

	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
_BufferInverter2@52 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_RowOffset$1 = -32					; size = 4
_Dest$ = -28						; size = 4
_Src$ = -24						; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Index$4 = -12						; size = 4
_PixelSize$ = -5					; size = 1
_A$5 = -4						; size = 1
_R$6 = -3						; size = 1
_G$7 = -2						; size = 1
_B$8 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_InvertAlpha$ = 28					; size = 4
_BufferInverter3@24 PROC

; 1831 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1832 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@BufferInve

; 1833 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@BufferInve
$LN8@BufferInve:

; 1834 :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@BufferInve

; 1835 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@BufferInve
$LN9@BufferInve:

; 1836 : 
; 1837 :     BYTE* Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1838 :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1839 :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 1840 : 
; 1841 :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@BufferInve
$LN2@BufferInve:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@BufferInve:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@BufferInve

; 1842 :     {
; 1843 :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 1844 :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@BufferInve
$LN5@BufferInve:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@BufferInve:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@BufferInve

; 1845 :         {
; 1846 :             int Index = RowOffset + (Column * PixelSize);

	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 1847 :             BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$5[ebp], al

; 1848 :             BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$6[ebp], dl

; 1849 :             BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$7[ebp], cl

; 1850 :             BYTE B = Src[Index + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$8[ebp], al

; 1851 :             R = ~R;

	movzx	ecx, BYTE PTR _R$6[ebp]
	not	ecx
	mov	BYTE PTR _R$6[ebp], cl

; 1852 :             G = ~G;

	movzx	edx, BYTE PTR _G$7[ebp]
	not	edx
	mov	BYTE PTR _G$7[ebp], dl

; 1853 :             B = ~B;

	movzx	eax, BYTE PTR _B$8[ebp]
	not	eax
	mov	BYTE PTR _B$8[ebp], al

; 1854 :             if (InvertAlpha)

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN10@BufferInve

; 1855 :                 A = ~A;

	movzx	ecx, BYTE PTR _A$5[ebp]
	not	ecx
	mov	BYTE PTR _A$5[ebp], cl
$LN10@BufferInve:

; 1856 :             Dest[Index + 0] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _B$8[ebp]
	mov	BYTE PTR [edx], al

; 1857 :             Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _G$7[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1858 :             Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _R$6[ebp]
	mov	BYTE PTR [eax+2], cl

; 1859 :             Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _A$5[ebp]
	mov	BYTE PTR [edx+3], al

; 1860 :         }

	jmp	$LN5@BufferInve
$LN6@BufferInve:

; 1861 :     }

	jmp	$LN2@BufferInve
$LN3@BufferInve:

; 1862 :     return Success;

	xor	eax, eax
$LN1@BufferInve:

; 1863 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_BufferInverter3@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_RowOffset$1 = -32					; size = 4
_Dest$ = -28						; size = 4
_Src$ = -24						; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Index$4 = -12						; size = 4
_PixelSize$ = -5					; size = 1
_A$5 = -4						; size = 1
_R$6 = -3						; size = 1
_G$7 = -2						; size = 1
_B$8 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_InvertAlpha$ = 28					; size = 4
_InvertRed$ = 32					; size = 4
_InvertGreen$ = 36					; size = 4
_InvertBlue$ = 40					; size = 4
_UseAlphaThreshold$ = 44				; size = 4
_AlphaThreshold$ = 48					; size = 1
_UseRedThreshold$ = 52					; size = 4
_RedThreshold$ = 56					; size = 1
_UseGreenThreshold$ = 60				; size = 4
_GreenThreshold$ = 64					; size = 1
_UseBlueThreshold$ = 68					; size = 4
_BlueThreshold$ = 72					; size = 1
_BufferInverter4@68 PROC

; 1752 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1753 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@BufferInve

; 1754 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@BufferInve
$LN8@BufferInve:

; 1755 :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@BufferInve

; 1756 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@BufferInve
$LN9@BufferInve:

; 1757 : 
; 1758 :     BYTE* Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1759 :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1760 :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 1761 : 
; 1762 :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@BufferInve
$LN2@BufferInve:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@BufferInve:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@BufferInve

; 1763 :     {
; 1764 :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 1765 :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@BufferInve
$LN5@BufferInve:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@BufferInve:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@BufferInve

; 1766 :         {
; 1767 :             int Index = RowOffset + (Column * PixelSize);

	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 1768 :             BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$5[ebp], al

; 1769 :             BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$6[ebp], dl

; 1770 :             BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$7[ebp], cl

; 1771 :             BYTE B = Src[Index + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$8[ebp], al

; 1772 :             if (InvertRed)

	cmp	DWORD PTR _InvertRed$[ebp], 0
	je	SHORT $LN10@BufferInve

; 1773 :             {
; 1774 :                 if (UseRedThreshold)

	cmp	DWORD PTR _UseRedThreshold$[ebp], 0
	je	SHORT $LN11@BufferInve

; 1775 :                 {
; 1776 :                     if (R > RedThreshold)

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _RedThreshold$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN13@BufferInve

; 1777 :                         R = ~R;

	movzx	eax, BYTE PTR _R$6[ebp]
	not	eax
	mov	BYTE PTR _R$6[ebp], al
$LN13@BufferInve:

; 1778 :                 }
; 1779 :                 else

	jmp	SHORT $LN10@BufferInve
$LN11@BufferInve:

; 1780 :                     R = ~R;

	movzx	ecx, BYTE PTR _R$6[ebp]
	not	ecx
	mov	BYTE PTR _R$6[ebp], cl
$LN10@BufferInve:

; 1781 :             }
; 1782 :             if (InvertGreen)

	cmp	DWORD PTR _InvertGreen$[ebp], 0
	je	SHORT $LN14@BufferInve

; 1783 :             {
; 1784 :                 if (UseGreenThreshold)

	cmp	DWORD PTR _UseGreenThreshold$[ebp], 0
	je	SHORT $LN15@BufferInve

; 1785 :                 {
; 1786 :                     if (G > GreenThreshold)

	movzx	edx, BYTE PTR _G$7[ebp]
	movzx	eax, BYTE PTR _GreenThreshold$[ebp]
	cmp	edx, eax
	jle	SHORT $LN17@BufferInve

; 1787 :                         G = ~G;

	movzx	ecx, BYTE PTR _G$7[ebp]
	not	ecx
	mov	BYTE PTR _G$7[ebp], cl
$LN17@BufferInve:

; 1788 :                 }
; 1789 :                 else

	jmp	SHORT $LN14@BufferInve
$LN15@BufferInve:

; 1790 :                     G = ~G;

	movzx	edx, BYTE PTR _G$7[ebp]
	not	edx
	mov	BYTE PTR _G$7[ebp], dl
$LN14@BufferInve:

; 1791 :             }
; 1792 :             if (InvertBlue)

	cmp	DWORD PTR _InvertBlue$[ebp], 0
	je	SHORT $LN18@BufferInve

; 1793 :             {
; 1794 :                 if (UseBlueThreshold)

	cmp	DWORD PTR _UseBlueThreshold$[ebp], 0
	je	SHORT $LN19@BufferInve

; 1795 :                 {
; 1796 :                     if (B > BlueThreshold)

	movzx	eax, BYTE PTR _B$8[ebp]
	movzx	ecx, BYTE PTR _BlueThreshold$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN21@BufferInve

; 1797 :                         B = ~B;

	movzx	edx, BYTE PTR _B$8[ebp]
	not	edx
	mov	BYTE PTR _B$8[ebp], dl
$LN21@BufferInve:

; 1798 :                 }
; 1799 :                 else

	jmp	SHORT $LN18@BufferInve
$LN19@BufferInve:

; 1800 :                     B = ~B;

	movzx	eax, BYTE PTR _B$8[ebp]
	not	eax
	mov	BYTE PTR _B$8[ebp], al
$LN18@BufferInve:

; 1801 :             }
; 1802 :             if (InvertAlpha)

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN22@BufferInve

; 1803 :             {
; 1804 :                 if (UseAlphaThreshold)

	cmp	DWORD PTR _UseAlphaThreshold$[ebp], 0
	je	SHORT $LN23@BufferInve

; 1805 :                 {
; 1806 :                     if (A > AlphaThreshold)

	movzx	ecx, BYTE PTR _A$5[ebp]
	movzx	edx, BYTE PTR _AlphaThreshold$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN23@BufferInve

; 1807 :                         A = ~A;

	movzx	eax, BYTE PTR _A$5[ebp]
	not	eax
	mov	BYTE PTR _A$5[ebp], al
$LN23@BufferInve:

; 1808 :                 }
; 1809 :                 A = ~A;

	movzx	ecx, BYTE PTR _A$5[ebp]
	not	ecx
	mov	BYTE PTR _A$5[ebp], cl
$LN22@BufferInve:

; 1810 :             }
; 1811 :             Dest[Index + 0] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _B$8[ebp]
	mov	BYTE PTR [edx], al

; 1812 :             Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _G$7[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1813 :             Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _R$6[ebp]
	mov	BYTE PTR [eax+2], cl

; 1814 :             Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _A$5[ebp]
	mov	BYTE PTR [edx+3], al

; 1815 :         }

	jmp	$LN5@BufferInve
$LN6@BufferInve:

; 1816 :     }

	jmp	$LN2@BufferInve
$LN3@BufferInve:

; 1817 :     return Success;

	xor	eax, eax
$LN1@BufferInve:

; 1818 : }

	mov	esp, ebp
	pop	ebp
	ret	68					; 00000044H
_BufferInverter4@68 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Luminance$1 = -44					; size = 8
_Ratio$2 = -36						; size = 8
_RowOffset$3 = -28					; size = 4
_Column$4 = -24						; size = 4
_Row$5 = -20						; size = 4
_Index$6 = -16						; size = 4
_Buffer$ = -12						; size = 4
_NewAlpha$7 = -6					; size = 1
_R$ = -5						; size = 1
_G$ = -4						; size = 1
_B$ = -3						; size = 1
_PixelSize$ = -2					; size = 1
_A$ = -1						; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_Invert$ = 24						; size = 4
_UseExistingAlpha$ = 28					; size = 4
_SetAlphaByBrightness@24 PROC

; 1400 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1401 :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@SetAlphaBy

; 1402 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@SetAlphaBy
$LN8@SetAlphaBy:

; 1403 : 
; 1404 :     BYTE* Buffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 1405 :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 1406 :     BYTE A, R, G, B;
; 1407 : 
; 1408 :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN4@SetAlphaBy
$LN2@SetAlphaBy:
	mov	ecx, DWORD PTR _Row$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$5[ebp], ecx
$LN4@SetAlphaBy:
	mov	edx, DWORD PTR _Row$5[ebp]
	cmp	edx, DWORD PTR _TargetHeight$[ebp]
	jge	$LN3@SetAlphaBy

; 1409 :     {
; 1410 :         int RowOffset = Row * TargetStride;

	mov	eax, DWORD PTR _Row$5[ebp]
	imul	eax, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], eax

; 1411 :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$4[ebp], 0
	jmp	SHORT $LN7@SetAlphaBy
$LN5@SetAlphaBy:
	mov	ecx, DWORD PTR _Column$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$4[ebp], ecx
$LN7@SetAlphaBy:
	mov	edx, DWORD PTR _Column$4[ebp]
	cmp	edx, DWORD PTR _TargetWidth$[ebp]
	jge	$LN6@SetAlphaBy

; 1412 :         {
; 1413 :             int Index = RowOffset + (Column * PixelSize);

	movzx	eax, BYTE PTR _PixelSize$[ebp]
	imul	eax, DWORD PTR _Column$4[ebp]
	add	eax, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$6[ebp], eax

; 1414 :             B = Buffer[Index + 0];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _B$[ebp], dl

; 1415 :             G = Buffer[Index + 1];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$[ebp], cl

; 1416 :             R = Buffer[Index + 2];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$[ebp], al

; 1417 :             A = Buffer[Index + 3];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR _A$[ebp], dl

; 1418 :             double Luminance = PixelLuminance(R, G, B);

	movzx	eax, BYTE PTR _B$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _G$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _R$[ebp]
	push	edx
	call	?PixelLuminance@@YGNEEE@Z		; PixelLuminance
	fstp	QWORD PTR _Luminance$1[ebp]

; 1419 :             double Ratio = Luminance / 255.0;

	movsd	xmm0, QWORD PTR _Luminance$1[ebp]
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _Ratio$2[ebp], xmm0

; 1420 :             if (Invert)

	cmp	DWORD PTR _Invert$[ebp], 0
	je	SHORT $LN9@SetAlphaBy

; 1421 :                 Ratio = 1.0 - Ratio;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _Ratio$2[ebp]
	movsd	QWORD PTR _Ratio$2[ebp], xmm0
$LN9@SetAlphaBy:

; 1422 :             BYTE NewAlpha = 0;

	mov	BYTE PTR _NewAlpha$7[ebp], 0

; 1423 :             if (UseExistingAlpha)

	cmp	DWORD PTR _UseExistingAlpha$[ebp], 0
	je	SHORT $LN10@SetAlphaBy

; 1424 :                 A = (BYTE)((double)A*Ratio);

	movzx	eax, BYTE PTR _A$[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _Ratio$2[ebp]
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _A$[ebp], cl

; 1425 :             else

	jmp	SHORT $LN11@SetAlphaBy
$LN10@SetAlphaBy:

; 1426 :                 A = (BYTE)(255.0 * Ratio);

	movsd	xmm0, QWORD PTR __real@406fe00000000000
	mulsd	xmm0, QWORD PTR _Ratio$2[ebp]
	cvttsd2si edx, xmm0
	mov	BYTE PTR _A$[ebp], dl
$LN11@SetAlphaBy:

; 1427 :             Buffer[Index + 3] = A;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [eax+3], cl

; 1428 :         }

	jmp	$LN5@SetAlphaBy
$LN6@SetAlphaBy:

; 1429 :     }

	jmp	$LN2@SetAlphaBy
$LN3@SetAlphaBy:

; 1430 : 
; 1431 :     return Success;

	xor	eax, eax
$LN1@SetAlphaBy:

; 1432 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_SetAlphaByBrightness@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Index$1 = -24						; size = 4
_Buffer$ = -20						; size = 4
_RowOffset$2 = -16					; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_PixelSize$ = -1					; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_NewAlpha$ = 24						; size = 1
_SetAlpha@20 PROC

; 1369 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1370 :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@SetAlpha

; 1371 :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@SetAlpha
$LN8@SetAlpha:

; 1372 : 
; 1373 :     BYTE* Buffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 1374 :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 1375 : 
; 1376 :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@SetAlpha
$LN2@SetAlpha:
	mov	ecx, DWORD PTR _Row$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$4[ebp], ecx
$LN4@SetAlpha:
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _TargetHeight$[ebp]
	jge	SHORT $LN3@SetAlpha

; 1377 :     {
; 1378 :         int RowOffset = Row * TargetStride;

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], eax

; 1379 :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@SetAlpha
$LN5@SetAlpha:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@SetAlpha:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _TargetWidth$[ebp]
	jge	SHORT $LN6@SetAlpha

; 1380 :         {
; 1381 :             int Index = RowOffset + (Column * PixelSize) + 3;

	movzx	eax, BYTE PTR _PixelSize$[ebp]
	imul	eax, DWORD PTR _Column$3[ebp]
	mov	ecx, DWORD PTR _RowOffset$2[ebp]
	lea	edx, DWORD PTR [ecx+eax+3]
	mov	DWORD PTR _Index$1[ebp], edx

; 1382 :             Buffer[Index + 3] = NewAlpha;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$1[ebp]
	mov	cl, BYTE PTR _NewAlpha$[ebp]
	mov	BYTE PTR [eax+3], cl

; 1383 :         }

	jmp	SHORT $LN5@SetAlpha
$LN6@SetAlpha:

; 1384 :     }

	jmp	SHORT $LN2@SetAlpha
$LN3@SetAlpha:

; 1385 : 
; 1386 :     return Success;

	xor	eax, eax
$LN1@SetAlpha:

; 1387 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetAlpha@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_InvertedAlpha$1 = -96					; size = 8
_FAlpha$2 = -88						; size = 8
_PlaneOffset$3 = -80					; size = 4
_BufferRowOffset$4 = -76				; size = 4
_CollectResults$ = -72					; size = 4
_PixelSize$ = -68					; size = 4
tv189 = -64						; size = 4
tv180 = -60						; size = 4
tv171 = -56						; size = 4
tv163 = -52						; size = 4
_PlaneIndex$5 = -48					; size = 4
_PlaneBuffer$6 = -44					; size = 4
_BufferIndex$7 = -40					; size = 4
_Buffer$ = -36						; size = 4
_Column$8 = -32						; size = 4
_Row$9 = -28						; size = 4
_ObjResults$ = -24					; size = 4
_Planes$ = -20						; size = 4
_BlobIndex$10 = -16					; size = 4
_FinalRed$11 = -11					; size = 1
_FinalGreen$12 = -10					; size = 1
_FinalBlue$13 = -9					; size = 1
_BGRed$14 = -8						; size = 1
_FGRed$15 = -7						; size = 1
_BGGreen$16 = -6					; size = 1
_FGGreen$17 = -5					; size = 1
_BGBlue$18 = -4						; size = 1
_FGBlue$19 = -3						; size = 1
_FGAlpha$20 = -2					; size = 1
tv68 = -1						; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_PlaneSet$ = 24						; size = 4
_PlaneCount$ = 28					; size = 4
_Results$ = 32						; size = 4
_MergePlanes4@28 PROC

; 778  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	esi

; 779  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN11@MergePlane

; 780  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MergePlane
$LN11@MergePlane:

; 781  :     if (PlaneSet == NULL)

	cmp	DWORD PTR _PlaneSet$[ebp], 0
	jne	SHORT $LN12@MergePlane

; 782  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MergePlane
$LN12@MergePlane:

; 783  :     if (PlaneCount < 1)

	cmp	DWORD PTR _PlaneCount$[ebp], 1
	jge	SHORT $LN13@MergePlane

; 784  :         return Error;

	mov	eax, 1
	jmp	$LN1@MergePlane
$LN13@MergePlane:

; 785  :     BOOL CollectResults = Results == NULL ? false : true;

	cmp	DWORD PTR _Results$[ebp], 0
	jne	SHORT $LN21@MergePlane
	mov	BYTE PTR tv68[ebp], 0
	jmp	SHORT $LN22@MergePlane
$LN21@MergePlane:
	mov	BYTE PTR tv68[ebp], 1
$LN22@MergePlane:
	movzx	eax, BYTE PTR tv68[ebp]
	mov	DWORD PTR _CollectResults$[ebp], eax

; 786  : 
; 787  :     BYTE* Buffer = (BYTE*)Target;

	mov	ecx, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], ecx

; 788  :     PlaneSetStruct *Planes = (PlaneSetStruct *)PlaneSet;

	mov	edx, DWORD PTR _PlaneSet$[ebp]
	mov	DWORD PTR _Planes$[ebp], edx

; 789  :     DrawnObject* ObjResults = (DrawnObject *)Results;

	mov	eax, DWORD PTR _Results$[ebp]
	mov	DWORD PTR _ObjResults$[ebp], eax

; 790  :     __int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 791  : 
; 792  :     for (int BlobIndex = 0; BlobIndex < PlaneCount; BlobIndex++)

	mov	DWORD PTR _BlobIndex$10[ebp], 0
	jmp	SHORT $LN4@MergePlane
$LN2@MergePlane:
	mov	ecx, DWORD PTR _BlobIndex$10[ebp]
	add	ecx, 1
	mov	DWORD PTR _BlobIndex$10[ebp], ecx
$LN4@MergePlane:
	mov	edx, DWORD PTR _BlobIndex$10[ebp]
	cmp	edx, DWORD PTR _PlaneCount$[ebp]
	jge	$LN3@MergePlane

; 793  :     {
; 794  :         if (CollectResults)

	cmp	DWORD PTR _CollectResults$[ebp], 0
	je	$LN14@MergePlane

; 795  :         {
; 796  :             ObjResults[BlobIndex].IsValid = TRUE;

	mov	eax, DWORD PTR _BlobIndex$10[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _ObjResults$[ebp]
	mov	DWORD PTR [ecx+eax], 1

; 797  :             ObjResults[BlobIndex].TargetHeight = TargetHeight;

	mov	edx, DWORD PTR _BlobIndex$10[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _ObjResults$[ebp]
	mov	ecx, DWORD PTR _TargetHeight$[ebp]
	mov	DWORD PTR [eax+edx+56], ecx

; 798  :             ObjResults[BlobIndex].TargetWidth = TargetWidth;

	mov	edx, DWORD PTR _BlobIndex$10[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _ObjResults$[ebp]
	mov	ecx, DWORD PTR _TargetWidth$[ebp]
	mov	DWORD PTR [eax+edx+52], ecx

; 799  :             ObjResults[BlobIndex].TargetStride = TargetStride;

	mov	edx, DWORD PTR _BlobIndex$10[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _ObjResults$[ebp]
	mov	ecx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR [eax+edx+60], ecx

; 800  :             ObjResults[BlobIndex].ObjectOrder = BlobIndex;

	mov	edx, DWORD PTR _BlobIndex$10[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _ObjResults$[ebp]
	mov	ecx, DWORD PTR _BlobIndex$10[ebp]
	mov	DWORD PTR [eax+edx+4], ecx

; 801  :             ObjResults[BlobIndex].X1 = Planes[BlobIndex].Left;

	imul	edx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	eax, DWORD PTR _BlobIndex$10[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _ObjResults$[ebp]
	mov	esi, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR [esi+edx+28]
	mov	DWORD PTR [ecx+eax+8], edx

; 802  :             ObjResults[BlobIndex].Y1 = Planes[BlobIndex].Top;

	imul	eax, DWORD PTR _BlobIndex$10[ebp], 48
	mov	ecx, DWORD PTR _BlobIndex$10[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _ObjResults$[ebp]
	mov	esi, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR [esi+eax+32]
	mov	DWORD PTR [edx+ecx+12], eax

; 803  :             ObjResults[BlobIndex].X2 = Planes[BlobIndex].Right;

	imul	ecx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	edx, DWORD PTR _BlobIndex$10[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _ObjResults$[ebp]
	mov	esi, DWORD PTR _Planes$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+36]
	mov	DWORD PTR [eax+edx+16], ecx

; 804  :             ObjResults[BlobIndex].Y2 = Planes[BlobIndex].Bottom;

	imul	edx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	eax, DWORD PTR _BlobIndex$10[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _ObjResults$[ebp]
	mov	esi, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR [esi+edx+40]
	mov	DWORD PTR [ecx+eax+20], edx

; 805  :             ObjResults[BlobIndex].Width = Planes[BlobIndex].Width;

	imul	eax, DWORD PTR _BlobIndex$10[ebp], 48
	mov	ecx, DWORD PTR _BlobIndex$10[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _ObjResults$[ebp]
	mov	esi, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR [esi+eax+8]
	mov	DWORD PTR [edx+ecx+28], eax

; 806  :             ObjResults[BlobIndex].Height = Planes[BlobIndex].Height;

	imul	ecx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	edx, DWORD PTR _BlobIndex$10[ebp]
	shl	edx, 6
	mov	eax, DWORD PTR _ObjResults$[ebp]
	mov	esi, DWORD PTR _Planes$[ebp]
	mov	ecx, DWORD PTR [esi+ecx+12]
	mov	DWORD PTR [eax+edx+24], ecx

; 807  :             ObjResults[BlobIndex].LeftOut = Planes[BlobIndex].Left < 0 ? TRUE : FALSE;

	imul	edx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	eax, DWORD PTR _Planes$[ebp]
	cmp	DWORD PTR [eax+edx+28], 0
	jge	SHORT $LN23@MergePlane
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN24@MergePlane
$LN23@MergePlane:
	mov	DWORD PTR tv163[ebp], 0
$LN24@MergePlane:
	mov	ecx, DWORD PTR _BlobIndex$10[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _ObjResults$[ebp]
	mov	eax, DWORD PTR tv163[ebp]
	mov	DWORD PTR [edx+ecx+36], eax

; 808  :             ObjResults[BlobIndex].TopOut = Planes[BlobIndex].Top < 0 ? TRUE : FALSE;

	imul	ecx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	cmp	DWORD PTR [edx+ecx+32], 0
	jge	SHORT $LN25@MergePlane
	mov	DWORD PTR tv171[ebp], 1
	jmp	SHORT $LN26@MergePlane
$LN25@MergePlane:
	mov	DWORD PTR tv171[ebp], 0
$LN26@MergePlane:
	mov	eax, DWORD PTR _BlobIndex$10[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _ObjResults$[ebp]
	mov	edx, DWORD PTR tv171[ebp]
	mov	DWORD PTR [ecx+eax+40], edx

; 809  :             ObjResults[BlobIndex].RightOut = Planes[BlobIndex].Right > TargetWidth - 1 ? TRUE : FALSE;

	imul	eax, DWORD PTR _BlobIndex$10[ebp], 48
	mov	ecx, DWORD PTR _TargetWidth$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _Planes$[ebp]
	cmp	DWORD PTR [edx+eax+36], ecx
	jle	SHORT $LN27@MergePlane
	mov	DWORD PTR tv180[ebp], 1
	jmp	SHORT $LN28@MergePlane
$LN27@MergePlane:
	mov	DWORD PTR tv180[ebp], 0
$LN28@MergePlane:
	mov	eax, DWORD PTR _BlobIndex$10[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _ObjResults$[ebp]
	mov	edx, DWORD PTR tv180[ebp]
	mov	DWORD PTR [ecx+eax+44], edx

; 810  :             ObjResults[BlobIndex].BottomOut = Planes[BlobIndex].Bottom > TargetHeight - 1 ? TRUE : FALSE;

	imul	eax, DWORD PTR _BlobIndex$10[ebp], 48
	mov	ecx, DWORD PTR _TargetHeight$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _Planes$[ebp]
	cmp	DWORD PTR [edx+eax+40], ecx
	jle	SHORT $LN29@MergePlane
	mov	DWORD PTR tv189[ebp], 1
	jmp	SHORT $LN30@MergePlane
$LN29@MergePlane:
	mov	DWORD PTR tv189[ebp], 0
$LN30@MergePlane:
	mov	eax, DWORD PTR _BlobIndex$10[ebp]
	shl	eax, 6
	mov	ecx, DWORD PTR _ObjResults$[ebp]
	mov	edx, DWORD PTR tv189[ebp]
	mov	DWORD PTR [ecx+eax+48], edx
$LN14@MergePlane:

; 811  :         }
; 812  : 
; 813  :         //Get a pointer to the plane's bits.
; 814  :         BYTE *PlaneBuffer = (BYTE *)Planes[BlobIndex].TheBits;

	imul	eax, DWORD PTR _BlobIndex$10[ebp], 48
	mov	ecx, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR [ecx+eax+44]
	mov	DWORD PTR _PlaneBuffer$6[ebp], edx

; 815  : 
; 816  :         for (int Row = 0; Row < Planes[BlobIndex].Height; Row++)

	mov	DWORD PTR _Row$9[ebp], 0
	jmp	SHORT $LN7@MergePlane
$LN5@MergePlane:
	mov	eax, DWORD PTR _Row$9[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$9[ebp], eax
$LN7@MergePlane:
	imul	ecx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _Row$9[ebp]
	cmp	eax, DWORD PTR [edx+ecx+12]
	jge	$LN6@MergePlane

; 817  :         {
; 818  :             if (Row + Planes[BlobIndex].Top < 0)

	imul	ecx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _Row$9[ebp]
	add	eax, DWORD PTR [edx+ecx+32]
	jns	SHORT $LN15@MergePlane

; 819  :                 continue;

	jmp	SHORT $LN5@MergePlane
$LN15@MergePlane:

; 820  :             if (Row + Planes[BlobIndex].Top > TargetHeight - 1)

	imul	ecx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _Row$9[ebp]
	add	eax, DWORD PTR [edx+ecx+32]
	mov	ecx, DWORD PTR _TargetHeight$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN16@MergePlane

; 821  :                 continue;

	jmp	SHORT $LN5@MergePlane
$LN16@MergePlane:

; 822  : 
; 823  :             UINT32 BufferRowOffset = (Row + Planes[BlobIndex].Top) * TargetStride;

	imul	edx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	eax, DWORD PTR _Planes$[ebp]
	mov	ecx, DWORD PTR _Row$9[ebp]
	add	ecx, DWORD PTR [eax+edx+32]
	imul	ecx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _BufferRowOffset$4[ebp], ecx

; 824  :             UINT32 PlaneOffset = (Row * Planes[BlobIndex].Stride);

	imul	edx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	eax, DWORD PTR _Planes$[ebp]
	mov	ecx, DWORD PTR _Row$9[ebp]
	imul	ecx, DWORD PTR [eax+edx+16]
	mov	DWORD PTR _PlaneOffset$3[ebp], ecx

; 825  :             for (int Column = 0; Column < Planes[BlobIndex].Width; Column++)

	mov	DWORD PTR _Column$8[ebp], 0
	jmp	SHORT $LN10@MergePlane
$LN8@MergePlane:
	mov	edx, DWORD PTR _Column$8[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$8[ebp], edx
$LN10@MergePlane:
	imul	eax, DWORD PTR _BlobIndex$10[ebp], 48
	mov	ecx, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR _Column$8[ebp]
	cmp	edx, DWORD PTR [ecx+eax+8]
	jge	$LN9@MergePlane

; 826  :             {
; 827  :                 if (Column + Planes[BlobIndex].Left > TargetWidth - 1)

	imul	eax, DWORD PTR _BlobIndex$10[ebp], 48
	mov	ecx, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR _Column$8[ebp]
	add	edx, DWORD PTR [ecx+eax+28]
	mov	eax, DWORD PTR _TargetWidth$[ebp]
	sub	eax, 1
	cmp	edx, eax
	jle	SHORT $LN17@MergePlane

; 828  :                     continue;

	jmp	SHORT $LN8@MergePlane
$LN17@MergePlane:

; 829  :                 if (Column + Planes[BlobIndex].Left < 0)

	imul	ecx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _Column$8[ebp]
	add	eax, DWORD PTR [edx+ecx+28]
	jns	SHORT $LN18@MergePlane

; 830  :                     continue;

	jmp	SHORT $LN8@MergePlane
$LN18@MergePlane:

; 831  : 
; 832  :                 UINT32 BufferIndex = BufferRowOffset + ((Column + Planes[BlobIndex].Left) * PixelSize);

	imul	ecx, DWORD PTR _BlobIndex$10[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _Column$8[ebp]
	add	eax, DWORD PTR [edx+ecx+28]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _BufferRowOffset$4[ebp]
	mov	DWORD PTR _BufferIndex$7[ebp], eax

; 833  :                 UINT32 PlaneIndex = PlaneOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$8[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _PlaneOffset$3[ebp]
	mov	DWORD PTR _PlaneIndex$5[ebp], ecx

; 834  : 
; 835  :                 BYTE FGBlue = PlaneBuffer[PlaneIndex + 0];

	mov	edx, DWORD PTR _PlaneBuffer$6[ebp]
	add	edx, DWORD PTR _PlaneIndex$5[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _FGBlue$19[ebp], al

; 836  :                 BYTE FGGreen = PlaneBuffer[PlaneIndex + 1];

	mov	ecx, DWORD PTR _PlaneBuffer$6[ebp]
	add	ecx, DWORD PTR _PlaneIndex$5[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _FGGreen$17[ebp], dl

; 837  :                 BYTE FGRed = PlaneBuffer[PlaneIndex + 2];

	mov	eax, DWORD PTR _PlaneBuffer$6[ebp]
	add	eax, DWORD PTR _PlaneIndex$5[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _FGRed$15[ebp], cl

; 838  :                 BYTE FGAlpha = PlaneBuffer[PlaneIndex + 3];

	mov	edx, DWORD PTR _PlaneBuffer$6[ebp]
	add	edx, DWORD PTR _PlaneIndex$5[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _FGAlpha$20[ebp], al

; 839  :                 //If there's nothing to draw skip calculations and buffer assignment and move to the next pixel.
; 840  :                 if (FGAlpha == 0x0)

	movzx	ecx, BYTE PTR _FGAlpha$20[ebp]
	test	ecx, ecx
	jne	SHORT $LN19@MergePlane

; 841  :                     continue;

	jmp	$LN8@MergePlane
$LN19@MergePlane:

; 842  :                 BYTE BGBlue = Buffer[BufferIndex + 0];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _BufferIndex$7[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _BGBlue$18[ebp], al

; 843  :                 BYTE BGGreen = Buffer[BufferIndex + 1];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _BufferIndex$7[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _BGGreen$16[ebp], dl

; 844  :                 BYTE BGRed = Buffer[BufferIndex + 2];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _BufferIndex$7[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _BGRed$14[ebp], cl

; 845  :                 //BYTE BGAlpha = Buffer[BufferIndex + 3];
; 846  :                 double FAlpha = (double)FGAlpha / 255.0;

	movzx	edx, BYTE PTR _FGAlpha$20[ebp]
	cvtsi2sd xmm0, edx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _FAlpha$2[ebp], xmm0

; 847  :                 double InvertedAlpha = 1.0 - FAlpha;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _FAlpha$2[ebp]
	movsd	QWORD PTR _InvertedAlpha$1[ebp], xmm0

; 848  :                 BYTE FinalBlue = (BYTE)(FAlpha * FGBlue) + (BYTE)(InvertedAlpha * BGBlue);

	movzx	eax, BYTE PTR _FGBlue$19[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _FAlpha$2[ebp]
	cvttsd2si ecx, xmm0
	movzx	edx, cl
	movzx	eax, BYTE PTR _BGBlue$18[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _InvertedAlpha$1[ebp]
	cvttsd2si ecx, xmm0
	movzx	eax, cl
	add	edx, eax
	mov	BYTE PTR _FinalBlue$13[ebp], dl

; 849  :                 BYTE FinalGreen = (BYTE)(FAlpha * FGGreen) + (BYTE)(InvertedAlpha * BGGreen);

	movzx	ecx, BYTE PTR _FGGreen$17[ebp]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR _FAlpha$2[ebp]
	cvttsd2si edx, xmm0
	movzx	eax, dl
	movzx	ecx, BYTE PTR _BGGreen$16[ebp]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR _InvertedAlpha$1[ebp]
	cvttsd2si edx, xmm0
	movzx	ecx, dl
	add	eax, ecx
	mov	BYTE PTR _FinalGreen$12[ebp], al

; 850  :                 BYTE FinalRed = (BYTE)(FAlpha * FGRed) + (BYTE)(InvertedAlpha * BGRed);

	movzx	edx, BYTE PTR _FGRed$15[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR _FAlpha$2[ebp]
	cvttsd2si eax, xmm0
	movzx	ecx, al
	movzx	edx, BYTE PTR _BGRed$14[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR _InvertedAlpha$1[ebp]
	cvttsd2si eax, xmm0
	movzx	edx, al
	add	ecx, edx
	mov	BYTE PTR _FinalRed$11[ebp], cl

; 851  :                 Buffer[BufferIndex + 0] = FinalBlue;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _BufferIndex$7[ebp]
	mov	cl, BYTE PTR _FinalBlue$13[ebp]
	mov	BYTE PTR [eax], cl

; 852  :                 Buffer[BufferIndex + 1] = FinalGreen;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _BufferIndex$7[ebp]
	mov	al, BYTE PTR _FinalGreen$12[ebp]
	mov	BYTE PTR [edx+1], al

; 853  :                 Buffer[BufferIndex + 2] = FinalRed;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _BufferIndex$7[ebp]
	mov	dl, BYTE PTR _FinalRed$11[ebp]
	mov	BYTE PTR [ecx+2], dl

; 854  :                 Buffer[BufferIndex + 3] = 0xff;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _BufferIndex$7[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH

; 855  :             }

	jmp	$LN8@MergePlane
$LN9@MergePlane:

; 856  :         }

	jmp	$LN5@MergePlane
$LN6@MergePlane:

; 857  :     }

	jmp	$LN2@MergePlane
$LN3@MergePlane:

; 858  : 
; 859  :     return Success;

	xor	eax, eax
$LN1@MergePlane:

; 860  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_MergePlanes4@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_PlaneRowOffset$1 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_PlaneColumn$2 = -32					; size = 4
_Planes$ = -28						; size = 4
_PlaneRow$3 = -24					; size = 4
_TargetIndex$4 = -20					; size = 4
_Buffer$ = -16						; size = 4
_PlanePixelIndex$5 = -12				; size = 4
_PlaneBuffer$6 = -8					; size = 4
_PlaneIndex$7 = -4					; size = 4
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_PlaneSet$ = 24						; size = 4
_PlaneCount$ = 28					; size = 4
_MergePlanes3@24 PROC

; 873  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi

; 874  :     if (PlaneCount < 1)

	cmp	DWORD PTR _PlaneCount$[ebp], 1
	jge	SHORT $LN11@MergePlane

; 875  :         return Error;

	mov	eax, 1
	jmp	$LN1@MergePlane
$LN11@MergePlane:

; 876  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN12@MergePlane

; 877  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MergePlane
$LN12@MergePlane:

; 878  :     if (PlaneSet == NULL)

	cmp	DWORD PTR _PlaneSet$[ebp], 0
	jne	SHORT $LN13@MergePlane

; 879  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MergePlane
$LN13@MergePlane:

; 880  : 
; 881  :     BYTE* Buffer = (BYTE*)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 882  :     PlaneSetStruct *Planes = (PlaneSetStruct *)PlaneSet;

	mov	ecx, DWORD PTR _PlaneSet$[ebp]
	mov	DWORD PTR _Planes$[ebp], ecx

; 883  :     __int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 884  : 
; 885  :     for (int PlaneIndex = 0; PlaneIndex < PlaneCount; PlaneIndex++)

	mov	DWORD PTR _PlaneIndex$7[ebp], 0
	jmp	SHORT $LN4@MergePlane
$LN2@MergePlane:
	mov	edx, DWORD PTR _PlaneIndex$7[ebp]
	add	edx, 1
	mov	DWORD PTR _PlaneIndex$7[ebp], edx
$LN4@MergePlane:
	mov	eax, DWORD PTR _PlaneIndex$7[ebp]
	cmp	eax, DWORD PTR _PlaneCount$[ebp]
	jge	$LN3@MergePlane

; 886  :     {
; 887  :         int PlanePixelIndex = 0;

	mov	DWORD PTR _PlanePixelIndex$5[ebp], 0

; 888  :         BYTE *PlaneBuffer = (BYTE *)Planes[PlaneIndex].TheBits;

	imul	ecx, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR [edx+ecx+44]
	mov	DWORD PTR _PlaneBuffer$6[ebp], eax

; 889  :         for (int PlaneRow = Planes[PlaneIndex].Top; PlaneRow < Planes[PlaneIndex].Bottom; PlaneRow++)

	imul	ecx, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR [edx+ecx+32]
	mov	DWORD PTR _PlaneRow$3[ebp], eax
	jmp	SHORT $LN7@MergePlane
$LN5@MergePlane:
	mov	ecx, DWORD PTR _PlaneRow$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _PlaneRow$3[ebp], ecx
$LN7@MergePlane:
	imul	edx, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	eax, DWORD PTR _Planes$[ebp]
	mov	ecx, DWORD PTR _PlaneRow$3[ebp]
	cmp	ecx, DWORD PTR [eax+edx+40]
	jge	$LN6@MergePlane

; 890  :         {
; 891  :             if (PlaneRow < 0)

	cmp	DWORD PTR _PlaneRow$3[ebp], 0
	jge	SHORT $LN14@MergePlane

; 892  :                 continue;

	jmp	SHORT $LN5@MergePlane
$LN14@MergePlane:

; 893  :             if (PlaneRow > TargetHeight - 1)

	mov	edx, DWORD PTR _TargetHeight$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _PlaneRow$3[ebp], edx
	jle	SHORT $LN15@MergePlane

; 894  :                 continue;

	jmp	SHORT $LN5@MergePlane
$LN15@MergePlane:

; 895  :             int PlaneRowOffset = PlaneRow * Planes[PlaneIndex].Stride;

	imul	eax, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	ecx, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR _PlaneRow$3[ebp]
	imul	edx, DWORD PTR [ecx+eax+16]
	mov	DWORD PTR _PlaneRowOffset$1[ebp], edx

; 896  :             for (int PlaneColumn = Planes[PlaneIndex].Left; PlaneColumn < Planes[PlaneIndex].Right; PlaneColumn++)

	imul	eax, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	ecx, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR [ecx+eax+28]
	mov	DWORD PTR _PlaneColumn$2[ebp], edx
	jmp	SHORT $LN10@MergePlane
$LN8@MergePlane:
	mov	eax, DWORD PTR _PlaneColumn$2[ebp]
	add	eax, 1
	mov	DWORD PTR _PlaneColumn$2[ebp], eax
$LN10@MergePlane:
	imul	ecx, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _PlaneColumn$2[ebp]
	cmp	eax, DWORD PTR [edx+ecx+36]
	jge	$LN9@MergePlane

; 897  :             {
; 898  :                 if (PlaneColumn < 0)

	cmp	DWORD PTR _PlaneColumn$2[ebp], 0
	jge	SHORT $LN16@MergePlane

; 899  :                     continue;

	jmp	SHORT $LN8@MergePlane
$LN16@MergePlane:

; 900  :                 if (PlaneColumn > TargetWidth - 1)

	mov	ecx, DWORD PTR _TargetWidth$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _PlaneColumn$2[ebp], ecx
	jle	SHORT $LN17@MergePlane

; 901  :                     continue;

	jmp	SHORT $LN8@MergePlane
$LN17@MergePlane:

; 902  :                 int TargetIndex = PlaneRowOffset + (PlaneColumn * PixelSize);

	mov	edx, DWORD PTR _PlaneColumn$2[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _PlaneRowOffset$1[ebp]
	mov	DWORD PTR _TargetIndex$4[ebp], edx

; 903  :                 //Merge plane pixel with target pixel.
; 904  :                 // Final = FG + BG * (1[0xff] - FG(alpha))
; 905  :                 Buffer[TargetIndex + 0] = PlaneBuffer[PlanePixelIndex + 0] + (Buffer[TargetIndex + 0] * (255 - PlaneBuffer[PlanePixelIndex]));

	mov	eax, DWORD PTR _PlaneBuffer$6[ebp]
	add	eax, DWORD PTR _PlanePixelIndex$5[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _TargetIndex$4[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	edx, DWORD PTR _PlaneBuffer$6[ebp]
	add	edx, DWORD PTR _PlanePixelIndex$5[ebp]
	movzx	edx, BYTE PTR [edx]
	mov	esi, 255				; 000000ffH
	sub	esi, edx
	imul	eax, esi
	add	ecx, eax
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _TargetIndex$4[ebp]
	mov	BYTE PTR [eax], cl

; 906  :                 Buffer[TargetIndex + 1] = PlaneBuffer[PlanePixelIndex + 1] + (Buffer[TargetIndex + 1] * (255 - PlaneBuffer[PlanePixelIndex]));

	mov	ecx, DWORD PTR _PlaneBuffer$6[ebp]
	add	ecx, DWORD PTR _PlanePixelIndex$5[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _TargetIndex$4[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	eax, DWORD PTR _PlaneBuffer$6[ebp]
	add	eax, DWORD PTR _PlanePixelIndex$5[ebp]
	movzx	eax, BYTE PTR [eax]
	mov	esi, 255				; 000000ffH
	sub	esi, eax
	imul	ecx, esi
	add	edx, ecx
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _TargetIndex$4[ebp]
	mov	BYTE PTR [ecx+1], dl

; 907  :                 Buffer[TargetIndex + 2] = PlaneBuffer[PlanePixelIndex + 2] + (Buffer[TargetIndex + 2] * (255 - PlaneBuffer[PlanePixelIndex]));

	mov	edx, DWORD PTR _PlaneBuffer$6[ebp]
	add	edx, DWORD PTR _PlanePixelIndex$5[ebp]
	movzx	eax, BYTE PTR [edx+2]
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _TargetIndex$4[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	mov	ecx, DWORD PTR _PlaneBuffer$6[ebp]
	add	ecx, DWORD PTR _PlanePixelIndex$5[ebp]
	movzx	ecx, BYTE PTR [ecx]
	mov	esi, 255				; 000000ffH
	sub	esi, ecx
	imul	edx, esi
	add	eax, edx
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _TargetIndex$4[ebp]
	mov	BYTE PTR [edx+2], al

; 908  :                 Buffer[TargetIndex + 3] = PlaneBuffer[PlanePixelIndex + 3] + (Buffer[TargetIndex + 3] * (255 - PlaneBuffer[PlanePixelIndex]));

	mov	eax, DWORD PTR _PlaneBuffer$6[ebp]
	add	eax, DWORD PTR _PlanePixelIndex$5[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _TargetIndex$4[ebp]
	movzx	eax, BYTE PTR [edx+3]
	mov	edx, DWORD PTR _PlaneBuffer$6[ebp]
	add	edx, DWORD PTR _PlanePixelIndex$5[ebp]
	movzx	edx, BYTE PTR [edx]
	mov	esi, 255				; 000000ffH
	sub	esi, edx
	imul	eax, esi
	add	ecx, eax
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _TargetIndex$4[ebp]
	mov	BYTE PTR [eax+3], cl

; 909  :             }

	jmp	$LN8@MergePlane
$LN9@MergePlane:

; 910  :         }

	jmp	$LN5@MergePlane
$LN6@MergePlane:

; 911  :     }

	jmp	$LN2@MergePlane
$LN3@MergePlane:

; 912  : 
; 913  :     return Success;

	xor	eax, eax
$LN1@MergePlane:

; 914  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_MergePlanes3@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Final$1 = -84						; size = 32
_RowOffset$2 = -52					; size = 4
_PixelSize$ = -48					; size = 4
_Index$3 = -44						; size = 4
_Buffer$ = -40						; size = 4
_OverlapCount$4 = -36					; size = 4
_PlaneBuffer$5 = -32					; size = 4
_Column$6 = -28						; size = 4
_Row$7 = -24						; size = 4
_Planes$ = -20						; size = 4
_PlanePixelIndex$8 = -16				; size = 4
_BlobIndex$9 = -12					; size = 4
_FinalA$10 = -5						; size = 1
_FinalR$11 = -4						; size = 1
_FinalG$12 = -3						; size = 1
_FinalB$13 = -2						; size = 1
_MaxAlpha$14 = -1					; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_PlaneSet$ = 24						; size = 4
_PlaneCount$ = 28					; size = 4
_MergePlanes2@24 PROC

; 673  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 674  :     if (PlaneCount < 1)

	cmp	DWORD PTR _PlaneCount$[ebp], 1
	jge	SHORT $LN11@MergePlane

; 675  :         return Error;

	mov	eax, 1
	jmp	$LN1@MergePlane
$LN11@MergePlane:

; 676  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN12@MergePlane

; 677  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MergePlane
$LN12@MergePlane:

; 678  :     if (PlaneSet == NULL)

	cmp	DWORD PTR _PlaneSet$[ebp], 0
	jne	SHORT $LN13@MergePlane

; 679  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MergePlane
$LN13@MergePlane:

; 680  : 
; 681  :     BYTE* Buffer = (BYTE*)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 682  :     PlaneSetStruct *Planes = (PlaneSetStruct *)PlaneSet;

	mov	ecx, DWORD PTR _PlaneSet$[ebp]
	mov	DWORD PTR _Planes$[ebp], ecx

; 683  :     __int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 684  : 
; 685  :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$7[ebp], 0
	jmp	SHORT $LN4@MergePlane
$LN2@MergePlane:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN4@MergePlane:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _TargetHeight$[ebp]
	jge	$LN3@MergePlane

; 686  :     {
; 687  :         int RowOffset = Row * TargetStride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 688  :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$6[ebp], 0
	jmp	SHORT $LN7@MergePlane
$LN5@MergePlane:
	mov	edx, DWORD PTR _Column$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$6[ebp], edx
$LN7@MergePlane:
	mov	eax, DWORD PTR _Column$6[ebp]
	cmp	eax, DWORD PTR _TargetWidth$[ebp]
	jge	$LN6@MergePlane

; 689  :         {
; 690  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$6[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$3[ebp], ecx

; 691  :             int OverlapCount = 0;

	mov	DWORD PTR _OverlapCount$4[ebp], 0

; 692  :             double Final[] = { 0.0, 0.0, 0.0, 0.0 };

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp+8], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp+16], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp+24], xmm0

; 693  :             BYTE MaxAlpha = 0;

	mov	BYTE PTR _MaxAlpha$14[ebp], 0

; 694  :             for (int BlobIndex = 0; BlobIndex < PlaneCount; BlobIndex++)

	mov	DWORD PTR _BlobIndex$9[ebp], 0
	jmp	SHORT $LN10@MergePlane
$LN8@MergePlane:
	mov	edx, DWORD PTR _BlobIndex$9[ebp]
	add	edx, 1
	mov	DWORD PTR _BlobIndex$9[ebp], edx
$LN10@MergePlane:
	mov	eax, DWORD PTR _BlobIndex$9[ebp]
	cmp	eax, DWORD PTR _PlaneCount$[ebp]
	jge	$LN9@MergePlane

; 695  :             {
; 696  :                 //Don't draw planes that are fully not within the view port.
; 697  :                 if (Row < Planes[BlobIndex].Top)

	imul	ecx, DWORD PTR _BlobIndex$9[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR [edx+ecx+32]
	jge	SHORT $LN14@MergePlane

; 698  :                     continue;

	jmp	SHORT $LN8@MergePlane
$LN14@MergePlane:

; 699  :                 if (Row > Planes[BlobIndex].Bottom)

	imul	ecx, DWORD PTR _BlobIndex$9[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR [edx+ecx+40]
	jle	SHORT $LN15@MergePlane

; 700  :                     continue;

	jmp	SHORT $LN8@MergePlane
$LN15@MergePlane:

; 701  :                 if (Column < Planes[BlobIndex].Left)

	imul	ecx, DWORD PTR _BlobIndex$9[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _Column$6[ebp]
	cmp	eax, DWORD PTR [edx+ecx+28]
	jge	SHORT $LN16@MergePlane

; 702  :                     continue;

	jmp	SHORT $LN8@MergePlane
$LN16@MergePlane:

; 703  :                 if (Column > Planes[BlobIndex].Right)

	imul	ecx, DWORD PTR _BlobIndex$9[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _Column$6[ebp]
	cmp	eax, DWORD PTR [edx+ecx+36]
	jle	SHORT $LN17@MergePlane

; 704  :                     continue;

	jmp	SHORT $LN8@MergePlane
$LN17@MergePlane:

; 705  : 
; 706  :                 //Accumulate color blob point intersection data.
; 707  :                 int PlanePixelIndex = (Row - Planes[BlobIndex].Top) * Planes[BlobIndex].Stride;

	imul	ecx, DWORD PTR _BlobIndex$9[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _Row$7[ebp]
	sub	eax, DWORD PTR [edx+ecx+32]
	imul	ecx, DWORD PTR _BlobIndex$9[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	imul	eax, DWORD PTR [edx+ecx+16]
	mov	DWORD PTR _PlanePixelIndex$8[ebp], eax

; 708  :                 PlanePixelIndex += (Column - Planes[BlobIndex].Left) * PixelSize;

	imul	eax, DWORD PTR _BlobIndex$9[ebp], 48
	mov	ecx, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR _Column$6[ebp]
	sub	edx, DWORD PTR [ecx+eax+28]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _PlanePixelIndex$8[ebp]
	mov	DWORD PTR _PlanePixelIndex$8[ebp], edx

; 709  :                 BYTE *PlaneBuffer = (BYTE *)Planes[BlobIndex].TheBits;

	imul	eax, DWORD PTR _BlobIndex$9[ebp], 48
	mov	ecx, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR [ecx+eax+44]
	mov	DWORD PTR _PlaneBuffer$5[ebp], edx

; 710  :                 if (PlaneBuffer[PlanePixelIndex + 3] > MaxAlpha)

	mov	eax, DWORD PTR _PlaneBuffer$5[ebp]
	add	eax, DWORD PTR _PlanePixelIndex$8[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	movzx	edx, BYTE PTR _MaxAlpha$14[ebp]
	cmp	ecx, edx
	jle	SHORT $LN18@MergePlane

; 711  :                     MaxAlpha = PlaneBuffer[PlanePixelIndex + 3];

	mov	eax, DWORD PTR _PlaneBuffer$5[ebp]
	add	eax, DWORD PTR _PlanePixelIndex$8[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR _MaxAlpha$14[ebp], cl
$LN18@MergePlane:

; 712  : #if TRUE
; 713  :                 if (
; 714  :                     //                    (PlaneBuffer[PlanePixelIndex + 0] == 0x0) &&
; 715  :                     //                    (PlaneBuffer[PlanePixelIndex + 1] == 0x0) &&
; 716  :                     //                    (PlaneBuffer[PlanePixelIndex + 2] == 0x0) &&
; 717  :                     (PlaneBuffer[PlanePixelIndex + 3] == 0x0)

	mov	edx, DWORD PTR _PlaneBuffer$5[ebp]
	add	edx, DWORD PTR _PlanePixelIndex$8[ebp]
	movzx	eax, BYTE PTR [edx+3]
	test	eax, eax
	jne	SHORT $LN19@MergePlane

; 718  :                     )
; 719  :                     continue;

	jmp	$LN8@MergePlane
$LN19@MergePlane:

; 720  : #endif
; 721  : #if FALSE
; 722  :                 double ARatio = (double)PlaneBuffer[PlanePixelIndex + 3] / 255.0;
; 723  :                 Final[0] += ((double)PlaneBuffer[PlanePixelIndex + 0] * ARatio);
; 724  :                 Final[1] += ((double)PlaneBuffer[PlanePixelIndex + 1] * ARatio);
; 725  :                 Final[2] += ((double)PlaneBuffer[PlanePixelIndex + 2] * ARatio);
; 726  :                 Final[3] += ((double)PlaneBuffer[PlanePixelIndex + 3] * ARatio);
; 727  : #else
; 728  :                 Final[0] += ((double)PlaneBuffer[PlanePixelIndex + 0] / 255.0);

	mov	ecx, 8
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _PlaneBuffer$5[ebp]
	add	eax, DWORD PTR _PlanePixelIndex$8[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	addsd	xmm0, QWORD PTR _Final$1[ebp+edx]
	mov	edx, 8
	imul	eax, edx, 0
	movsd	QWORD PTR _Final$1[ebp+eax], xmm0

; 729  :                 Final[1] += ((double)PlaneBuffer[PlanePixelIndex + 1] / 255.0);

	mov	ecx, 8
	shl	ecx, 0
	mov	edx, DWORD PTR _PlaneBuffer$5[ebp]
	add	edx, DWORD PTR _PlanePixelIndex$8[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	addsd	xmm0, QWORD PTR _Final$1[ebp+ecx]
	mov	ecx, 8
	shl	ecx, 0
	movsd	QWORD PTR _Final$1[ebp+ecx], xmm0

; 730  :                 Final[2] += ((double)PlaneBuffer[PlanePixelIndex + 2] / 255.0);

	mov	edx, 8
	shl	edx, 1
	mov	eax, DWORD PTR _PlaneBuffer$5[ebp]
	add	eax, DWORD PTR _PlanePixelIndex$8[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	addsd	xmm0, QWORD PTR _Final$1[ebp+edx]
	mov	edx, 8
	shl	edx, 1
	movsd	QWORD PTR _Final$1[ebp+edx], xmm0

; 731  :                 Final[3] += ((double)PlaneBuffer[PlanePixelIndex + 3] / 255.0);

	mov	eax, 8
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _PlaneBuffer$5[ebp]
	add	edx, DWORD PTR _PlanePixelIndex$8[ebp]
	movzx	eax, BYTE PTR [edx+3]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	addsd	xmm0, QWORD PTR _Final$1[ebp+ecx]
	mov	ecx, 8
	imul	edx, ecx, 3
	movsd	QWORD PTR _Final$1[ebp+edx], xmm0

; 732  : #endif
; 733  : 
; 734  :                 OverlapCount++;

	mov	eax, DWORD PTR _OverlapCount$4[ebp]
	add	eax, 1
	mov	DWORD PTR _OverlapCount$4[ebp], eax

; 735  :             }

	jmp	$LN8@MergePlane
$LN9@MergePlane:

; 736  :             if (OverlapCount > 0)

	cmp	DWORD PTR _OverlapCount$4[ebp], 0
	jle	$LN20@MergePlane

; 737  :             {
; 738  :                 Final[0] /= (double)OverlapCount;

	mov	ecx, 8
	imul	edx, ecx, 0
	cvtsi2sd xmm0, DWORD PTR _OverlapCount$4[ebp]
	movsd	xmm1, QWORD PTR _Final$1[ebp+edx]
	divsd	xmm1, xmm0
	mov	eax, 8
	imul	ecx, eax, 0
	movsd	QWORD PTR _Final$1[ebp+ecx], xmm1

; 739  :                 Final[1] /= (double)OverlapCount;

	mov	edx, 8
	shl	edx, 0
	cvtsi2sd xmm0, DWORD PTR _OverlapCount$4[ebp]
	movsd	xmm1, QWORD PTR _Final$1[ebp+edx]
	divsd	xmm1, xmm0
	mov	eax, 8
	shl	eax, 0
	movsd	QWORD PTR _Final$1[ebp+eax], xmm1

; 740  :                 Final[2] /= (double)OverlapCount;

	mov	ecx, 8
	shl	ecx, 1
	cvtsi2sd xmm0, DWORD PTR _OverlapCount$4[ebp]
	movsd	xmm1, QWORD PTR _Final$1[ebp+ecx]
	divsd	xmm1, xmm0
	mov	edx, 8
	shl	edx, 1
	movsd	QWORD PTR _Final$1[ebp+edx], xmm1

; 741  :                 Final[3] /= (double)OverlapCount;

	mov	eax, 8
	imul	ecx, eax, 3
	cvtsi2sd xmm0, DWORD PTR _OverlapCount$4[ebp]
	movsd	xmm1, QWORD PTR _Final$1[ebp+ecx]
	divsd	xmm1, xmm0
	mov	edx, 8
	imul	eax, edx, 3
	movsd	QWORD PTR _Final$1[ebp+eax], xmm1

; 742  : #if FALSE
; 743  :                 BYTE FinalB = Final[0];
; 744  :                 BYTE FinalG = Final[1];
; 745  :                 BYTE FinalR = Final[2];
; 746  :                 BYTE FinalA = Final[3];
; 747  : #else
; 748  :                 BYTE FinalB = (Final[0] * 255.0);

	mov	ecx, 8
	imul	edx, ecx, 0
	movsd	xmm0, QWORD PTR _Final$1[ebp+edx]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si eax, xmm0
	mov	BYTE PTR _FinalB$13[ebp], al

; 749  :                 BYTE FinalG = (Final[1] * 255.0);

	mov	ecx, 8
	shl	ecx, 0
	movsd	xmm0, QWORD PTR _Final$1[ebp+ecx]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si edx, xmm0
	mov	BYTE PTR _FinalG$12[ebp], dl

; 750  :                 BYTE FinalR = (Final[2] * 255.0);

	mov	eax, 8
	shl	eax, 1
	movsd	xmm0, QWORD PTR _Final$1[ebp+eax]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _FinalR$11[ebp], cl

; 751  :                 BYTE FinalA = (Final[3] * 255.0);

	mov	edx, 8
	imul	eax, edx, 3
	movsd	xmm0, QWORD PTR _Final$1[ebp+eax]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _FinalA$10[ebp], cl

; 752  : #endif
; 753  :                 Buffer[Index + 0] = FinalB;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$3[ebp]
	mov	al, BYTE PTR _FinalB$13[ebp]
	mov	BYTE PTR [edx], al

; 754  :                 Buffer[Index + 1] = FinalG;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$3[ebp]
	mov	dl, BYTE PTR _FinalG$12[ebp]
	mov	BYTE PTR [ecx+1], dl

; 755  :                 Buffer[Index + 2] = FinalR;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$3[ebp]
	mov	cl, BYTE PTR _FinalR$11[ebp]
	mov	BYTE PTR [eax+2], cl

; 756  :                 Buffer[Index + 3] = FinalA;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$3[ebp]
	mov	al, BYTE PTR _FinalA$10[ebp]
	mov	BYTE PTR [edx+3], al
$LN20@MergePlane:

; 757  :             }
; 758  :         }

	jmp	$LN5@MergePlane
$LN6@MergePlane:

; 759  :     }

	jmp	$LN2@MergePlane
$LN3@MergePlane:

; 760  : 
; 761  :     return Success;

	xor	eax, eax
$LN1@MergePlane:

; 762  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_MergePlanes2@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_MaxPlaneIndex$1 = -48					; size = 4
_MaxValidIndex$ = -44					; size = 4
_RowOffset$2 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_PlaneBuffer$3 = -32					; size = 4
_Buffer$ = -28						; size = 4
_Row$4 = -24						; size = 4
_Index$5 = -20						; size = 4
_Column$6 = -16						; size = 4
_Planes$ = -12						; size = 4
_PlaneIndex$7 = -8					; size = 4
_PlanePointer$8 = -4					; size = 4
_Target$ = 8						; size = 4
_PlaneSet$ = 12						; size = 4
_PlaneCount$ = 16					; size = 4
_TargetWidth$ = 20					; size = 4
_TargetHeight$ = 24					; size = 4
_TargetStride$ = 28					; size = 4
_MergePlanes@24 PROC

; 615  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi

; 616  :     if (PlaneCount < 1)

	cmp	DWORD PTR _PlaneCount$[ebp], 1
	jge	SHORT $LN11@MergePlane

; 617  :         return Error;

	mov	eax, 1
	jmp	$LN1@MergePlane
$LN11@MergePlane:

; 618  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN12@MergePlane

; 619  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MergePlane
$LN12@MergePlane:

; 620  :     if (PlaneSet == NULL)

	cmp	DWORD PTR _PlaneSet$[ebp], 0
	jne	SHORT $LN13@MergePlane

; 621  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MergePlane
$LN13@MergePlane:

; 622  : 
; 623  :     BYTE* Buffer = (BYTE*)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 624  :     PlaneSetStruct *Planes = (PlaneSetStruct *)PlaneSet;

	mov	ecx, DWORD PTR _PlaneSet$[ebp]
	mov	DWORD PTR _Planes$[ebp], ecx

; 625  :     __int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 626  :     UINT32 MaxValidIndex = (TargetStride * TargetHeight) - 1;

	mov	edx, DWORD PTR _TargetStride$[ebp]
	imul	edx, DWORD PTR _TargetHeight$[ebp]
	sub	edx, 1
	mov	DWORD PTR _MaxValidIndex$[ebp], edx

; 627  : 
; 628  :     for (int PlaneIndex = 0; PlaneIndex < PlaneCount; PlaneIndex++)

	mov	DWORD PTR _PlaneIndex$7[ebp], 0
	jmp	SHORT $LN4@MergePlane
$LN2@MergePlane:
	mov	eax, DWORD PTR _PlaneIndex$7[ebp]
	add	eax, 1
	mov	DWORD PTR _PlaneIndex$7[ebp], eax
$LN4@MergePlane:
	mov	ecx, DWORD PTR _PlaneIndex$7[ebp]
	cmp	ecx, DWORD PTR _PlaneCount$[ebp]
	jge	$LN3@MergePlane

; 629  :     {
; 630  :         int PlanePointer = 0;

	mov	DWORD PTR _PlanePointer$8[ebp], 0

; 631  :         UINT32 MaxPlaneIndex = (Planes[PlaneIndex].Stride * Planes[PlaneIndex].Height) - 1;

	imul	edx, DWORD PTR _PlaneIndex$7[ebp], 48
	imul	eax, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	ecx, DWORD PTR _Planes$[ebp]
	mov	esi, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR [ecx+edx+16]
	imul	edx, DWORD PTR [esi+eax+12]
	sub	edx, 1
	mov	DWORD PTR _MaxPlaneIndex$1[ebp], edx

; 632  :         BYTE* PlaneBuffer = (BYTE *)Planes[PlaneIndex].TheBits;

	imul	eax, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	ecx, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR [ecx+eax+44]
	mov	DWORD PTR _PlaneBuffer$3[ebp], edx

; 633  :         for (int Row = Planes[PlaneIndex].Top; Row < Planes[PlaneIndex].Bottom; Row++)

	imul	eax, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	ecx, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR [ecx+eax+32]
	mov	DWORD PTR _Row$4[ebp], edx
	jmp	SHORT $LN7@MergePlane
$LN5@MergePlane:
	mov	eax, DWORD PTR _Row$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$4[ebp], eax
$LN7@MergePlane:
	imul	ecx, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR [edx+ecx+40]
	jge	$LN6@MergePlane

; 634  :         {
; 635  :             if (Row < 0)

	cmp	DWORD PTR _Row$4[ebp], 0
	jge	SHORT $LN14@MergePlane

; 636  :                 return NegativeIndex;

	mov	eax, 4
	jmp	$LN1@MergePlane
$LN14@MergePlane:

; 637  :             __int32 RowOffset = Row * TargetStride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 638  :             for (int Column = Planes[PlaneIndex].Left; Column < Planes[PlaneIndex].Right; Column++)

	imul	edx, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	eax, DWORD PTR _Planes$[ebp]
	mov	ecx, DWORD PTR [eax+edx+28]
	mov	DWORD PTR _Column$6[ebp], ecx
	jmp	SHORT $LN10@MergePlane
$LN8@MergePlane:
	mov	edx, DWORD PTR _Column$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$6[ebp], edx
$LN10@MergePlane:
	imul	eax, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	ecx, DWORD PTR _Planes$[ebp]
	mov	edx, DWORD PTR _Column$6[ebp]
	cmp	edx, DWORD PTR [ecx+eax+36]
	jge	$LN9@MergePlane

; 639  :             {
; 640  :                 if (Column < 0)

	cmp	DWORD PTR _Column$6[ebp], 0
	jge	SHORT $LN15@MergePlane

; 641  :                     return NegativeIndex;

	mov	eax, 4
	jmp	$LN1@MergePlane
$LN15@MergePlane:

; 642  :                 if (Column > TargetWidth - 1)

	mov	eax, DWORD PTR _TargetWidth$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _Column$6[ebp], eax
	jle	SHORT $LN16@MergePlane

; 643  :                     return IndexOutOfRange;

	mov	eax, 6
	jmp	$LN1@MergePlane
$LN16@MergePlane:

; 644  :                 __int32 Index = RowOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$6[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 645  :                 if (Index < 0)

	jns	SHORT $LN17@MergePlane

; 646  :                     return NegativeIndex;

	mov	eax, 4
	jmp	$LN1@MergePlane
$LN17@MergePlane:

; 647  :                 if ((UINT32)(Index + PixelSize) > MaxValidIndex)

	mov	edx, DWORD PTR _Index$5[ebp]
	add	edx, DWORD PTR _PixelSize$[ebp]
	cmp	edx, DWORD PTR _MaxValidIndex$[ebp]
	jbe	SHORT $LN18@MergePlane

; 648  :                     return IndexOutOfRange;

	mov	eax, 6
	jmp	$LN1@MergePlane
$LN18@MergePlane:

; 649  :                 if (((UINT32)PlanePointer + PixelSize) > (UINT32)Planes[PlaneIndex].PlaneSize)

	mov	eax, DWORD PTR _PlanePointer$8[ebp]
	add	eax, DWORD PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _PlaneIndex$7[ebp], 48
	mov	edx, DWORD PTR _Planes$[ebp]
	cmp	eax, DWORD PTR [edx+ecx+4]
	jbe	SHORT $LN19@MergePlane

; 650  :                     return BadSecondaryIndex;

	mov	eax, 5
	jmp	SHORT $LN1@MergePlane
$LN19@MergePlane:

; 651  :                 Buffer[Index + 0] = PlaneBuffer[PlanePointer++];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	ecx, DWORD PTR _PlaneBuffer$3[ebp]
	add	ecx, DWORD PTR _PlanePointer$8[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _PlanePointer$8[ebp]
	add	eax, 1
	mov	DWORD PTR _PlanePointer$8[ebp], eax

; 652  :                 Buffer[Index + 1] = PlaneBuffer[PlanePointer++];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	edx, DWORD PTR _PlaneBuffer$3[ebp]
	add	edx, DWORD PTR _PlanePointer$8[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+1], al
	mov	ecx, DWORD PTR _PlanePointer$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _PlanePointer$8[ebp], ecx

; 653  :                 Buffer[Index + 2] = PlaneBuffer[PlanePointer++];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _PlaneBuffer$3[ebp]
	add	eax, DWORD PTR _PlanePointer$8[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx+2], cl
	mov	edx, DWORD PTR _PlanePointer$8[ebp]
	add	edx, 1
	mov	DWORD PTR _PlanePointer$8[ebp], edx

; 654  :                 Buffer[Index + 3] = PlaneBuffer[PlanePointer++];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	ecx, DWORD PTR _PlaneBuffer$3[ebp]
	add	ecx, DWORD PTR _PlanePointer$8[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+3], dl
	mov	eax, DWORD PTR _PlanePointer$8[ebp]
	add	eax, 1
	mov	DWORD PTR _PlanePointer$8[ebp], eax

; 655  :             }

	jmp	$LN8@MergePlane
$LN9@MergePlane:

; 656  :         }

	jmp	$LN5@MergePlane
$LN6@MergePlane:

; 657  :     }

	jmp	$LN2@MergePlane
$LN3@MergePlane:

; 658  : 
; 659  :     return Success;

	xor	eax, eax
$LN1@MergePlane:

; 660  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_MergePlanes@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Hypotenuse$ = -56					; size = 8
tv225 = -48						; size = 8
_RowOffset$1 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_ColorPoints$ = -32					; size = 4
_ColorSet$ = -28					; size = 4
_ColorIndex$2 = -24					; size = 4
_Column$3 = -20						; size = 4
_Row$4 = -16						; size = 4
_Index$5 = -12						; size = 4
_Buffer$ = -8						; size = 4
_iA$6 = -4						; size = 1
_iR$7 = -3						; size = 1
_iG$8 = -2						; size = 1
_iB$9 = -1						; size = 1
_Target$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_PureColorCount$ = 24					; size = 4
_ColorLocations$ = 28					; size = 4
_PureColors$ = 32					; size = 4
_BlendColors@28 PROC

; 133  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 134  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@BlendColor

; 135  :         return FALSE;

	xor	al, al
	jmp	$LN1@BlendColor
$LN8@BlendColor:

; 136  :     if (ColorLocations == NULL)

	cmp	DWORD PTR _ColorLocations$[ebp], 0
	jne	SHORT $LN9@BlendColor

; 137  :         return FALSE;

	xor	al, al
	jmp	$LN1@BlendColor
$LN9@BlendColor:

; 138  :     if (PureColors == NULL)

	cmp	DWORD PTR _PureColors$[ebp], 0
	jne	SHORT $LN10@BlendColor

; 139  :         return FALSE;

	xor	al, al
	jmp	$LN1@BlendColor
$LN10@BlendColor:

; 140  :     if (PureColorCount < 1)

	cmp	DWORD PTR _PureColorCount$[ebp], 1
	jge	SHORT $LN11@BlendColor

; 141  :         return FALSE;

	xor	al, al
	jmp	$LN1@BlendColor
$LN11@BlendColor:

; 142  : 
; 143  :     __int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 144  :     BYTE* Buffer = (BYTE*)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 145  :     PureColorStruct* ColorSet = (PureColorStruct*)PureColors;

	mov	ecx, DWORD PTR _PureColors$[ebp]
	mov	DWORD PTR _ColorSet$[ebp], ecx

; 146  :     AbsolutePointStruct* ColorPoints = (AbsolutePointStruct*)ColorLocations;

	mov	edx, DWORD PTR _ColorLocations$[ebp]
	mov	DWORD PTR _ColorPoints$[ebp], edx

; 147  :     double Hypotenuse = sqrt(pow((double)Width, 2) + pow((double)Height, 2));

	cvtsi2sd xmm0, DWORD PTR _Width$[ebp]
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	cvtsi2sd xmm1, DWORD PTR _Height$[ebp]
	movsd	QWORD PTR tv225[ebp], xmm0
	movaps	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR tv225[ebp]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	call	__libm_sse2_sqrt_precise
	movsd	QWORD PTR _Hypotenuse$[ebp], xmm0

; 148  : 
; 149  :     for (__int32 Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@BlendColor
$LN2@BlendColor:
	mov	eax, DWORD PTR _Row$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$4[ebp], eax
$LN4@BlendColor:
	mov	ecx, DWORD PTR _Row$4[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN3@BlendColor

; 150  :     {
; 151  :         __int32 RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$4[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 152  :         for (__int32 Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@BlendColor
$LN5@BlendColor:
	mov	eax, DWORD PTR _Column$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$3[ebp], eax
$LN7@BlendColor:
	mov	ecx, DWORD PTR _Column$3[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	$LN6@BlendColor

; 153  :         {
; 154  :             __int32 Index = RowOffset + (Column * PixelSize);

	mov	edx, DWORD PTR _Column$3[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$5[ebp], edx

; 155  :             int ColorIndex = ColorPointIndex(Column, Row, ColorPoints, PureColorCount);

	mov	eax, DWORD PTR _PureColorCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ColorPoints$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Row$4[ebp]
	push	edx
	mov	eax, DWORD PTR _Column$3[ebp]
	push	eax
	call	?ColorPointIndex@@YGHHHPAUAbsolutePointStruct@@H@Z ; ColorPointIndex
	mov	DWORD PTR _ColorIndex$2[ebp], eax

; 156  :             if (ColorIndex > -1)

	cmp	DWORD PTR _ColorIndex$2[ebp], -1
	jle	SHORT $LN12@BlendColor

; 157  :             {
; 158  :                 Buffer[Index + 0] = ColorSet[ColorIndex].Blue;

	imul	ecx, DWORD PTR _ColorIndex$2[ebp], 5
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	cl, BYTE PTR [eax+ecx+4]
	mov	BYTE PTR [edx], cl

; 159  :                 Buffer[Index + 1] = ColorSet[ColorIndex].Green;

	imul	edx, DWORD PTR _ColorIndex$2[ebp], 5
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	dl, BYTE PTR [ecx+edx+3]
	mov	BYTE PTR [eax+1], dl

; 160  :                 Buffer[Index + 2] = ColorSet[ColorIndex].Red;

	imul	eax, DWORD PTR _ColorIndex$2[ebp], 5
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	al, BYTE PTR [edx+eax+2]
	mov	BYTE PTR [ecx+2], al

; 161  :                 Buffer[Index + 3] = ColorSet[ColorIndex].Alpha;

	imul	ecx, DWORD PTR _ColorIndex$2[ebp], 5
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	cl, BYTE PTR [eax+ecx+1]
	mov	BYTE PTR [edx+3], cl

; 162  :             }
; 163  :             else

	jmp	SHORT $LN13@BlendColor
$LN12@BlendColor:

; 164  :             {
; 165  :                 byte iR = 0;

	mov	BYTE PTR _iR$7[ebp], 0

; 166  :                 byte iG = 0;

	mov	BYTE PTR _iG$8[ebp], 0

; 167  :                 byte iB = 0;

	mov	BYTE PTR _iB$9[ebp], 0

; 168  :                 byte iA = 0xff;

	mov	BYTE PTR _iA$6[ebp], 255		; 000000ffH

; 169  :                 MakeColor(Column, Row, Width, Height, Hypotenuse, PureColorCount, ColorSet, ColorPoints, &iR, &iG, &iB);

	lea	edx, DWORD PTR _iB$9[ebp]
	push	edx
	lea	eax, DWORD PTR _iG$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _iR$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _ColorPoints$[ebp]
	push	edx
	mov	eax, DWORD PTR _ColorSet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _PureColorCount$[ebp]
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _Hypotenuse$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Row$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _Column$3[ebp]
	push	edx
	call	?MakeColor@@YGXHHHHNHPAUPureColorStruct@@PAUAbsolutePointStruct@@PAE22@Z ; MakeColor

; 170  :                 Buffer[Index + 0] = iB;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _iB$9[ebp]
	mov	BYTE PTR [eax], cl

; 171  :                 Buffer[Index + 1] = iG;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _iG$8[ebp]
	mov	BYTE PTR [edx+1], al

; 172  :                 Buffer[Index + 2] = iR;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _iR$7[ebp]
	mov	BYTE PTR [ecx+2], dl

; 173  :                 Buffer[Index + 3] = iA;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _iA$6[ebp]
	mov	BYTE PTR [eax+3], cl
$LN13@BlendColor:

; 174  :             }
; 175  :         }

	jmp	$LN5@BlendColor
$LN6@BlendColor:

; 176  :     }

	jmp	$LN2@BlendColor
$LN3@BlendColor:

; 177  : 
; 178  :     return TRUE;

	mov	al, 1
$LN1@BlendColor:

; 179  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_BlendColors@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_LogicalOperator$ = 28					; size = 4
_AlphaMask$ = 32					; size = 1
_RedMask$ = 36						; size = 1
_GreenMask$ = 40					; size = 1
_BlueMask$ = 44						; size = 1
_IncludeAlpha$ = 48					; size = 4
_ApplyChannelMasks@44 PROC

; 1544 : {

	push	ebp
	mov	ebp, esp

; 1545 :     return ApplyChannelMasks2(Source, Width, Height, Stride, Destination,

	push	1
	movzx	eax, BYTE PTR _BlueMask$[ebp]
	push	eax
	push	1
	movzx	ecx, BYTE PTR _GreenMask$[ebp]
	push	ecx
	push	1
	movzx	edx, BYTE PTR _RedMask$[ebp]
	push	edx
	mov	eax, DWORD PTR _IncludeAlpha$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _AlphaMask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _LogicalOperator$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_ApplyChannelMasks2@56

; 1546 :         LogicalOperator, AlphaMask, IncludeAlpha, RedMask, TRUE, GreenMask, TRUE, BlueMask, TRUE);
; 1547 : }

	pop	ebp
	ret	44					; 0000002cH
_ApplyChannelMasks@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_RowOffset$1 = -36					; size = 4
tv86 = -32						; size = 4
_Dest$ = -28						; size = 4
_Column$2 = -24						; size = 4
_Row$3 = -20						; size = 4
_Src$ = -16						; size = 4
_Index$4 = -12						; size = 4
_PixelSize$ = -5					; size = 1
_B$5 = -4						; size = 1
_G$6 = -3						; size = 1
_R$7 = -2						; size = 1
_A$8 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_LogicalOperator$ = 28					; size = 4
_AlphaMask$ = 32					; size = 1
_UseAlpha$ = 36						; size = 4
_RedMask$ = 40						; size = 1
_UseRed$ = 44						; size = 4
_GreenMask$ = 48					; size = 1
_UseGreen$ = 52						; size = 4
_BlueMask$ = 56						; size = 1
_UseBlue$ = 60						; size = 4
_ApplyChannelMasks2@56 PROC

; 1458 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1459 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN10@ApplyChann

; 1460 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ApplyChann
$LN10@ApplyChann:

; 1461 :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN11@ApplyChann

; 1462 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ApplyChann
$LN11@ApplyChann:

; 1463 : 
; 1464 :     BYTE* Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1465 :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1466 :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 1467 : 
; 1468 :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ApplyChann
$LN2@ApplyChann:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@ApplyChann:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@ApplyChann

; 1469 :     {
; 1470 :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 1471 :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ApplyChann
$LN5@ApplyChann:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@ApplyChann:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@ApplyChann

; 1472 :         {
; 1473 :             int Index = (Column * PixelSize) + RowOffset;

	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 1474 :             BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 1475 :             BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$7[ebp], dl

; 1476 :             BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$6[ebp], cl

; 1477 :             BYTE B = Src[Index + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$5[ebp], al

; 1478 :             switch (LogicalOperator)

	mov	ecx, DWORD PTR _LogicalOperator$[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	cmp	DWORD PTR tv86[ebp], 0
	je	SHORT $LN12@ApplyChann
	cmp	DWORD PTR tv86[ebp], 1
	je	SHORT $LN17@ApplyChann
	cmp	DWORD PTR tv86[ebp], 2
	je	$LN22@ApplyChann
	jmp	$LN27@ApplyChann
$LN12@ApplyChann:

; 1479 :             {
; 1480 :                 case AndMask:
; 1481 :                     if (UseAlpha)

	cmp	DWORD PTR _UseAlpha$[ebp], 0
	je	SHORT $LN13@ApplyChann

; 1482 :                         A = Src[Index + 3] & AlphaMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+3]
	movzx	ecx, BYTE PTR _AlphaMask$[ebp]
	and	eax, ecx
	mov	BYTE PTR _A$8[ebp], al
$LN13@ApplyChann:

; 1483 :                     if (UseRed)

	cmp	DWORD PTR _UseRed$[ebp], 0
	je	SHORT $LN14@ApplyChann

; 1484 :                         R = Src[Index + 2] & RedMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+2]
	movzx	ecx, BYTE PTR _RedMask$[ebp]
	and	eax, ecx
	mov	BYTE PTR _R$7[ebp], al
$LN14@ApplyChann:

; 1485 :                     if (UseGreen)

	cmp	DWORD PTR _UseGreen$[ebp], 0
	je	SHORT $LN15@ApplyChann

; 1486 :                         G = Src[Index + 1] & GreenMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+1]
	movzx	ecx, BYTE PTR _GreenMask$[ebp]
	and	eax, ecx
	mov	BYTE PTR _G$6[ebp], al
$LN15@ApplyChann:

; 1487 :                     if (UseBlue)

	cmp	DWORD PTR _UseBlue$[ebp], 0
	je	SHORT $LN16@ApplyChann

; 1488 :                         B = Src[Index + 0] & BlueMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _BlueMask$[ebp]
	and	eax, ecx
	mov	BYTE PTR _B$5[ebp], al
$LN16@ApplyChann:

; 1489 :                     break;

	jmp	$LN8@ApplyChann
$LN17@ApplyChann:

; 1490 : 
; 1491 :                 case OrMask:
; 1492 :                     if (UseAlpha)

	cmp	DWORD PTR _UseAlpha$[ebp], 0
	je	SHORT $LN18@ApplyChann

; 1493 :                         A = Src[Index + 3] | AlphaMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+3]
	movzx	ecx, BYTE PTR _AlphaMask$[ebp]
	or	eax, ecx
	mov	BYTE PTR _A$8[ebp], al
$LN18@ApplyChann:

; 1494 :                     if (UseRed)

	cmp	DWORD PTR _UseRed$[ebp], 0
	je	SHORT $LN19@ApplyChann

; 1495 :                         R = Src[Index + 2] | RedMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+2]
	movzx	ecx, BYTE PTR _RedMask$[ebp]
	or	eax, ecx
	mov	BYTE PTR _R$7[ebp], al
$LN19@ApplyChann:

; 1496 :                     if (UseGreen)

	cmp	DWORD PTR _UseGreen$[ebp], 0
	je	SHORT $LN20@ApplyChann

; 1497 :                         G = Src[Index + 1] | GreenMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+1]
	movzx	ecx, BYTE PTR _GreenMask$[ebp]
	or	eax, ecx
	mov	BYTE PTR _G$6[ebp], al
$LN20@ApplyChann:

; 1498 :                     if (UseBlue)

	cmp	DWORD PTR _UseBlue$[ebp], 0
	je	SHORT $LN21@ApplyChann

; 1499 :                         B = Src[Index + 0] | BlueMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _BlueMask$[ebp]
	or	eax, ecx
	mov	BYTE PTR _B$5[ebp], al
$LN21@ApplyChann:

; 1500 :                     break;

	jmp	SHORT $LN8@ApplyChann
$LN22@ApplyChann:

; 1501 : 
; 1502 :                 case XorMask:
; 1503 :                     if (UseAlpha)

	cmp	DWORD PTR _UseAlpha$[ebp], 0
	je	SHORT $LN23@ApplyChann

; 1504 :                         A = Src[Index + 3] ^ AlphaMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+3]
	movzx	ecx, BYTE PTR _AlphaMask$[ebp]
	xor	eax, ecx
	mov	BYTE PTR _A$8[ebp], al
$LN23@ApplyChann:

; 1505 :                     if (UseRed)

	cmp	DWORD PTR _UseRed$[ebp], 0
	je	SHORT $LN24@ApplyChann

; 1506 :                         R = Src[Index + 2] ^ RedMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+2]
	movzx	ecx, BYTE PTR _RedMask$[ebp]
	xor	eax, ecx
	mov	BYTE PTR _R$7[ebp], al
$LN24@ApplyChann:

; 1507 :                     if (UseGreen)

	cmp	DWORD PTR _UseGreen$[ebp], 0
	je	SHORT $LN25@ApplyChann

; 1508 :                         G = Src[Index + 1] ^ GreenMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+1]
	movzx	ecx, BYTE PTR _GreenMask$[ebp]
	xor	eax, ecx
	mov	BYTE PTR _G$6[ebp], al
$LN25@ApplyChann:

; 1509 :                     if (UseBlue)

	cmp	DWORD PTR _UseBlue$[ebp], 0
	je	SHORT $LN26@ApplyChann

; 1510 :                         B = Src[Index + 0] ^ BlueMask;

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _BlueMask$[ebp]
	xor	eax, ecx
	mov	BYTE PTR _B$5[ebp], al
$LN26@ApplyChann:

; 1511 :                     break;

	jmp	SHORT $LN8@ApplyChann
$LN27@ApplyChann:

; 1512 : 
; 1513 :                 default:
; 1514 :                     return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@ApplyChann
$LN8@ApplyChann:

; 1515 :             }
; 1516 : 
; 1517 :             Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [edx+3], al

; 1518 :             Dest[Index + 2] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [ecx+2], dl

; 1519 :             Dest[Index + 1] = G;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [eax+1], cl

; 1520 :             Dest[Index + 0] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _B$5[ebp]
	mov	BYTE PTR [edx], al

; 1521 :         }

	jmp	$LN5@ApplyChann
$LN6@ApplyChann:

; 1522 :     }

	jmp	$LN2@ApplyChann
$LN3@ApplyChann:

; 1523 : 
; 1524 :     return Success;

	xor	eax, eax
$LN1@ApplyChann:

; 1525 : }

	mov	esp, ebp
	pop	ebp
	ret	56					; 00000038H
_ApplyChannelMasks2@56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
_TEXT	SEGMENT
_RowOffset$1 = -40					; size = 4
tv86 = -36						; size = 4
_Dest$ = -32						; size = 4
_Src$ = -28						; size = 4
_Column$2 = -24						; size = 4
_Row$3 = -20						; size = 4
_Index$4 = -16						; size = 4
_PixelSize$ = -9					; size = 1
_As$5 = -8						; size = 1
_Bs$6 = -7						; size = 1
_Gs$7 = -6						; size = 1
_Rs$8 = -5						; size = 1
_A$9 = -4						; size = 1
_B$10 = -3						; size = 1
_R$11 = -2						; size = 1
_G$12 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_LogicalOperator$ = 28					; size = 4
_RightToLeft$ = 32					; size = 4
_Mask$ = 36						; size = 1
_IncludeAlpha$ = 40					; size = 4
_PixelChannelRollingLogicalOperation@36 PROC

; 1567 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1568 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN10@PixelChann

; 1569 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@PixelChann
$LN10@PixelChann:

; 1570 :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN11@PixelChann

; 1571 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@PixelChann
$LN11@PixelChann:

; 1572 : 
; 1573 :     BYTE* Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1574 :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1575 :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 1576 : 
; 1577 :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@PixelChann
$LN2@PixelChann:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@PixelChann:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@PixelChann

; 1578 :     {
; 1579 :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 1580 :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@PixelChann
$LN5@PixelChann:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@PixelChann:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@PixelChann

; 1581 :         {
; 1582 :             int Index = (Column * PixelSize) + RowOffset;

	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 1583 :             BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$9[ebp], al

; 1584 :             BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$11[ebp], dl

; 1585 :             BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$12[ebp], cl

; 1586 :             BYTE B = Src[Index + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$10[ebp], al

; 1587 :             BYTE As = A;

	mov	cl, BYTE PTR _A$9[ebp]
	mov	BYTE PTR _As$5[ebp], cl

; 1588 :             BYTE Rs = 0;

	mov	BYTE PTR _Rs$8[ebp], 0

; 1589 :             BYTE Gs = 0;

	mov	BYTE PTR _Gs$7[ebp], 0

; 1590 :             BYTE Bs = 0;

	mov	BYTE PTR _Bs$6[ebp], 0

; 1591 : 
; 1592 :             switch (LogicalOperator)

	mov	edx, DWORD PTR _LogicalOperator$[ebp]
	mov	DWORD PTR tv86[ebp], edx
	cmp	DWORD PTR tv86[ebp], 0
	je	SHORT $LN12@PixelChann
	cmp	DWORD PTR tv86[ebp], 1
	je	$LN19@PixelChann
	cmp	DWORD PTR tv86[ebp], 2
	je	$LN26@PixelChann
	jmp	$LN33@PixelChann
$LN12@PixelChann:

; 1593 :             {
; 1594 :                 case RollingChannelAnd:
; 1595 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	$LN13@PixelChann

; 1596 :                     {
; 1597 :                         if (RightToLeft)

	cmp	DWORD PTR _RightToLeft$[ebp], 0
	je	$LN15@PixelChann

; 1598 :                         {
; 1599 :                             As = ((B & Mask) & (A & Mask)) | (A & ~Mask);

	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _A$9[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	and	eax, edx
	movzx	edx, BYTE PTR _A$9[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	or	eax, edx
	mov	BYTE PTR _As$5[ebp], al

; 1600 :                             Rs = ((A & Mask) & (R & Mask)) | (R & ~Mask);

	movzx	edx, BYTE PTR _A$9[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	and	edx, ecx
	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	or	edx, ecx
	mov	BYTE PTR _Rs$8[ebp], dl

; 1601 :                             Gs = ((R & Mask) & (G & Mask)) | (G & ~Mask);

	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	and	ecx, eax
	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	or	ecx, eax
	mov	BYTE PTR _Gs$7[ebp], cl

; 1602 :                             Bs = ((G & Mask) & (B & Mask)) | (B & ~Mask);

	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	and	eax, edx
	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	or	eax, edx
	mov	BYTE PTR _Bs$6[ebp], al

; 1603 :                         }
; 1604 :                         else

	jmp	$LN16@PixelChann
$LN15@PixelChann:

; 1605 :                         {
; 1606 :                             As = ((R & Mask) & (A & Mask)) | (A & ~Mask);

	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _A$9[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	and	edx, ecx
	movzx	ecx, BYTE PTR _A$9[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	or	edx, ecx
	mov	BYTE PTR _As$5[ebp], dl

; 1607 :                             Rs = ((G & Mask) & (R & Mask)) | (R & ~Mask);

	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	and	ecx, eax
	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	or	ecx, eax
	mov	BYTE PTR _Rs$8[ebp], cl

; 1608 :                             Gs = ((B & Mask) & (G & Mask)) | (G & ~Mask);

	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	and	eax, edx
	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	or	eax, edx
	mov	BYTE PTR _Gs$7[ebp], al

; 1609 :                             Bs = ((A & Mask) & (B & Mask)) | (B & ~Mask);

	movzx	edx, BYTE PTR _A$9[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	and	edx, ecx
	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	or	edx, ecx
	mov	BYTE PTR _Bs$6[ebp], dl
$LN16@PixelChann:

; 1610 :                         }
; 1611 :                     }
; 1612 :                     else

	jmp	$LN14@PixelChann
$LN13@PixelChann:

; 1613 :                     {
; 1614 :                         if (RightToLeft)

	cmp	DWORD PTR _RightToLeft$[ebp], 0
	je	SHORT $LN17@PixelChann

; 1615 :                         {
; 1616 :                             Rs = ((B & Mask) & (R & Mask)) | (R & ~Mask);

	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	and	ecx, eax
	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	or	ecx, eax
	mov	BYTE PTR _Rs$8[ebp], cl

; 1617 :                             Gs = ((R & Mask) & (G & Mask)) | (G & ~Mask);

	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	and	eax, edx
	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	or	eax, edx
	mov	BYTE PTR _Gs$7[ebp], al

; 1618 :                             Bs = ((G & Mask) & (B & Mask)) | (B & ~Mask);

	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	and	edx, ecx
	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	or	edx, ecx
	mov	BYTE PTR _Bs$6[ebp], dl

; 1619 :                         }
; 1620 :                         else

	jmp	SHORT $LN14@PixelChann
$LN17@PixelChann:

; 1621 :                         {
; 1622 :                             Rs = ((G & Mask) & (R & Mask)) | (R & ~Mask);

	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	and	ecx, eax
	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	or	ecx, eax
	mov	BYTE PTR _Rs$8[ebp], cl

; 1623 :                             Gs = ((B & Mask) & (G & Mask)) | (G & ~Mask);

	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	and	eax, edx
	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	or	eax, edx
	mov	BYTE PTR _Gs$7[ebp], al

; 1624 :                             Bs = ((R & Mask) & (B & Mask)) | (B & ~Mask);

	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	and	edx, ecx
	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	or	edx, ecx
	mov	BYTE PTR _Bs$6[ebp], dl
$LN14@PixelChann:

; 1625 :                         }
; 1626 :                     }
; 1627 :                     break;

	jmp	$LN8@PixelChann
$LN19@PixelChann:

; 1628 : 
; 1629 :                 case RollingChannelOr:
; 1630 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	$LN20@PixelChann

; 1631 :                     {
; 1632 :                         if (RightToLeft)

	cmp	DWORD PTR _RightToLeft$[ebp], 0
	je	$LN22@PixelChann

; 1633 :                         {
; 1634 :                             As = ((B & Mask) | (A & Mask)) | (A & ~Mask);

	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _A$9[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	or	ecx, eax
	movzx	eax, BYTE PTR _A$9[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	or	ecx, eax
	mov	BYTE PTR _As$5[ebp], cl

; 1635 :                             Rs = ((A & Mask) | (R & Mask)) | (R & ~Mask);

	movzx	eax, BYTE PTR _A$9[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	or	eax, edx
	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	or	eax, edx
	mov	BYTE PTR _Rs$8[ebp], al

; 1636 :                             Gs = ((R & Mask) | (G & Mask)) | (G & ~Mask);

	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	or	edx, ecx
	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	or	edx, ecx
	mov	BYTE PTR _Gs$7[ebp], dl

; 1637 :                             Bs = ((G & Mask) | (B & Mask)) | (B & ~Mask);

	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	or	ecx, eax
	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	or	ecx, eax
	mov	BYTE PTR _Bs$6[ebp], cl

; 1638 :                         }
; 1639 :                         else

	jmp	$LN23@PixelChann
$LN22@PixelChann:

; 1640 :                         {
; 1641 :                             As = ((R & Mask) | (A & Mask)) | (A & ~Mask);

	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _A$9[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	or	eax, edx
	movzx	edx, BYTE PTR _A$9[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	or	eax, edx
	mov	BYTE PTR _As$5[ebp], al

; 1642 :                             Rs = ((G & Mask) | (R & Mask)) | (R & ~Mask);

	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	or	edx, ecx
	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	or	edx, ecx
	mov	BYTE PTR _Rs$8[ebp], dl

; 1643 :                             Gs = ((B & Mask) | (G & Mask)) | (G & ~Mask);

	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	or	ecx, eax
	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	or	ecx, eax
	mov	BYTE PTR _Gs$7[ebp], cl

; 1644 :                             Bs = ((A & Mask) | (B & Mask)) | (B & ~Mask);

	movzx	eax, BYTE PTR _A$9[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	or	eax, edx
	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	or	eax, edx
	mov	BYTE PTR _Bs$6[ebp], al
$LN23@PixelChann:

; 1645 :                         }
; 1646 :                     }
; 1647 :                     else

	jmp	$LN21@PixelChann
$LN20@PixelChann:

; 1648 :                     {
; 1649 :                         if (RightToLeft)

	cmp	DWORD PTR _RightToLeft$[ebp], 0
	je	SHORT $LN24@PixelChann

; 1650 :                         {
; 1651 :                             Rs = ((B & Mask) | (R & Mask)) | (R & ~Mask);

	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	or	edx, ecx
	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	or	edx, ecx
	mov	BYTE PTR _Rs$8[ebp], dl

; 1652 :                             Gs = ((R & Mask) | (G & Mask)) | (G & ~Mask);

	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	or	ecx, eax
	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	or	ecx, eax
	mov	BYTE PTR _Gs$7[ebp], cl

; 1653 :                             Bs = ((G & Mask) | (B & Mask)) | (B & ~Mask);

	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	or	eax, edx
	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	or	eax, edx
	mov	BYTE PTR _Bs$6[ebp], al

; 1654 :                         }
; 1655 :                         else

	jmp	SHORT $LN21@PixelChann
$LN24@PixelChann:

; 1656 :                         {
; 1657 :                             Rs = ((G & Mask) | (R & Mask)) | (R & ~Mask);

	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	or	edx, ecx
	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	or	edx, ecx
	mov	BYTE PTR _Rs$8[ebp], dl

; 1658 :                             Gs = ((B & Mask) | (G & Mask)) | (G & ~Mask);

	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	or	ecx, eax
	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	or	ecx, eax
	mov	BYTE PTR _Gs$7[ebp], cl

; 1659 :                             Bs = ((R & Mask) | (B & Mask)) | (B & ~Mask);

	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	or	eax, edx
	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	or	eax, edx
	mov	BYTE PTR _Bs$6[ebp], al
$LN21@PixelChann:

; 1660 :                         }
; 1661 :                     }
; 1662 :                     break;

	jmp	$LN8@PixelChann
$LN26@PixelChann:

; 1663 : 
; 1664 :                 case RollingChannelXor:
; 1665 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	$LN27@PixelChann

; 1666 :                     {
; 1667 :                         if (RightToLeft)

	cmp	DWORD PTR _RightToLeft$[ebp], 0
	je	$LN29@PixelChann

; 1668 :                         {
; 1669 :                             As = ((B & Mask) ^ (A & Mask)) ^ (A & ~Mask);

	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _A$9[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	xor	edx, ecx
	movzx	ecx, BYTE PTR _A$9[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	xor	edx, ecx
	mov	BYTE PTR _As$5[ebp], dl

; 1670 :                             Rs = ((A & Mask) ^ (R & Mask)) ^ (R & ~Mask);

	movzx	ecx, BYTE PTR _A$9[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	xor	ecx, eax
	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	xor	ecx, eax
	mov	BYTE PTR _Rs$8[ebp], cl

; 1671 :                             Gs = ((R & Mask) ^ (G & Mask)) ^ (G & ~Mask);

	movzx	eax, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	xor	eax, edx
	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	xor	eax, edx
	mov	BYTE PTR _Gs$7[ebp], al

; 1672 :                             Bs = ((G & Mask) ^ (B & Mask)) ^ (B & ~Mask);

	movzx	edx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	xor	edx, ecx
	movzx	ecx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	xor	edx, ecx
	mov	BYTE PTR _Bs$6[ebp], dl

; 1673 :                         }
; 1674 :                         else

	jmp	$LN30@PixelChann
$LN29@PixelChann:

; 1675 :                         {
; 1676 :                             As = ((R & Mask) ^ (A & Mask)) ^ (A & ~Mask);

	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _A$9[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	xor	ecx, eax
	movzx	eax, BYTE PTR _A$9[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	xor	ecx, eax
	mov	BYTE PTR _As$5[ebp], cl

; 1677 :                             Rs = ((G & Mask) ^ (R & Mask)) ^ (R & ~Mask);

	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	xor	eax, edx
	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	xor	eax, edx
	mov	BYTE PTR _Rs$8[ebp], al

; 1678 :                             Gs = ((B & Mask) ^ (G & Mask)) ^ (G & ~Mask);

	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	xor	edx, ecx
	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	xor	edx, ecx
	mov	BYTE PTR _Gs$7[ebp], dl

; 1679 :                             Bs = ((A & Mask) ^ (B & Mask)) ^ (B & ~Mask);

	movzx	ecx, BYTE PTR _A$9[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	xor	ecx, eax
	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	xor	ecx, eax
	mov	BYTE PTR _Bs$6[ebp], cl
$LN30@PixelChann:

; 1680 :                         }
; 1681 :                     }
; 1682 :                     else

	jmp	$LN28@PixelChann
$LN27@PixelChann:

; 1683 :                     {
; 1684 :                         if (RightToLeft)

	cmp	DWORD PTR _RightToLeft$[ebp], 0
	je	SHORT $LN31@PixelChann

; 1685 :                         {
; 1686 :                             Rs = ((B & Mask) ^ (R & Mask)) ^ (R & ~Mask);

	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	xor	eax, edx
	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	xor	eax, edx
	mov	BYTE PTR _Rs$8[ebp], al

; 1687 :                             Gs = ((R & Mask) ^ (G & Mask)) ^ (G & ~Mask);

	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	xor	edx, ecx
	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	xor	edx, ecx
	mov	BYTE PTR _Gs$7[ebp], dl

; 1688 :                             Bs = ((G & Mask) ^ (B & Mask)) ^ (B & ~Mask);

	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	xor	ecx, eax
	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	xor	ecx, eax
	mov	BYTE PTR _Bs$6[ebp], cl

; 1689 :                         }
; 1690 :                         else

	jmp	SHORT $LN28@PixelChann
$LN31@PixelChann:

; 1691 :                         {
; 1692 :                             Rs = ((G & Mask) ^ (R & Mask)) ^ (R & ~Mask);

	movzx	eax, BYTE PTR _G$12[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	and	edx, ecx
	xor	eax, edx
	movzx	edx, BYTE PTR _R$11[ebp]
	movzx	ecx, BYTE PTR _Mask$[ebp]
	not	ecx
	and	edx, ecx
	xor	eax, edx
	mov	BYTE PTR _Rs$8[ebp], al

; 1693 :                             Gs = ((B & Mask) ^ (G & Mask)) ^ (G & ~Mask);

	movzx	edx, BYTE PTR _B$10[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	edx, eax
	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	and	ecx, eax
	xor	edx, ecx
	movzx	ecx, BYTE PTR _G$12[ebp]
	movzx	eax, BYTE PTR _Mask$[ebp]
	not	eax
	and	ecx, eax
	xor	edx, ecx
	mov	BYTE PTR _Gs$7[ebp], dl

; 1694 :                             Bs = ((R & Mask) ^ (B & Mask)) ^ (B & ~Mask);

	movzx	ecx, BYTE PTR _R$11[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	ecx, edx
	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	and	eax, edx
	xor	ecx, eax
	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	edx, BYTE PTR _Mask$[ebp]
	not	edx
	and	eax, edx
	xor	ecx, eax
	mov	BYTE PTR _Bs$6[ebp], cl
$LN28@PixelChann:

; 1695 :                         }
; 1696 :                     }
; 1697 :                     break;

	jmp	SHORT $LN8@PixelChann
$LN33@PixelChann:

; 1698 : 
; 1699 :                 default:
; 1700 :                     return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@PixelChann
$LN8@PixelChann:

; 1701 :             }
; 1702 : 
; 1703 :             Dest[Index + 3] = As;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _As$5[ebp]
	mov	BYTE PTR [eax+3], cl

; 1704 :             Dest[Index + 2] = Rs;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Rs$8[ebp]
	mov	BYTE PTR [edx+2], al

; 1705 :             Dest[Index + 1] = Gs;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _Gs$7[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1706 :             Dest[Index + 0] = Bs;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Bs$6[ebp]
	mov	BYTE PTR [eax], cl

; 1707 :         }

	jmp	$LN5@PixelChann
$LN6@PixelChann:

; 1708 :     }

	jmp	$LN2@PixelChann
$LN3@PixelChann:

; 1709 : 
; 1710 :     return Success;

	xor	eax, eax
$LN1@PixelChann:

; 1711 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_PixelChannelRollingLogicalOperation@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
;	COMDAT ?PixelLuminanceSc@@YGNNNN@Z
_TEXT	SEGMENT
tv73 = -8						; size = 8
_R$ = 8							; size = 8
_G$ = 16						; size = 8
_B$ = 24						; size = 8
?PixelLuminanceSc@@YGNNNN@Z PROC			; PixelLuminanceSc, COMDAT

; 41   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 42   :     return (0.2126 * (double)R) + (0.7152 * (double)G) + (0.0722 * (double)B);

	movsd	xmm0, QWORD PTR __real@3fcb367a0f9096bc
	mulsd	xmm0, QWORD PTR _R$[ebp]
	movsd	xmm1, QWORD PTR __real@3fe6e2eb1c432ca5
	mulsd	xmm1, QWORD PTR _G$[ebp]
	addsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@3fb27bb2fec56d5d
	mulsd	xmm1, QWORD PTR _B$[ebp]
	addsd	xmm0, xmm1
	movsd	QWORD PTR tv73[ebp], xmm0
	fld	QWORD PTR tv73[ebp]

; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?PixelLuminanceSc@@YGNNNN@Z ENDP			; PixelLuminanceSc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
;	COMDAT ?PixelLuminance@@YGNEEE@Z
_TEXT	SEGMENT
tv79 = -8						; size = 8
_R$ = 8							; size = 1
_G$ = 12						; size = 1
_B$ = 16						; size = 1
?PixelLuminance@@YGNEEE@Z PROC				; PixelLuminance, COMDAT

; 29   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 30   :     return (0.2126 * (double)R) + (0.7152 * (double)G) + (0.0722 * (double)B);

	movzx	eax, BYTE PTR _R$[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3fcb367a0f9096bc
	movzx	ecx, BYTE PTR _G$[ebp]
	cvtsi2sd xmm1, ecx
	mulsd	xmm1, QWORD PTR __real@3fe6e2eb1c432ca5
	addsd	xmm0, xmm1
	movzx	edx, BYTE PTR _B$[ebp]
	cvtsi2sd xmm1, edx
	mulsd	xmm1, QWORD PTR __real@3fb27bb2fec56d5d
	addsd	xmm0, xmm1
	movsd	QWORD PTR tv79[ebp], xmm0
	fld	QWORD PTR tv79[ebp]

; 31   : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?PixelLuminance@@YGNEEE@Z ENDP				; PixelLuminance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
;	COMDAT ?Distance@@YGNHHHH@Z
_TEXT	SEGMENT
tv83 = -16						; size = 8
tv86 = -8						; size = 8
_X1$ = 8						; size = 4
_Y1$ = 12						; size = 4
_X2$ = 16						; size = 4
_Y2$ = 20						; size = 4
?Distance@@YGNHHHH@Z PROC				; Distance, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 96   :     return sqrt(pow((double)(X1 - X2), 2) + pow((double)(Y1 - Y2), 2));

	mov	eax, DWORD PTR _X1$[ebp]
	sub	eax, DWORD PTR _X2$[ebp]
	cvtsi2sd xmm0, eax
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	mov	ecx, DWORD PTR _Y1$[ebp]
	sub	ecx, DWORD PTR _Y2$[ebp]
	cvtsi2sd xmm1, ecx
	movsd	QWORD PTR tv86[ebp], xmm0
	movaps	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR tv86[ebp]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	call	__libm_sse2_sqrt_precise
	movsd	QWORD PTR tv83[ebp], xmm0
	fld	QWORD PTR tv83[ebp]

; 97   : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Distance@@YGNHHHH@Z ENDP				; Distance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\colorblender.cpp
;	COMDAT _ColorLuminance@12
_TEXT	SEGMENT
_nR$ = -24						; size = 8
_nG$ = -16						; size = 8
_nB$ = -8						; size = 8
_R$ = 8							; size = 1
_G$ = 12						; size = 1
_B$ = 16						; size = 1
_ColorLuminance@12 PROC					; COMDAT

; 54   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 55   :     double nR = (double)R / 255.0;

	movzx	eax, BYTE PTR _R$[ebp]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _nR$[ebp], xmm0

; 56   :     double nG = (double)G / 255.0;

	movzx	ecx, BYTE PTR _G$[ebp]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _nG$[ebp], xmm0

; 57   :     double nB = (double)B / 255.0;

	movzx	edx, BYTE PTR _B$[ebp]
	cvtsi2sd xmm0, edx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _nB$[ebp], xmm0

; 58   :     return PixelLuminanceSc(nR, nG, nB);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _nB$[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _nG$[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _nR$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?PixelLuminanceSc@@YGNNNN@Z		; PixelLuminanceSc

; 59   :     //return PixelLuminance(R, G, B);
; 60   : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_ColorLuminance@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
_TEXT	SEGMENT
__Expr_val$1 = -24					; size = 4
__Expr_val$2 = -20					; size = 4
__Expr_val$3 = -16					; size = 4
tv74 = -12						; size = 4
tv70 = -8						; size = 4
tv66 = -4						; size = 4
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memmove_s PROC

; 70   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 71   :         if (_SourceSize == 0)

	cmp	DWORD PTR __SourceSize$[ebp], 0
	jne	SHORT $LN2@memmove_s

; 72   :         {
; 73   :             return 0;

	xor	eax, eax
	jmp	$LN1@memmove_s
$LN2@memmove_s:

; 74   :         }
; 75   : 
; 76   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL,            EINVAL);

	cmp	DWORD PTR __Destination$[ebp], 0
	je	SHORT $LN7@memmove_s
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN8@memmove_s
$LN7@memmove_s:
	mov	DWORD PTR tv66[ebp], 0
$LN8@memmove_s:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR __Expr_val$3[ebp], eax
	cmp	DWORD PTR __Expr_val$3[ebp], 0
	jne	SHORT $LN3@memmove_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 22					; 00000016H
	jmp	$LN1@memmove_s
$LN3@memmove_s:

; 77   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

	cmp	DWORD PTR __Source$[ebp], 0
	je	SHORT $LN9@memmove_s
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN10@memmove_s
$LN9@memmove_s:
	mov	DWORD PTR tv70[ebp], 0
$LN10@memmove_s:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR __Expr_val$2[ebp], ecx
	cmp	DWORD PTR __Expr_val$2[ebp], 0
	jne	SHORT $LN4@memmove_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 22					; 00000016H
	jmp	SHORT $LN1@memmove_s
$LN4@memmove_s:

; 78   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

	mov	edx, DWORD PTR __DestinationSize$[ebp]
	cmp	edx, DWORD PTR __SourceSize$[ebp]
	jb	SHORT $LN11@memmove_s
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN12@memmove_s
$LN11@memmove_s:
	mov	DWORD PTR tv74[ebp], 0
$LN12@memmove_s:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR __Expr_val$1[ebp], eax
	cmp	DWORD PTR __Expr_val$1[ebp], 0
	jne	SHORT $LN5@memmove_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 34			; 00000022H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 34					; 00000022H
	jmp	SHORT $LN1@memmove_s
$LN5@memmove_s:

; 79   : 
; 80   :         memmove(_Destination, _Source, _SourceSize);

	mov	ecx, DWORD PTR __SourceSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Source$[ebp]
	push	edx
	mov	eax, DWORD PTR __Destination$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 81   :         return 0;

	xor	eax, eax
$LN1@memmove_s:

; 82   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_memmove_s ENDP
_TEXT	ENDS
END
