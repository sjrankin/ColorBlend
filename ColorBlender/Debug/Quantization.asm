; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Quantization.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Octree@28
PUBLIC	_ReduceColors@28
PUBLIC	_ReduceColor@8
PUBLIC	_ReduceColor2@16
PUBLIC	_MedianCut@20
PUBLIC	_MedianCutToIndexed@28
PUBLIC	_OverallBrightness@16
PUBLIC	?OverallBrightnessRegion@@YGNPAXHHHHHHH@Z	; OverallBrightnessRegion
PUBLIC	__real@4008000000000000
PUBLIC	__real@4026000000000000
EXTRN	_ColorLuminance@12:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@4026000000000000
CONST	SEGMENT
__real@4026000000000000 DQ 04026000000000000r	; 11
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\quantization.cpp
_TEXT	SEGMENT
_Final$ = -52						; size = 8
tv162 = -44						; size = 8
_Accumulator$ = -36					; size = 8
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_PixelCount$ = -20					; size = 4
_Index$2 = -16						; size = 4
_Src$ = -12						; size = 4
_Row$3 = -8						; size = 4
_Column$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Left$ = 24						; size = 4
_Top$ = 28						; size = 4
_Right$ = 32						; size = 4
_Bottom$ = 36						; size = 4
?OverallBrightnessRegion@@YGNPAXHHHHHHH@Z PROC		; OverallBrightnessRegion

; 175  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 176  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@OverallBri

; 177  :         return NullPointer;

	fld	QWORD PTR __real@4008000000000000
	jmp	$LN1@OverallBri
$LN8@OverallBri:

; 178  :     if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN9@OverallBri

; 179  :         return InvalidOperation;

	fld	QWORD PTR __real@4026000000000000
	jmp	$LN1@OverallBri
$LN9@OverallBri:

; 180  :     if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN10@OverallBri

; 181  :         return InvalidOperation;

	fld	QWORD PTR __real@4026000000000000
	jmp	$LN1@OverallBri
$LN10@OverallBri:

; 182  :     if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN11@OverallBri

; 183  :         return InvalidOperation;

	fld	QWORD PTR __real@4026000000000000
	jmp	$LN1@OverallBri
$LN11@OverallBri:

; 184  :     if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN12@OverallBri

; 185  :         return InvalidOperation;

	fld	QWORD PTR __real@4026000000000000
	jmp	$LN1@OverallBri
$LN12@OverallBri:

; 186  : 
; 187  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 188  :     int PixelCount = 0;

	mov	DWORD PTR _PixelCount$[ebp], 0

; 189  :     double Accumulator = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Accumulator$[ebp], xmm0

; 190  :     BYTE *Src = (BYTE *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], edx

; 191  : 
; 192  :     for (int Row = Top; Row <= Bottom; Row++)

	mov	eax, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$3[ebp], eax
	jmp	SHORT $LN4@OverallBri
$LN2@OverallBri:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@OverallBri:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _Bottom$[ebp]
	jg	$LN3@OverallBri

; 193  :     {
; 194  :         int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 195  :         for (int Column = Left; Column <= Right; Column++)

	mov	ecx, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$4[ebp], ecx
	jmp	SHORT $LN7@OverallBri
$LN5@OverallBri:
	mov	edx, DWORD PTR _Column$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$4[ebp], edx
$LN7@OverallBri:
	mov	eax, DWORD PTR _Column$4[ebp]
	cmp	eax, DWORD PTR _Right$[ebp]
	jg	SHORT $LN6@OverallBri

; 196  :         {
; 197  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$4[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], ecx

; 198  :             if ((Column >= Left) && (Column <= Right) && (Row >= Top) && (Row <= Bottom))

	mov	edx, DWORD PTR _Column$4[ebp]
	cmp	edx, DWORD PTR _Left$[ebp]
	jl	SHORT $LN13@OverallBri
	mov	eax, DWORD PTR _Column$4[ebp]
	cmp	eax, DWORD PTR _Right$[ebp]
	jg	SHORT $LN13@OverallBri
	mov	ecx, DWORD PTR _Row$3[ebp]
	cmp	ecx, DWORD PTR _Top$[ebp]
	jl	SHORT $LN13@OverallBri
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN13@OverallBri

; 199  :             {
; 200  :                 Accumulator += ColorLuminance(Src[Index + 2], Src[Index + 1], Src[Index + 0]);

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	call	_ColorLuminance@12
	fstp	QWORD PTR tv162[ebp]
	movsd	xmm0, QWORD PTR tv162[ebp]
	addsd	xmm0, QWORD PTR _Accumulator$[ebp]
	movsd	QWORD PTR _Accumulator$[ebp], xmm0

; 201  :                 PixelCount++;

	mov	eax, DWORD PTR _PixelCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _PixelCount$[ebp], eax
$LN13@OverallBri:

; 202  :             }
; 203  :         }

	jmp	SHORT $LN5@OverallBri
$LN6@OverallBri:

; 204  :     }

	jmp	$LN2@OverallBri
$LN3@OverallBri:

; 205  : 
; 206  :     double Final = Accumulator / (double)PixelCount;

	cvtsi2sd xmm0, DWORD PTR _PixelCount$[ebp]
	movsd	xmm1, QWORD PTR _Accumulator$[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _Final$[ebp], xmm1

; 207  :     return Final;

	fld	QWORD PTR _Final$[ebp]
$LN1@OverallBri:

; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?OverallBrightnessRegion@@YGNPAXHHHHHHH@Z ENDP		; OverallBrightnessRegion
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\quantization.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_OverallBrightness@16 PROC

; 219  : {

	push	ebp
	mov	ebp, esp

; 220  :     return OverallBrightnessRegion(Source, Width, Height, Stride, 0, 0, Width - 1, Height - 1);

	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Stride$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Source$[ebp]
	push	edx
	call	?OverallBrightnessRegion@@YGNPAXHHHHHHH@Z ; OverallBrightnessRegion

; 221  : }

	pop	ebp
	ret	16					; 00000010H
_OverallBrightness@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\quantization.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_IndexedDestination$ = 24				; size = 4
_PaletteData$ = 28					; size = 4
_PaletteSize$ = 32					; size = 4
_MedianCutToIndexed@28 PROC

; 148  : {

	push	ebp
	mov	ebp, esp

; 149  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@MedianCutT

; 150  :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@MedianCutT
$LN2@MedianCutT:

; 151  :     if (IndexedDestination == NULL)

	cmp	DWORD PTR _IndexedDestination$[ebp], 0
	jne	SHORT $LN3@MedianCutT

; 152  :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@MedianCutT
$LN3@MedianCutT:

; 153  :     if (PaletteData == NULL)

	cmp	DWORD PTR _PaletteData$[ebp], 0
	jne	SHORT $LN4@MedianCutT

; 154  :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@MedianCutT
$LN4@MedianCutT:

; 155  :     if ((PaletteSize < 1) || (PaletteSize > 256))

	cmp	DWORD PTR _PaletteSize$[ebp], 1
	jl	SHORT $LN6@MedianCutT
	cmp	DWORD PTR _PaletteSize$[ebp], 256	; 00000100H
	jle	SHORT $LN5@MedianCutT
$LN6@MedianCutT:

; 156  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@MedianCutT
$LN5@MedianCutT:

; 157  : 
; 158  :     return Success;

	xor	eax, eax
$LN1@MedianCutT:

; 159  : }

	pop	ebp
	ret	28					; 0000001cH
_MedianCutToIndexed@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\quantization.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_MedianCut@20 PROC

; 121  : {

	push	ebp
	mov	ebp, esp

; 122  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@MedianCut

; 123  :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@MedianCut
$LN2@MedianCut:

; 124  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN3@MedianCut

; 125  :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@MedianCut
$LN3@MedianCut:

; 126  : 
; 127  :     return Success;

	xor	eax, eax
$LN1@MedianCut:

; 128  : }

	pop	ebp
	ret	20					; 00000014H
_MedianCut@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\quantization.cpp
_TEXT	SEGMENT
_OTree$ = 8						; size = 4
_Red$ = 12						; size = 1
_Green$ = 16						; size = 1
_Blue$ = 20						; size = 1
_ReduceColor2@16 PROC

; 57   : {

	push	ebp
	mov	ebp, esp

; 58   :     return ReduceColor(OTree, 0xff000000 | Red << 16 | Green << 8 | Blue << 0);

	movzx	eax, BYTE PTR _Red$[ebp]
	shl	eax, 16					; 00000010H
	or	eax, -16777216				; ff000000H
	movzx	ecx, BYTE PTR _Green$[ebp]
	shl	ecx, 8
	or	eax, ecx
	movzx	edx, BYTE PTR _Blue$[ebp]
	or	eax, edx
	push	eax
	mov	eax, DWORD PTR _OTree$[ebp]
	push	eax
	call	_ReduceColor@8

; 59   : }

	pop	ebp
	ret	16					; 00000010H
_ReduceColor2@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\quantization.cpp
_TEXT	SEGMENT
_OTree$ = 8						; size = 4
_PackedColor$ = 12					; size = 4
_ReduceColor@8 PROC

; 41   : {

	push	ebp
	mov	ebp, esp

; 42   :     return 0x0;

	xor	eax, eax

; 43   : }

	pop	ebp
	ret	8
_ReduceColor@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\quantization.cpp
_TEXT	SEGMENT
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Reduced$2 = -24					; size = 4
_Dest$ = -20						; size = 4
_Src$ = -16						; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_Index$5 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_OTree$ = 28						; size = 4
_OTreeCount$ = 32					; size = 4
_ReduceColors@28 PROC

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 75   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ReduceColo

; 76   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ReduceColo
$LN8@ReduceColo:

; 77   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ReduceColo

; 78   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ReduceColo
$LN9@ReduceColo:

; 79   :     if (OTree == NULL)

	cmp	DWORD PTR _OTree$[ebp], 0
	jne	SHORT $LN10@ReduceColo

; 80   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ReduceColo
$LN10@ReduceColo:

; 81   : 
; 82   :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 83   :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 84   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 85   : 
; 86   :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@ReduceColo
$LN2@ReduceColo:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@ReduceColo:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@ReduceColo

; 87   :     {
; 88   :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 89   :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@ReduceColo
$LN5@ReduceColo:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@ReduceColo:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@ReduceColo

; 90   :         {
; 91   :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 92   :             UINT32 Reduced = ReduceColor2(OTree, Src[Index + 2], Src[Index + 1], Src[Index + 0]);

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _OTree$[ebp]
	push	edx
	call	_ReduceColor2@16
	mov	DWORD PTR _Reduced$2[ebp], eax

; 93   :             Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 94   :             Dest[Index + 2] = (Reduced & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _Reduced$2[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [ecx+2], al

; 95   :             Dest[Index + 1] = (Reduced & 0x0000ff00) >> 8;

	mov	edx, DWORD PTR _Reduced$2[ebp]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+1], dl

; 96   :             Dest[Index + 0] = (Reduced & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _Reduced$2[ebp]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx], cl

; 97   :         }

	jmp	$LN5@ReduceColo
$LN6@ReduceColo:

; 98   :     }

	jmp	$LN2@ReduceColo
$LN3@ReduceColo:

; 99   : 
; 100  :     return Success;

	xor	eax, eax
$LN1@ReduceColo:

; 101  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_ReduceColors@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\quantization.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Count$ = 24						; size = 4
_OTree$ = 28						; size = 4
_OTreeCount$ = 32					; size = 4
_Octree@28 PROC

; 23   : {

	push	ebp
	mov	ebp, esp

; 24   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@Octree

; 25   :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@Octree
$LN2@Octree:

; 26   :     if (Count < 2)

	cmp	DWORD PTR _Count$[ebp], 2
	jge	SHORT $LN3@Octree

; 27   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@Octree
$LN3@Octree:

; 28   :     if (Count > 256)

	cmp	DWORD PTR _Count$[ebp], 256		; 00000100H
	jle	SHORT $LN4@Octree

; 29   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@Octree
$LN4@Octree:

; 30   : 
; 31   :     return Success;

	xor	eax, eax
$LN1@Octree:

; 32   : }

	pop	ebp
	ret	28					; 0000001cH
_Octree@28 ENDP
_TEXT	ENDS
END
