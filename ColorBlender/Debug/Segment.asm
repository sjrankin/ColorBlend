; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Segment.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_SegmentizeImage@40
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_HorizontalMirrorPixel@16:PROC
EXTRN	_VerticalMirrorPixel@16:PROC
EXTRN	_CopyBufferRegion@36:PROC
EXTRN	_PasteRegion2@40:PROC
EXTRN	_PasteRegion4@40:PROC
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\segment.cpp
_TEXT	SEGMENT
_VerticalSegmentRemainder$ = -128			; size = 4
_HorizontalSegmentRemainder$ = -124			; size = 4
_Src$ = -120						; size = 4
$T1 = -116						; size = 4
$T2 = -112						; size = 4
$T3 = -108						; size = 4
$T4 = -104						; size = 4
$T5 = -100						; size = 4
_Dest$ = -96						; size = 4
_HorizontalSegmentCount$ = -92				; size = 4
_VerticalSegmentCount$ = -88				; size = 4
$T6 = -84						; size = 4
$T7 = -80						; size = 4
$T8 = -76						; size = 4
$T9 = -72						; size = 4
$T10 = -68						; size = 4
tv164 = -64						; size = 4
tv152 = -60						; size = 4
_Result$ = -56						; size = 4
_CellSize$ = -52					; size = 4
$T11 = -48						; size = 4
$T12 = -44						; size = 4
_Column$13 = -40					; size = 4
_Row$14 = -36						; size = 4
_Cell$ = -32						; size = 4
_Segment$ = -28						; size = 4
_MCell$ = -24						; size = 4
_PixelSize$ = -20					; size = 4
_SegmentHeight$ = -16					; size = 4
_SegmentWidth$ = -12					; size = 4
_LR$ = -8						; size = 4
_UL$ = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_CellWidth$ = 28					; size = 4
_CellHeight$ = 32					; size = 4
_CellOriginX$ = 36					; size = 4
_CellOriginY$ = 40					; size = 4
_SegmentPattern$ = 44					; size = 4
_SegmentizeImage@40 PROC

; 13   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H

; 14   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@Segmentize

; 15   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@Segmentize
$LN8@Segmentize:

; 16   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@Segmentize

; 17   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@Segmentize
$LN9@Segmentize:

; 18   : 
; 19   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 20   :     UINT32 *Src = (UINT32 *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 21   :     UINT32 *Dest = (UINT32 *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 22   :     int HorizontalSegmentCount = Width / (CellWidth * 2);

	mov	ecx, DWORD PTR _CellWidth$[ebp]
	shl	ecx, 1
	mov	eax, DWORD PTR _Width$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _HorizontalSegmentCount$[ebp], eax

; 23   :     int HorizontalSegmentRemainder = Width % (CellWidth * 2);

	mov	ecx, DWORD PTR _CellWidth$[ebp]
	shl	ecx, 1
	mov	eax, DWORD PTR _Width$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _HorizontalSegmentRemainder$[ebp], edx

; 24   :     int VerticalSegmentCount = Height / (CellHeight * 2);

	mov	ecx, DWORD PTR _CellHeight$[ebp]
	shl	ecx, 1
	mov	eax, DWORD PTR _Height$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _VerticalSegmentCount$[ebp], eax

; 25   :     int VerticalSegmentRemainder = Height % (CellHeight * 2);

	mov	ecx, DWORD PTR _CellHeight$[ebp]
	shl	ecx, 1
	mov	eax, DWORD PTR _Height$[ebp]
	cdq
	idiv	ecx
	mov	DWORD PTR _VerticalSegmentRemainder$[ebp], edx

; 26   :     int CellSize = CellWidth * CellHeight;

	mov	edx, DWORD PTR _CellWidth$[ebp]
	imul	edx, DWORD PTR _CellHeight$[ebp]
	mov	DWORD PTR _CellSize$[ebp], edx

; 27   : 
; 28   :     UINT32 *Cell = new UINT32[CellSize];

	xor	ecx, ecx
	mov	eax, DWORD PTR _CellSize$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T10[ebp], eax
	mov	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR _Cell$[ebp], eax

; 29   :     int Result = CopyBufferRegion(Source, Cell, Width, Height, Stride, CellOriginX, CellOriginY, CellOriginX + CellWidth,

	mov	ecx, DWORD PTR _CellOriginX$[ebp]
	add	ecx, DWORD PTR _CellHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CellOriginX$[ebp]
	add	edx, DWORD PTR _CellWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _CellOriginY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CellOriginX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stride$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Cell$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_CopyBufferRegion@36
	mov	DWORD PTR _Result$[ebp], eax

; 30   :         CellOriginX + CellHeight);
; 31   :     if (Result != Success)

	cmp	DWORD PTR _Result$[ebp], 0
	je	SHORT $LN10@Segmentize

; 32   :     {
; 33   :         delete[] Cell;

	mov	ecx, DWORD PTR _Cell$[ebp]
	mov	DWORD PTR $T9[ebp], ecx
	mov	edx, DWORD PTR $T9[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 34   :         return Result;

	mov	eax, DWORD PTR _Result$[ebp]
	jmp	$LN1@Segmentize
$LN10@Segmentize:

; 35   :     }
; 36   : 
; 37   :     int SegmentWidth = 0;

	mov	DWORD PTR _SegmentWidth$[ebp], 0

; 38   :     int SegmentHeight = 0;

	mov	DWORD PTR _SegmentHeight$[ebp], 0

; 39   :     if (SegmentPattern == SegmentHorizontalMirror)

	cmp	DWORD PTR _SegmentPattern$[ebp], 1
	jne	SHORT $LN11@Segmentize

; 40   :     {
; 41   :         SegmentWidth = CellWidth * 2;

	mov	eax, DWORD PTR _CellWidth$[ebp]
	shl	eax, 1
	mov	DWORD PTR _SegmentWidth$[ebp], eax

; 42   :         SegmentHeight = CellHeight;

	mov	ecx, DWORD PTR _CellHeight$[ebp]
	mov	DWORD PTR _SegmentHeight$[ebp], ecx

; 43   :     }
; 44   :     else

	jmp	SHORT $LN12@Segmentize
$LN11@Segmentize:

; 45   :     {
; 46   :         SegmentWidth = CellWidth;

	mov	edx, DWORD PTR _CellWidth$[ebp]
	mov	DWORD PTR _SegmentWidth$[ebp], edx

; 47   :         SegmentHeight = CellHeight * 2;

	mov	eax, DWORD PTR _CellHeight$[ebp]
	shl	eax, 1
	mov	DWORD PTR _SegmentHeight$[ebp], eax
$LN12@Segmentize:

; 48   :     }
; 49   :     UINT32 *Segment = new UINT32[SegmentWidth * SegmentHeight * PixelSize];

	mov	eax, DWORD PTR _SegmentWidth$[ebp]
	imul	eax, DWORD PTR _SegmentHeight$[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR _Segment$[ebp], eax

; 50   : 
; 51   :     AbsolutePointStruct *UL = new AbsolutePointStruct();

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	cmp	DWORD PTR $T12[ebp], 0
	je	SHORT $LN16@Segmentize
	xor	ecx, ecx
	mov	edx, DWORD PTR $T12[ebp]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T12[ebp]
	mov	DWORD PTR tv152[ebp], eax
	jmp	SHORT $LN17@Segmentize
$LN16@Segmentize:
	mov	DWORD PTR tv152[ebp], 0
$LN17@Segmentize:
	mov	ecx, DWORD PTR tv152[ebp]
	mov	DWORD PTR _UL$[ebp], ecx

; 52   :     UL->X = 0;

	mov	edx, DWORD PTR _UL$[ebp]
	mov	DWORD PTR [edx], 0

; 53   :     UL->Y = 0;

	mov	eax, DWORD PTR _UL$[ebp]
	mov	DWORD PTR [eax+4], 0

; 54   :     AbsolutePointStruct *LR = new AbsolutePointStruct();

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T11[ebp], eax
	cmp	DWORD PTR $T11[ebp], 0
	je	SHORT $LN18@Segmentize
	xor	ecx, ecx
	mov	edx, DWORD PTR $T11[ebp]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN19@Segmentize
$LN18@Segmentize:
	mov	DWORD PTR tv164[ebp], 0
$LN19@Segmentize:
	mov	ecx, DWORD PTR tv164[ebp]
	mov	DWORD PTR _LR$[ebp], ecx

; 55   :     LR->X = CellWidth - 1;

	mov	edx, DWORD PTR _CellWidth$[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [eax], edx

; 56   :     LR->Y = CellHeight - 1;

	mov	ecx, DWORD PTR _CellHeight$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 57   : 
; 58   :     PasteRegion4(Destination, Width, Height, Segment, SegmentWidth, SegmentHeight, UL->X,UL->Y,LR->X,LR->Y);

	mov	eax, DWORD PTR _LR$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _LR$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _SegmentHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _SegmentWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Segment$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Destination$[ebp]
	push	ecx
	call	_PasteRegion4@40

; 59   :     return Success;

	xor	eax, eax
	jmp	$LN1@Segmentize

; 60   : 
; 61   :     PasteRegion2(Segment, SegmentWidth, SegmentHeight, SegmentWidth * PixelSize,

	mov	edx, DWORD PTR _LR$[ebp]
	push	edx
	mov	eax, DWORD PTR _UL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CellWidth$[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CellHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _CellWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Cell$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SegmentWidth$[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _SegmentHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SegmentWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Segment$[ebp]
	push	edx
	call	_PasteRegion2@40

; 62   :         Cell, CellWidth, CellHeight, CellWidth * PixelSize, UL, LR);
; 63   :     UINT32 *MCell = NULL;

	mov	DWORD PTR _MCell$[ebp], 0

; 64   :     if (SegmentPattern == SegmentHorizontalMirror)

	cmp	DWORD PTR _SegmentPattern$[ebp], 1
	jne	$LN13@Segmentize

; 65   :     {
; 66   :         MCell = new UINT32[CellSize];

	xor	ecx, ecx
	mov	eax, DWORD PTR _CellSize$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR _MCell$[ebp], eax

; 67   :         HorizontalMirrorPixel(Cell, CellWidth, CellHeight, MCell);

	mov	ecx, DWORD PTR _MCell$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CellHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _CellWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Cell$[ebp]
	push	ecx
	call	_HorizontalMirrorPixel@16

; 68   :         UL->X = CellWidth;

	mov	edx, DWORD PTR _UL$[ebp]
	mov	eax, DWORD PTR _CellWidth$[ebp]
	mov	DWORD PTR [edx], eax

; 69   :         UL->Y = 0;

	mov	ecx, DWORD PTR _UL$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 70   :         LR->X = SegmentWidth - 1;

	mov	edx, DWORD PTR _SegmentWidth$[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [eax], edx

; 71   :         LR->Y = CellHeight - 1;

	mov	ecx, DWORD PTR _CellHeight$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 72   :         PasteRegion2(Segment, SegmentWidth, SegmentHeight, SegmentWidth * PixelSize,

	mov	eax, DWORD PTR _LR$[ebp]
	push	eax
	mov	ecx, DWORD PTR _UL$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CellWidth$[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _CellHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CellWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _MCell$[ebp]
	push	edx
	mov	eax, DWORD PTR _SegmentWidth$[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SegmentHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SegmentWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Segment$[ebp]
	push	eax
	call	_PasteRegion2@40

; 73   :             MCell, CellWidth, CellHeight, CellWidth * PixelSize, UL, LR);
; 74   :     }
; 75   :     else

	jmp	$LN14@Segmentize
$LN13@Segmentize:

; 76   :     {
; 77   :         MCell = new UINT32[CellSize];

	xor	ecx, ecx
	mov	eax, DWORD PTR _CellSize$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _MCell$[ebp], eax

; 78   :         VerticalMirrorPixel(Cell, CellWidth, CellHeight, MCell);

	mov	ecx, DWORD PTR _MCell$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CellHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _CellWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Cell$[ebp]
	push	ecx
	call	_VerticalMirrorPixel@16

; 79   :         UL->X = 0;

	mov	edx, DWORD PTR _UL$[ebp]
	mov	DWORD PTR [edx], 0

; 80   :         UL->Y = CellHeight;

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _CellHeight$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 81   :         LR->X = SegmentWidth - 1;

	mov	edx, DWORD PTR _SegmentWidth$[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [eax], edx

; 82   :         LR->Y = SegmentHeight - 1;

	mov	ecx, DWORD PTR _SegmentHeight$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 83   :         PasteRegion2(Segment, SegmentWidth, SegmentHeight, SegmentWidth * PixelSize,

	mov	eax, DWORD PTR _LR$[ebp]
	push	eax
	mov	ecx, DWORD PTR _UL$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CellWidth$[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _CellHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CellWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _MCell$[ebp]
	push	edx
	mov	eax, DWORD PTR _SegmentWidth$[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SegmentHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SegmentWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Segment$[ebp]
	push	eax
	call	_PasteRegion2@40
$LN14@Segmentize:

; 84   :             MCell, CellWidth, CellHeight, CellWidth * PixelSize, UL, LR);
; 85   :     }
; 86   : 
; 87   :     for (int Row = 0; Row < VerticalSegmentCount + 1; Row++)

	mov	DWORD PTR _Row$14[ebp], 0
	jmp	SHORT $LN4@Segmentize
$LN2@Segmentize:
	mov	ecx, DWORD PTR _Row$14[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$14[ebp], ecx
$LN4@Segmentize:
	mov	edx, DWORD PTR _VerticalSegmentCount$[ebp]
	add	edx, 1
	cmp	DWORD PTR _Row$14[ebp], edx
	jge	$LN3@Segmentize

; 88   :     {
; 89   :         for (int Column = 0; Column < HorizontalSegmentCount + 1; Column++)

	mov	DWORD PTR _Column$13[ebp], 0
	jmp	SHORT $LN7@Segmentize
$LN5@Segmentize:
	mov	eax, DWORD PTR _Column$13[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$13[ebp], eax
$LN7@Segmentize:
	mov	ecx, DWORD PTR _HorizontalSegmentCount$[ebp]
	add	ecx, 1
	cmp	DWORD PTR _Column$13[ebp], ecx
	jge	SHORT $LN6@Segmentize

; 90   :         {
; 91   :             UL->X = Row + Column;

	mov	edx, DWORD PTR _Row$14[ebp]
	add	edx, DWORD PTR _Column$13[ebp]
	mov	eax, DWORD PTR _UL$[ebp]
	mov	DWORD PTR [eax], edx

; 92   :             UL->Y = Row;

	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR _Row$14[ebp]
	mov	DWORD PTR [ecx+4], edx

; 93   :             LR->X = UL->X + SegmentWidth;

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _SegmentWidth$[ebp]
	mov	edx, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [edx], ecx

; 94   :             LR->Y = UL->Y + SegmentHeight;

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _SegmentHeight$[ebp]
	mov	edx, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 95   :             PasteRegion4(Dest, Width, Height, Segment, SegmentWidth, SegmentHeight, UL->X, UL->Y, LR->X,LR->Y);

	mov	eax, DWORD PTR _LR$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _LR$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _SegmentHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _SegmentWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Segment$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Dest$[ebp]
	push	ecx
	call	_PasteRegion4@40

; 96   :         }

	jmp	SHORT $LN5@Segmentize
$LN6@Segmentize:

; 97   :     }

	jmp	$LN2@Segmentize
$LN3@Segmentize:

; 98   : 
; 99   :     delete UL;

	mov	edx, DWORD PTR _UL$[ebp]
	mov	DWORD PTR $T5[ebp], edx
	push	8
	mov	eax, DWORD PTR $T5[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 100  :     delete LR;

	mov	ecx, DWORD PTR _LR$[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	push	8
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 101  :     delete[] MCell;

	mov	eax, DWORD PTR _MCell$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 102  :     delete[] Segment;

	mov	edx, DWORD PTR _Segment$[ebp]
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 103  :     delete[] Cell;

	mov	ecx, DWORD PTR _Cell$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 104  :     return Success;

	xor	eax, eax
$LN1@Segmentize:

; 105  : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_SegmentizeImage@40 ENDP
_TEXT	ENDS
END
