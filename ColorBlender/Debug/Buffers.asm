; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Buffers.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_InPlaceReverseScanLine@8
PUBLIC	_SwapPixel@8
PUBLIC	_CopyBuffer3@12
PUBLIC	_CopyBuffer2@16
PUBLIC	_CopyHorizontalLine@28
PUBLIC	_CopyVerticalLine@28
PUBLIC	_CopyCircularBuffer@48
PUBLIC	_ClearBuffer2@20
PUBLIC	_CopyRegion@36
PUBLIC	_PasteRegion@40
PUBLIC	_PasteRegion2@40
PUBLIC	_PasteRegion3@32
PUBLIC	_PasteRegion4@40
PUBLIC	_CopyBufferToBuffer@20
PUBLIC	_ClearBufferRegion2@36
PUBLIC	_SwapImageBuffers@20
PUBLIC	_ClearBufferDWord@16
PUBLIC	_ExtractScanLine@28
PUBLIC	_CopyBufferRegionPixel@32
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp___errno:PROC
EXTRN	_memmove:PROC
EXTRN	_ClearBufferRegion@36:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_Src$ = -28						; size = 4
_Index$1 = -24						; size = 4
_Dest$ = -20						; size = 4
_RowOffset$2 = -16					; size = 4
_DestIndex$ = -12					; size = 4
_Column$3 = -8						; size = 4
_Row$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_X1$ = 24						; size = 4
_Y1$ = 28						; size = 4
_X2$ = 32						; size = 4
_Y2$ = 36						; size = 4
_CopyBufferRegionPixel@32 PROC

; 759  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 760  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@CopyBuffer

; 761  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyBuffer
$LN8@CopyBuffer:

; 762  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@CopyBuffer

; 763  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyBuffer
$LN9@CopyBuffer:

; 764  : 	if (X1 < 0)

	cmp	DWORD PTR _X1$[ebp], 0
	jge	SHORT $LN10@CopyBuffer

; 765  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyBuffer
$LN10@CopyBuffer:

; 766  : 	if (Y1 < 0)

	cmp	DWORD PTR _Y1$[ebp], 0
	jge	SHORT $LN11@CopyBuffer

; 767  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyBuffer
$LN11@CopyBuffer:

; 768  : 	if (X2 > Width - 1)

	mov	eax, DWORD PTR _Width$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _X2$[ebp], eax
	jle	SHORT $LN12@CopyBuffer

; 769  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyBuffer
$LN12@CopyBuffer:

; 770  : 	if (Y2 > Height - 1)

	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Y2$[ebp], ecx
	jle	SHORT $LN13@CopyBuffer

; 771  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyBuffer
$LN13@CopyBuffer:

; 772  : 	if (X1 >= X2)

	mov	edx, DWORD PTR _X1$[ebp]
	cmp	edx, DWORD PTR _X2$[ebp]
	jl	SHORT $LN14@CopyBuffer

; 773  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyBuffer
$LN14@CopyBuffer:

; 774  : 	if (Y1 >= Y2)

	mov	eax, DWORD PTR _Y1$[ebp]
	cmp	eax, DWORD PTR _Y2$[ebp]
	jl	SHORT $LN15@CopyBuffer

; 775  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopyBuffer
$LN15@CopyBuffer:

; 776  : 
; 777  : 	UINT32 *Src = (UINT32 *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 778  : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	edx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], edx

; 779  : 
; 780  : 	int DestIndex = 0;

	mov	DWORD PTR _DestIndex$[ebp], 0

; 781  : 	for (int Row = Y1; Row <= Y2; Row++)

	mov	eax, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _Row$4[ebp], eax
	jmp	SHORT $LN4@CopyBuffer
$LN2@CopyBuffer:
	mov	ecx, DWORD PTR _Row$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$4[ebp], ecx
$LN4@CopyBuffer:
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _Y2$[ebp]
	jg	SHORT $LN3@CopyBuffer

; 782  : 	{
; 783  : 		int RowOffset = Row * Width;

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], eax

; 784  : 		for (int Column = X1; Column <= X2; Column++)

	mov	ecx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _Column$3[ebp], ecx
	jmp	SHORT $LN7@CopyBuffer
$LN5@CopyBuffer:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@CopyBuffer:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _X2$[ebp]
	jg	SHORT $LN6@CopyBuffer

; 785  : 		{
; 786  : 			int Index = Column + RowOffset;

	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$1[ebp], ecx

; 787  : 			Dest[DestIndex] = Src[Index];

	mov	edx, DWORD PTR _DestIndex$[ebp]
	mov	eax, DWORD PTR _Dest$[ebp]
	mov	ecx, DWORD PTR _Index$1[ebp]
	mov	esi, DWORD PTR _Src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx

; 788  : 			DestIndex++;

	mov	edx, DWORD PTR _DestIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _DestIndex$[ebp], edx

; 789  : 		}

	jmp	SHORT $LN5@CopyBuffer
$LN6@CopyBuffer:

; 790  : 	}

	jmp	SHORT $LN2@CopyBuffer
$LN3@CopyBuffer:

; 791  : 
; 792  : 	return Success;

	xor	eax, eax
$LN1@CopyBuffer:

; 793  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_CopyBufferRegionPixel@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_Src$ = -20						; size = 4
_Dest$ = -16						; size = 4
_RowOffset$ = -12					; size = 4
_Index$1 = -8						; size = 4
_Column$2 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_X1$ = 24						; size = 4
_X2$ = 28						; size = 4
_Y$ = 32						; size = 4
_ExtractScanLine@28 PROC

; 729  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 730  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN5@ExtractSca

; 731  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ExtractSca
$LN5@ExtractSca:

; 732  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN6@ExtractSca

; 733  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ExtractSca
$LN6@ExtractSca:

; 734  : 	if (X1 < 0)

	cmp	DWORD PTR _X1$[ebp], 0
	jge	SHORT $LN7@ExtractSca

; 735  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ExtractSca
$LN7@ExtractSca:

; 736  : 	if (X2 > Width - 1)

	mov	eax, DWORD PTR _Width$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _X2$[ebp], eax
	jle	SHORT $LN8@ExtractSca

; 737  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@ExtractSca
$LN8@ExtractSca:

; 738  : 	if (X1 > X2)

	mov	ecx, DWORD PTR _X1$[ebp]
	cmp	ecx, DWORD PTR _X2$[ebp]
	jle	SHORT $LN9@ExtractSca

; 739  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@ExtractSca
$LN9@ExtractSca:

; 740  : 	if (Y < 0)

	cmp	DWORD PTR _Y$[ebp], 0
	jge	SHORT $LN10@ExtractSca

; 741  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@ExtractSca
$LN10@ExtractSca:

; 742  : 	if (Y > Height - 1)

	mov	edx, DWORD PTR _Height$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _Y$[ebp], edx
	jle	SHORT $LN11@ExtractSca

; 743  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@ExtractSca
$LN11@ExtractSca:

; 744  : 
; 745  : 	UINT32 *Src = (UINT32 *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 746  : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 747  : 
; 748  : 	int RowOffset = Y * Width;

	mov	edx, DWORD PTR _Y$[ebp]
	imul	edx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$[ebp], edx

; 749  : 	for (int Column = X1; Column <= X2; Column++)

	mov	eax, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _Column$2[ebp], eax
	jmp	SHORT $LN4@ExtractSca
$LN2@ExtractSca:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN4@ExtractSca:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _X2$[ebp]
	jg	SHORT $LN3@ExtractSca

; 750  : 	{
; 751  : 		int Index = Column + RowOffset;

	mov	eax, DWORD PTR _Column$2[ebp]
	add	eax, DWORD PTR _RowOffset$[ebp]
	mov	DWORD PTR _Index$1[ebp], eax

; 752  : 		Dest[Index] = Src[Index];

	mov	ecx, DWORD PTR _Index$1[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _Index$1[ebp]
	mov	esi, DWORD PTR _Src$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax

; 753  : 	}

	jmp	SHORT $LN2@ExtractSca
$LN3@ExtractSca:

; 754  : 	return Success;

	xor	eax, eax
$LN1@ExtractSca:

; 755  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_ExtractScanLine@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_Dest$ = -8						; size = 4
_BufferSize$ = -4					; size = 4
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_ClearWith$ = 20					; size = 4
_ClearBufferDWord@16 PROC

; 464  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 465  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN2@ClearBuffe

; 466  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@ClearBuffe
$LN2@ClearBuffe:

; 467  : 
; 468  : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 469  : 	//memset(Dest, ClearWith, (size_t)(Width * Height));
; 470  : 	UINT32 BufferSize = Width * Height;

	mov	ecx, DWORD PTR _Width$[ebp]
	imul	ecx, DWORD PTR _Height$[ebp]
	mov	DWORD PTR _BufferSize$[ebp], ecx

; 471  : 	//Dest[10] = ClearWith;
; 472  : 	__asm
; 473  : 	{
; 474  : 		mov ecx, BufferSize;

	mov	ecx, DWORD PTR _BufferSize$[ebp]

; 475  : 		mov edx, 4;

	mov	edx, 4
$Repeat$4:

; 476  : 	Repeat:
; 477  : 		imul eax, edx, ecx;

	imul	eax, edx, ecx

; 478  : 		mov ebx, DWORD PTR Dest;

	mov	ebx, DWORD PTR _Dest$[ebp]

; 479  : 		mov edx, DWORD PTR ClearWith;

	mov	edx, DWORD PTR _ClearWith$[ebp]

; 480  : 		mov DWORD PTR[ebx + eax], edx;

	mov	DWORD PTR [ebx+eax], edx

; 481  : 		loop Repeat;

	loop	$Repeat$4

; 482  : 	}
; 483  : 	/*
; 484  : 	__asm
; 485  : 	{
; 486  : 		movd cx, BufferSize;
; 487  : 		mov edi, Destination;
; 488  : 		mov esi, 1;
; 489  : 		start :
; 490  : 		mov dword ptr [edi+esi], ClearWidth;
; 491  : 		inc esi;
; 492  : 		loop start;
; 493  : 	}
; 494  : */
; 495  : /*
; 496  : 	for (int Row = 0; Row < Height; Row++)
; 497  : 	{
; 498  : 		int DestIndex = Row * Width;
; 499  : 		memset(Dest, ClearWith, (size_t)Width);
; 500  : 	}
; 501  :   */
; 502  : 	return Success;

	xor	eax, eax
$LN1@ClearBuffe:

; 503  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_ClearBufferDWord@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_PixelSize$ = -32					; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
_BufferSize$ = -20					; size = 4
_Buf2$ = -16						; size = 4
_Buf1$ = -12						; size = 4
_Swap$ = -8						; size = 4
_Result$ = -4						; size = 4
_Buffer1$ = 8						; size = 4
_Buffer2$ = 12						; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_Stride$ = 24						; size = 4
_SwapImageBuffers@20 PROC

; 702  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 703  : 	if (Buffer1 == NULL)

	cmp	DWORD PTR _Buffer1$[ebp], 0
	jne	SHORT $LN2@SwapImageB

; 704  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SwapImageB
$LN2@SwapImageB:

; 705  : 	if (Buffer2 == NULL)

	cmp	DWORD PTR _Buffer2$[ebp], 0
	jne	SHORT $LN3@SwapImageB

; 706  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SwapImageB
$LN3@SwapImageB:

; 707  : 
; 708  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 709  : 	BYTE *Buf1 = (BYTE *)Buffer1;

	mov	eax, DWORD PTR _Buffer1$[ebp]
	mov	DWORD PTR _Buf1$[ebp], eax

; 710  : 	BYTE *Buf2 = (BYTE *)Buffer2;

	mov	ecx, DWORD PTR _Buffer2$[ebp]
	mov	DWORD PTR _Buf2$[ebp], ecx

; 711  : 	UINT32 BufferSize = Height * Stride;

	mov	edx, DWORD PTR _Height$[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _BufferSize$[ebp], edx

; 712  : 	BYTE *Swap = new BYTE[BufferSize];

	mov	eax, DWORD PTR _BufferSize$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _Swap$[ebp], ecx

; 713  : 	int Result = Success;

	mov	DWORD PTR _Result$[ebp], 0

; 714  : 
; 715  : 	Result = CopyBufferToBuffer(Buf1, Width, Height, Stride, Swap);

	mov	edx, DWORD PTR _Swap$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Buf1$[ebp]
	push	eax
	call	_CopyBufferToBuffer@20
	mov	DWORD PTR _Result$[ebp], eax

; 716  : 	if (Result == Success)

	cmp	DWORD PTR _Result$[ebp], 0
	jne	SHORT $LN4@SwapImageB

; 717  : 	{
; 718  : 		Result = CopyBufferToBuffer(Buf2, Width, Height, Stride, Buf1);

	mov	ecx, DWORD PTR _Buf1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stride$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Buf2$[ebp]
	push	edx
	call	_CopyBufferToBuffer@20
	mov	DWORD PTR _Result$[ebp], eax

; 719  : 		if (Result == Success)

	cmp	DWORD PTR _Result$[ebp], 0
	jne	SHORT $LN4@SwapImageB

; 720  : 		{
; 721  : 			Result = CopyBufferToBuffer(Swap, Width, Height, Stride, Buf2);

	mov	eax, DWORD PTR _Buf2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Swap$[ebp]
	push	ecx
	call	_CopyBufferToBuffer@20
	mov	DWORD PTR _Result$[ebp], eax
$LN4@SwapImageB:

; 722  : 		}
; 723  : 	}
; 724  : 	delete[] Swap;

	mov	edx, DWORD PTR _Swap$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 725  : 	return Result;

	mov	eax, DWORD PTR _Result$[ebp]
$LN1@SwapImageB:

; 726  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SwapImageBuffers@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Index$2 = -20						; size = 4
_Dest$ = -16						; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_B$ = -4						; size = 1
_G$ = -3						; size = 1
_R$ = -2						; size = 1
_A$ = -1						; size = 1
_Buffer$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_FillColor$ = 24					; size = 4
_Left$ = 28						; size = 4
_Top$ = 32						; size = 4
_Right$ = 36						; size = 4
_Bottom$ = 40						; size = 4
_ClearBufferRegion2@36 PROC

; 565  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 566  : 	if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN8@ClearBuffe

; 567  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ClearBuffe
$LN8@ClearBuffe:

; 568  : 	if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN9@ClearBuffe

; 569  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ClearBuffe
$LN9@ClearBuffe:

; 570  : 	if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN10@ClearBuffe

; 571  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ClearBuffe
$LN10@ClearBuffe:

; 572  : 	if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN11@ClearBuffe

; 573  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ClearBuffe
$LN11@ClearBuffe:

; 574  : 
; 575  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 576  : 	BYTE *Dest = (BYTE *)Buffer;

	mov	edx, DWORD PTR _Buffer$[ebp]
	mov	DWORD PTR _Dest$[ebp], edx

; 577  : 	BYTE A = (FillColor & 0xff000000) >> 24;

	mov	eax, DWORD PTR _FillColor$[ebp]
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	BYTE PTR _A$[ebp], al

; 578  : 	BYTE R = (FillColor & 0x00ff0000) >> 16;

	mov	ecx, DWORD PTR _FillColor$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR _R$[ebp], cl

; 579  : 	BYTE G = (FillColor & 0x0000ff00) >> 8;

	mov	edx, DWORD PTR _FillColor$[ebp]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _G$[ebp], dl

; 580  : 	BYTE B = (FillColor & 0x000000ff) >> 0;

	mov	eax, DWORD PTR _FillColor$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _B$[ebp], al

; 581  : 
; 582  : 	for (int Row = Top; Row <= Bottom; Row++)

	mov	ecx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$4[ebp], ecx
	jmp	SHORT $LN4@ClearBuffe
$LN2@ClearBuffe:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@ClearBuffe:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN3@ClearBuffe

; 583  : 	{
; 584  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 585  : 		for (int Column = Left; Column <= Right; Column++)

	mov	edx, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$3[ebp], edx
	jmp	SHORT $LN7@ClearBuffe
$LN5@ClearBuffe:
	mov	eax, DWORD PTR _Column$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$3[ebp], eax
$LN7@ClearBuffe:
	mov	ecx, DWORD PTR _Column$3[ebp]
	cmp	ecx, DWORD PTR _Right$[ebp]
	jg	SHORT $LN6@ClearBuffe

; 586  : 		{
; 587  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$3[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], edx

; 588  : 			Dest[Index + 3] = A;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	cl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [eax+3], cl

; 589  : 			Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR _R$[ebp]
	mov	BYTE PTR [edx+2], al

; 590  : 			Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	mov	dl, BYTE PTR _G$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 591  : 			Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	cl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [eax], cl

; 592  : 		}

	jmp	SHORT $LN5@ClearBuffe
$LN6@ClearBuffe:

; 593  : 	}

	jmp	SHORT $LN2@ClearBuffe
$LN3@ClearBuffe:

; 594  : 	return Success;

	xor	eax, eax
$LN1@ClearBuffe:

; 595  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_ClearBufferRegion2@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Src$ = -20						; size = 4
_Dest$ = -16						; size = 4
_Column$2 = -12						; size = 4
_Row$3 = -8						; size = 4
_Index$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_CopyBufferToBuffer@20 PROC

; 607  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 608  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@CopyBuffer

; 609  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyBuffer
$LN8@CopyBuffer:

; 610  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@CopyBuffer

; 611  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyBuffer
$LN9@CopyBuffer:

; 612  : 
; 613  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 614  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 615  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 616  : 
; 617  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@CopyBuffer
$LN2@CopyBuffer:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@CopyBuffer:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@CopyBuffer

; 618  : 	{
; 619  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 620  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@CopyBuffer
$LN5@CopyBuffer:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@CopyBuffer:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@CopyBuffer

; 621  : 		{
; 622  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 623  : 			Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 624  : 			Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 625  : 			Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 626  : 			Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 627  : 		}

	jmp	SHORT $LN5@CopyBuffer
$LN6@CopyBuffer:

; 628  : 	}

	jmp	$LN2@CopyBuffer
$LN3@CopyBuffer:

; 629  : 
; 630  : 	return Success;

	xor	eax, eax
$LN1@CopyBuffer:

; 631  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_CopyBufferToBuffer@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_Dest$ = -48						; size = 4
_DestIndex$1 = -44					; size = 4
_Src$ = -40						; size = 4
_SrcIndex$2 = -36					; size = 4
tv84 = -32						; size = 4
tv72 = -28						; size = 4
_SrcRow$ = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_Row$5 = -12						; size = 4
_LR$ = -8						; size = 4
_UL$ = -4						; size = 4
_Destination$ = 8					; size = 4
_DestWidth$ = 12					; size = 4
_DestHeight$ = 16					; size = 4
_Source$ = 20						; size = 4
_SourceWidth$ = 24					; size = 4
_SourceHeight$ = 28					; size = 4
_X1$ = 32						; size = 4
_Y1$ = 36						; size = 4
_X2$ = 40						; size = 4
_Y2$ = 44						; size = 4
_PasteRegion4@40 PROC

; 519  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 520  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN5@PasteRegio

; 521  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN5@PasteRegio:

; 522  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN6@PasteRegio

; 523  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN6@PasteRegio:

; 524  : 
; 525  : 	UINT32 *Src = (UINT32 *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 526  : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 527  : 	AbsolutePointStruct *UL = new AbsolutePointStruct();

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 0
	je	SHORT $LN15@PasteRegio
	xor	edx, edx
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T4[ebp]
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN16@PasteRegio
$LN15@PasteRegio:
	mov	DWORD PTR tv72[ebp], 0
$LN16@PasteRegio:
	mov	edx, DWORD PTR tv72[ebp]
	mov	DWORD PTR _UL$[ebp], edx

; 528  : 	UL->X = X1;

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR [eax], ecx

; 529  : 	UL->Y = Y1;

	mov	edx, DWORD PTR _UL$[ebp]
	mov	eax, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR [edx+4], eax

; 530  : 	AbsolutePointStruct *LR = new AbsolutePointStruct();

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 0
	je	SHORT $LN17@PasteRegio
	xor	ecx, ecx
	mov	edx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [edx], ecx
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR tv84[ebp], eax
	jmp	SHORT $LN18@PasteRegio
$LN17@PasteRegio:
	mov	DWORD PTR tv84[ebp], 0
$LN18@PasteRegio:
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR _LR$[ebp], ecx

; 531  : 	LR->X = X2;

	mov	edx, DWORD PTR _LR$[ebp]
	mov	eax, DWORD PTR _X2$[ebp]
	mov	DWORD PTR [edx], eax

; 532  : 	LR->Y = Y2;

	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _Y2$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 533  : 
; 534  : 	if (UL->X < 0)

	mov	eax, DWORD PTR _UL$[ebp]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN7@PasteRegio

; 535  : 		UL->X = SourceWidth - UL->X;

	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR _SourceWidth$[ebp]
	sub	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _UL$[ebp]
	mov	DWORD PTR [eax], edx
$LN7@PasteRegio:

; 536  : 	if (UL->Y < 0)

	mov	ecx, DWORD PTR _UL$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jge	SHORT $LN8@PasteRegio

; 537  : 		UL->Y = SourceHeight - UL->Y;

	mov	edx, DWORD PTR _UL$[ebp]
	mov	eax, DWORD PTR _SourceHeight$[ebp]
	sub	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _UL$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN8@PasteRegio:

; 538  : 	if (UL->X >= LR->X)

	mov	edx, DWORD PTR _UL$[ebp]
	mov	eax, DWORD PTR _LR$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jl	SHORT $LN9@PasteRegio

; 539  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN9@PasteRegio:

; 540  : 	if (UL->Y >= LR->Y)

	mov	edx, DWORD PTR _UL$[ebp]
	mov	eax, DWORD PTR _LR$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $LN10@PasteRegio

; 541  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN10@PasteRegio:

; 542  : 	if (LR->X >= DestWidth)

	mov	edx, DWORD PTR _LR$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _DestWidth$[ebp]
	jl	SHORT $LN11@PasteRegio

; 543  : 		LR->X = DestWidth - LR->X;

	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _DestWidth$[ebp]
	sub	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [eax], edx
$LN11@PasteRegio:

; 544  : 	if (LR->Y >= DestHeight)

	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _DestHeight$[ebp]
	jl	SHORT $LN12@PasteRegio

; 545  : 		LR->Y = DestHeight - LR->Y;

	mov	eax, DWORD PTR _LR$[ebp]
	mov	ecx, DWORD PTR _DestHeight$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN12@PasteRegio:

; 546  : 
; 547  : 	ClearBufferDWord(Destination, DestWidth, DestHeight, 0xff00ff00);

	push	-16711936				; ff00ff00H
	mov	eax, DWORD PTR _DestHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _DestWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	call	_ClearBufferDWord@16

; 548  : 
; 549  : 	int SrcRow = 0;

	mov	DWORD PTR _SrcRow$[ebp], 0

; 550  : 	for (int Row = UL->Y; Row <= LR->Y; Row++)

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _Row$5[ebp], ecx
	jmp	SHORT $LN4@PasteRegio
$LN2@PasteRegio:
	mov	edx, DWORD PTR _Row$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$5[ebp], edx
$LN4@PasteRegio:
	mov	eax, DWORD PTR _LR$[ebp]
	mov	ecx, DWORD PTR _Row$5[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jg	SHORT $LN3@PasteRegio

; 551  : 	{
; 552  : 		if ((Row & 0x1) == 0)

	mov	edx, DWORD PTR _Row$5[ebp]
	and	edx, 1
	jne	SHORT $LN13@PasteRegio

; 553  : 			continue;

	jmp	SHORT $LN2@PasteRegio
$LN13@PasteRegio:

; 554  : 		int DestIndex = Row * DestWidth;

	mov	eax, DWORD PTR _Row$5[ebp]
	imul	eax, DWORD PTR _DestWidth$[ebp]
	mov	DWORD PTR _DestIndex$1[ebp], eax

; 555  : 		int SrcIndex = SrcRow * SourceWidth;

	mov	ecx, DWORD PTR _SrcRow$[ebp]
	imul	ecx, DWORD PTR _SourceWidth$[ebp]
	mov	DWORD PTR _SrcIndex$2[ebp], ecx

; 556  : 		memcpy(Dest + DestIndex, Src + SrcIndex, SourceWidth * 4);

	mov	edx, DWORD PTR _SourceWidth$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _SrcIndex$2[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _DestIndex$1[ebp]
	mov	ecx, DWORD PTR _Dest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 557  : 		SrcRow++;

	mov	eax, DWORD PTR _SrcRow$[ebp]
	add	eax, 1
	mov	DWORD PTR _SrcRow$[ebp], eax

; 558  : 	}

	jmp	SHORT $LN2@PasteRegio
$LN3@PasteRegio:

; 559  : 
; 560  : 	return Success;

	xor	eax, eax
$LN1@PasteRegio:

; 561  : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_PasteRegion4@40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_Src$ = -44						; size = 4
_SrcIndex$1 = -40					; size = 4
_Dest$ = -36						; size = 4
_DestIndex$2 = -32					; size = 4
_RowOffset$3 = -28					; size = 4
_SrcRow$ = -24						; size = 4
_Column$4 = -20						; size = 4
_Row$5 = -16						; size = 4
_SrcColumn$ = -12					; size = 4
_LR$ = -8						; size = 4
_UL$ = -4						; size = 4
_Destination$ = 8					; size = 4
_DestWidth$ = 12					; size = 4
_DestHeight$ = 16					; size = 4
_Source$ = 20						; size = 4
_SourceWidth$ = 24					; size = 4
_SourceHeight$ = 28					; size = 4
_UpperLeft$ = 32					; size = 4
_LowerRight$ = 36					; size = 4
_PasteRegion3@32 PROC

; 413  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi

; 414  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@PasteRegio

; 415  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN8@PasteRegio:

; 416  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@PasteRegio

; 417  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN9@PasteRegio:

; 418  : 	if (UpperLeft == NULL)

	cmp	DWORD PTR _UpperLeft$[ebp], 0
	jne	SHORT $LN10@PasteRegio

; 419  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN10@PasteRegio:

; 420  : 	if (LowerRight == NULL)

	cmp	DWORD PTR _LowerRight$[ebp], 0
	jne	SHORT $LN11@PasteRegio

; 421  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN11@PasteRegio:

; 422  : 
; 423  : 	UINT32 *Src = (UINT32 *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 424  : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 425  : 	AbsolutePointStruct *UL = (AbsolutePointStruct *)UpperLeft;

	mov	edx, DWORD PTR _UpperLeft$[ebp]
	mov	DWORD PTR _UL$[ebp], edx

; 426  : 	AbsolutePointStruct *LR = (AbsolutePointStruct *)LowerRight;

	mov	eax, DWORD PTR _LowerRight$[ebp]
	mov	DWORD PTR _LR$[ebp], eax

; 427  : 
; 428  : 	if (UL->X < 0)

	mov	ecx, DWORD PTR _UL$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	SHORT $LN12@PasteRegio

; 429  : 		UL->X = SourceWidth - UL->X;

	mov	edx, DWORD PTR _UL$[ebp]
	mov	eax, DWORD PTR _SourceWidth$[ebp]
	sub	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _UL$[ebp]
	mov	DWORD PTR [ecx], eax
$LN12@PasteRegio:

; 430  : 	if (UL->Y < 0)

	mov	edx, DWORD PTR _UL$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jge	SHORT $LN13@PasteRegio

; 431  : 		UL->Y = SourceHeight - UL->Y;

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _SourceHeight$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _UL$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN13@PasteRegio:

; 432  : 	if (UL->X >= LR->X)

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN14@PasteRegio

; 433  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN14@PasteRegio:

; 434  : 	if (UL->Y >= LR->Y)

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN15@PasteRegio

; 435  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN15@PasteRegio:

; 436  : 	if (LR->X >= DestWidth)

	mov	eax, DWORD PTR _LR$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _DestWidth$[ebp]
	jl	SHORT $LN16@PasteRegio

; 437  : 		LR->X = DestWidth - LR->X;

	mov	edx, DWORD PTR _LR$[ebp]
	mov	eax, DWORD PTR _DestWidth$[ebp]
	sub	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [ecx], eax
$LN16@PasteRegio:

; 438  : 	if (LR->Y >= DestHeight)

	mov	edx, DWORD PTR _LR$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _DestHeight$[ebp]
	jl	SHORT $LN17@PasteRegio

; 439  : 		LR->Y = DestHeight - LR->Y;

	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _DestHeight$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN17@PasteRegio:

; 440  : 
; 441  : 	int SrcRow = 0;

	mov	DWORD PTR _SrcRow$[ebp], 0

; 442  : 	int SrcColumn = 0;

	mov	DWORD PTR _SrcColumn$[ebp], 0

; 443  : 	for (int Row = UL->Y; Row <= LR->Y; Row++)

	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _Row$5[ebp], edx
	jmp	SHORT $LN4@PasteRegio
$LN2@PasteRegio:
	mov	eax, DWORD PTR _Row$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$5[ebp], eax
$LN4@PasteRegio:
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _Row$5[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jg	SHORT $LN3@PasteRegio

; 444  : 	{
; 445  : 		int RowOffset = Row * SourceWidth;

	mov	eax, DWORD PTR _Row$5[ebp]
	imul	eax, DWORD PTR _SourceWidth$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], eax

; 446  : 		for (int Column = UL->X; Column <= LR->Y; Column++)

	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _Column$4[ebp], edx
	jmp	SHORT $LN7@PasteRegio
$LN5@PasteRegio:
	mov	eax, DWORD PTR _Column$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$4[ebp], eax
$LN7@PasteRegio:
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _Column$4[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jg	SHORT $LN6@PasteRegio

; 447  : 		{
; 448  : 			int DestIndex = Column + RowOffset;

	mov	eax, DWORD PTR _Column$4[ebp]
	add	eax, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _DestIndex$2[ebp], eax

; 449  : 			int SrcIndex = SrcColumn + SrcRow;

	mov	ecx, DWORD PTR _SrcColumn$[ebp]
	add	ecx, DWORD PTR _SrcRow$[ebp]
	mov	DWORD PTR _SrcIndex$1[ebp], ecx

; 450  : 			Dest[DestIndex] = Src[SrcIndex];

	mov	edx, DWORD PTR _DestIndex$2[ebp]
	mov	eax, DWORD PTR _Dest$[ebp]
	mov	ecx, DWORD PTR _SrcIndex$1[ebp]
	mov	esi, DWORD PTR _Src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx

; 451  : 			SrcColumn++;

	mov	edx, DWORD PTR _SrcColumn$[ebp]
	add	edx, 1
	mov	DWORD PTR _SrcColumn$[ebp], edx

; 452  : 			if (SrcColumn >= SourceWidth)

	mov	eax, DWORD PTR _SrcColumn$[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jl	SHORT $LN18@PasteRegio

; 453  : 			{
; 454  : 				SrcColumn = 0;

	mov	DWORD PTR _SrcColumn$[ebp], 0

; 455  : 				SrcRow++;

	mov	ecx, DWORD PTR _SrcRow$[ebp]
	add	ecx, 1
	mov	DWORD PTR _SrcRow$[ebp], ecx
$LN18@PasteRegio:

; 456  : 			}
; 457  : 		}

	jmp	SHORT $LN5@PasteRegio
$LN6@PasteRegio:

; 458  : 	}

	jmp	$LN2@PasteRegio
$LN3@PasteRegio:

; 459  : 
; 460  : 	return Success;

	xor	eax, eax
$LN1@PasteRegio:

; 461  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_PasteRegion3@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_RowOffset$1 = -48					; size = 4
_PixelSize$ = -44					; size = 4
_SrcRow$ = -40						; size = 4
_SrcIndex$2 = -36					; size = 4
_Src$ = -32						; size = 4
_DestIndex$3 = -28					; size = 4
_Dest$ = -24						; size = 4
_Column$4 = -20						; size = 4
_Row$5 = -16						; size = 4
_SrcColumn$ = -12					; size = 4
_LR$ = -8						; size = 4
_UL$ = -4						; size = 4
_Destination$ = 8					; size = 4
_DestWidth$ = 12					; size = 4
_DestHeight$ = 16					; size = 4
_DestStride$ = 20					; size = 4
_Source$ = 24						; size = 4
_SourceWidth$ = 28					; size = 4
_SourceHeight$ = 32					; size = 4
_SourceStride$ = 36					; size = 4
_UpperLeft$ = 40					; size = 4
_LowerRight$ = 44					; size = 4
_PasteRegion2@40 PROC

; 345  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 346  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@PasteRegio

; 347  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN8@PasteRegio:

; 348  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@PasteRegio

; 349  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN9@PasteRegio:

; 350  : 	if (UpperLeft == NULL)

	cmp	DWORD PTR _UpperLeft$[ebp], 0
	jne	SHORT $LN10@PasteRegio

; 351  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN10@PasteRegio:

; 352  : 	if (LowerRight == NULL)

	cmp	DWORD PTR _LowerRight$[ebp], 0
	jne	SHORT $LN11@PasteRegio

; 353  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN11@PasteRegio:

; 354  : 
; 355  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 356  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 357  : 	AbsolutePointStruct *UL = (AbsolutePointStruct *)UpperLeft;

	mov	edx, DWORD PTR _UpperLeft$[ebp]
	mov	DWORD PTR _UL$[ebp], edx

; 358  : 	AbsolutePointStruct *LR = (AbsolutePointStruct *)LowerRight;

	mov	eax, DWORD PTR _LowerRight$[ebp]
	mov	DWORD PTR _LR$[ebp], eax

; 359  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 360  : 
; 361  : 	if (UL->X < 0)

	mov	ecx, DWORD PTR _UL$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	SHORT $LN12@PasteRegio

; 362  : 		UL->X = SourceWidth - UL->X;

	mov	edx, DWORD PTR _UL$[ebp]
	mov	eax, DWORD PTR _SourceWidth$[ebp]
	sub	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _UL$[ebp]
	mov	DWORD PTR [ecx], eax
$LN12@PasteRegio:

; 363  : 	if (UL->Y < 0)

	mov	edx, DWORD PTR _UL$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jge	SHORT $LN13@PasteRegio

; 364  : 		UL->Y = SourceHeight - UL->Y;

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _SourceHeight$[ebp]
	sub	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _UL$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN13@PasteRegio:

; 365  : 	if (UL->X >= LR->X)

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN14@PasteRegio

; 366  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN14@PasteRegio:

; 367  : 	if (UL->Y >= LR->Y)

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN15@PasteRegio

; 368  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN15@PasteRegio:

; 369  : 	if (LR->X >= DestWidth)

	mov	eax, DWORD PTR _LR$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _DestWidth$[ebp]
	jl	SHORT $LN16@PasteRegio

; 370  : 		LR->X = DestWidth - LR->X;

	mov	edx, DWORD PTR _LR$[ebp]
	mov	eax, DWORD PTR _DestWidth$[ebp]
	sub	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [ecx], eax
$LN16@PasteRegio:

; 371  : 	if (LR->Y >= DestHeight)

	mov	edx, DWORD PTR _LR$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _DestHeight$[ebp]
	jl	SHORT $LN17@PasteRegio

; 372  : 		LR->Y = DestHeight - LR->Y;

	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _DestHeight$[ebp]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _LR$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN17@PasteRegio:

; 373  : 
; 374  : 	int SrcRow = 0;

	mov	DWORD PTR _SrcRow$[ebp], 0

; 375  : 	int SrcColumn = 0;

	mov	DWORD PTR _SrcColumn$[ebp], 0

; 376  : 	for (int Row = UL->Y; Row <= LR->Y; Row++)

	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _Row$5[ebp], edx
	jmp	SHORT $LN4@PasteRegio
$LN2@PasteRegio:
	mov	eax, DWORD PTR _Row$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$5[ebp], eax
$LN4@PasteRegio:
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _Row$5[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jg	$LN3@PasteRegio

; 377  : 	{
; 378  : 		int RowOffset = Row * DestStride;

	mov	eax, DWORD PTR _Row$5[ebp]
	imul	eax, DWORD PTR _DestStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 379  : 		for (int Column = UL->X; Column <= LR->Y; Column++)

	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _Column$4[ebp], edx
	jmp	SHORT $LN7@PasteRegio
$LN5@PasteRegio:
	mov	eax, DWORD PTR _Column$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$4[ebp], eax
$LN7@PasteRegio:
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _Column$4[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jg	$LN6@PasteRegio

; 380  : 		{
; 381  : 			int DestIndex = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$4[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _DestIndex$3[ebp], eax

; 382  : 			int SrcIndex = (SrcColumn * PixelSize) + (SrcRow * SourceStride);

	mov	ecx, DWORD PTR _SrcColumn$[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	mov	edx, DWORD PTR _SrcRow$[ebp]
	imul	edx, DWORD PTR _SourceStride$[ebp]
	add	ecx, edx
	mov	DWORD PTR _SrcIndex$2[ebp], ecx

; 383  : 			Dest[DestIndex + 0] = Src[SrcIndex + 0];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$3[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _SrcIndex$2[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 384  : 			Dest[DestIndex + 1] = Src[SrcIndex + 1];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$3[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _SrcIndex$2[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 385  : 			Dest[DestIndex + 2] = Src[SrcIndex + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$3[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _SrcIndex$2[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 386  : 			Dest[DestIndex + 3] = Src[SrcIndex + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$3[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _SrcIndex$2[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 387  : 			SrcColumn++;

	mov	eax, DWORD PTR _SrcColumn$[ebp]
	add	eax, 1
	mov	DWORD PTR _SrcColumn$[ebp], eax

; 388  : 			if (SrcColumn >= SourceWidth)

	mov	ecx, DWORD PTR _SrcColumn$[ebp]
	cmp	ecx, DWORD PTR _SourceWidth$[ebp]
	jl	SHORT $LN18@PasteRegio

; 389  : 			{
; 390  : 				SrcColumn = 0;

	mov	DWORD PTR _SrcColumn$[ebp], 0

; 391  : 				SrcRow++;

	mov	edx, DWORD PTR _SrcRow$[ebp]
	add	edx, 1
	mov	DWORD PTR _SrcRow$[ebp], edx
$LN18@PasteRegio:

; 392  : 			}
; 393  : 		}

	jmp	$LN5@PasteRegio
$LN6@PasteRegio:

; 394  : 	}

	jmp	$LN2@PasteRegio
$LN3@PasteRegio:

; 395  : 
; 396  : 	return Success;

	xor	eax, eax
$LN1@PasteRegio:

; 397  : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_PasteRegion2@40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_RowOffset$1 = -48					; size = 4
_PixelSize$ = -44					; size = 4
_SrcRow$ = -40						; size = 4
_SrcIndex$2 = -36					; size = 4
_Src$ = -32						; size = 4
_DestIndex$3 = -28					; size = 4
_Dest$ = -24						; size = 4
_Column$4 = -20						; size = 4
_Row$5 = -16						; size = 4
_SrcColumn$ = -12					; size = 4
_LR$ = -8						; size = 4
_UL$ = -4						; size = 4
_Destination$ = 8					; size = 4
_DestWidth$ = 12					; size = 4
_DestHeight$ = 16					; size = 4
_DestStride$ = 20					; size = 4
_Source$ = 24						; size = 4
_SourceWidth$ = 28					; size = 4
_SourceHeight$ = 32					; size = 4
_SourceStride$ = 36					; size = 4
_UpperLeft$ = 40					; size = 4
_LowerRight$ = 44					; size = 4
_PasteRegion@40 PROC

; 274  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 275  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@PasteRegio

; 276  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN8@PasteRegio:

; 277  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@PasteRegio

; 278  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN9@PasteRegio:

; 279  : 	if (UpperLeft == NULL)

	cmp	DWORD PTR _UpperLeft$[ebp], 0
	jne	SHORT $LN10@PasteRegio

; 280  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN10@PasteRegio:

; 281  : 	if (LowerRight == NULL)

	cmp	DWORD PTR _LowerRight$[ebp], 0
	jne	SHORT $LN11@PasteRegio

; 282  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@PasteRegio
$LN11@PasteRegio:

; 283  : 
; 284  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 285  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 286  : 	AbsolutePointStruct *UL = (AbsolutePointStruct *)UpperLeft;

	mov	edx, DWORD PTR _UpperLeft$[ebp]
	mov	DWORD PTR _UL$[ebp], edx

; 287  : 	AbsolutePointStruct *LR = (AbsolutePointStruct *)LowerRight;

	mov	eax, DWORD PTR _LowerRight$[ebp]
	mov	DWORD PTR _LR$[ebp], eax

; 288  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 289  : 
; 290  : 	if (UL->X < 0)

	mov	ecx, DWORD PTR _UL$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	SHORT $LN12@PasteRegio

; 291  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN12@PasteRegio:

; 292  : 	if (UL->Y < 0)

	mov	edx, DWORD PTR _UL$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jge	SHORT $LN13@PasteRegio

; 293  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN13@PasteRegio:

; 294  : 	if (UL->X >= LR->X)

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN14@PasteRegio

; 295  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN14@PasteRegio:

; 296  : 	if (UL->Y >= LR->Y)

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN15@PasteRegio

; 297  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN15@PasteRegio:

; 298  : 	if (LR->X >= DestWidth)

	mov	eax, DWORD PTR _LR$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _DestWidth$[ebp]
	jl	SHORT $LN16@PasteRegio

; 299  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN16@PasteRegio:

; 300  : 	if (LR->Y >= DestHeight)

	mov	edx, DWORD PTR _LR$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _DestHeight$[ebp]
	jl	SHORT $LN17@PasteRegio

; 301  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PasteRegio
$LN17@PasteRegio:

; 302  : 
; 303  : 	int SrcRow = 0;

	mov	DWORD PTR _SrcRow$[ebp], 0

; 304  : 	int SrcColumn = 0;

	mov	DWORD PTR _SrcColumn$[ebp], 0

; 305  : 	for (int Row = UL->Y; Row <= LR->Y; Row++)

	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _Row$5[ebp], edx
	jmp	SHORT $LN4@PasteRegio
$LN2@PasteRegio:
	mov	eax, DWORD PTR _Row$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$5[ebp], eax
$LN4@PasteRegio:
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _Row$5[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jg	$LN3@PasteRegio

; 306  : 	{
; 307  : 		int RowOffset = Row * DestStride;

	mov	eax, DWORD PTR _Row$5[ebp]
	imul	eax, DWORD PTR _DestStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 308  : 		for (int Column = UL->X; Column <= LR->Y; Column++)

	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _Column$4[ebp], edx
	jmp	SHORT $LN7@PasteRegio
$LN5@PasteRegio:
	mov	eax, DWORD PTR _Column$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$4[ebp], eax
$LN7@PasteRegio:
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _Column$4[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jg	$LN6@PasteRegio

; 309  : 		{
; 310  : 			int DestIndex = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$4[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _DestIndex$3[ebp], eax

; 311  : 			int SrcIndex = (SrcColumn * PixelSize) + (SrcRow * SourceStride);

	mov	ecx, DWORD PTR _SrcColumn$[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	mov	edx, DWORD PTR _SrcRow$[ebp]
	imul	edx, DWORD PTR _SourceStride$[ebp]
	add	ecx, edx
	mov	DWORD PTR _SrcIndex$2[ebp], ecx

; 312  : 			Dest[DestIndex + 0] = Src[SrcIndex + 0];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$3[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _SrcIndex$2[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 313  : 			Dest[DestIndex + 1] = Src[SrcIndex + 1];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$3[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _SrcIndex$2[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 314  : 			Dest[DestIndex + 2] = Src[SrcIndex + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$3[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _SrcIndex$2[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 315  : 			Dest[DestIndex + 3] = Src[SrcIndex + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$3[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _SrcIndex$2[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 316  : 			SrcColumn++;

	mov	eax, DWORD PTR _SrcColumn$[ebp]
	add	eax, 1
	mov	DWORD PTR _SrcColumn$[ebp], eax

; 317  : 			if (SrcColumn >= SourceWidth)

	mov	ecx, DWORD PTR _SrcColumn$[ebp]
	cmp	ecx, DWORD PTR _SourceWidth$[ebp]
	jl	SHORT $LN18@PasteRegio

; 318  : 			{
; 319  : 				SrcColumn = 0;

	mov	DWORD PTR _SrcColumn$[ebp], 0

; 320  : 				SrcRow++;

	mov	edx, DWORD PTR _SrcRow$[ebp]
	add	edx, 1
	mov	DWORD PTR _SrcRow$[ebp], edx
$LN18@PasteRegio:

; 321  : 			}
; 322  : 		}

	jmp	$LN5@PasteRegio
$LN6@PasteRegio:

; 323  : 	}

	jmp	$LN2@PasteRegio
$LN3@PasteRegio:

; 324  : 
; 325  : 	return Success;

	xor	eax, eax
$LN1@PasteRegio:

; 326  : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_PasteRegion@40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_DestRowOffset$1 = -52					; size = 4
_RowOffset$2 = -48					; size = 4
_PixelSize$ = -44					; size = 4
_DestRow$ = -40						; size = 4
_DestColumn$ = -36					; size = 4
_Index$3 = -32						; size = 4
_Buffer$ = -28						; size = 4
_DestIndex$4 = -24					; size = 4
_Dest$ = -20						; size = 4
_Column$5 = -16						; size = 4
_Row$6 = -12						; size = 4
_LR$ = -8						; size = 4
_UL$ = -4						; size = 4
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Destination$ = 24					; size = 4
_DestinationWidth$ = 28					; size = 4
_DestinationStride$ = 32				; size = 4
_UpperLeft$ = 36					; size = 4
_LowerRight$ = 40					; size = 4
_CopyRegion@36 PROC

; 204  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 205  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@CopyRegion

; 206  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyRegion
$LN8@CopyRegion:

; 207  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@CopyRegion

; 208  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyRegion
$LN9@CopyRegion:

; 209  : 	if (UpperLeft == NULL)

	cmp	DWORD PTR _UpperLeft$[ebp], 0
	jne	SHORT $LN10@CopyRegion

; 210  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyRegion
$LN10@CopyRegion:

; 211  : 	if (LowerRight == NULL)

	cmp	DWORD PTR _LowerRight$[ebp], 0
	jne	SHORT $LN11@CopyRegion

; 212  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyRegion
$LN11@CopyRegion:

; 213  : 
; 214  : 	BYTE *Buffer = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 215  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 216  : 	AbsolutePointStruct *UL = (AbsolutePointStruct *)UpperLeft;

	mov	edx, DWORD PTR _UpperLeft$[ebp]
	mov	DWORD PTR _UL$[ebp], edx

; 217  : 	AbsolutePointStruct *LR = (AbsolutePointStruct *)LowerRight;

	mov	eax, DWORD PTR _LowerRight$[ebp]
	mov	DWORD PTR _LR$[ebp], eax

; 218  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 219  : 
; 220  : 	if (UL->X < 0)

	mov	ecx, DWORD PTR _UL$[ebp]
	cmp	DWORD PTR [ecx], 0
	jge	SHORT $LN12@CopyRegion

; 221  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyRegion
$LN12@CopyRegion:

; 222  : 	if (UL->Y < 0)

	mov	edx, DWORD PTR _UL$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jge	SHORT $LN13@CopyRegion

; 223  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyRegion
$LN13@CopyRegion:

; 224  : 	if (UL->X >= LR->X)

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN14@CopyRegion

; 225  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyRegion
$LN14@CopyRegion:

; 226  : 	if (UL->Y >= LR->Y)

	mov	eax, DWORD PTR _UL$[ebp]
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN15@CopyRegion

; 227  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyRegion
$LN15@CopyRegion:

; 228  : 	if (LR->X >= SourceWidth)

	mov	eax, DWORD PTR _LR$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _SourceWidth$[ebp]
	jl	SHORT $LN16@CopyRegion

; 229  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyRegion
$LN16@CopyRegion:

; 230  : 	if (LR->Y >= SourceHeight)

	mov	edx, DWORD PTR _LR$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jl	SHORT $LN17@CopyRegion

; 231  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyRegion
$LN17@CopyRegion:

; 232  : 
; 233  : 	int DestRow = 0;

	mov	DWORD PTR _DestRow$[ebp], 0

; 234  : 	int DestColumn = 0;

	mov	DWORD PTR _DestColumn$[ebp], 0

; 235  : 
; 236  : 	for (int Row = UL->Y; Row <= LR->Y; Row++)

	mov	ecx, DWORD PTR _UL$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _Row$6[ebp], edx
	jmp	SHORT $LN4@CopyRegion
$LN2@CopyRegion:
	mov	eax, DWORD PTR _Row$6[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$6[ebp], eax
$LN4@CopyRegion:
	mov	ecx, DWORD PTR _LR$[ebp]
	mov	edx, DWORD PTR _Row$6[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jg	$LN3@CopyRegion

; 237  : 	{
; 238  : 		int RowOffset = Row * SourceStride;

	mov	eax, DWORD PTR _Row$6[ebp]
	imul	eax, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], eax

; 239  : 		int DestRowOffset = DestRow * DestinationStride;

	mov	ecx, DWORD PTR _DestRow$[ebp]
	imul	ecx, DWORD PTR _DestinationStride$[ebp]
	mov	DWORD PTR _DestRowOffset$1[ebp], ecx

; 240  : 		DestColumn = 0;

	mov	DWORD PTR _DestColumn$[ebp], 0

; 241  : 		for (int Column = UL->X; Column <= LR->X; Column++)

	mov	edx, DWORD PTR _UL$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _Column$5[ebp], eax
	jmp	SHORT $LN7@CopyRegion
$LN5@CopyRegion:
	mov	ecx, DWORD PTR _Column$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$5[ebp], ecx
$LN7@CopyRegion:
	mov	edx, DWORD PTR _LR$[ebp]
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR [edx]
	jg	SHORT $LN6@CopyRegion

; 242  : 		{
; 243  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$3[ebp], ecx

; 244  : 			int DestIndex = (DestColumn * PixelSize) + DestRowOffset;

	mov	edx, DWORD PTR _DestColumn$[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _DestRowOffset$1[ebp]
	mov	DWORD PTR _DestIndex$4[ebp], edx

; 245  : 			Dest[DestIndex + 0] = Buffer[Index + 0];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$4[ebp]
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$3[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 246  : 			Dest[DestIndex + 1] = Buffer[Index + 1];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$4[ebp]
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$3[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 247  : 			Dest[DestIndex + 2] = Buffer[Index + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$4[ebp]
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$3[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 248  : 			Dest[DestIndex + 3] = Buffer[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _DestIndex$4[ebp]
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$3[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 249  : 			DestColumn++;

	mov	eax, DWORD PTR _DestColumn$[ebp]
	add	eax, 1
	mov	DWORD PTR _DestColumn$[ebp], eax

; 250  : 		}

	jmp	SHORT $LN5@CopyRegion
$LN6@CopyRegion:

; 251  : 		DestRow++;

	mov	ecx, DWORD PTR _DestRow$[ebp]
	add	ecx, 1
	mov	DWORD PTR _DestRow$[ebp], ecx

; 252  : 	}

	jmp	$LN2@CopyRegion
$LN3@CopyRegion:

; 253  : 
; 254  : 	return Success;

	xor	eax, eax
$LN1@CopyRegion:

; 255  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_CopyRegion@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_FillColor$ = 24					; size = 4
_ClearBuffer2@20 PROC

; 643  : {

	push	ebp
	mov	ebp, esp

; 644  : 	return ClearBufferRegion(Destination, Width, Height, Stride, FillColor, 0, 0, Width - 1, Height - 1);

	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _FillColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	call	_ClearBufferRegion@36

; 645  : }

	pop	ebp
	ret	20					; 00000014H
_ClearBuffer2@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_Result$ = -8						; size = 4
_B$ = -4						; size = 1
_G$ = -3						; size = 1
_R$ = -2						; size = 1
_A$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_DestWidth$ = 28					; size = 4
_DestHeight$ = 32					; size = 4
_DestStride$ = 36					; size = 4
_X$ = 40						; size = 4
_Y$ = 44						; size = 4
_Radius$ = 48						; size = 4
_PackedBG$ = 52						; size = 4
_CopyCircularBuffer@48 PROC

; 667  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 668  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@CopyCircul

; 669  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyCircul
$LN2@CopyCircul:

; 670  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN3@CopyCircul

; 671  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyCircul
$LN3@CopyCircul:

; 672  : 	if (X + DestWidth > Width - 1)

	mov	eax, DWORD PTR _X$[ebp]
	add	eax, DWORD PTR _DestWidth$[ebp]
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN4@CopyCircul

; 673  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyCircul
$LN4@CopyCircul:

; 674  : 	if (X - DestWidth < 0)

	mov	edx, DWORD PTR _X$[ebp]
	sub	edx, DWORD PTR _DestWidth$[ebp]
	jns	SHORT $LN5@CopyCircul

; 675  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyCircul
$LN5@CopyCircul:

; 676  : 	if (Y + DestHeight > Height - 1)

	mov	eax, DWORD PTR _Y$[ebp]
	add	eax, DWORD PTR _DestHeight$[ebp]
	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN6@CopyCircul

; 677  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopyCircul
$LN6@CopyCircul:

; 678  : 	if (Y - DestHeight < 0)

	mov	edx, DWORD PTR _Y$[ebp]
	sub	edx, DWORD PTR _DestHeight$[ebp]
	jns	SHORT $LN7@CopyCircul

; 679  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopyCircul
$LN7@CopyCircul:

; 680  : 
; 681  : 	int Result = ClearBuffer2(Destination, DestWidth, DestHeight, DestStride, PackedBG);

	mov	eax, DWORD PTR _PackedBG$[ebp]
	push	eax
	mov	ecx, DWORD PTR _DestStride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DestHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _DestWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Destination$[ebp]
	push	ecx
	call	_ClearBuffer2@20
	mov	DWORD PTR _Result$[ebp], eax

; 682  : 	if (Result != Success)

	cmp	DWORD PTR _Result$[ebp], 0
	je	SHORT $LN8@CopyCircul

; 683  : 		return Result;

	mov	eax, DWORD PTR _Result$[ebp]
	jmp	SHORT $LN1@CopyCircul
$LN8@CopyCircul:

; 684  : 
; 685  : 	BYTE A = (PackedBG & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedBG$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _A$[ebp], dl

; 686  : 	BYTE R = (PackedBG & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedBG$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _R$[ebp], al

; 687  : 	BYTE G = (PackedBG & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedBG$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _G$[ebp], cl

; 688  : 	BYTE B = (PackedBG & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedBG$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _B$[ebp], dl

; 689  : 
; 690  : 	return Success;

	xor	eax, eax
$LN1@CopyCircul:

; 691  : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_CopyCircularBuffer@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_PixelSize$ = -28					; size = 4
_ColumnIndex$1 = -24					; size = 4
_ColumnData$ = -20					; size = 4
_Index$2 = -16						; size = 4
_Buffer$ = -12						; size = 4
_Column$3 = -8						; size = 4
_Row$4 = -4						; size = 4
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_ColumnBuffer$ = 24					; size = 4
_ColumnCount$ = 28					; size = 4
_ColumnStart$ = 32					; size = 4
_CopyVerticalLine@28 PROC

; 153  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 154  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@CopyVertic

; 155  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyVertic
$LN8@CopyVertic:

; 156  : 	if (ColumnBuffer == NULL)

	cmp	DWORD PTR _ColumnBuffer$[ebp], 0
	jne	SHORT $LN9@CopyVertic

; 157  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyVertic
$LN9@CopyVertic:

; 158  : 	if (ColumnCount < 1)

	cmp	DWORD PTR _ColumnCount$[ebp], 1
	jge	SHORT $LN10@CopyVertic

; 159  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyVertic
$LN10@CopyVertic:

; 160  : 	if (ColumnStart < 0)

	cmp	DWORD PTR _ColumnStart$[ebp], 0
	jge	SHORT $LN11@CopyVertic

; 161  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyVertic
$LN11@CopyVertic:

; 162  : 	if (ColumnStart > Height - 1)

	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _ColumnStart$[ebp], eax
	jle	SHORT $LN12@CopyVertic

; 163  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyVertic
$LN12@CopyVertic:

; 164  : 	if (ColumnStart + ColumnCount > Height - 1)

	mov	ecx, DWORD PTR _ColumnStart$[ebp]
	add	ecx, DWORD PTR _ColumnCount$[ebp]
	mov	edx, DWORD PTR _Height$[ebp]
	sub	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN13@CopyVertic

; 165  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyVertic
$LN13@CopyVertic:

; 166  : 	BYTE *Buffer = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 167  : 	BYTE *ColumnData = (BYTE *)ColumnBuffer;

	mov	ecx, DWORD PTR _ColumnBuffer$[ebp]
	mov	DWORD PTR _ColumnData$[ebp], ecx

; 168  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 169  : 
; 170  : 	for (int Column = ColumnStart; Column < ColumnStart + ColumnCount; Column++)

	mov	edx, DWORD PTR _ColumnStart$[ebp]
	mov	DWORD PTR _Column$3[ebp], edx
	jmp	SHORT $LN4@CopyVertic
$LN2@CopyVertic:
	mov	eax, DWORD PTR _Column$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$3[ebp], eax
$LN4@CopyVertic:
	mov	ecx, DWORD PTR _ColumnStart$[ebp]
	add	ecx, DWORD PTR _ColumnCount$[ebp]
	cmp	DWORD PTR _Column$3[ebp], ecx
	jge	SHORT $LN3@CopyVertic

; 171  : 	{
; 172  : 		for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN7@CopyVertic
$LN5@CopyVertic:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN7@CopyVertic:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	SHORT $LN6@CopyVertic

; 173  : 		{
; 174  : 			int Index = (Row * Stride) + Column;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	add	ecx, DWORD PTR _Column$3[ebp]
	mov	DWORD PTR _Index$2[ebp], ecx

; 175  : 			int ColumnIndex = Row * PixelSize;

	mov	edx, DWORD PTR _Row$4[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	mov	DWORD PTR _ColumnIndex$1[ebp], edx

; 176  : 			Buffer[Index + 0] = ColumnData[ColumnIndex + 0];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	ecx, DWORD PTR _ColumnData$[ebp]
	add	ecx, DWORD PTR _ColumnIndex$1[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 177  : 			Buffer[Index + 1] = ColumnData[ColumnIndex + 1];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	ecx, DWORD PTR _ColumnData$[ebp]
	add	ecx, DWORD PTR _ColumnIndex$1[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 178  : 			Buffer[Index + 2] = ColumnData[ColumnIndex + 2];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	ecx, DWORD PTR _ColumnData$[ebp]
	add	ecx, DWORD PTR _ColumnIndex$1[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 179  : 			Buffer[Index + 3] = ColumnData[ColumnIndex + 3];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	ecx, DWORD PTR _ColumnData$[ebp]
	add	ecx, DWORD PTR _ColumnIndex$1[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 180  : 		}

	jmp	SHORT $LN5@CopyVertic
$LN6@CopyVertic:

; 181  : 	}

	jmp	$LN2@CopyVertic
$LN3@CopyVertic:

; 182  : 
; 183  : 	return Success;

	xor	eax, eax
$LN1@CopyVertic:

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_CopyVerticalLine@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_DestIndex$1 = -16					; size = 4
_Buffer$ = -12						; size = 4
_Line$ = -8						; size = 4
_Row$2 = -4						; size = 4
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_LineBuffer$ = 24					; size = 4
_LineCount$ = 28					; size = 4
_LineStart$ = 32					; size = 4
_CopyHorizontalLine@28 PROC

; 112  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 113  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN5@CopyHorizo

; 114  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyHorizo
$LN5@CopyHorizo:

; 115  : 	if (LineBuffer == NULL)

	cmp	DWORD PTR _LineBuffer$[ebp], 0
	jne	SHORT $LN6@CopyHorizo

; 116  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CopyHorizo
$LN6@CopyHorizo:

; 117  : 	if (LineCount < 1)

	cmp	DWORD PTR _LineCount$[ebp], 1
	jge	SHORT $LN7@CopyHorizo

; 118  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CopyHorizo
$LN7@CopyHorizo:

; 119  : 	if (LineStart < 0)

	cmp	DWORD PTR _LineStart$[ebp], 0
	jge	SHORT $LN8@CopyHorizo

; 120  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopyHorizo
$LN8@CopyHorizo:

; 121  : 	if (LineStart > Height - 1)

	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _LineStart$[ebp], eax
	jle	SHORT $LN9@CopyHorizo

; 122  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopyHorizo
$LN9@CopyHorizo:

; 123  : 	if (LineStart + LineCount > Height - 1)

	mov	ecx, DWORD PTR _LineStart$[ebp]
	add	ecx, DWORD PTR _LineCount$[ebp]
	mov	edx, DWORD PTR _Height$[ebp]
	sub	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN10@CopyHorizo

; 124  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@CopyHorizo
$LN10@CopyHorizo:

; 125  : 	BYTE *Buffer = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 126  : 	BYTE *Line = (BYTE *)LineBuffer;

	mov	ecx, DWORD PTR _LineBuffer$[ebp]
	mov	DWORD PTR _Line$[ebp], ecx

; 127  : 
; 128  : 	for (int Row = LineStart; Row < LineStart + LineCount; Row++)

	mov	edx, DWORD PTR _LineStart$[ebp]
	mov	DWORD PTR _Row$2[ebp], edx
	jmp	SHORT $LN4@CopyHorizo
$LN2@CopyHorizo:
	mov	eax, DWORD PTR _Row$2[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$2[ebp], eax
$LN4@CopyHorizo:
	mov	ecx, DWORD PTR _LineStart$[ebp]
	add	ecx, DWORD PTR _LineCount$[ebp]
	cmp	DWORD PTR _Row$2[ebp], ecx
	jge	SHORT $LN3@CopyHorizo

; 129  : 	{
; 130  : 		int DestIndex = Row * Stride;

	mov	edx, DWORD PTR _Row$2[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _DestIndex$1[ebp], edx

; 131  : 		memmove_s(Buffer + (DestIndex), Stride,

	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Line$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stride$[ebp]
	push	edx
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _DestIndex$1[ebp]
	push	eax
	call	_memmove_s
	add	esp, 16					; 00000010H

; 132  : 			Line, Stride);
; 133  : 	}

	jmp	SHORT $LN2@CopyHorizo
$LN3@CopyHorizo:

; 134  : 
; 135  : 	return Success;

	xor	eax, eax
$LN1@CopyHorizo:

; 136  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_CopyHorizontalLine@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_Src$ = -20						; size = 4
_Dest$ = -16						; size = 4
_Index$1 = -12						; size = 4
_Column$2 = -8						; size = 4
_Row$3 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_CopyBuffer2@16 PROC

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 54   : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@CopyBuffer

; 55   : 		return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@CopyBuffer
$LN8@CopyBuffer:

; 56   : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@CopyBuffer

; 57   : 		return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@CopyBuffer
$LN9@CopyBuffer:

; 58   : 
; 59   : 	UINT32 *Src = (UINT32 *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 60   : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 61   : 
; 62   : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@CopyBuffer
$LN2@CopyBuffer:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@CopyBuffer:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@CopyBuffer

; 63   : 	{
; 64   : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@CopyBuffer
$LN5@CopyBuffer:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@CopyBuffer:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@CopyBuffer

; 65   : 		{
; 66   : 			int Index = (Row * Width) + Column;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _Width$[ebp]
	add	eax, DWORD PTR _Column$2[ebp]
	mov	DWORD PTR _Index$1[ebp], eax

; 67   : 			Dest[Index] = Src[Index];

	mov	ecx, DWORD PTR _Index$1[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _Index$1[ebp]
	mov	esi, DWORD PTR _Src$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax

; 68   : 		}

	jmp	SHORT $LN5@CopyBuffer
$LN6@CopyBuffer:

; 69   : 	}

	jmp	SHORT $LN2@CopyBuffer
$LN3@CopyBuffer:

; 70   : 
; 71   : 	return Success;

	xor	eax, eax
$LN1@CopyBuffer:

; 72   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CopyBuffer2@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_BufferSize$ = 12					; size = 4
_Destination$ = 16					; size = 4
_CopyBuffer3@12 PROC

; 85   : {

	push	ebp
	mov	ebp, esp

; 86   : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@CopyBuffer

; 87   : 		return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@CopyBuffer
$LN2@CopyBuffer:

; 88   : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN3@CopyBuffer

; 89   : 		return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@CopyBuffer
$LN3@CopyBuffer:

; 90   : 	if (BufferSize < 1)

	cmp	DWORD PTR _BufferSize$[ebp], 1
	jae	SHORT $LN4@CopyBuffer

; 91   : 		return Success;

	xor	eax, eax
	jmp	SHORT $LN1@CopyBuffer
$LN4@CopyBuffer:

; 92   : 
; 93   : 	memcpy_s(Destination, (rsize_t)BufferSize, Source, (rsize_t)BufferSize);

	mov	eax, DWORD PTR _BufferSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	mov	edx, DWORD PTR _BufferSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 94   : 	return Success;

	xor	eax, eax
$LN1@CopyBuffer:

; 95   : }

	pop	ebp
	ret	12					; 0000000cH
_CopyBuffer3@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_Scratch$ = -4						; size = 4
_Pixel1$ = 8						; size = 4
_Pixel2$ = 12						; size = 4
_SwapPixel@8 PROC

; 13   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 14   : 	if (Pixel1 == NULL)

	cmp	DWORD PTR _Pixel1$[ebp], 0
	jne	SHORT $LN2@SwapPixel

; 15   : 		return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@SwapPixel
$LN2@SwapPixel:

; 16   : 	if (Pixel2 == NULL)

	cmp	DWORD PTR _Pixel2$[ebp], 0
	jne	SHORT $LN3@SwapPixel

; 17   : 		return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@SwapPixel
$LN3@SwapPixel:

; 18   : 	UINT32 Scratch = *Pixel1;

	mov	eax, DWORD PTR _Pixel1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _Scratch$[ebp], ecx

; 19   : 	*Pixel1 = *Pixel2;

	mov	edx, DWORD PTR _Pixel1$[ebp]
	mov	eax, DWORD PTR _Pixel2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 20   : 	*Pixel2 = Scratch;

	mov	edx, DWORD PTR _Pixel2$[ebp]
	mov	eax, DWORD PTR _Scratch$[ebp]
	mov	DWORD PTR [edx], eax

; 21   : 	return Success;

	xor	eax, eax
$LN1@SwapPixel:

; 22   : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SwapPixel@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\buffers.cpp
_TEXT	SEGMENT
_SwapIndex$1 = -12					; size = 4
_WorkingCount$ = -8					; size = 4
_i$2 = -4						; size = 4
_ScanLine$ = 8						; size = 4
_PixelCount$ = 12					; size = 4
_InPlaceReverseScanLine@8 PROC

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 32   : 	if (ScanLine == NULL)

	cmp	DWORD PTR _ScanLine$[ebp], 0
	jne	SHORT $LN5@InPlaceRev

; 33   : 		return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@InPlaceRev
$LN5@InPlaceRev:

; 34   : 
; 35   : 	int WorkingCount = PixelCount / 2;

	mov	eax, DWORD PTR _PixelCount$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _WorkingCount$[ebp], eax

; 36   : 	for (int i = 0; i < WorkingCount; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@InPlaceRev
$LN2@InPlaceRev:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@InPlaceRev:
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR _WorkingCount$[ebp]
	jge	SHORT $LN3@InPlaceRev

; 37   : 	{
; 38   : 		int SwapIndex = (PixelCount - 1) - i;

	mov	edx, DWORD PTR _PixelCount$[ebp]
	sub	edx, 1
	sub	edx, DWORD PTR _i$2[ebp]
	mov	DWORD PTR _SwapIndex$1[ebp], edx

; 39   : 		SwapPixel(&ScanLine[i], &ScanLine[SwapIndex]);

	mov	eax, DWORD PTR _SwapIndex$1[ebp]
	mov	ecx, DWORD PTR _ScanLine$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _ScanLine$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_SwapPixel@8

; 40   : 	}

	jmp	SHORT $LN2@InPlaceRev
$LN3@InPlaceRev:

; 41   : 
; 42   : 	return Success;

	xor	eax, eax
$LN1@InPlaceRev:

; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	8
_InPlaceReverseScanLine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
_TEXT	SEGMENT
__Expr_val$1 = -24					; size = 4
__Expr_val$2 = -20					; size = 4
__Expr_val$3 = -16					; size = 4
tv74 = -12						; size = 4
tv70 = -8						; size = 4
tv66 = -4						; size = 4
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memmove_s PROC

; 70   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 71   :         if (_SourceSize == 0)

	cmp	DWORD PTR __SourceSize$[ebp], 0
	jne	SHORT $LN2@memmove_s

; 72   :         {
; 73   :             return 0;

	xor	eax, eax
	jmp	$LN1@memmove_s
$LN2@memmove_s:

; 74   :         }
; 75   : 
; 76   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL,            EINVAL);

	cmp	DWORD PTR __Destination$[ebp], 0
	je	SHORT $LN7@memmove_s
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN8@memmove_s
$LN7@memmove_s:
	mov	DWORD PTR tv66[ebp], 0
$LN8@memmove_s:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR __Expr_val$3[ebp], eax
	cmp	DWORD PTR __Expr_val$3[ebp], 0
	jne	SHORT $LN3@memmove_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 22					; 00000016H
	jmp	$LN1@memmove_s
$LN3@memmove_s:

; 77   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

	cmp	DWORD PTR __Source$[ebp], 0
	je	SHORT $LN9@memmove_s
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN10@memmove_s
$LN9@memmove_s:
	mov	DWORD PTR tv70[ebp], 0
$LN10@memmove_s:
	mov	ecx, DWORD PTR tv70[ebp]
	mov	DWORD PTR __Expr_val$2[ebp], ecx
	cmp	DWORD PTR __Expr_val$2[ebp], 0
	jne	SHORT $LN4@memmove_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 22					; 00000016H
	jmp	SHORT $LN1@memmove_s
$LN4@memmove_s:

; 78   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

	mov	edx, DWORD PTR __DestinationSize$[ebp]
	cmp	edx, DWORD PTR __SourceSize$[ebp]
	jb	SHORT $LN11@memmove_s
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN12@memmove_s
$LN11@memmove_s:
	mov	DWORD PTR tv74[ebp], 0
$LN12@memmove_s:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR __Expr_val$1[ebp], eax
	cmp	DWORD PTR __Expr_val$1[ebp], 0
	jne	SHORT $LN5@memmove_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 34			; 00000022H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 34					; 00000022H
	jmp	SHORT $LN1@memmove_s
$LN5@memmove_s:

; 79   : 
; 80   :         memmove(_Destination, _Source, _SourceSize);

	mov	ecx, DWORD PTR __SourceSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Source$[ebp]
	push	edx
	mov	eax, DWORD PTR __Destination$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH

; 81   :         return 0;

	xor	eax, eax
$LN1@memmove_s:

; 82   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_memmove_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
_TEXT	SEGMENT
__Expr_val$1 = -24					; size = 4
__Expr_val$2 = -20					; size = 4
__Expr_val$3 = -16					; size = 4
tv79 = -12						; size = 4
tv75 = -8						; size = 4
tv66 = -4						; size = 4
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memcpy_s PROC

; 41   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 42   :         if (_SourceSize == 0)

	cmp	DWORD PTR __SourceSize$[ebp], 0
	jne	SHORT $LN2@memcpy_s

; 43   :         {
; 44   :             return 0;

	xor	eax, eax
	jmp	$LN1@memcpy_s
$LN2@memcpy_s:

; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	cmp	DWORD PTR __Destination$[ebp], 0
	je	SHORT $LN9@memcpy_s
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN10@memcpy_s
$LN9@memcpy_s:
	mov	DWORD PTR tv66[ebp], 0
$LN10@memcpy_s:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR __Expr_val$3[ebp], eax
	cmp	DWORD PTR __Expr_val$3[ebp], 0
	jne	SHORT $LN3@memcpy_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 22					; 00000016H
	jmp	$LN1@memcpy_s
$LN3@memcpy_s:

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

	cmp	DWORD PTR __Source$[ebp], 0
	je	SHORT $LN5@memcpy_s
	mov	ecx, DWORD PTR __DestinationSize$[ebp]
	cmp	ecx, DWORD PTR __SourceSize$[ebp]
	jae	$LN4@memcpy_s
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

	mov	edx, DWORD PTR __DestinationSize$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Destination$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

	cmp	DWORD PTR __Source$[ebp], 0
	je	SHORT $LN11@memcpy_s
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN12@memcpy_s
$LN11@memcpy_s:
	mov	DWORD PTR tv75[ebp], 0
$LN12@memcpy_s:
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR __Expr_val$2[ebp], ecx
	cmp	DWORD PTR __Expr_val$2[ebp], 0
	jne	SHORT $LN6@memcpy_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 22					; 00000016H
	jmp	SHORT $LN1@memcpy_s
$LN6@memcpy_s:

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

	mov	edx, DWORD PTR __DestinationSize$[ebp]
	cmp	edx, DWORD PTR __SourceSize$[ebp]
	jb	SHORT $LN13@memcpy_s
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN14@memcpy_s
$LN13@memcpy_s:
	mov	DWORD PTR tv79[ebp], 0
$LN14@memcpy_s:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR __Expr_val$1[ebp], eax
	cmp	DWORD PTR __Expr_val$1[ebp], 0
	jne	SHORT $LN7@memcpy_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 34			; 00000022H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 34					; 00000022H
	jmp	SHORT $LN1@memcpy_s
$LN7@memcpy_s:

; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;

	mov	eax, 22					; 00000016H
	jmp	SHORT $LN1@memcpy_s
$LN4@memcpy_s:

; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

	mov	ecx, DWORD PTR __SourceSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Source$[ebp]
	push	edx
	mov	eax, DWORD PTR __Destination$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 60   :         return 0;

	xor	eax, eax
$LN1@memcpy_s:

; 61   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_memcpy_s ENDP
_TEXT	ENDS
END
