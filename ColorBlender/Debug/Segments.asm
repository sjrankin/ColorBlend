; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Segments.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG110608 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110611 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110614 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110617 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110620 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110622 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110624 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110626 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110628 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110630 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110632 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110636 DB	'SegmentDrawColorShape2', 00H
	ORG $+1
$SG110254 DB	'Source is null', 00H
	ORG $+1
$SG110255 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110257 DB	'Destination is null', 00H
$SG110258 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110260 DB	'BlocksX < 1', 00H
$SG110261 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110263 DB	'BlocksY < 1', 00H
$SG110264 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110266 DB	'BlockXWidth < 1', 00H
$SG110267 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110270 DB	'BlockYHeight < 1', 00H
	ORG $+3
$SG110271 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110280 DB	'SegmentBlocks2', 00H
	ORG $+1
$SG110334 DB	'Source is null', 00H
	ORG $+1
$SG110335 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110337 DB	'Destination is null', 00H
$SG110338 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110340 DB	'BlocksX < 1', 00H
$SG110341 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110343 DB	'BlocksY < 1', 00H
$SG110344 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110346 DB	'BlockXWidth < 1', 00H
$SG110347 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110350 DB	'BlockYHeight < 1', 00H
	ORG $+3
$SG110351 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110370 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110373 DB	'SegmentBlocks', 00H
	ORG $+2
$SG110473 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110476 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110479 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110482 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110485 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110487 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110489 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110491 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110493 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110495 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110497 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110536 DB	'SegmentDrawColorShape', 00H
	ORG $+2
$SG110537 DB	'SegmentDrawColorShape', 00H
CONST	ENDS
PUBLIC	_SegmentBlocks@72
PUBLIC	_SegmentBlocks2@52
PUBLIC	_SegmentDrawColorShape@68
PUBLIC	_SegmentDrawColorShape2@80
PUBLIC	?PointInEllipse@@YGHHHHHHH@Z			; PointInEllipse
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@bff0000000000000
EXTRN	?Distance@@YGNHHHH@Z:PROC			; Distance
EXTRN	_RegionMeanColor@64:PROC
EXTRN	_RegionMedianColor@36:PROC
EXTRN	_RegionBrightestColor@36:PROC
EXTRN	_RegionDarkestColor@36:PROC
EXTRN	_RegionLuminanceValue@36:PROC
EXTRN	_ErrorStackPushReturn@8:PROC
EXTRN	_ErrorStackPushReturn2@12:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\segments.cpp
_TEXT	SEGMENT
_Result$ = -44						; size = 8
_Term2$ = -36						; size = 8
_Term1$ = -28						; size = 8
tv130 = -20						; size = 8
tv128 = -12						; size = 8
tv86 = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_RadiusX$ = 16						; size = 4
_RadiusY$ = 20						; size = 4
_OriginX$ = 24						; size = 4
_OriginY$ = 28						; size = 4
?PointInEllipse@@YGHHHHHHH@Z PROC			; PointInEllipse

; 215  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 216  :     double Term1 = pow(X - OriginX, 2) / pow(RadiusX, 2);

	mov	eax, DWORD PTR _X$[ebp]
	sub	eax, DWORD PTR _OriginX$[ebp]
	cvtsi2sd xmm0, eax
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	cvtsi2sd xmm1, DWORD PTR _RadiusX$[ebp]
	movsd	QWORD PTR tv128[ebp], xmm0
	movaps	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR tv128[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _Term1$[ebp], xmm1

; 217  :     double Term2 = pow(Y - OriginY, 2) / pow(RadiusY, 2);

	mov	ecx, DWORD PTR _Y$[ebp]
	sub	ecx, DWORD PTR _OriginY$[ebp]
	cvtsi2sd xmm0, ecx
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	cvtsi2sd xmm1, DWORD PTR _RadiusY$[ebp]
	movsd	QWORD PTR tv130[ebp], xmm0
	movaps	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR tv130[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _Term2$[ebp], xmm1

; 218  :     double Result = Term1 + Term2;

	movsd	xmm0, QWORD PTR _Term1$[ebp]
	addsd	xmm0, QWORD PTR _Term2$[ebp]
	movsd	QWORD PTR _Result$[ebp], xmm0

; 219  :     return Result <= 1 ? TRUE : FALSE;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	comisd	xmm0, QWORD PTR _Result$[ebp]
	jb	SHORT $LN3@PointInEll
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN4@PointInEll
$LN3@PointInEll:
	mov	DWORD PTR tv86[ebp], 0
$LN4@PointInEll:
	mov	eax, DWORD PTR tv86[ebp]

; 220  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?PointInEllipse@@YGHHHHHHH@Z ENDP			; PointInEllipse
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\segments.cpp
_TEXT	SEGMENT
_RowOffset$1 = -88					; size = 4
_RowOffset$2 = -84					; size = 4
_PixelSize$ = -80					; size = 4
_Delta$3 = -76						; size = 4
_Delta$4 = -72						; size = 4
_SqRight$ = -68						; size = 4
_SqLeft$ = -64						; size = 4
_SqBottom$ = -60					; size = 4
_SqTop$ = -56						; size = 4
_YSpan$ = -52						; size = 4
_XSpan$ = -48						; size = 4
_Index$5 = -44						; size = 4
_Column$6 = -40						; size = 4
_Row$7 = -36						; size = 4
_SegmentHeight$ = -32					; size = 4
_SegmentWidth$ = -28					; size = 4
_Index$8 = -24						; size = 4
_Column$9 = -20						; size = 4
_Row$10 = -16						; size = 4
_Dest$ = -12						; size = 4
_B$ = -8						; size = 1
_G$ = -7						; size = 1
_R$ = -6						; size = 1
_A$ = -5						; size = 1
_BgB$ = -4						; size = 1
_BgG$ = -3						; size = 1
_BgR$ = -2						; size = 1
_BgA$ = -1						; size = 1
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_X1$ = 24						; size = 4
_Y1$ = 28						; size = 4
_X2$ = 32						; size = 4
_Y2$ = 36						; size = 4
_ShapeType$ = 40					; size = 4
_ShapeMargin$ = 44					; size = 4
_PackedColor$ = 48					; size = 4
_PackedBGColor$ = 52					; size = 4
_Brightest$ = 56					; size = 8
_Darkest$ = 64						; size = 8
_BrightX$ = 72						; size = 4
_BrightY$ = 76						; size = 4
_DarkX$ = 80						; size = 4
_DarkY$ = 84						; size = 4
_SegmentDrawColorShape2@80 PROC

; 437  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 438  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN14@SegmentDra

; 439  :         return ErrorStackPushReturn(NullPointer, "SegmentDrawColorShape2");

	push	OFFSET $SG110608
	push	3
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN14@SegmentDra:

; 440  :     if (X1 < 0 || X2 < 0)

	cmp	DWORD PTR _X1$[ebp], 0
	jl	SHORT $LN16@SegmentDra
	cmp	DWORD PTR _X2$[ebp], 0
	jge	SHORT $LN15@SegmentDra
$LN16@SegmentDra:

; 441  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape2");

	push	OFFSET $SG110611
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN15@SegmentDra:

; 442  :     if (X1 >= Width || X2 >= Width)

	mov	eax, DWORD PTR _X1$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN18@SegmentDra
	mov	ecx, DWORD PTR _X2$[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jl	SHORT $LN17@SegmentDra
$LN18@SegmentDra:

; 443  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape2");

	push	OFFSET $SG110614
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN17@SegmentDra:

; 444  :     if (Y1 < 0 || Y2 < 0)

	cmp	DWORD PTR _Y1$[ebp], 0
	jl	SHORT $LN20@SegmentDra
	cmp	DWORD PTR _Y2$[ebp], 0
	jge	SHORT $LN19@SegmentDra
$LN20@SegmentDra:

; 445  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape2");

	push	OFFSET $SG110617
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN19@SegmentDra:

; 446  :     if (Y1 >= Height || Y2 >= Height)

	mov	edx, DWORD PTR _Y1$[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN22@SegmentDra
	mov	eax, DWORD PTR _Y2$[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jl	SHORT $LN21@SegmentDra
$LN22@SegmentDra:

; 447  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape2");

	push	OFFSET $SG110620
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN21@SegmentDra:

; 448  :     if (X1 >= X2)

	mov	ecx, DWORD PTR _X1$[ebp]
	cmp	ecx, DWORD PTR _X2$[ebp]
	jl	SHORT $LN23@SegmentDra

; 449  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape2");

	push	OFFSET $SG110622
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN23@SegmentDra:

; 450  :     if (Y1 >= Y2)

	mov	edx, DWORD PTR _Y1$[ebp]
	cmp	edx, DWORD PTR _Y2$[ebp]
	jl	SHORT $LN24@SegmentDra

; 451  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape2");

	push	OFFSET $SG110624
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN24@SegmentDra:

; 452  :     if (ShapeMargin * 2 > (X2 - X1 + 1))

	mov	eax, DWORD PTR _ShapeMargin$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _X2$[ebp]
	sub	ecx, DWORD PTR _X1$[ebp]
	add	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN25@SegmentDra

; 453  :         return ErrorStackPushReturn(ComputedIndexOutOfRange, "SegmentDrawColorShape2");

	push	OFFSET $SG110626
	push	19					; 00000013H
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN25@SegmentDra:

; 454  :     if (ShapeMargin * 2 > (Y2 - Y1 + 1))

	mov	edx, DWORD PTR _ShapeMargin$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _Y2$[ebp]
	sub	eax, DWORD PTR _Y1$[ebp]
	add	eax, 1
	cmp	edx, eax
	jle	SHORT $LN26@SegmentDra

; 455  :         return ErrorStackPushReturn(ComputedIndexOutOfRange, "SegmentDrawColorShape2");

	push	OFFSET $SG110628
	push	19					; 00000013H
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN26@SegmentDra:

; 456  : 
; 457  :     BYTE A = (PackedColor & 0xff000000) >> 24;

	mov	ecx, DWORD PTR _PackedColor$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _A$[ebp], cl

; 458  :     BYTE R = (PackedColor & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _PackedColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _R$[ebp], dl

; 459  :     BYTE G = (PackedColor & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _PackedColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _G$[ebp], al

; 460  :     BYTE B = (PackedColor & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _PackedColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _B$[ebp], cl

; 461  :     BYTE BgA = (PackedBGColor & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedBGColor$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _BgA$[ebp], dl

; 462  :     BYTE BgR = (PackedBGColor & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedBGColor$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _BgR$[ebp], al

; 463  :     BYTE BgG = (PackedBGColor & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedBGColor$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _BgG$[ebp], cl

; 464  :     BYTE BgB = (PackedBGColor & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedBGColor$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _BgB$[ebp], dl

; 465  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 466  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 467  : 
; 468  :     //First, fill in the background.
; 469  :     for (int Row = Y1; Row <= Y2; Row++)

	mov	ecx, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _Row$10[ebp], ecx
	jmp	SHORT $LN4@SegmentDra
$LN2@SegmentDra:
	mov	edx, DWORD PTR _Row$10[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$10[ebp], edx
$LN4@SegmentDra:
	mov	eax, DWORD PTR _Row$10[ebp]
	cmp	eax, DWORD PTR _Y2$[ebp]
	jg	SHORT $LN3@SegmentDra

; 470  :     {
; 471  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$10[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 472  :         for (int Column = X1; Column <= X2; Column++)

	mov	edx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _Column$9[ebp], edx
	jmp	SHORT $LN7@SegmentDra
$LN5@SegmentDra:
	mov	eax, DWORD PTR _Column$9[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$9[ebp], eax
$LN7@SegmentDra:
	mov	ecx, DWORD PTR _Column$9[ebp]
	cmp	ecx, DWORD PTR _X2$[ebp]
	jg	SHORT $LN6@SegmentDra

; 473  :         {
; 474  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$9[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$8[ebp], edx

; 475  :             Dest[Index + 3] = BgA;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR _BgA$[ebp]
	mov	BYTE PTR [eax+3], cl

; 476  :             Dest[Index + 2] = BgR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR _BgR$[ebp]
	mov	BYTE PTR [edx+2], al

; 477  :             Dest[Index + 1] = BgG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	dl, BYTE PTR _BgG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 478  :             Dest[Index + 0] = BgB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR _BgB$[ebp]
	mov	BYTE PTR [eax], cl

; 479  :         }

	jmp	SHORT $LN5@SegmentDra
$LN6@SegmentDra:

; 480  :     }

	jmp	SHORT $LN2@SegmentDra
$LN3@SegmentDra:

; 481  : 
; 482  :     int XSpan = X2 - X1 + 1;

	mov	edx, DWORD PTR _X2$[ebp]
	sub	edx, DWORD PTR _X1$[ebp]
	add	edx, 1
	mov	DWORD PTR _XSpan$[ebp], edx

; 483  :     XSpan -= ShapeMargin * 2;

	mov	eax, DWORD PTR _ShapeMargin$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _XSpan$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _XSpan$[ebp], ecx

; 484  :     if (XSpan < 1)

	cmp	DWORD PTR _XSpan$[ebp], 1
	jge	SHORT $LN27@SegmentDra

; 485  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape2");

	push	OFFSET $SG110630
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN27@SegmentDra:

; 486  :     int YSpan = Y2 - Y1 + 1;

	mov	edx, DWORD PTR _Y2$[ebp]
	sub	edx, DWORD PTR _Y1$[ebp]
	add	edx, 1
	mov	DWORD PTR _YSpan$[ebp], edx

; 487  :     YSpan -= ShapeMargin * 2;

	mov	eax, DWORD PTR _ShapeMargin$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _YSpan$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _YSpan$[ebp], ecx

; 488  :     if (YSpan < 1)

	cmp	DWORD PTR _YSpan$[ebp], 1
	jge	SHORT $LN28@SegmentDra

; 489  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape2");

	push	OFFSET $SG110632
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN28@SegmentDra:

; 490  : 
; 491  :     int SqTop = Y1;

	mov	edx, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _SqTop$[ebp], edx

; 492  :     int SqBottom = Y2;

	mov	eax, DWORD PTR _Y2$[ebp]
	mov	DWORD PTR _SqBottom$[ebp], eax

; 493  :     int SqLeft = X1;

	mov	ecx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _SqLeft$[ebp], ecx

; 494  :     int SqRight = X2;

	mov	edx, DWORD PTR _X2$[ebp]
	mov	DWORD PTR _SqRight$[ebp], edx

; 495  :     int SegmentHeight = Y2 - Y1 + 1;

	mov	eax, DWORD PTR _Y2$[ebp]
	sub	eax, DWORD PTR _Y1$[ebp]
	add	eax, 1
	mov	DWORD PTR _SegmentHeight$[ebp], eax

; 496  :     int SegmentWidth = X2 - X1 + 1;

	mov	ecx, DWORD PTR _X2$[ebp]
	sub	ecx, DWORD PTR _X1$[ebp]
	add	ecx, 1
	mov	DWORD PTR _SegmentWidth$[ebp], ecx

; 497  :     if (SegmentHeight > SegmentWidth)

	mov	edx, DWORD PTR _SegmentHeight$[ebp]
	cmp	edx, DWORD PTR _SegmentWidth$[ebp]
	jle	SHORT $LN29@SegmentDra

; 498  :     {
; 499  :         int Delta = SegmentHeight - SegmentWidth;

	mov	eax, DWORD PTR _SegmentHeight$[ebp]
	sub	eax, DWORD PTR _SegmentWidth$[ebp]
	mov	DWORD PTR _Delta$4[ebp], eax

; 500  :         SqTop = Y1 + (int)((double)Delta / 2.0);

	cvtsi2sd xmm0, DWORD PTR _Delta$4[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si ecx, xmm0
	add	ecx, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _SqTop$[ebp], ecx

; 501  :         SqBottom = Y2 - (int)((double)Delta / 2.0);

	cvtsi2sd xmm0, DWORD PTR _Delta$4[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si edx, xmm0
	mov	eax, DWORD PTR _Y2$[ebp]
	sub	eax, edx
	mov	DWORD PTR _SqBottom$[ebp], eax

; 502  :     }
; 503  :     else

	jmp	SHORT $LN31@SegmentDra
$LN29@SegmentDra:

; 504  :         if (SegmentWidth > SegmentHeight)

	mov	ecx, DWORD PTR _SegmentWidth$[ebp]
	cmp	ecx, DWORD PTR _SegmentHeight$[ebp]
	jle	SHORT $LN31@SegmentDra

; 505  :         {
; 506  :             int Delta = SegmentWidth - SegmentHeight;

	mov	edx, DWORD PTR _SegmentWidth$[ebp]
	sub	edx, DWORD PTR _SegmentHeight$[ebp]
	mov	DWORD PTR _Delta$3[ebp], edx

; 507  :             SqLeft = X1 + (int)((double)Delta / 2.0);

	cvtsi2sd xmm0, DWORD PTR _Delta$3[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si eax, xmm0
	add	eax, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _SqLeft$[ebp], eax

; 508  :             SqRight = X2 - (int)((double)Delta / 2.0);

	cvtsi2sd xmm0, DWORD PTR _Delta$3[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _X2$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _SqRight$[ebp], edx
$LN31@SegmentDra:

; 509  :         }
; 510  :     SqTop += ShapeMargin;

	mov	eax, DWORD PTR _SqTop$[ebp]
	add	eax, DWORD PTR _ShapeMargin$[ebp]
	mov	DWORD PTR _SqTop$[ebp], eax

; 511  :     SqBottom -= ShapeMargin;

	mov	ecx, DWORD PTR _SqBottom$[ebp]
	sub	ecx, DWORD PTR _ShapeMargin$[ebp]
	mov	DWORD PTR _SqBottom$[ebp], ecx

; 512  :     SqLeft += ShapeMargin;

	mov	edx, DWORD PTR _SqLeft$[ebp]
	add	edx, DWORD PTR _ShapeMargin$[ebp]
	mov	DWORD PTR _SqLeft$[ebp], edx

; 513  :     SqRight -= ShapeMargin;

	mov	eax, DWORD PTR _SqRight$[ebp]
	sub	eax, DWORD PTR _ShapeMargin$[ebp]
	mov	DWORD PTR _SqRight$[ebp], eax

; 514  : 
; 515  :     //Lastly, fill in the shape.
; 516  :     for (int Row = Y1; Row <= Y2; Row++)

	mov	ecx, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _Row$7[ebp], ecx
	jmp	SHORT $LN10@SegmentDra
$LN8@SegmentDra:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN10@SegmentDra:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _Y2$[ebp]
	jg	SHORT $LN9@SegmentDra

; 517  :     {
; 518  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 519  :         for (int Column = X1; Column <= X2; Column++)

	mov	edx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _Column$6[ebp], edx
	jmp	SHORT $LN13@SegmentDra
$LN11@SegmentDra:
	mov	eax, DWORD PTR _Column$6[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$6[ebp], eax
$LN13@SegmentDra:
	mov	ecx, DWORD PTR _Column$6[ebp]
	cmp	ecx, DWORD PTR _X2$[ebp]
	jg	SHORT $LN12@SegmentDra

; 520  :         {
; 521  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$6[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$5[ebp], edx

; 522  :             Dest[Index + 3] = A;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [eax+3], cl

; 523  :             Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _R$[ebp]
	mov	BYTE PTR [edx+2], al

; 524  :             Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _G$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 525  :             Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [eax], cl

; 526  :         }

	jmp	SHORT $LN11@SegmentDra
$LN12@SegmentDra:

; 527  :     }

	jmp	SHORT $LN8@SegmentDra
$LN9@SegmentDra:

; 528  : 
; 529  :     return ErrorStackPushReturn(Success, "SegmentDrawColorShape2");

	push	OFFSET $SG110636
	push	0
	call	_ErrorStackPushReturn@8
$LN1@SegmentDra:

; 530  : }

	mov	esp, ebp
	pop	ebp
	ret	80					; 00000050H
_SegmentDrawColorShape2@80 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\segments.cpp
_TEXT	SEGMENT
tv283 = -164						; size = 8
_Dist$1 = -156						; size = 8
_DrawPixel$2 = -148					; size = 4
_InEllipse$3 = -144					; size = 4
_RowOffset$4 = -140					; size = 4
_RowOffset$5 = -136					; size = 4
_Percent$6 = -132					; size = 8
_CircleRadius$ = -124					; size = 4
tv361 = -120						; size = 4
tv358 = -116						; size = 4
_CenterX$ = -112					; size = 4
_CenterY$ = -108					; size = 4
tv314 = -104						; size = 4
tv299 = -100						; size = 4
_PixelSize$ = -96					; size = 4
tv290 = -92						; size = 4
_Delta$7 = -88						; size = 4
_Delta$8 = -84						; size = 4
tv242 = -80						; size = 4
_DrawPixel$9 = -76					; size = 4
_SqBottom$ = -72					; size = 4
_SqTop$ = -68						; size = 4
_SqRight$ = -64						; size = 4
_SqLeft$ = -60						; size = 4
_Index$10 = -56						; size = 4
_Column$11 = -52					; size = 4
_Row$12 = -48						; size = 4
_SegmentWidth$ = -44					; size = 4
_SegmentHeight$ = -40					; size = 4
_YSpan$ = -36						; size = 4
_XSpan$ = -32						; size = 4
_BgA$ = -28						; size = 1
_BgB$ = -27						; size = 1
_BgG$ = -26						; size = 1
_BgR$ = -25						; size = 1
_Row$13 = -24						; size = 4
_Column$14 = -20					; size = 4
_B$ = -16						; size = 1
_G$ = -15						; size = 1
_R$ = -14						; size = 1
_A$ = -13						; size = 1
_Index$15 = -12						; size = 4
_Dest$ = -8						; size = 4
_tA$ = -1						; size = 1
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_X1$ = 24						; size = 4
_Y1$ = 28						; size = 4
_X2$ = 32						; size = 4
_Y2$ = 36						; size = 4
_ShapeType$ = 40					; size = 4
_ShapeMargin$ = 44					; size = 4
_PackedColor$ = 48					; size = 4
_PackedBGColor$ = 52					; size = 4
_OverrideTransparency$ = 56				; size = 4
_GradientTransparency$ = 60				; size = 4
_OverriddenTransparency$ = 64				; size = 8
_InvertSpatially$ = 72					; size = 4
_SegmentDrawColorShape@68 PROC

; 226  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H

; 227  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN16@SegmentDra

; 228  :         return ErrorStackPushReturn(NullPointer, "SegmentDrawColorShape");

	push	OFFSET $SG110473
	push	3
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN16@SegmentDra:

; 229  :     if (X1 < 0 || X2 < 0)

	cmp	DWORD PTR _X1$[ebp], 0
	jl	SHORT $LN18@SegmentDra
	cmp	DWORD PTR _X2$[ebp], 0
	jge	SHORT $LN17@SegmentDra
$LN18@SegmentDra:

; 230  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape");

	push	OFFSET $SG110476
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN17@SegmentDra:

; 231  :     if (X1 >= Width || X2 >= Width)

	mov	eax, DWORD PTR _X1$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN20@SegmentDra
	mov	ecx, DWORD PTR _X2$[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jl	SHORT $LN19@SegmentDra
$LN20@SegmentDra:

; 232  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape");

	push	OFFSET $SG110479
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN19@SegmentDra:

; 233  :     if (Y1 < 0 || Y2 < 0)

	cmp	DWORD PTR _Y1$[ebp], 0
	jl	SHORT $LN22@SegmentDra
	cmp	DWORD PTR _Y2$[ebp], 0
	jge	SHORT $LN21@SegmentDra
$LN22@SegmentDra:

; 234  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape");

	push	OFFSET $SG110482
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN21@SegmentDra:

; 235  :     if (Y1 >= Height || Y2 >= Height)

	mov	edx, DWORD PTR _Y1$[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN24@SegmentDra
	mov	eax, DWORD PTR _Y2$[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jl	SHORT $LN23@SegmentDra
$LN24@SegmentDra:

; 236  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape");

	push	OFFSET $SG110485
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN23@SegmentDra:

; 237  :     if (X1 >= X2)

	mov	ecx, DWORD PTR _X1$[ebp]
	cmp	ecx, DWORD PTR _X2$[ebp]
	jl	SHORT $LN25@SegmentDra

; 238  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape");

	push	OFFSET $SG110487
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN25@SegmentDra:

; 239  :     if (Y1 >= Y2)

	mov	edx, DWORD PTR _Y1$[ebp]
	cmp	edx, DWORD PTR _Y2$[ebp]
	jl	SHORT $LN26@SegmentDra

; 240  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape");

	push	OFFSET $SG110489
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN26@SegmentDra:

; 241  :     if (ShapeMargin * 2 > (X2 - X1 + 1))

	mov	eax, DWORD PTR _ShapeMargin$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _X2$[ebp]
	sub	ecx, DWORD PTR _X1$[ebp]
	add	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN27@SegmentDra

; 242  :         return ErrorStackPushReturn(ComputedIndexOutOfRange, "SegmentDrawColorShape");

	push	OFFSET $SG110491
	push	19					; 00000013H
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN27@SegmentDra:

; 243  :     if (ShapeMargin * 2 > (Y2 - Y1 + 1))

	mov	edx, DWORD PTR _ShapeMargin$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _Y2$[ebp]
	sub	eax, DWORD PTR _Y1$[ebp]
	add	eax, 1
	cmp	edx, eax
	jle	SHORT $LN28@SegmentDra

; 244  :         return ErrorStackPushReturn(ComputedIndexOutOfRange, "SegmentDrawColorShape");

	push	OFFSET $SG110493
	push	19					; 00000013H
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN28@SegmentDra:

; 245  : 
; 246  :     BYTE A = (PackedColor & 0xff000000) >> 24;

	mov	ecx, DWORD PTR _PackedColor$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _A$[ebp], cl

; 247  :     BYTE R = (PackedColor & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _PackedColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _R$[ebp], dl

; 248  :     BYTE G = (PackedColor & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _PackedColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _G$[ebp], al

; 249  :     BYTE B = (PackedColor & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _PackedColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _B$[ebp], cl

; 250  :     BYTE BgA = (PackedBGColor & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedBGColor$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _BgA$[ebp], dl

; 251  :     BYTE BgR = (PackedBGColor & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedBGColor$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _BgR$[ebp], al

; 252  :     BYTE BgG = (PackedBGColor & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedBGColor$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _BgG$[ebp], cl

; 253  :     BYTE BgB = (PackedBGColor & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedBGColor$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _BgB$[ebp], dl

; 254  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 255  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 256  : 
; 257  :     //First, fill in the background.
; 258  :     for (int Row = Y1; Row <= Y2; Row++)

	mov	ecx, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _Row$12[ebp], ecx
	jmp	SHORT $LN4@SegmentDra
$LN2@SegmentDra:
	mov	edx, DWORD PTR _Row$12[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$12[ebp], edx
$LN4@SegmentDra:
	mov	eax, DWORD PTR _Row$12[ebp]
	cmp	eax, DWORD PTR _Y2$[ebp]
	jg	SHORT $LN3@SegmentDra

; 259  :     {
; 260  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$12[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$5[ebp], ecx

; 261  :         for (int Column = X1; Column <= X2; Column++)

	mov	edx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _Column$11[ebp], edx
	jmp	SHORT $LN7@SegmentDra
$LN5@SegmentDra:
	mov	eax, DWORD PTR _Column$11[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$11[ebp], eax
$LN7@SegmentDra:
	mov	ecx, DWORD PTR _Column$11[ebp]
	cmp	ecx, DWORD PTR _X2$[ebp]
	jg	SHORT $LN6@SegmentDra

; 262  :         {
; 263  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$11[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$5[ebp]
	mov	DWORD PTR _Index$10[ebp], edx

; 264  :             Dest[Index + 3] = BgA;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$10[ebp]
	mov	cl, BYTE PTR _BgA$[ebp]
	mov	BYTE PTR [eax+3], cl

; 265  :             Dest[Index + 2] = BgR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$10[ebp]
	mov	al, BYTE PTR _BgR$[ebp]
	mov	BYTE PTR [edx+2], al

; 266  :             Dest[Index + 1] = BgG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	dl, BYTE PTR _BgG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 267  :             Dest[Index + 0] = BgB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$10[ebp]
	mov	cl, BYTE PTR _BgB$[ebp]
	mov	BYTE PTR [eax], cl

; 268  :         }

	jmp	SHORT $LN5@SegmentDra
$LN6@SegmentDra:

; 269  :     }

	jmp	SHORT $LN2@SegmentDra
$LN3@SegmentDra:

; 270  : 
; 271  :     int XSpan = X2 - X1 + 1;

	mov	edx, DWORD PTR _X2$[ebp]
	sub	edx, DWORD PTR _X1$[ebp]
	add	edx, 1
	mov	DWORD PTR _XSpan$[ebp], edx

; 272  :     XSpan -= ShapeMargin * 2;

	mov	eax, DWORD PTR _ShapeMargin$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _XSpan$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _XSpan$[ebp], ecx

; 273  :     if (XSpan < 1)

	cmp	DWORD PTR _XSpan$[ebp], 1
	jge	SHORT $LN29@SegmentDra

; 274  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape");

	push	OFFSET $SG110495
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN29@SegmentDra:

; 275  :     int YSpan = Y2 - Y1 + 1;

	mov	edx, DWORD PTR _Y2$[ebp]
	sub	edx, DWORD PTR _Y1$[ebp]
	add	edx, 1
	mov	DWORD PTR _YSpan$[ebp], edx

; 276  :     YSpan -= ShapeMargin * 2;

	mov	eax, DWORD PTR _ShapeMargin$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _YSpan$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _YSpan$[ebp], ecx

; 277  :     if (YSpan < 1)

	cmp	DWORD PTR _YSpan$[ebp], 1
	jge	SHORT $LN30@SegmentDra

; 278  :         return ErrorStackPushReturn(IndexOutOfRange, "SegmentDrawColorShape");

	push	OFFSET $SG110497
	push	6
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentDra
$LN30@SegmentDra:

; 279  :     int CenterX = (int)((double)XSpan / 2.0) + X1;

	cvtsi2sd xmm0, DWORD PTR _XSpan$[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si edx, xmm0
	add	edx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _CenterX$[ebp], edx

; 280  :     int CenterY = (int)((double)YSpan / 2.0) + Y1;

	cvtsi2sd xmm0, DWORD PTR _YSpan$[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si eax, xmm0
	add	eax, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _CenterY$[ebp], eax

; 281  :     int CircleRadius = (min(XSpan, YSpan) / 2.0);

	mov	ecx, DWORD PTR _XSpan$[ebp]
	cmp	ecx, DWORD PTR _YSpan$[ebp]
	jge	SHORT $LN70@SegmentDra
	mov	edx, DWORD PTR _XSpan$[ebp]
	mov	DWORD PTR tv242[ebp], edx
	jmp	SHORT $LN71@SegmentDra
$LN70@SegmentDra:
	mov	eax, DWORD PTR _YSpan$[ebp]
	mov	DWORD PTR tv242[ebp], eax
$LN71@SegmentDra:
	cvtsi2sd xmm0, DWORD PTR tv242[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _CircleRadius$[ebp], ecx

; 282  : 
; 283  :     int SqTop = Y1;

	mov	edx, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _SqTop$[ebp], edx

; 284  :     int SqBottom = Y2;

	mov	eax, DWORD PTR _Y2$[ebp]
	mov	DWORD PTR _SqBottom$[ebp], eax

; 285  :     int SqLeft = X1;

	mov	ecx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _SqLeft$[ebp], ecx

; 286  :     int SqRight = X2;

	mov	edx, DWORD PTR _X2$[ebp]
	mov	DWORD PTR _SqRight$[ebp], edx

; 287  :     int SegmentHeight = Y2 - Y1 + 1;

	mov	eax, DWORD PTR _Y2$[ebp]
	sub	eax, DWORD PTR _Y1$[ebp]
	add	eax, 1
	mov	DWORD PTR _SegmentHeight$[ebp], eax

; 288  :     int SegmentWidth = X2 - X1 + 1;

	mov	ecx, DWORD PTR _X2$[ebp]
	sub	ecx, DWORD PTR _X1$[ebp]
	add	ecx, 1
	mov	DWORD PTR _SegmentWidth$[ebp], ecx

; 289  :     if (SegmentHeight > SegmentWidth)

	mov	edx, DWORD PTR _SegmentHeight$[ebp]
	cmp	edx, DWORD PTR _SegmentWidth$[ebp]
	jle	SHORT $LN31@SegmentDra

; 290  :     {
; 291  :         int Delta = SegmentHeight - SegmentWidth;

	mov	eax, DWORD PTR _SegmentHeight$[ebp]
	sub	eax, DWORD PTR _SegmentWidth$[ebp]
	mov	DWORD PTR _Delta$8[ebp], eax

; 292  :         SqTop = Y1 + (int)((double)Delta / 2.0);

	cvtsi2sd xmm0, DWORD PTR _Delta$8[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si ecx, xmm0
	add	ecx, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _SqTop$[ebp], ecx

; 293  :         SqBottom = Y2 - (int)((double)Delta / 2.0);

	cvtsi2sd xmm0, DWORD PTR _Delta$8[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si edx, xmm0
	mov	eax, DWORD PTR _Y2$[ebp]
	sub	eax, edx
	mov	DWORD PTR _SqBottom$[ebp], eax

; 294  :     }
; 295  :     else

	jmp	SHORT $LN33@SegmentDra
$LN31@SegmentDra:

; 296  :         if (SegmentWidth > SegmentHeight)

	mov	ecx, DWORD PTR _SegmentWidth$[ebp]
	cmp	ecx, DWORD PTR _SegmentHeight$[ebp]
	jle	SHORT $LN33@SegmentDra

; 297  :         {
; 298  :             int Delta = SegmentWidth - SegmentHeight;

	mov	edx, DWORD PTR _SegmentWidth$[ebp]
	sub	edx, DWORD PTR _SegmentHeight$[ebp]
	mov	DWORD PTR _Delta$7[ebp], edx

; 299  :             SqLeft = X1 + (int)((double)Delta / 2.0);

	cvtsi2sd xmm0, DWORD PTR _Delta$7[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si eax, xmm0
	add	eax, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _SqLeft$[ebp], eax

; 300  :             SqRight = X2 - (int)((double)Delta / 2.0);

	cvtsi2sd xmm0, DWORD PTR _Delta$7[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _X2$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _SqRight$[ebp], edx
$LN33@SegmentDra:

; 301  :         }
; 302  :     SqTop += ShapeMargin;

	mov	eax, DWORD PTR _SqTop$[ebp]
	add	eax, DWORD PTR _ShapeMargin$[ebp]
	mov	DWORD PTR _SqTop$[ebp], eax

; 303  :     SqBottom -= ShapeMargin;

	mov	ecx, DWORD PTR _SqBottom$[ebp]
	sub	ecx, DWORD PTR _ShapeMargin$[ebp]
	mov	DWORD PTR _SqBottom$[ebp], ecx

; 304  :     SqLeft += ShapeMargin;

	mov	edx, DWORD PTR _SqLeft$[ebp]
	add	edx, DWORD PTR _ShapeMargin$[ebp]
	mov	DWORD PTR _SqLeft$[ebp], edx

; 305  :     SqRight -= ShapeMargin;

	mov	eax, DWORD PTR _SqRight$[ebp]
	sub	eax, DWORD PTR _ShapeMargin$[ebp]
	mov	DWORD PTR _SqRight$[ebp], eax

; 306  :     if (SegmentHeight == SegmentWidth && ShapeType == SegmentShapeEllipse)

	mov	ecx, DWORD PTR _SegmentHeight$[ebp]
	cmp	ecx, DWORD PTR _SegmentWidth$[ebp]
	jne	SHORT $LN34@SegmentDra
	cmp	DWORD PTR _ShapeType$[ebp], 1
	jne	SHORT $LN34@SegmentDra

; 307  :         ShapeType = SegmentShapeCircle;

	mov	DWORD PTR _ShapeType$[ebp], 2
$LN34@SegmentDra:

; 308  :     if (SegmentHeight == SegmentWidth && ShapeType == SegmentShapeSquare)

	mov	edx, DWORD PTR _SegmentHeight$[ebp]
	cmp	edx, DWORD PTR _SegmentWidth$[ebp]
	jne	SHORT $LN35@SegmentDra
	cmp	DWORD PTR _ShapeType$[ebp], 3
	jne	SHORT $LN35@SegmentDra

; 309  :         ShapeType = SegmentShapeRectangle;

	mov	DWORD PTR _ShapeType$[ebp], 0
$LN35@SegmentDra:

; 310  :     //Get the overridden transparency but make sure the caller didn't get frisky on us.
; 311  :     BYTE tA = (BYTE)(255.0 * min(1.0, OverriddenTransparency));

	movsd	xmm0, QWORD PTR _OverriddenTransparency$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN72@SegmentDra
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR tv283[ebp], xmm0
	jmp	SHORT $LN73@SegmentDra
$LN72@SegmentDra:
	movsd	xmm0, QWORD PTR _OverriddenTransparency$[ebp]
	movsd	QWORD PTR tv283[ebp], xmm0
$LN73@SegmentDra:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	mulsd	xmm0, QWORD PTR tv283[ebp]
	cvttsd2si eax, xmm0
	mov	BYTE PTR _tA$[ebp], al

; 312  :     tA = max(tA, 255);

	movzx	ecx, BYTE PTR _tA$[ebp]
	cmp	ecx, 255				; 000000ffH
	jle	SHORT $LN74@SegmentDra
	movzx	edx, BYTE PTR _tA$[ebp]
	mov	DWORD PTR tv290[ebp], edx
	jmp	SHORT $LN75@SegmentDra
$LN74@SegmentDra:
	mov	DWORD PTR tv290[ebp], 255		; 000000ffH
$LN75@SegmentDra:
	mov	al, BYTE PTR tv290[ebp]
	mov	BYTE PTR _tA$[ebp], al

; 313  : 
; 314  :     //Lastly, fill in the shape.
; 315  :     for (int Row = Y1; Row <= Y2; Row++)

	mov	ecx, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _Row$13[ebp], ecx
	jmp	SHORT $LN10@SegmentDra
$LN8@SegmentDra:
	mov	edx, DWORD PTR _Row$13[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$13[ebp], edx
$LN10@SegmentDra:
	mov	eax, DWORD PTR _Row$13[ebp]
	cmp	eax, DWORD PTR _Y2$[ebp]
	jg	$LN9@SegmentDra

; 316  :     {
; 317  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$13[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 318  :         for (int Column = X1; Column <= X2; Column++)

	mov	edx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _Column$14[ebp], edx
	jmp	SHORT $LN13@SegmentDra
$LN11@SegmentDra:
	mov	eax, DWORD PTR _Column$14[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$14[ebp], eax
$LN13@SegmentDra:
	mov	ecx, DWORD PTR _Column$14[ebp]
	cmp	ecx, DWORD PTR _X2$[ebp]
	jg	$LN12@SegmentDra

; 319  :         {
; 320  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$14[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$15[ebp], edx

; 321  :             switch (ShapeType)

	mov	eax, DWORD PTR _ShapeType$[ebp]
	mov	DWORD PTR tv299[ebp], eax
	cmp	DWORD PTR tv299[ebp], 3
	ja	$LN68@SegmentDra
	mov	ecx, DWORD PTR tv299[ebp]
	jmp	DWORD PTR $LN82@SegmentDra[ecx*4]
$LN36@SegmentDra:

; 322  :             {
; 323  :             case SegmentShapeEllipse:
; 324  :             {
; 325  :                 BOOL InEllipse = PointInEllipse(Column, Row, (X2 - X1 + 1) / 2,

	mov	edx, DWORD PTR _CenterY$[ebp]
	push	edx
	mov	eax, DWORD PTR _CenterX$[ebp]
	push	eax
	mov	eax, DWORD PTR _Y2$[ebp]
	sub	eax, DWORD PTR _Y1$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	eax, DWORD PTR _X2$[ebp]
	sub	eax, DWORD PTR _X1$[ebp]
	add	eax, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Row$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _Column$14[ebp]
	push	edx
	call	?PointInEllipse@@YGHHHHHHH@Z		; PointInEllipse
	mov	DWORD PTR _InEllipse$3[ebp], eax

; 326  :                     (Y2 - Y1 + 1) / 2, CenterX, CenterY);
; 327  :                 BOOL DrawPixel = !InvertSpatially & InEllipse;

	cmp	DWORD PTR _InvertSpatially$[ebp], 0
	jne	SHORT $LN76@SegmentDra
	mov	DWORD PTR tv314[ebp], 1
	jmp	SHORT $LN77@SegmentDra
$LN76@SegmentDra:
	mov	DWORD PTR tv314[ebp], 0
$LN77@SegmentDra:
	mov	eax, DWORD PTR tv314[ebp]
	and	eax, DWORD PTR _InEllipse$3[ebp]
	mov	DWORD PTR _DrawPixel$2[ebp], eax

; 328  :                 if (DrawPixel)

	je	SHORT $LN37@SegmentDra

; 329  :                 {
; 330  :                     if (OverrideTransparency)

	cmp	DWORD PTR _OverrideTransparency$[ebp], 0
	je	SHORT $LN38@SegmentDra

; 331  :                     {
; 332  :                         if (GradientTransparency)

	cmp	DWORD PTR _GradientTransparency$[ebp], 0
	je	SHORT $LN40@SegmentDra

; 333  :                         {
; 334  :                         }
; 335  :                         else

	jmp	SHORT $LN41@SegmentDra
$LN40@SegmentDra:

; 336  :                             Dest[Index + 3] = tA;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$15[ebp]
	mov	dl, BYTE PTR _tA$[ebp]
	mov	BYTE PTR [ecx+3], dl
$LN41@SegmentDra:

; 337  :                     }
; 338  :                     else

	jmp	SHORT $LN39@SegmentDra
$LN38@SegmentDra:

; 339  :                         Dest[Index + 3] = A;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$15[ebp]
	mov	cl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [eax+3], cl
$LN39@SegmentDra:

; 340  :                     Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$15[ebp]
	mov	al, BYTE PTR _R$[ebp]
	mov	BYTE PTR [edx+2], al

; 341  :                     Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$15[ebp]
	mov	dl, BYTE PTR _G$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 342  :                     Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$15[ebp]
	mov	cl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [eax], cl
$LN37@SegmentDra:

; 343  :                 }
; 344  :             }
; 345  :             break;

	jmp	$LN14@SegmentDra
$LN42@SegmentDra:

; 346  : 
; 347  :             case SegmentShapeRectangle:
; 348  :                 if (OverrideTransparency)

	cmp	DWORD PTR _OverrideTransparency$[ebp], 0
	je	SHORT $LN43@SegmentDra

; 349  :                 {
; 350  :                     if (GradientTransparency)

	cmp	DWORD PTR _GradientTransparency$[ebp], 0
	je	SHORT $LN45@SegmentDra

; 351  :                     {
; 352  :                     }
; 353  :                     else

	jmp	SHORT $LN46@SegmentDra
$LN45@SegmentDra:

; 354  :                         Dest[Index + 3] = tA;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$15[ebp]
	mov	al, BYTE PTR _tA$[ebp]
	mov	BYTE PTR [edx+3], al
$LN46@SegmentDra:

; 355  :                 }
; 356  :                 else

	jmp	SHORT $LN44@SegmentDra
$LN43@SegmentDra:

; 357  :                     Dest[Index + 3] = A;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$15[ebp]
	mov	dl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [ecx+3], dl
$LN44@SegmentDra:

; 358  :                 Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$15[ebp]
	mov	cl, BYTE PTR _R$[ebp]
	mov	BYTE PTR [eax+2], cl

; 359  :                 Dest[Index + 1] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$15[ebp]
	mov	al, BYTE PTR _G$[ebp]
	mov	BYTE PTR [edx+1], al

; 360  :                 Dest[Index + 0] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$15[ebp]
	mov	dl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [ecx], dl

; 361  :                 break;

	jmp	$LN14@SegmentDra
$LN47@SegmentDra:

; 362  : 
; 363  :             case SegmentShapeCircle:
; 364  :             {
; 365  :                 double Dist = Distance(Column, Row, CenterX, CenterY);

	mov	eax, DWORD PTR _CenterY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CenterX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Row$13[ebp]
	push	edx
	mov	eax, DWORD PTR _Column$14[ebp]
	push	eax
	call	?Distance@@YGNHHHH@Z			; Distance
	fstp	QWORD PTR _Dist$1[ebp]

; 366  :                 BOOL DrawPixel = Dist < CircleRadius;

	cvtsi2sd xmm0, DWORD PTR _CircleRadius$[ebp]
	comisd	xmm0, QWORD PTR _Dist$1[ebp]
	jbe	SHORT $LN78@SegmentDra
	mov	DWORD PTR tv358[ebp], 1
	jmp	SHORT $LN79@SegmentDra
$LN78@SegmentDra:
	mov	DWORD PTR tv358[ebp], 0
$LN79@SegmentDra:
	mov	ecx, DWORD PTR tv358[ebp]
	mov	DWORD PTR _DrawPixel$9[ebp], ecx

; 367  :                 if (InvertSpatially) DrawPixel = !DrawPixel;

	cmp	DWORD PTR _InvertSpatially$[ebp], 0
	je	SHORT $LN48@SegmentDra
	cmp	DWORD PTR _DrawPixel$9[ebp], 0
	jne	SHORT $LN80@SegmentDra
	mov	DWORD PTR tv361[ebp], 1
	jmp	SHORT $LN81@SegmentDra
$LN80@SegmentDra:
	mov	DWORD PTR tv361[ebp], 0
$LN81@SegmentDra:
	mov	edx, DWORD PTR tv361[ebp]
	mov	DWORD PTR _DrawPixel$9[ebp], edx
$LN48@SegmentDra:

; 368  :                 if (DrawPixel)

	cmp	DWORD PTR _DrawPixel$9[ebp], 0
	je	$LN49@SegmentDra

; 369  :                 {
; 370  :                     if (OverrideTransparency)

	cmp	DWORD PTR _OverrideTransparency$[ebp], 0
	je	$LN50@SegmentDra

; 371  :                     {
; 372  :                         if (GradientTransparency)

	cmp	DWORD PTR _GradientTransparency$[ebp], 0
	je	$LN52@SegmentDra

; 373  :                         {
; 374  :                             if (Dist == 0.0)

	movsd	xmm0, QWORD PTR _Dist$1[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN54@SegmentDra

; 375  :                                 Dest[Index + 3] = 0xff;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$15[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH

; 376  :                             else

	jmp	$LN58@SegmentDra
$LN54@SegmentDra:

; 377  :                             {
; 378  :                                 double Percent = Dist / CircleRadius;

	cvtsi2sd xmm0, DWORD PTR _CircleRadius$[ebp]
	movsd	xmm1, QWORD PTR _Dist$1[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _Percent$6[ebp], xmm1

; 379  :                                 Percent = 1.0 - Percent;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _Percent$6[ebp]
	movsd	QWORD PTR _Percent$6[ebp], xmm0

; 380  :                                 if (Percent < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _Percent$6[ebp]
	jbe	SHORT $LN56@SegmentDra

; 381  :                                     Percent = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Percent$6[ebp], xmm0
$LN56@SegmentDra:

; 382  :                                 if (OverriddenTransparency == 0)

	movsd	xmm0, QWORD PTR _OverriddenTransparency$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN57@SegmentDra

; 383  :                                     Dest[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$15[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH

; 384  :                                 else

	jmp	SHORT $LN58@SegmentDra
$LN57@SegmentDra:

; 385  :                                     Dest[Index + 3] = (BYTE)(Percent * ((double)OverriddenTransparency * 255.0));

	movsd	xmm0, QWORD PTR _OverriddenTransparency$[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	mulsd	xmm0, QWORD PTR _Percent$6[ebp]
	cvttsd2si edx, xmm0
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$15[ebp]
	mov	BYTE PTR [eax+3], dl
$LN58@SegmentDra:

; 386  :                             }
; 387  :                         }
; 388  :                         else

	jmp	SHORT $LN53@SegmentDra
$LN52@SegmentDra:

; 389  :                             Dest[Index + 3] = (BYTE)((double)OverriddenTransparency * 255.0);

	movsd	xmm0, QWORD PTR _OverriddenTransparency$[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$15[ebp]
	mov	BYTE PTR [edx+3], cl
$LN53@SegmentDra:

; 390  :                     }
; 391  :                     else

	jmp	SHORT $LN51@SegmentDra
$LN50@SegmentDra:

; 392  :                         Dest[Index + 3] = A;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$15[ebp]
	mov	cl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [eax+3], cl
$LN51@SegmentDra:

; 393  :                     Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$15[ebp]
	mov	al, BYTE PTR _R$[ebp]
	mov	BYTE PTR [edx+2], al

; 394  :                     Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$15[ebp]
	mov	dl, BYTE PTR _G$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 395  :                     Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$15[ebp]
	mov	cl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [eax], cl
$LN49@SegmentDra:

; 396  :                 }
; 397  :             }
; 398  :             break;

	jmp	$LN14@SegmentDra
$LN59@SegmentDra:

; 399  : 
; 400  :             case SegmentShapeSquare:
; 401  :                 if (Column < SqLeft)

	mov	edx, DWORD PTR _Column$14[ebp]
	cmp	edx, DWORD PTR _SqLeft$[ebp]
	jge	SHORT $LN60@SegmentDra

; 402  :                     continue;

	jmp	$LN11@SegmentDra
$LN60@SegmentDra:

; 403  :                 if (Column > SqRight)

	mov	eax, DWORD PTR _Column$14[ebp]
	cmp	eax, DWORD PTR _SqRight$[ebp]
	jle	SHORT $LN61@SegmentDra

; 404  :                     continue;

	jmp	$LN11@SegmentDra
$LN61@SegmentDra:

; 405  :                 if (Row < SqTop)

	mov	ecx, DWORD PTR _Row$13[ebp]
	cmp	ecx, DWORD PTR _SqTop$[ebp]
	jge	SHORT $LN62@SegmentDra

; 406  :                     continue;

	jmp	$LN11@SegmentDra
$LN62@SegmentDra:

; 407  :                 if (Row > SqBottom)

	mov	edx, DWORD PTR _Row$13[ebp]
	cmp	edx, DWORD PTR _SqBottom$[ebp]
	jle	SHORT $LN63@SegmentDra

; 408  :                     continue;

	jmp	$LN11@SegmentDra
$LN63@SegmentDra:

; 409  :                 if (OverrideTransparency)

	cmp	DWORD PTR _OverrideTransparency$[ebp], 0
	je	SHORT $LN64@SegmentDra

; 410  :                 {
; 411  :                     if (GradientTransparency)

	cmp	DWORD PTR _GradientTransparency$[ebp], 0
	je	SHORT $LN66@SegmentDra

; 412  :                     {
; 413  :                     }
; 414  :                     else

	jmp	SHORT $LN67@SegmentDra
$LN66@SegmentDra:

; 415  :                         Dest[Index + 3] = tA;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$15[ebp]
	mov	cl, BYTE PTR _tA$[ebp]
	mov	BYTE PTR [eax+3], cl
$LN67@SegmentDra:

; 416  :                 }
; 417  :                 else

	jmp	SHORT $LN65@SegmentDra
$LN64@SegmentDra:

; 418  :                     Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$15[ebp]
	mov	al, BYTE PTR _A$[ebp]
	mov	BYTE PTR [edx+3], al
$LN65@SegmentDra:

; 419  :                 Dest[Index + 2] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$15[ebp]
	mov	dl, BYTE PTR _R$[ebp]
	mov	BYTE PTR [ecx+2], dl

; 420  :                 Dest[Index + 1] = G;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$15[ebp]
	mov	cl, BYTE PTR _G$[ebp]
	mov	BYTE PTR [eax+1], cl

; 421  :                 Dest[Index + 0] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$15[ebp]
	mov	al, BYTE PTR _B$[ebp]
	mov	BYTE PTR [edx], al

; 422  :                 break;

	jmp	SHORT $LN14@SegmentDra
$LN68@SegmentDra:

; 423  : 
; 424  :             default:
; 425  :                 ErrorStackPushReturn(InvalidOperation, "SegmentDrawColorShape");

	push	OFFSET $SG110536
	push	11					; 0000000bH
	call	_ErrorStackPushReturn@8
$LN14@SegmentDra:

; 426  :             }
; 427  :         }

	jmp	$LN11@SegmentDra
$LN12@SegmentDra:

; 428  :     }

	jmp	$LN8@SegmentDra
$LN9@SegmentDra:

; 429  : 
; 430  :     return ErrorStackPushReturn(Success, "SegmentDrawColorShape");

	push	OFFSET $SG110537
	push	0
	call	_ErrorStackPushReturn@8
$LN1@SegmentDra:

; 431  : }

	mov	esp, ebp
	pop	ebp
	ret	68					; 00000044H
	npad	1
$LN82@SegmentDra:
	DD	$LN42@SegmentDra
	DD	$LN36@SegmentDra
	DD	$LN47@SegmentDra
	DD	$LN59@SegmentDra
_SegmentDrawColorShape@68 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\segments.cpp
_TEXT	SEGMENT
_FinalBlockHeight$1 = -60				; size = 4
_Src$ = -56						; size = 4
_Dest$ = -52						; size = 4
_PixelSize$ = -48					; size = 4
_PackedResult$2 = -44					; size = 4
_FinalBlockWidth$3 = -40				; size = 4
_AnalysisResult$4 = -36					; size = 4
_X1$5 = -32						; size = 4
_Y1$6 = -28						; size = 4
_X2$7 = -24						; size = 4
_Y2$8 = -20						; size = 4
_BlockY$9 = -16						; size = 4
_BlockX$10 = -12					; size = 4
_BlockYHeight$ = -8					; size = 4
_BlockXWidth$ = -4					; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_BlocksX$ = 24						; size = 4
_BlocksY$ = 28						; size = 4
_Destination$ = 32					; size = 4
_ShowGrid$ = 36						; size = 4
_GridColor$ = 40					; size = 4
_HighlightCell$ = 44					; size = 4
_HightlightCellX$ = 48					; size = 4
_HighlightCellY$ = 52					; size = 4
_CellHighlightColor$ = 56				; size = 4
_SegmentBlocks2@52 PROC

; 26   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 27   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@SegmentBlo

; 28   :         return ErrorStackPushReturn2(NullPointer, "SegmentBlocks", "Source is null");

	push	OFFSET $SG110254
	push	OFFSET $SG110255
	push	3
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN8@SegmentBlo:

; 29   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@SegmentBlo

; 30   :         return ErrorStackPushReturn2(NullPointer, "SegmentBlocks", "Destination is null");

	push	OFFSET $SG110257
	push	OFFSET $SG110258
	push	3
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN9@SegmentBlo:

; 31   :     if (BlocksX < 1)

	cmp	DWORD PTR _BlocksX$[ebp], 1
	jge	SHORT $LN10@SegmentBlo

; 32   :         return ErrorStackPushReturn2(InvalidRegion, "SegmentBlocks", "BlocksX < 1");

	push	OFFSET $SG110260
	push	OFFSET $SG110261
	push	21					; 00000015H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN10@SegmentBlo:

; 33   :     if (BlocksY < 1)

	cmp	DWORD PTR _BlocksY$[ebp], 1
	jge	SHORT $LN11@SegmentBlo

; 34   :         return ErrorStackPushReturn2(InvalidRegion, "SegmentBlocks", "BlocksY < 1");

	push	OFFSET $SG110263
	push	OFFSET $SG110264
	push	21					; 00000015H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN11@SegmentBlo:

; 35   : 
; 36   :     int BlockXWidth = Width / BlocksX;

	mov	eax, DWORD PTR _Width$[ebp]
	cdq
	idiv	DWORD PTR _BlocksX$[ebp]
	mov	DWORD PTR _BlockXWidth$[ebp], eax

; 37   :     if (BlockXWidth < 1)

	cmp	DWORD PTR _BlockXWidth$[ebp], 1
	jge	SHORT $LN12@SegmentBlo

; 38   :         return ErrorStackPushReturn2(InvalidRegion, "SegmentBlocks", "BlockXWidth < 1");

	push	OFFSET $SG110266
	push	OFFSET $SG110267
	push	21					; 00000015H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN12@SegmentBlo:

; 39   :     if (Width % BlocksX > 0)

	mov	eax, DWORD PTR _Width$[ebp]
	cdq
	idiv	DWORD PTR _BlocksX$[ebp]
	test	edx, edx
	jle	SHORT $LN13@SegmentBlo

; 40   :         BlockXWidth++;

	mov	eax, DWORD PTR _BlockXWidth$[ebp]
	add	eax, 1
	mov	DWORD PTR _BlockXWidth$[ebp], eax
$LN13@SegmentBlo:

; 41   :     int BlockYHeight = Height / BlocksY;

	mov	eax, DWORD PTR _Height$[ebp]
	cdq
	idiv	DWORD PTR _BlocksY$[ebp]
	mov	DWORD PTR _BlockYHeight$[ebp], eax

; 42   :     if (BlockYHeight < 1)

	cmp	DWORD PTR _BlockYHeight$[ebp], 1
	jge	SHORT $LN14@SegmentBlo

; 43   :         return ErrorStackPushReturn2(InvalidRegion, "SegmentBlocks", "BlockYHeight < 1");

	push	OFFSET $SG110270
	push	OFFSET $SG110271
	push	21					; 00000015H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN14@SegmentBlo:

; 44   :     if (Height % BlocksY > 0)

	mov	eax, DWORD PTR _Height$[ebp]
	cdq
	idiv	DWORD PTR _BlocksY$[ebp]
	test	edx, edx
	jle	SHORT $LN15@SegmentBlo

; 45   :         BlockYHeight++;

	mov	ecx, DWORD PTR _BlockYHeight$[ebp]
	add	ecx, 1
	mov	DWORD PTR _BlockYHeight$[ebp], ecx
$LN15@SegmentBlo:

; 46   : 
; 47   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 48   :     BYTE *Dest = (BYTE *)Destination;

	mov	edx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], edx

; 49   :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 50   : 
; 51   :     for (int BlockY = 0; BlockY < BlocksY; BlockY++)

	mov	DWORD PTR _BlockY$9[ebp], 0
	jmp	SHORT $LN4@SegmentBlo
$LN2@SegmentBlo:
	mov	ecx, DWORD PTR _BlockY$9[ebp]
	add	ecx, 1
	mov	DWORD PTR _BlockY$9[ebp], ecx
$LN4@SegmentBlo:
	mov	edx, DWORD PTR _BlockY$9[ebp]
	cmp	edx, DWORD PTR _BlocksY$[ebp]
	jge	$LN3@SegmentBlo

; 52   :     {
; 53   :         for (int BlockX = 0; BlockX < BlocksX; BlockX++)

	mov	DWORD PTR _BlockX$10[ebp], 0
	jmp	SHORT $LN7@SegmentBlo
$LN5@SegmentBlo:
	mov	eax, DWORD PTR _BlockX$10[ebp]
	add	eax, 1
	mov	DWORD PTR _BlockX$10[ebp], eax
$LN7@SegmentBlo:
	mov	ecx, DWORD PTR _BlockX$10[ebp]
	cmp	ecx, DWORD PTR _BlocksX$[ebp]
	jge	$LN6@SegmentBlo

; 54   :         {
; 55   :             int FinalBlockWidth = BlockXWidth;

	mov	edx, DWORD PTR _BlockXWidth$[ebp]
	mov	DWORD PTR _FinalBlockWidth$3[ebp], edx

; 56   :             if (BlockX == BlocksX - 1)

	mov	eax, DWORD PTR _BlocksX$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _BlockX$10[ebp], eax
	jne	SHORT $LN16@SegmentBlo

; 57   :                 FinalBlockWidth = (int)(Width % BlocksX);

	mov	eax, DWORD PTR _Width$[ebp]
	cdq
	idiv	DWORD PTR _BlocksX$[ebp]
	mov	DWORD PTR _FinalBlockWidth$3[ebp], edx
$LN16@SegmentBlo:

; 58   :             int FinalBlockHeight = BlockYHeight;

	mov	ecx, DWORD PTR _BlockYHeight$[ebp]
	mov	DWORD PTR _FinalBlockHeight$1[ebp], ecx

; 59   :             if (BlockY == BlocksY - 1)

	mov	edx, DWORD PTR _BlocksY$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _BlockY$9[ebp], edx
	jne	SHORT $LN17@SegmentBlo

; 60   :                 FinalBlockWidth = (int)(Height % BlocksY);

	mov	eax, DWORD PTR _Height$[ebp]
	cdq
	idiv	DWORD PTR _BlocksY$[ebp]
	mov	DWORD PTR _FinalBlockWidth$3[ebp], edx
$LN17@SegmentBlo:

; 61   : 
; 62   :             UINT32 PackedResult = 0;

	mov	DWORD PTR _PackedResult$2[ebp], 0

; 63   :             int AnalysisResult = Success;

	mov	DWORD PTR _AnalysisResult$4[ebp], 0

; 64   :             int X1 = BlockX * BlockXWidth;

	mov	eax, DWORD PTR _BlockX$10[ebp]
	imul	eax, DWORD PTR _BlockXWidth$[ebp]
	mov	DWORD PTR _X1$5[ebp], eax

; 65   :             if (X1 >= Width)

	mov	ecx, DWORD PTR _X1$5[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jl	SHORT $LN18@SegmentBlo

; 66   :                 break;

	jmp	$LN6@SegmentBlo
$LN18@SegmentBlo:

; 67   :             int X2 = X1 + BlockXWidth;

	mov	edx, DWORD PTR _X1$5[ebp]
	add	edx, DWORD PTR _BlockXWidth$[ebp]
	mov	DWORD PTR _X2$7[ebp], edx

; 68   :             if (X2 >= Width)

	mov	eax, DWORD PTR _X2$7[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN19@SegmentBlo

; 69   :                 X2 = Width - 1;

	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _X2$7[ebp], ecx
$LN19@SegmentBlo:

; 70   :             int Y1 = BlockY * BlockYHeight;

	mov	edx, DWORD PTR _BlockY$9[ebp]
	imul	edx, DWORD PTR _BlockYHeight$[ebp]
	mov	DWORD PTR _Y1$6[ebp], edx

; 71   :             if (Y1 >= Height)

	mov	eax, DWORD PTR _Y1$6[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jl	SHORT $LN20@SegmentBlo

; 72   :                 break;

	jmp	$LN6@SegmentBlo
$LN20@SegmentBlo:

; 73   :             int Y2 = Y1 + BlockYHeight;

	mov	ecx, DWORD PTR _Y1$6[ebp]
	add	ecx, DWORD PTR _BlockYHeight$[ebp]
	mov	DWORD PTR _Y2$8[ebp], ecx

; 74   :             if (Y2 >= Height)

	mov	edx, DWORD PTR _Y2$8[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN21@SegmentBlo

; 75   :                 Y2 = Height - 1;

	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	mov	DWORD PTR _Y2$8[ebp], eax
$LN21@SegmentBlo:

; 76   :             AnalysisResult = RegionMedianColor(Source, Width, Height, Stride,

	lea	ecx, DWORD PTR _PackedResult$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _Y2$8[ebp]
	push	edx
	mov	eax, DWORD PTR _X2$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _Y1$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _X1$5[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_RegionMedianColor@36
	mov	DWORD PTR _AnalysisResult$4[ebp], eax

; 77   :                 X1, Y1, X2, Y2, &PackedResult);
; 78   :             if (AnalysisResult != Success)

	cmp	DWORD PTR _AnalysisResult$4[ebp], 0
	je	SHORT $LN22@SegmentBlo

; 79   :                 return AnalysisResult;

	mov	eax, DWORD PTR _AnalysisResult$4[ebp]
	jmp	SHORT $LN1@SegmentBlo
$LN22@SegmentBlo:

; 80   :             SegmentDrawColorShape(Destination, Width, Height, Stride,

	push	0
	sub	esp, 8
	xorps	xmm0, xmm0
	movsd	QWORD PTR [esp], xmm0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _PackedResult$2[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Y2$8[ebp]
	push	edx
	mov	eax, DWORD PTR _X2$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _Y1$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _X1$5[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	call	_SegmentDrawColorShape@68

; 81   :                 X1, Y1, X2, Y2, SegmentShapeRectangle, 0, PackedResult, 0x0, FALSE,
; 82   :                 FALSE, 0.0, FALSE);
; 83   :         }

	jmp	$LN5@SegmentBlo
$LN6@SegmentBlo:

; 84   :     }

	jmp	$LN2@SegmentBlo
$LN3@SegmentBlo:

; 85   :     return ErrorStackPushReturn(Success, "SegmentBlocks2");

	push	OFFSET $SG110280
	push	0
	call	_ErrorStackPushReturn@8
$LN1@SegmentBlo:

; 86   : }

	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
_SegmentBlocks2@52 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\segments.cpp
_TEXT	SEGMENT
_BrightLum$ = -96					; size = 8
_DarkLum$ = -88						; size = 8
_FinalBlockHeight$1 = -80				; size = 4
_Src$ = -76						; size = 4
_Dest$ = -72						; size = 4
_PixelSize$ = -68					; size = 4
_BrightX$ = -64						; size = 4
_BrightY$ = -60						; size = 4
_DarkX$ = -56						; size = 4
_DarkY$ = -52						; size = 4
tv154 = -48						; size = 4
_FinalBlockWidth$2 = -44				; size = 4
_BlockY$3 = -40						; size = 4
_BlockX$4 = -36						; size = 4
_BlockYHeight$ = -32					; size = 4
_BlockXWidth$ = -28					; size = 4
_PackedResult$5 = -24					; size = 4
_X1$6 = -20						; size = 4
_Y1$7 = -16						; size = 4
_X2$8 = -12						; size = 4
_Y2$9 = -8						; size = 4
_AnalysisResult$10 = -4					; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_BlocksX$ = 24						; size = 4
_BlocksY$ = 28						; size = 4
_SegmentType$ = 32					; size = 4
_ShapeType$ = 36					; size = 4
_ShapeMargin$ = 40					; size = 4
_OverrideTransparency$ = 44				; size = 4
_GradientTransparency$ = 48				; size = 4
_OverriddenTransparency$ = 52				; size = 8
_Destination$ = 60					; size = 4
_BGColor$ = 64						; size = 4
_InvertSpatially$ = 68					; size = 4
_HighlightByLuminance$ = 72				; size = 4
_InvertHighlighting$ = 76				; size = 4
_SegmentBlocks@72 PROC

; 93   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 94   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN10@SegmentBlo

; 95   :         return ErrorStackPushReturn2(NullPointer, "SegmentBlocks", "Source is null");

	push	OFFSET $SG110334
	push	OFFSET $SG110335
	push	3
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN10@SegmentBlo:

; 96   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN11@SegmentBlo

; 97   :         return ErrorStackPushReturn2(NullPointer, "SegmentBlocks", "Destination is null");

	push	OFFSET $SG110337
	push	OFFSET $SG110338
	push	3
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN11@SegmentBlo:

; 98   :     if (BlocksX < 1)

	cmp	DWORD PTR _BlocksX$[ebp], 1
	jge	SHORT $LN12@SegmentBlo

; 99   :         return ErrorStackPushReturn2(InvalidRegion, "SegmentBlocks", "BlocksX < 1");

	push	OFFSET $SG110340
	push	OFFSET $SG110341
	push	21					; 00000015H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN12@SegmentBlo:

; 100  :     if (BlocksY < 1)

	cmp	DWORD PTR _BlocksY$[ebp], 1
	jge	SHORT $LN13@SegmentBlo

; 101  :         return ErrorStackPushReturn2(InvalidRegion, "SegmentBlocks", "BlocksY < 1");

	push	OFFSET $SG110343
	push	OFFSET $SG110344
	push	21					; 00000015H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN13@SegmentBlo:

; 102  : 
; 103  :     int BlockXWidth = Width / BlocksX;

	mov	eax, DWORD PTR _Width$[ebp]
	cdq
	idiv	DWORD PTR _BlocksX$[ebp]
	mov	DWORD PTR _BlockXWidth$[ebp], eax

; 104  :     if (BlockXWidth < 1)

	cmp	DWORD PTR _BlockXWidth$[ebp], 1
	jge	SHORT $LN14@SegmentBlo

; 105  :         return ErrorStackPushReturn2(InvalidRegion, "SegmentBlocks", "BlockXWidth < 1");

	push	OFFSET $SG110346
	push	OFFSET $SG110347
	push	21					; 00000015H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN14@SegmentBlo:

; 106  :     if (Width % BlocksX > 0)

	mov	eax, DWORD PTR _Width$[ebp]
	cdq
	idiv	DWORD PTR _BlocksX$[ebp]
	test	edx, edx
	jle	SHORT $LN15@SegmentBlo

; 107  :         BlockXWidth++;

	mov	eax, DWORD PTR _BlockXWidth$[ebp]
	add	eax, 1
	mov	DWORD PTR _BlockXWidth$[ebp], eax
$LN15@SegmentBlo:

; 108  :     int BlockYHeight = Height / BlocksY;

	mov	eax, DWORD PTR _Height$[ebp]
	cdq
	idiv	DWORD PTR _BlocksY$[ebp]
	mov	DWORD PTR _BlockYHeight$[ebp], eax

; 109  :     if (BlockYHeight < 1)

	cmp	DWORD PTR _BlockYHeight$[ebp], 1
	jge	SHORT $LN16@SegmentBlo

; 110  :         return ErrorStackPushReturn2(InvalidRegion, "SegmentBlocks", "BlockYHeight < 1");

	push	OFFSET $SG110350
	push	OFFSET $SG110351
	push	21					; 00000015H
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@SegmentBlo
$LN16@SegmentBlo:

; 111  :     if (Height % BlocksY > 0)

	mov	eax, DWORD PTR _Height$[ebp]
	cdq
	idiv	DWORD PTR _BlocksY$[ebp]
	test	edx, edx
	jle	SHORT $LN17@SegmentBlo

; 112  :         BlockYHeight++;

	mov	ecx, DWORD PTR _BlockYHeight$[ebp]
	add	ecx, 1
	mov	DWORD PTR _BlockYHeight$[ebp], ecx
$LN17@SegmentBlo:

; 113  : 
; 114  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 115  :     BYTE *Dest = (BYTE *)Destination;

	mov	edx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], edx

; 116  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 117  : 
; 118  :     double BrightLum = -1.0;

	movsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR _BrightLum$[ebp], xmm0

; 119  :     double DarkLum = 100.0;

	movsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR _DarkLum$[ebp], xmm0

; 120  :     __int32 BrightX = -1;

	mov	DWORD PTR _BrightX$[ebp], -1

; 121  :     __int32 BrightY = -1;

	mov	DWORD PTR _BrightY$[ebp], -1

; 122  :     __int32 DarkX = -1;

	mov	DWORD PTR _DarkX$[ebp], -1

; 123  :     __int32 DarkY = -1;

	mov	DWORD PTR _DarkY$[ebp], -1

; 124  : 
; 125  :     for (int BlockY = 0; BlockY < BlocksY; BlockY++)

	mov	DWORD PTR _BlockY$3[ebp], 0
	jmp	SHORT $LN4@SegmentBlo
$LN2@SegmentBlo:
	mov	ecx, DWORD PTR _BlockY$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _BlockY$3[ebp], ecx
$LN4@SegmentBlo:
	mov	edx, DWORD PTR _BlockY$3[ebp]
	cmp	edx, DWORD PTR _BlocksY$[ebp]
	jge	$LN3@SegmentBlo

; 126  :     {
; 127  :         for (int BlockX = 0; BlockX < BlocksX; BlockX++)

	mov	DWORD PTR _BlockX$4[ebp], 0
	jmp	SHORT $LN7@SegmentBlo
$LN5@SegmentBlo:
	mov	eax, DWORD PTR _BlockX$4[ebp]
	add	eax, 1
	mov	DWORD PTR _BlockX$4[ebp], eax
$LN7@SegmentBlo:
	mov	ecx, DWORD PTR _BlockX$4[ebp]
	cmp	ecx, DWORD PTR _BlocksX$[ebp]
	jge	$LN6@SegmentBlo

; 128  :         {
; 129  :             int FinalBlockWidth = BlockXWidth;

	mov	edx, DWORD PTR _BlockXWidth$[ebp]
	mov	DWORD PTR _FinalBlockWidth$2[ebp], edx

; 130  :             if (BlockX == BlocksX - 1)

	mov	eax, DWORD PTR _BlocksX$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _BlockX$4[ebp], eax
	jne	SHORT $LN18@SegmentBlo

; 131  :                 FinalBlockWidth = (int)(Width % BlocksX);

	mov	eax, DWORD PTR _Width$[ebp]
	cdq
	idiv	DWORD PTR _BlocksX$[ebp]
	mov	DWORD PTR _FinalBlockWidth$2[ebp], edx
$LN18@SegmentBlo:

; 132  :             int FinalBlockHeight = BlockYHeight;

	mov	ecx, DWORD PTR _BlockYHeight$[ebp]
	mov	DWORD PTR _FinalBlockHeight$1[ebp], ecx

; 133  :             if (BlockY == BlocksY - 1)

	mov	edx, DWORD PTR _BlocksY$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _BlockY$3[ebp], edx
	jne	SHORT $LN19@SegmentBlo

; 134  :                 FinalBlockWidth = (int)(Height % BlocksY);

	mov	eax, DWORD PTR _Height$[ebp]
	cdq
	idiv	DWORD PTR _BlocksY$[ebp]
	mov	DWORD PTR _FinalBlockWidth$2[ebp], edx
$LN19@SegmentBlo:

; 135  : 
; 136  :             UINT32 PackedResult = 0;

	mov	DWORD PTR _PackedResult$5[ebp], 0

; 137  :             int AnalysisResult = Success;

	mov	DWORD PTR _AnalysisResult$10[ebp], 0

; 138  :             int X1 = BlockX * BlockXWidth;

	mov	eax, DWORD PTR _BlockX$4[ebp]
	imul	eax, DWORD PTR _BlockXWidth$[ebp]
	mov	DWORD PTR _X1$6[ebp], eax

; 139  :             if (X1 >= Width)

	mov	ecx, DWORD PTR _X1$6[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jl	SHORT $LN20@SegmentBlo

; 140  :                 break;

	jmp	$LN6@SegmentBlo
$LN20@SegmentBlo:

; 141  :             int X2 = X1 + BlockXWidth;

	mov	edx, DWORD PTR _X1$6[ebp]
	add	edx, DWORD PTR _BlockXWidth$[ebp]
	mov	DWORD PTR _X2$8[ebp], edx

; 142  :             if (X2 >= Width)

	mov	eax, DWORD PTR _X2$8[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN21@SegmentBlo

; 143  :                 X2 = Width - 1;

	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _X2$8[ebp], ecx
$LN21@SegmentBlo:

; 144  :             int Y1 = BlockY * BlockYHeight;

	mov	edx, DWORD PTR _BlockY$3[ebp]
	imul	edx, DWORD PTR _BlockYHeight$[ebp]
	mov	DWORD PTR _Y1$7[ebp], edx

; 145  :             if (Y1 >= Height)

	mov	eax, DWORD PTR _Y1$7[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jl	SHORT $LN22@SegmentBlo

; 146  :                 break;

	jmp	$LN6@SegmentBlo
$LN22@SegmentBlo:

; 147  :             int Y2 = Y1 + BlockYHeight;

	mov	ecx, DWORD PTR _Y1$7[ebp]
	add	ecx, DWORD PTR _BlockYHeight$[ebp]
	mov	DWORD PTR _Y2$9[ebp], ecx

; 148  :             if (Y2 >= Height)

	mov	edx, DWORD PTR _Y2$9[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN23@SegmentBlo

; 149  :                 Y2 = Height - 1;

	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	mov	DWORD PTR _Y2$9[ebp], eax
$LN23@SegmentBlo:

; 150  :             switch (SegmentType)

	mov	ecx, DWORD PTR _SegmentType$[ebp]
	mov	DWORD PTR tv154[ebp], ecx
	cmp	DWORD PTR tv154[ebp], 4
	ja	$LN34@SegmentBlo
	mov	edx, DWORD PTR tv154[ebp]
	jmp	DWORD PTR $LN38@SegmentBlo[edx*4]
$LN24@SegmentBlo:

; 151  :             {
; 152  :             case SegmentMeanColor:
; 153  :             {
; 154  :                 AnalysisResult = RegionMeanColor(Source, Width, Height, Stride,

	lea	eax, DWORD PTR _DarkY$[ebp]
	push	eax
	lea	ecx, DWORD PTR _DarkX$[ebp]
	push	ecx
	lea	edx, DWORD PTR _BrightY$[ebp]
	push	edx
	lea	eax, DWORD PTR _BrightX$[ebp]
	push	eax
	lea	ecx, DWORD PTR _DarkLum$[ebp]
	push	ecx
	lea	edx, DWORD PTR _BrightLum$[ebp]
	push	edx
	mov	eax, DWORD PTR _HighlightByLuminance$[ebp]
	push	eax
	lea	ecx, DWORD PTR _PackedResult$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _Y2$9[ebp]
	push	edx
	mov	eax, DWORD PTR _X2$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _Y1$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _X1$6[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_RegionMeanColor@64
	mov	DWORD PTR _AnalysisResult$10[ebp], eax

; 155  :                     X1, Y1, X2, Y2, &PackedResult, HighlightByLuminance, &BrightLum, &DarkLum,
; 156  :                     &BrightX, &BrightY, &DarkX, &DarkY);
; 157  :                 if (AnalysisResult != Success)

	cmp	DWORD PTR _AnalysisResult$10[ebp], 0
	je	SHORT $LN25@SegmentBlo

; 158  :                     return AnalysisResult;

	mov	eax, DWORD PTR _AnalysisResult$10[ebp]
	jmp	$LN1@SegmentBlo
$LN25@SegmentBlo:

; 159  :             }
; 160  :             break;

	jmp	$LN8@SegmentBlo
$LN26@SegmentBlo:

; 161  : 
; 162  :             case SegmentMedianColor:
; 163  :                 AnalysisResult = RegionMedianColor(Source, Width, Height, Stride,

	lea	ecx, DWORD PTR _PackedResult$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _Y2$9[ebp]
	push	edx
	mov	eax, DWORD PTR _X2$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _Y1$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _X1$6[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_RegionMedianColor@36
	mov	DWORD PTR _AnalysisResult$10[ebp], eax

; 164  :                     X1, Y1, X2, Y2, &PackedResult);
; 165  :                 if (AnalysisResult != Success)

	cmp	DWORD PTR _AnalysisResult$10[ebp], 0
	je	SHORT $LN27@SegmentBlo

; 166  :                     return AnalysisResult;

	mov	eax, DWORD PTR _AnalysisResult$10[ebp]
	jmp	$LN1@SegmentBlo
$LN27@SegmentBlo:

; 167  :                 break;

	jmp	$LN8@SegmentBlo
$LN28@SegmentBlo:

; 168  : 
; 169  :             case SegmentBrightestColor:
; 170  :                 AnalysisResult = RegionBrightestColor(Source, Width, Height, Stride,

	lea	ecx, DWORD PTR _PackedResult$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _Y2$9[ebp]
	push	edx
	mov	eax, DWORD PTR _X2$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _Y1$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _X1$6[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_RegionBrightestColor@36
	mov	DWORD PTR _AnalysisResult$10[ebp], eax

; 171  :                     X1, Y1, X2, Y2, &PackedResult);
; 172  :                 if (AnalysisResult != Success)

	cmp	DWORD PTR _AnalysisResult$10[ebp], 0
	je	SHORT $LN29@SegmentBlo

; 173  :                     return AnalysisResult;

	mov	eax, DWORD PTR _AnalysisResult$10[ebp]
	jmp	$LN1@SegmentBlo
$LN29@SegmentBlo:

; 174  :                 break;

	jmp	$LN8@SegmentBlo
$LN30@SegmentBlo:

; 175  : 
; 176  :             case SegmentDarkestColor:
; 177  :                 AnalysisResult = RegionDarkestColor(Source, Width, Height, Stride,

	lea	ecx, DWORD PTR _PackedResult$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _Y2$9[ebp]
	push	edx
	mov	eax, DWORD PTR _X2$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _Y1$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _X1$6[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_RegionDarkestColor@36
	mov	DWORD PTR _AnalysisResult$10[ebp], eax

; 178  :                     X1, Y1, X2, Y2, &PackedResult);
; 179  :                 if (AnalysisResult != Success)

	cmp	DWORD PTR _AnalysisResult$10[ebp], 0
	je	SHORT $LN31@SegmentBlo

; 180  :                     return AnalysisResult;

	mov	eax, DWORD PTR _AnalysisResult$10[ebp]
	jmp	$LN1@SegmentBlo
$LN31@SegmentBlo:

; 181  :                 break;

	jmp	SHORT $LN8@SegmentBlo
$LN32@SegmentBlo:

; 182  : 
; 183  :             case SegmentLuminence:
; 184  :                 AnalysisResult = RegionLuminanceValue(Source, Width, Height, Stride,

	lea	ecx, DWORD PTR _PackedResult$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _Y2$9[ebp]
	push	edx
	mov	eax, DWORD PTR _X2$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _Y1$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _X1$6[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_RegionLuminanceValue@36
	mov	DWORD PTR _AnalysisResult$10[ebp], eax

; 185  :                     X1, Y1, X2, Y2, &PackedResult);
; 186  :                 if (AnalysisResult != Success)

	cmp	DWORD PTR _AnalysisResult$10[ebp], 0
	je	SHORT $LN33@SegmentBlo

; 187  :                     return AnalysisResult;

	mov	eax, DWORD PTR _AnalysisResult$10[ebp]
	jmp	$LN1@SegmentBlo
$LN33@SegmentBlo:

; 188  :                 break;

	jmp	SHORT $LN8@SegmentBlo
$LN34@SegmentBlo:

; 189  : 
; 190  :             default:
; 191  :                 return ErrorStackPushReturn(InvalidOperation, "SegmentBlocks");

	push	OFFSET $SG110370
	push	11					; 0000000bH
	call	_ErrorStackPushReturn@8
	jmp	$LN1@SegmentBlo
$LN8@SegmentBlo:

; 192  :             }
; 193  : 
; 194  :             if (ShapeType == SegmentShapeRectangle && HighlightByLuminance)

	cmp	DWORD PTR _ShapeType$[ebp], 0
	jne	SHORT $LN35@SegmentBlo
	cmp	DWORD PTR _HighlightByLuminance$[ebp], 0
	je	SHORT $LN35@SegmentBlo

; 195  :             {
; 196  :                 SegmentDrawColorShape2(Destination, Width, Height, Stride,

	mov	ecx, DWORD PTR _DarkY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DarkX$[ebp]
	push	edx
	mov	eax, DWORD PTR _BrightY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _BrightX$[ebp]
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _DarkLum$[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _BrightLum$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _BGColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _PackedResult$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _ShapeMargin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ShapeType$[ebp]
	push	edx
	mov	eax, DWORD PTR _Y2$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _X2$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _Y1$7[ebp]
	push	edx
	mov	eax, DWORD PTR _X1$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Destination$[ebp]
	push	ecx
	call	_SegmentDrawColorShape2@80

; 197  :                     X1, Y1, X2, Y2, ShapeType, ShapeMargin, PackedResult, BGColor,
; 198  :                     BrightLum, DarkLum, BrightX, BrightY, DarkX, DarkY);
; 199  :             }
; 200  :             else

	jmp	SHORT $LN36@SegmentBlo
$LN35@SegmentBlo:

; 201  :             {
; 202  :                 SegmentDrawColorShape(Destination, Width, Height, Stride,

	mov	edx, DWORD PTR _InvertSpatially$[ebp]
	push	edx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _OverriddenTransparency$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _GradientTransparency$[ebp]
	push	eax
	mov	ecx, DWORD PTR _OverrideTransparency$[ebp]
	push	ecx
	mov	edx, DWORD PTR _BGColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _PackedResult$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _ShapeMargin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ShapeType$[ebp]
	push	edx
	mov	eax, DWORD PTR _Y2$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _X2$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _Y1$7[ebp]
	push	edx
	mov	eax, DWORD PTR _X1$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Destination$[ebp]
	push	ecx
	call	_SegmentDrawColorShape@68
$LN36@SegmentBlo:

; 203  :                     X1, Y1, X2, Y2, ShapeType, ShapeMargin, PackedResult, BGColor,
; 204  :                     OverrideTransparency, GradientTransparency, OverriddenTransparency,
; 205  :                     InvertSpatially);
; 206  :             }
; 207  :         }

	jmp	$LN5@SegmentBlo
$LN6@SegmentBlo:

; 208  :     }

	jmp	$LN2@SegmentBlo
$LN3@SegmentBlo:

; 209  : 
; 210  :     return ErrorStackPushReturn(Success, "SegmentBlocks");

	push	OFFSET $SG110373
	push	0
	call	_ErrorStackPushReturn@8
$LN1@SegmentBlo:

; 211  : }

	mov	esp, ebp
	pop	ebp
	ret	72					; 00000048H
$LN38@SegmentBlo:
	DD	$LN24@SegmentBlo
	DD	$LN26@SegmentBlo
	DD	$LN28@SegmentBlo
	DD	$LN30@SegmentBlo
	DD	$LN32@SegmentBlo
_SegmentBlocks@72 ENDP
_TEXT	ENDS
END
