; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Render.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG110252 DB	'Source is null.', 00H
$SG110253 DB	'DrawRectangle', 00H
	ORG $+2
$SG110255 DB	'Destination is null.', 00H
	ORG $+3
$SG110256 DB	'DrawRectangle', 00H
	ORG $+2
$SG110258 DB	'Left < 0', 00H
	ORG $+3
$SG110259 DB	'DrawRectangle', 00H
	ORG $+2
$SG110261 DB	'Top < 0', 00H
$SG110262 DB	'DrawRectangle', 00H
	ORG $+2
$SG110264 DB	'Right > Width - 1', 00H
	ORG $+2
$SG110265 DB	'DrawRectangle', 00H
	ORG $+2
$SG110267 DB	'Bottom > Height - 1', 00H
$SG110268 DB	'DrawRectangle', 00H
	ORG $+2
$SG110270 DB	'Left >= Right', 00H
	ORG $+2
$SG110271 DB	'DrawRectangle', 00H
	ORG $+2
$SG110273 DB	'Top >= Bottom', 00H
	ORG $+2
$SG110274 DB	'DrawRectangle', 00H
	ORG $+2
$SG110285 DB	'Destination is null.', 00H
	ORG $+3
$SG110286 DB	'DrawRectangle2', 00H
	ORG $+1
$SG110288 DB	'Left < 0', 00H
	ORG $+3
$SG110289 DB	'DrawRectangle2', 00H
	ORG $+1
$SG110291 DB	'Top < 0', 00H
$SG110292 DB	'DrawRectangle2', 00H
	ORG $+1
$SG110294 DB	'Right > Width - 1', 00H
	ORG $+2
$SG110295 DB	'DrawRectangle2', 00H
	ORG $+1
$SG110297 DB	'Bottom > Height - 1', 00H
$SG110298 DB	'DrawRectangle2', 00H
	ORG $+1
$SG110300 DB	'Left >= Right', 00H
	ORG $+2
$SG110301 DB	'DrawRectangle2', 00H
	ORG $+1
$SG110303 DB	'Top >= Bottom', 00H
	ORG $+2
$SG110304 DB	'DrawRectangle2', 00H
	ORG $+1
$SG110334 DB	'DrawRectangle', 00H
	ORG $+2
$SG110361 DB	'DrawRectangle2', 00H
CONST	ENDS
PUBLIC	_DrawRectangle2_Validate@28
PUBLIC	_DrawRectangle2@32
PUBLIC	_DrawRectangle_Validate@32
PUBLIC	_DrawRectangle@36
PUBLIC	_OverlayGrid@28
PUBLIC	_DrawBlocks@28
PUBLIC	_DrawLine@40
PUBLIC	_DrawAnyLine2@44
PUBLIC	_RenderColorBlob@32
PUBLIC	_DrawHorizontalLine@36
PUBLIC	_DrawVerticalLine@36
PUBLIC	_DrawAnyLine@56
PUBLIC	?OverlayGridX@@YGHPAXHHH0HHI@Z			; OverlayGridX
PUBLIC	?DrawVerticalLine@@YGXPAEHHHHPAUPureColorType@@@Z ; DrawVerticalLine
PUBLIC	?DrawHorizontalLine@@YGXPAEHHHHPAUPureColorType@@@Z ; DrawHorizontalLine
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@406fe00000000000
EXTRN	?Distance@@YGNHHHH@Z:PROC			; Distance
EXTRN	_ErrorStackPushReturn@8:PROC
EXTRN	_ErrorStackPushReturn2@12:PROC
EXTRN	_memcpy:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_MaxValidIndex$ = -12					; size = 4
_X$1 = -8						; size = 4
_XLineIndex$2 = -4					; size = 4
_Buffer$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_ColorIndex$ = 24					; size = 4
_ColorSet$ = 28						; size = 4
?DrawHorizontalLine@@YGXPAEHHHHPAUPureColorType@@@Z PROC ; DrawHorizontalLine

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 534  :     UINT32 MaxValidIndex = ((Width * Stride) * Height) - 1;

	mov	eax, DWORD PTR _Width$[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	imul	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	mov	DWORD PTR _MaxValidIndex$[ebp], eax

; 535  :     for (int X = 0; X < Width; X++)

	mov	DWORD PTR _X$1[ebp], 0
	jmp	SHORT $LN4@DrawHorizo
$LN2@DrawHorizo:
	mov	ecx, DWORD PTR _X$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _X$1[ebp], ecx
$LN4@DrawHorizo:
	mov	edx, DWORD PTR _X$1[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN1@DrawHorizo

; 536  :     {
; 537  :         int XLineIndex = (ColorSet[ColorIndex].Y * Stride) + (X * 4);

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	eax, DWORD PTR _X$1[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _XLineIndex$2[ebp], ecx

; 538  :         if ((UINT32)(XLineIndex + 3) > MaxValidIndex)

	mov	edx, DWORD PTR _XLineIndex$2[ebp]
	add	edx, 3
	cmp	edx, DWORD PTR _MaxValidIndex$[ebp]
	jbe	SHORT $LN5@DrawHorizo

; 539  :             continue;

	jmp	SHORT $LN2@DrawHorizo
$LN5@DrawHorizo:

; 540  :         Buffer[XLineIndex + 0] = ColorSet[ColorIndex].Blue;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _XLineIndex$2[ebp]
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	al, BYTE PTR [edx+eax+11]
	mov	BYTE PTR [ecx], al

; 541  :         Buffer[XLineIndex + 1] = ColorSet[ColorIndex].Green;

	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _XLineIndex$2[ebp]
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	cl, BYTE PTR [eax+ecx+10]
	mov	BYTE PTR [edx+1], cl

; 542  :         Buffer[XLineIndex + 2] = ColorSet[ColorIndex].Red;

	imul	edx, DWORD PTR _ColorIndex$[ebp], 72
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _XLineIndex$2[ebp]
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	dl, BYTE PTR [ecx+edx+9]
	mov	BYTE PTR [eax+2], dl

; 543  :         Buffer[XLineIndex + 3] = ColorSet[ColorIndex].Alpha;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _XLineIndex$2[ebp]
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	al, BYTE PTR [edx+eax+8]
	mov	BYTE PTR [ecx+3], al

; 544  :     }

	jmp	$LN2@DrawHorizo
$LN1@DrawHorizo:

; 545  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DrawHorizontalLine@@YGXPAEHHHHPAUPureColorType@@@Z ENDP ; DrawHorizontalLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_MaxValidIndex$ = -12					; size = 4
_Y$1 = -8						; size = 4
_YLineIndex$2 = -4					; size = 4
_Buffer$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_ColorIndex$ = 24					; size = 4
_ColorSet$ = 28						; size = 4
?DrawVerticalLine@@YGXPAEHHHHPAUPureColorType@@@Z PROC	; DrawVerticalLine

; 509  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 510  :     UINT32 MaxValidIndex = ((Width * Stride) * Height) - 1;

	mov	eax, DWORD PTR _Width$[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	imul	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	mov	DWORD PTR _MaxValidIndex$[ebp], eax

; 511  :     for (int Y = 0; Y < Height; Y++)

	mov	DWORD PTR _Y$1[ebp], 0
	jmp	SHORT $LN4@DrawVertic
$LN2@DrawVertic:
	mov	ecx, DWORD PTR _Y$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _Y$1[ebp], ecx
$LN4@DrawVertic:
	mov	edx, DWORD PTR _Y$1[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN1@DrawVertic

; 512  :     {
; 513  :         int YLineIndex = (Y * Stride) + (ColorSet[ColorIndex].X * 4);

	mov	eax, DWORD PTR _Y$1[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _YLineIndex$2[ebp], edx

; 514  :         if ((UINT32)(YLineIndex + 3) > MaxValidIndex)

	mov	eax, DWORD PTR _YLineIndex$2[ebp]
	add	eax, 3
	cmp	eax, DWORD PTR _MaxValidIndex$[ebp]
	jbe	SHORT $LN5@DrawVertic

; 515  :             continue;

	jmp	SHORT $LN2@DrawVertic
$LN5@DrawVertic:

; 516  :         Buffer[YLineIndex + 0] = ColorSet[ColorIndex].Blue;

	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _YLineIndex$2[ebp]
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	cl, BYTE PTR [eax+ecx+11]
	mov	BYTE PTR [edx], cl

; 517  :         Buffer[YLineIndex + 1] = ColorSet[ColorIndex].Green;

	imul	edx, DWORD PTR _ColorIndex$[ebp], 72
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _YLineIndex$2[ebp]
	mov	ecx, DWORD PTR _ColorSet$[ebp]
	mov	dl, BYTE PTR [ecx+edx+10]
	mov	BYTE PTR [eax+1], dl

; 518  :         Buffer[YLineIndex + 2] = ColorSet[ColorIndex].Red;

	imul	eax, DWORD PTR _ColorIndex$[ebp], 72
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _YLineIndex$2[ebp]
	mov	edx, DWORD PTR _ColorSet$[ebp]
	mov	al, BYTE PTR [edx+eax+9]
	mov	BYTE PTR [ecx+2], al

; 519  :         Buffer[YLineIndex + 3] = ColorSet[ColorIndex].Alpha;

	imul	ecx, DWORD PTR _ColorIndex$[ebp], 72
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _YLineIndex$2[ebp]
	mov	eax, DWORD PTR _ColorSet$[ebp]
	mov	cl, BYTE PTR [eax+ecx+8]
	mov	BYTE PTR [edx+3], cl

; 520  :     }

	jmp	$LN2@DrawVertic
$LN1@DrawVertic:

; 521  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DrawVerticalLine@@YGXPAEHHHHPAUPureColorType@@@Z ENDP	; DrawVerticalLine
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Src$ = -24						; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Dest$ = -12						; size = 4
_Index$4 = -8						; size = 4
_grA$ = -4						; size = 1
_grR$ = -3						; size = 1
_grG$ = -2						; size = 1
_grB$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_HorizontalFrequency$ = 28				; size = 4
_VerticalFrequency$ = 32				; size = 4
_GridColor$ = 36					; size = 4
?OverlayGridX@@YGHPAXHHH0HHI@Z PROC			; OverlayGridX

; 13   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 14   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@OverlayGri

; 15   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@OverlayGri
$LN8@OverlayGri:

; 16   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@OverlayGri

; 17   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@OverlayGri
$LN9@OverlayGri:

; 18   : 
; 19   :     BYTE grB = (BYTE)((GridColor & 0xff000000) >> 24);

	mov	eax, DWORD PTR _GridColor$[ebp]
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	BYTE PTR _grB$[ebp], al

; 20   :     BYTE grG = (BYTE)((GridColor & 0x00ff0000) >> 16);

	mov	ecx, DWORD PTR _GridColor$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR _grG$[ebp], cl

; 21   :     BYTE grR = (BYTE)((GridColor & 0x0000ff00) >> 8);

	mov	edx, DWORD PTR _GridColor$[ebp]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _grR$[ebp], dl

; 22   :     BYTE grA = (BYTE)((GridColor & 0x000000ff) >> 0);

	mov	eax, DWORD PTR _GridColor$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _grA$[ebp], al

; 23   : 
; 24   :     BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 25   :     BYTE *Dest = (BYTE *)Destination;

	mov	edx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], edx

; 26   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 27   : 
; 28   :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@OverlayGri
$LN2@OverlayGri:
	mov	eax, DWORD PTR _Row$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$3[ebp], eax
$LN4@OverlayGri:
	mov	ecx, DWORD PTR _Row$3[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN3@OverlayGri

; 29   :     {
; 30   :         int RowOffset = Row * Width;

	mov	edx, DWORD PTR _Row$3[ebp]
	imul	edx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 31   :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@OverlayGri
$LN5@OverlayGri:
	mov	eax, DWORD PTR _Column$2[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$2[ebp], eax
$LN7@OverlayGri:
	mov	ecx, DWORD PTR _Column$2[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	$LN6@OverlayGri

; 32   :         {
; 33   :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$2[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], edx

; 34   :             if (
; 35   :                 (Row % VerticalFrequency == 0) ||

	mov	eax, DWORD PTR _Row$3[ebp]
	cdq
	idiv	DWORD PTR _VerticalFrequency$[ebp]
	test	edx, edx
	je	SHORT $LN11@OverlayGri
	mov	eax, DWORD PTR _Column$2[ebp]
	cdq
	idiv	DWORD PTR _HorizontalFrequency$[ebp]
	test	edx, edx
	jne	SHORT $LN10@OverlayGri
$LN11@OverlayGri:

; 36   :                 (Column % HorizontalFrequency == 0)
; 37   :                 )
; 38   :             {
; 39   :                 Dest[Index + 0] = grB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _grB$[ebp]
	mov	BYTE PTR [eax], cl

; 40   :                 Dest[Index + 1] = grG;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _grG$[ebp]
	mov	BYTE PTR [edx+1], al

; 41   :                 Dest[Index + 2] = grR;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _grR$[ebp]
	mov	BYTE PTR [ecx+2], dl

; 42   :                 Dest[Index + 3] = grA;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _grA$[ebp]
	mov	BYTE PTR [eax+3], cl

; 43   :                 continue;

	jmp	SHORT $LN5@OverlayGri
$LN10@OverlayGri:

; 44   :             }
; 45   :             Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 46   :             Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 47   :             Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 48   :             Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 49   :         }

	jmp	$LN5@OverlayGri
$LN6@OverlayGri:

; 50   :     }

	jmp	$LN2@OverlayGri
$LN3@OverlayGri:

; 51   : 
; 52   :     return Success;

	xor	eax, eax
$LN1@OverlayGri:

; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?OverlayGridX@@YGHPAXHHH0HHI@Z ENDP			; OverlayGridX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_PackedColor$ = -4					; size = 4
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_X1$ = 24						; size = 4
_Y1$ = 28						; size = 4
_X2$ = 32						; size = 4
_Y2$ = 36						; size = 4
_A$ = 40						; size = 1
_R$ = 44						; size = 1
_G$ = 48						; size = 1
_B$ = 52						; size = 1
_AntiAlias$ = 56					; size = 4
_LineThickness$ = 60					; size = 4
_DrawAnyLine@56 PROC

; 396  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 397  :     UINT32 PackedColor = (A << 24) | (R << 16) | (G << 8) | (B << 0);

	movzx	eax, BYTE PTR _A$[ebp]
	shl	eax, 24					; 00000018H
	movzx	ecx, BYTE PTR _R$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	movzx	edx, BYTE PTR _G$[ebp]
	shl	edx, 8
	or	eax, edx
	movzx	ecx, BYTE PTR _B$[ebp]
	or	eax, ecx
	mov	DWORD PTR _PackedColor$[ebp], eax

; 398  :     return DrawAnyLine2(Target, TargetWidth, TargetHeight, TargetStride, X1, Y1, X2, Y2, PackedColor, AntiAlias, LineThickness);

	mov	edx, DWORD PTR _LineThickness$[ebp]
	push	edx
	mov	eax, DWORD PTR _AntiAlias$[ebp]
	push	eax
	mov	ecx, DWORD PTR _PackedColor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Y2$[ebp]
	push	edx
	mov	eax, DWORD PTR _X2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Y1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _X1$[ebp]
	push	edx
	mov	eax, DWORD PTR _TargetStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _TargetHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _TargetWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Target$[ebp]
	push	eax
	call	_DrawAnyLine2@44

; 399  : }

	mov	esp, ebp
	pop	ebp
	ret	56					; 00000038H
_DrawAnyLine@56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_Alpha$ = -28						; size = 8
_ColumnOffset$ = -20					; size = 4
_PixelSize$ = -16					; size = 4
_Index$1 = -12						; size = 4
_TargetBuffer$ = -8					; size = 4
_Row$2 = -4						; size = 4
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_X$ = 24						; size = 4
_A$ = 28						; size = 1
_R$ = 32						; size = 1
_G$ = 36						; size = 1
_B$ = 40						; size = 1
_DrawVerticalLine@36 PROC

; 464  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 465  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN5@DrawVertic

; 466  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@DrawVertic
$LN5@DrawVertic:

; 467  :     if (X < 0)

	cmp	DWORD PTR _X$[ebp], 0
	jge	SHORT $LN6@DrawVertic

; 468  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@DrawVertic
$LN6@DrawVertic:

; 469  :     if (X > TargetWidth - 1)

	mov	eax, DWORD PTR _TargetWidth$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _X$[ebp], eax
	jle	SHORT $LN7@DrawVertic

; 470  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@DrawVertic
$LN7@DrawVertic:

; 471  :     BYTE* TargetBuffer = (BYTE *)Target;

	mov	ecx, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _TargetBuffer$[ebp], ecx

; 472  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 473  :     __int32 ColumnOffset = X * PixelSize;

	mov	edx, DWORD PTR _X$[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	mov	DWORD PTR _ColumnOffset$[ebp], edx

; 474  :     double Alpha = (double)A / 255.0;

	movzx	eax, BYTE PTR _A$[ebp]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _Alpha$[ebp], xmm0

; 475  : 
; 476  :     for (__int32 Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$2[ebp], 0
	jmp	SHORT $LN4@DrawVertic
$LN2@DrawVertic:
	mov	ecx, DWORD PTR _Row$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$2[ebp], ecx
$LN4@DrawVertic:
	mov	edx, DWORD PTR _Row$2[ebp]
	cmp	edx, DWORD PTR _TargetHeight$[ebp]
	jge	SHORT $LN3@DrawVertic

; 477  :     {
; 478  :         __int32 Index = (Row * TargetStride) + ColumnOffset;

	mov	eax, DWORD PTR _Row$2[ebp]
	imul	eax, DWORD PTR _TargetStride$[ebp]
	add	eax, DWORD PTR _ColumnOffset$[ebp]
	mov	DWORD PTR _Index$1[ebp], eax

; 479  :         TargetBuffer[Index + 0] = B;

	mov	ecx, DWORD PTR _TargetBuffer$[ebp]
	add	ecx, DWORD PTR _Index$1[ebp]
	mov	dl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [ecx], dl

; 480  :         TargetBuffer[Index + 1] = G;

	mov	eax, DWORD PTR _TargetBuffer$[ebp]
	add	eax, DWORD PTR _Index$1[ebp]
	mov	cl, BYTE PTR _G$[ebp]
	mov	BYTE PTR [eax+1], cl

; 481  :         TargetBuffer[Index + 2] = R;

	mov	edx, DWORD PTR _TargetBuffer$[ebp]
	add	edx, DWORD PTR _Index$1[ebp]
	mov	al, BYTE PTR _R$[ebp]
	mov	BYTE PTR [edx+2], al

; 482  :         TargetBuffer[Index + 3] = A;

	mov	ecx, DWORD PTR _TargetBuffer$[ebp]
	add	ecx, DWORD PTR _Index$1[ebp]
	mov	dl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [ecx+3], dl

; 483  :         /*
; 484  :         double DestinationAlpha = (double) TargetBuffer[Index + 3] / 255.0;
; 485  :         BYTE FinalB = (B * (Alpha)) + (TargetBuffer[Index + 0] * (DestinationAlpha) *(255 - A));
; 486  :         BYTE FinalG = (G * (Alpha)) + (TargetBuffer[Index + 1] * (DestinationAlpha) *(255 - A));
; 487  :         BYTE FinalR = (R * (Alpha)) + (TargetBuffer[Index + 2] * (DestinationAlpha) *(255 - A));
; 488  :         BYTE FinalA = A + (TargetBuffer[Index + 3] * (255 - A));
; 489  :         TargetBuffer[Index + 0] = FinalB;
; 490  :         TargetBuffer[Index + 1] = FinalG;
; 491  :         TargetBuffer[Index + 2] = FinalR;
; 492  :         TargetBuffer[Index + 3] = FinalA;
; 493  :         */
; 494  :     }

	jmp	SHORT $LN2@DrawVertic
$LN3@DrawVertic:

; 495  : 
; 496  :     return TRUE;

	mov	eax, 1
$LN1@DrawVertic:

; 497  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_DrawVerticalLine@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_Alpha$ = -28						; size = 8
_RowOffset$ = -20					; size = 4
_PixelSize$ = -16					; size = 4
_Index$1 = -12						; size = 4
_TargetBuffer$ = -8					; size = 4
_Column$2 = -4						; size = 4
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_Y$ = 24						; size = 4
_A$ = 28						; size = 1
_R$ = 32						; size = 1
_G$ = 36						; size = 1
_B$ = 40						; size = 1
_DrawHorizontalLine@36 PROC

; 415  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 416  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN5@DrawHorizo

; 417  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@DrawHorizo
$LN5@DrawHorizo:

; 418  :     if (Y < 0)

	cmp	DWORD PTR _Y$[ebp], 0
	jge	SHORT $LN6@DrawHorizo

; 419  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@DrawHorizo
$LN6@DrawHorizo:

; 420  :     if (Y > TargetHeight - 1)

	mov	eax, DWORD PTR _TargetHeight$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _Y$[ebp], eax
	jle	SHORT $LN7@DrawHorizo

; 421  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@DrawHorizo
$LN7@DrawHorizo:

; 422  :     BYTE* TargetBuffer = (BYTE *)Target;

	mov	ecx, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _TargetBuffer$[ebp], ecx

; 423  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 424  :     __int32 RowOffset = Y * TargetStride;

	mov	edx, DWORD PTR _Y$[ebp]
	imul	edx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowOffset$[ebp], edx

; 425  :     double Alpha = (double)A / 255.0;

	movzx	eax, BYTE PTR _A$[ebp]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _Alpha$[ebp], xmm0

; 426  : 
; 427  :     for (__int32 Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN4@DrawHorizo
$LN2@DrawHorizo:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN4@DrawHorizo:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _TargetWidth$[ebp]
	jge	SHORT $LN3@DrawHorizo

; 428  :     {
; 429  :         __int32 Index = RowOffset + (Column * PixelSize);

	mov	eax, DWORD PTR _Column$2[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$[ebp]
	mov	DWORD PTR _Index$1[ebp], eax

; 430  :         TargetBuffer[Index + 0] = B;

	mov	ecx, DWORD PTR _TargetBuffer$[ebp]
	add	ecx, DWORD PTR _Index$1[ebp]
	mov	dl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [ecx], dl

; 431  :         TargetBuffer[Index + 1] = G;

	mov	eax, DWORD PTR _TargetBuffer$[ebp]
	add	eax, DWORD PTR _Index$1[ebp]
	mov	cl, BYTE PTR _G$[ebp]
	mov	BYTE PTR [eax+1], cl

; 432  :         TargetBuffer[Index + 2] = R;

	mov	edx, DWORD PTR _TargetBuffer$[ebp]
	add	edx, DWORD PTR _Index$1[ebp]
	mov	al, BYTE PTR _R$[ebp]
	mov	BYTE PTR [edx+2], al

; 433  :         TargetBuffer[Index + 3] = A;

	mov	ecx, DWORD PTR _TargetBuffer$[ebp]
	add	ecx, DWORD PTR _Index$1[ebp]
	mov	dl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [ecx+3], dl

; 434  :         /*
; 435  :         double DestinationAlpha = (double) TargetBuffer[Index + 3] / 255.0;
; 436  :         BYTE FinalB = (B * (Alpha)) + (TargetBuffer[Index + 0] * (DestinationAlpha) *(255 - A));
; 437  :         BYTE FinalG = (G * (Alpha)) + (TargetBuffer[Index + 1] * (DestinationAlpha) *(255 - A));
; 438  :         BYTE FinalR = (R * (Alpha)) + (TargetBuffer[Index + 2] * (DestinationAlpha) *(255 - A));
; 439  :         BYTE FinalA = A + (TargetBuffer[Index + 3] * (255 - A));
; 440  :         TargetBuffer[Index + 0] = FinalB;
; 441  :         TargetBuffer[Index + 1] = FinalG;
; 442  :         TargetBuffer[Index + 2] = FinalR;
; 443  :         TargetBuffer[Index + 3] = FinalA;
; 444  :         */
; 445  :     }

	jmp	SHORT $LN2@DrawHorizo
$LN3@DrawHorizo:

; 446  : 
; 447  :     return TRUE;

	mov	eax, 1
$LN1@DrawHorizo:

; 448  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_DrawHorizontalLine@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_Dist$1 = -76						; size = 8
_Percent$2 = -68					; size = 8
_AlphaDirection$ = -60					; size = 4
_CenterX$ = -56						; size = 4
_CenterY$ = -52						; size = 4
_RowOffset$3 = -48					; size = 4
_PixelSize$ = -44					; size = 4
_Radius$ = -40						; size = 4
tv70 = -36						; size = 4
_AlphaDelta$ = -32					; size = 4
_Column$4 = -28						; size = 4
_Row$5 = -24						; size = 4
_Index$6 = -20						; size = 4
_Buffer$ = -16						; size = 4
_iR$7 = -11						; size = 1
_iG$8 = -10						; size = 1
_iB$9 = -9						; size = 1
_CenterBlue$ = -8					; size = 1
_CenterGreen$ = -7					; size = 1
_CenterRed$ = -6					; size = 1
_EdgeR$ = -5						; size = 1
_EdgeG$ = -4						; size = 1
_EdgeB$ = -3						; size = 1
_EdgeA$ = -2						; size = 1
_iA$10 = -1						; size = 1
_Target$ = 8						; size = 4
_ImageWidth$ = 12					; size = 4
_ImageHeight$ = 16					; size = 4
_ImageStride$ = 20					; size = 4
_BlobColor$ = 24					; size = 4
_CenterAlpha$ = 28					; size = 1
_EdgeAlpha$ = 32					; size = 1
_EdgeColor$ = 36					; size = 4
_RenderColorBlob@32 PROC

; 563  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 564  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@RenderColo

; 565  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderColo
$LN8@RenderColo:

; 566  :     __int32 PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 567  :     BYTE* Buffer = (BYTE*)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 568  :     //UINT32 MaxValidIndex = ((ImageWidth * ImageStride) * ImageHeight) - 1;
; 569  :     int Radius = ImageWidth / 2;

	mov	eax, DWORD PTR _ImageWidth$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _Radius$[ebp], eax

; 570  :     int AlphaDelta = (CenterAlpha - EdgeAlpha);

	movzx	ecx, BYTE PTR _CenterAlpha$[ebp]
	movzx	edx, BYTE PTR _EdgeAlpha$[ebp]
	sub	ecx, edx
	mov	DWORD PTR _AlphaDelta$[ebp], ecx

; 571  :     int AlphaDirection = AlphaDelta >= 0 ? 1 : -1;

	js	SHORT $LN19@RenderColo
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN20@RenderColo
$LN19@RenderColo:
	mov	DWORD PTR tv70[ebp], -1
$LN20@RenderColo:
	mov	eax, DWORD PTR tv70[ebp]
	mov	DWORD PTR _AlphaDirection$[ebp], eax

; 572  :     AlphaDelta = abs(AlphaDelta);

	mov	eax, DWORD PTR _AlphaDelta$[ebp]
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _AlphaDelta$[ebp], eax

; 573  :     __int32 CenterX = ImageWidth / 2;

	mov	eax, DWORD PTR _ImageWidth$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _CenterX$[ebp], eax

; 574  :     __int32 CenterY = ImageHeight / 2;

	mov	eax, DWORD PTR _ImageHeight$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _CenterY$[ebp], eax

; 575  :     BYTE EdgeB = (BYTE)((EdgeColor & 0xff000000) >> 24);

	mov	ecx, DWORD PTR _EdgeColor$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _EdgeB$[ebp], cl

; 576  :     BYTE EdgeG = (BYTE)((EdgeColor & 0x00ff0000) >> 16);

	mov	edx, DWORD PTR _EdgeColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _EdgeG$[ebp], dl

; 577  :     BYTE EdgeR = (BYTE)((EdgeColor & 0x0000ff00) >> 8);

	mov	eax, DWORD PTR _EdgeColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _EdgeR$[ebp], al

; 578  :     BYTE EdgeA = (BYTE)((EdgeColor & 0x000000ff) >> 0);

	mov	ecx, DWORD PTR _EdgeColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _EdgeA$[ebp], cl

; 579  :     BYTE CenterBlue = (BYTE)((BlobColor & 0xff000000) >> 24);

	mov	edx, DWORD PTR _BlobColor$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _CenterBlue$[ebp], dl

; 580  :     BYTE CenterGreen = (BYTE)((BlobColor & 0x00ff0000) >> 16);

	mov	eax, DWORD PTR _BlobColor$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _CenterGreen$[ebp], al

; 581  :     BYTE CenterRed = (BYTE)((BlobColor & 0x0000ff00) >> 8);

	mov	ecx, DWORD PTR _BlobColor$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _CenterRed$[ebp], cl

; 582  : 
; 583  :     for (__int32 Row = 0; Row < ImageHeight; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN4@RenderColo
$LN2@RenderColo:
	mov	edx, DWORD PTR _Row$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$5[ebp], edx
$LN4@RenderColo:
	mov	eax, DWORD PTR _Row$5[ebp]
	cmp	eax, DWORD PTR _ImageHeight$[ebp]
	jge	$LN3@RenderColo

; 584  :     {
; 585  :         __int32 RowOffset = Row * ImageStride;

	mov	ecx, DWORD PTR _Row$5[ebp]
	imul	ecx, DWORD PTR _ImageStride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], ecx

; 586  :         for (__int32 Column = 0; Column < ImageWidth; Column++)

	mov	DWORD PTR _Column$4[ebp], 0
	jmp	SHORT $LN7@RenderColo
$LN5@RenderColo:
	mov	edx, DWORD PTR _Column$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$4[ebp], edx
$LN7@RenderColo:
	mov	eax, DWORD PTR _Column$4[ebp]
	cmp	eax, DWORD PTR _ImageWidth$[ebp]
	jge	$LN6@RenderColo

; 587  :         {
; 588  :             __int32 Index = RowOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$4[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$6[ebp], ecx

; 589  :             //            if ((UINT32)(Index + PixelSize) > MaxValidIndex)
; 590  :             //                return BadIndex;
; 591  : 
; 592  :             if (EdgeA > 0x0)

	movzx	edx, BYTE PTR _EdgeA$[ebp]
	test	edx, edx
	jle	SHORT $LN10@RenderColo

; 593  :             {
; 594  :                 if (
; 595  :                     (Row == 0) || (Row == ImageHeight - 1) || (Column == 0) || (Column == ImageWidth - 1)

	cmp	DWORD PTR _Row$5[ebp], 0
	je	SHORT $LN11@RenderColo
	mov	eax, DWORD PTR _ImageHeight$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _Row$5[ebp], eax
	je	SHORT $LN11@RenderColo
	cmp	DWORD PTR _Column$4[ebp], 0
	je	SHORT $LN11@RenderColo
	mov	ecx, DWORD PTR _ImageWidth$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Column$4[ebp], ecx
	jne	SHORT $LN10@RenderColo
$LN11@RenderColo:

; 596  :                     )
; 597  :                 {
; 598  :                     Buffer[Index + 0] = EdgeB;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _EdgeB$[ebp]
	mov	BYTE PTR [edx], al

; 599  :                     Buffer[Index + 1] = EdgeG;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _EdgeG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 600  :                     Buffer[Index + 2] = EdgeR;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _EdgeR$[ebp]
	mov	BYTE PTR [eax+2], cl

; 601  :                     Buffer[Index + 3] = EdgeA;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _EdgeA$[ebp]
	mov	BYTE PTR [edx+3], al

; 602  :                     continue;

	jmp	SHORT $LN5@RenderColo
$LN10@RenderColo:

; 603  :                 }
; 604  :             }
; 605  : 
; 606  :             byte iR = CenterRed;

	mov	cl, BYTE PTR _CenterRed$[ebp]
	mov	BYTE PTR _iR$7[ebp], cl

; 607  :             byte iG = CenterGreen;

	mov	dl, BYTE PTR _CenterGreen$[ebp]
	mov	BYTE PTR _iG$8[ebp], dl

; 608  :             byte iB = CenterBlue;

	mov	al, BYTE PTR _CenterBlue$[ebp]
	mov	BYTE PTR _iB$9[ebp], al

; 609  :             byte iA = 0x0;

	mov	BYTE PTR _iA$10[ebp], 0

; 610  : 
; 611  :             double Dist = Distance(Column, Row, CenterX, CenterY);

	mov	ecx, DWORD PTR _CenterY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CenterX$[ebp]
	push	edx
	mov	eax, DWORD PTR _Row$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _Column$4[ebp]
	push	ecx
	call	?Distance@@YGNHHHH@Z			; Distance
	fstp	QWORD PTR _Dist$1[ebp]

; 612  :             if (Dist > Radius)

	cvtsi2sd xmm0, DWORD PTR _Radius$[ebp]
	movsd	xmm1, QWORD PTR _Dist$1[ebp]
	comisd	xmm1, xmm0
	jbe	SHORT $LN12@RenderColo

; 613  :             {
; 614  :                 Buffer[Index + 0] = 0xff;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	BYTE PTR [edx], 255			; 000000ffH

; 615  :                 Buffer[Index + 1] = 0xff;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH

; 616  :                 Buffer[Index + 2] = 0xff;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	BYTE PTR [ecx+2], 255			; 000000ffH

; 617  :                 Buffer[Index + 3] = 0x0;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	BYTE PTR [edx+3], 0

; 618  :                 continue;

	jmp	$LN5@RenderColo
$LN12@RenderColo:

; 619  :             }
; 620  :             if (Dist == 0)

	movsd	xmm0, QWORD PTR _Dist$1[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN13@RenderColo

; 621  :                 iA = CenterAlpha;

	mov	al, BYTE PTR _CenterAlpha$[ebp]
	mov	BYTE PTR _iA$10[ebp], al

; 622  :             else

	jmp	SHORT $LN17@RenderColo
$LN13@RenderColo:

; 623  :             {
; 624  :                 double Percent = Dist / Radius;

	cvtsi2sd xmm0, DWORD PTR _Radius$[ebp]
	movsd	xmm1, QWORD PTR _Dist$1[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _Percent$2[ebp], xmm1

; 625  :                 //if (AlphaDirection == 1)
; 626  :                 Percent = 1.0 - Percent;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _Percent$2[ebp]
	movsd	QWORD PTR _Percent$2[ebp], xmm0

; 627  :                 if (Percent < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _Percent$2[ebp]
	jbe	SHORT $LN15@RenderColo

; 628  :                     Percent = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Percent$2[ebp], xmm0
$LN15@RenderColo:

; 629  :                 if (AlphaDelta == 0)

	cmp	DWORD PTR _AlphaDelta$[ebp], 0
	jne	SHORT $LN16@RenderColo

; 630  :                     iA = 0xff;

	mov	BYTE PTR _iA$10[ebp], 255		; 000000ffH

; 631  :                 else

	jmp	SHORT $LN17@RenderColo
$LN16@RenderColo:

; 632  :                     iA = (byte)(Percent * (double)AlphaDelta);

	cvtsi2sd xmm0, DWORD PTR _AlphaDelta$[ebp]
	mulsd	xmm0, QWORD PTR _Percent$2[ebp]
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _iA$10[ebp], cl
$LN17@RenderColo:

; 633  :             }
; 634  : 
; 635  :             Buffer[Index + 0] = iB;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _iB$9[ebp]
	mov	BYTE PTR [edx], al

; 636  :             Buffer[Index + 1] = iG;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _iG$8[ebp]
	mov	BYTE PTR [ecx+1], dl

; 637  :             Buffer[Index + 2] = iR;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _iR$7[ebp]
	mov	BYTE PTR [eax+2], cl

; 638  :             Buffer[Index + 3] = iA;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _iA$10[ebp]
	mov	BYTE PTR [edx+3], al

; 639  :         }

	jmp	$LN5@RenderColo
$LN6@RenderColo:

; 640  :     }

	jmp	$LN2@RenderColo
$LN3@RenderColo:

; 641  : 
; 642  :     return Success;

	xor	eax, eax
$LN1@RenderColo:

; 643  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_RenderColorBlob@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_MaxIndex$ = -40					; size = 4
_YPlot$1 = -36						; size = 4
_DeltaX$ = -32						; size = 4
_DeltaY$ = -28						; size = 4
_temp$2 = -24						; size = 4
_Buffer$ = -20						; size = 4
_XPlot$3 = -16						; size = 4
_Index$4 = -12						; size = 4
_A$ = -5						; size = 1
_R$ = -4						; size = 1
_G$ = -3						; size = 1
_B$ = -2						; size = 1
_PixelSize$ = -1					; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_X1$ = 24						; size = 4
_Y1$ = 28						; size = 4
_X2$ = 32						; size = 4
_Y2$ = 36						; size = 4
_PackedLineColor$ = 40					; size = 4
_AntiAlias$ = 44					; size = 4
_LineThickness$ = 48					; size = 4
_DrawAnyLine2@44 PROC

; 339  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 340  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN5@DrawAnyLin

; 341  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@DrawAnyLin
$LN5@DrawAnyLin:

; 342  : 
; 343  :     BYTE A = (PackedLineColor & 0xff000000) >> 24;

	mov	eax, DWORD PTR _PackedLineColor$[ebp]
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	BYTE PTR _A$[ebp], al

; 344  :     BYTE R = (PackedLineColor & 0x00ff0000) >> 16;

	mov	ecx, DWORD PTR _PackedLineColor$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR _R$[ebp], cl

; 345  :     BYTE G = (PackedLineColor & 0x0000ff00) >> 8;

	mov	edx, DWORD PTR _PackedLineColor$[ebp]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _G$[ebp], dl

; 346  :     BYTE B = (PackedLineColor & 0x000000ff) >> 0;

	mov	eax, DWORD PTR _PackedLineColor$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _B$[ebp], al

; 347  :     BYTE *Buffer = (BYTE*)Target;

	mov	ecx, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], ecx

; 348  :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 349  :     __int32 DeltaX = X2 - X1;

	mov	edx, DWORD PTR _X2$[ebp]
	sub	edx, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _DeltaX$[ebp], edx

; 350  :     __int32 DeltaY = Y2 - Y1;

	mov	eax, DWORD PTR _Y2$[ebp]
	sub	eax, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _DeltaY$[ebp], eax

; 351  :     if (X1 > X2)

	mov	ecx, DWORD PTR _X1$[ebp]
	cmp	ecx, DWORD PTR _X2$[ebp]
	jle	SHORT $LN6@DrawAnyLin

; 352  :     {
; 353  :         __int32 temp = X2;

	mov	edx, DWORD PTR _X2$[ebp]
	mov	DWORD PTR _temp$2[ebp], edx

; 354  :         X2 = X1;

	mov	eax, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _X2$[ebp], eax

; 355  :         X1 = temp;

	mov	ecx, DWORD PTR _temp$2[ebp]
	mov	DWORD PTR _X1$[ebp], ecx
$LN6@DrawAnyLin:

; 356  :     }
; 357  :     UINT32 MaxIndex = (TargetStride * TargetHeight) - 1;

	mov	edx, DWORD PTR _TargetStride$[ebp]
	imul	edx, DWORD PTR _TargetHeight$[ebp]
	sub	edx, 1
	mov	DWORD PTR _MaxIndex$[ebp], edx

; 358  : 
; 359  :     for (__int32 XPlot = X1; XPlot < X2 + 1; XPlot++)

	mov	eax, DWORD PTR _X1$[ebp]
	mov	DWORD PTR _XPlot$3[ebp], eax
	jmp	SHORT $LN4@DrawAnyLin
$LN2@DrawAnyLin:
	mov	ecx, DWORD PTR _XPlot$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _XPlot$3[ebp], ecx
$LN4@DrawAnyLin:
	mov	edx, DWORD PTR _X2$[ebp]
	add	edx, 1
	cmp	DWORD PTR _XPlot$3[ebp], edx
	jge	SHORT $LN3@DrawAnyLin

; 360  :     {
; 361  :         __int32 YPlot = Y1 + DeltaY * (XPlot - X1) / DeltaX;

	mov	eax, DWORD PTR _XPlot$3[ebp]
	sub	eax, DWORD PTR _X1$[ebp]
	imul	eax, DWORD PTR _DeltaY$[ebp]
	cdq
	idiv	DWORD PTR _DeltaX$[ebp]
	add	eax, DWORD PTR _Y1$[ebp]
	mov	DWORD PTR _YPlot$1[ebp], eax

; 362  :         __int32 Index = (YPlot - 1) * TargetStride;

	mov	ecx, DWORD PTR _YPlot$1[ebp]
	sub	ecx, 1
	imul	ecx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 363  :         Index += XPlot * PixelSize;

	movzx	edx, BYTE PTR _PixelSize$[ebp]
	imul	edx, DWORD PTR _XPlot$3[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	DWORD PTR _Index$4[ebp], edx

; 364  :         if ((UINT32)(Index + PixelSize) > MaxIndex)

	movzx	eax, BYTE PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	cmp	eax, DWORD PTR _MaxIndex$[ebp]
	jbe	SHORT $LN7@DrawAnyLin

; 365  :             continue;

	jmp	SHORT $LN2@DrawAnyLin
$LN7@DrawAnyLin:

; 366  :         Buffer[Index + 0] = B;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [ecx], dl

; 367  :         Buffer[Index + 1] = G;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _G$[ebp]
	mov	BYTE PTR [eax+1], cl

; 368  :         Buffer[Index + 2] = R;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _R$[ebp]
	mov	BYTE PTR [edx+2], al

; 369  :         Buffer[Index + 3] = A;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [ecx+3], dl

; 370  :     }

	jmp	$LN2@DrawAnyLin
$LN3@DrawAnyLin:

; 371  : 
; 372  :     return TRUE;

	mov	eax, 1
$LN1@DrawAnyLin:

; 373  : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_DrawAnyLine2@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_IsHorizontal$ = 24					; size = 4
_Coordinate$ = 28					; size = 4
_A$ = 32						; size = 1
_R$ = 36						; size = 1
_G$ = 40						; size = 1
_B$ = 44						; size = 1
_DrawLine@40 PROC

; 329  : {

	push	ebp
	mov	ebp, esp

; 330  :     if (IsHorizontal)

	cmp	DWORD PTR _IsHorizontal$[ebp], 0
	je	SHORT $LN2@DrawLine

; 331  :         return DrawHorizontalLine(Target, TargetWidth, TargetHeight, TargetStride, Coordinate, A, R, G, B);

	movzx	eax, BYTE PTR _B$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _G$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _R$[ebp]
	push	edx
	movzx	eax, BYTE PTR _A$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Coordinate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _TargetStride$[ebp]
	push	edx
	mov	eax, DWORD PTR _TargetHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _TargetWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Target$[ebp]
	push	edx
	call	_DrawHorizontalLine@36
	jmp	SHORT $LN1@DrawLine

; 332  :     else

	jmp	SHORT $LN1@DrawLine
$LN2@DrawLine:

; 333  :         return DrawVerticalLine(Target, TargetWidth, TargetHeight, TargetStride, Coordinate, A, R, G, B);

	movzx	eax, BYTE PTR _B$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _G$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _R$[ebp]
	push	edx
	movzx	eax, BYTE PTR _A$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Coordinate$[ebp]
	push	ecx
	mov	edx, DWORD PTR _TargetStride$[ebp]
	push	edx
	mov	eax, DWORD PTR _TargetHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _TargetWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Target$[ebp]
	push	edx
	call	_DrawVerticalLine@36
$LN1@DrawLine:

; 334  : }

	pop	ebp
	ret	40					; 00000028H
_DrawLine@40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_Final$1 = -88						; size = 32
_ARatio$2 = -56						; size = 8
_RowOffset$3 = -48					; size = 4
_PixelSize$ = -44					; size = 4
_OverlapCount$4 = -40					; size = 4
_Column$5 = -36						; size = 4
_Row$6 = -32						; size = 4
_Index$7 = -28						; size = 4
_Buffer$ = -24						; size = 4
_BlockIndex$8 = -20					; size = 4
_i$9 = -16						; size = 4
_BlockList$ = -12					; size = 4
_DefaultA$ = -5						; size = 1
_DefaultR$ = -4						; size = 1
_DefaultG$ = -3						; size = 1
_DefaultB$ = -2						; size = 1
_MaxAlpha$10 = -1					; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_ColorBlockList$ = 24					; size = 4
_ColorBlockCount$ = 28					; size = 4
_DefaultColor$ = 32					; size = 4
_DrawBlocks@28 PROC

; 209  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 210  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN14@DrawBlocks

; 211  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@DrawBlocks
$LN14@DrawBlocks:

; 212  :     if (ColorBlockList == NULL)

	cmp	DWORD PTR _ColorBlockList$[ebp], 0
	jne	SHORT $LN15@DrawBlocks

; 213  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@DrawBlocks
$LN15@DrawBlocks:

; 214  :     if (ColorBlockCount < 1)

	cmp	DWORD PTR _ColorBlockCount$[ebp], 1
	jge	SHORT $LN16@DrawBlocks

; 215  :         return FALSE;

	xor	eax, eax
	jmp	$LN1@DrawBlocks
$LN16@DrawBlocks:

; 216  : 
; 217  :     BYTE DefaultB = (DefaultColor & 0xff000000) >> 24;

	mov	eax, DWORD PTR _DefaultColor$[ebp]
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	BYTE PTR _DefaultB$[ebp], al

; 218  :     BYTE DefaultG = (DefaultColor & 0x00ff0000) >> 16;

	mov	ecx, DWORD PTR _DefaultColor$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR _DefaultG$[ebp], cl

; 219  :     BYTE DefaultR = (DefaultColor & 0x0000ff00) >> 8;

	mov	edx, DWORD PTR _DefaultColor$[ebp]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _DefaultR$[ebp], dl

; 220  :     BYTE DefaultA = (DefaultColor & 0x000000ff) >> 0;

	mov	eax, DWORD PTR _DefaultColor$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _DefaultA$[ebp], al

; 221  :     BYTE *Buffer = (BYTE *)Target;

	mov	ecx, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], ecx

; 222  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 223  :     ColorBlock *BlockList = (ColorBlock *)ColorBlockList;

	mov	edx, DWORD PTR _ColorBlockList$[ebp]
	mov	DWORD PTR _BlockList$[ebp], edx

; 224  :     for (int i = 0; i < ColorBlockCount; i++)

	mov	DWORD PTR _i$9[ebp], 0
	jmp	SHORT $LN4@DrawBlocks
$LN2@DrawBlocks:
	mov	eax, DWORD PTR _i$9[ebp]
	add	eax, 1
	mov	DWORD PTR _i$9[ebp], eax
$LN4@DrawBlocks:
	mov	ecx, DWORD PTR _i$9[ebp]
	cmp	ecx, DWORD PTR _ColorBlockCount$[ebp]
	jge	$LN3@DrawBlocks

; 225  :     {
; 226  :         BlockList[i].Right = BlockList[i].Left + BlockList[i].Width;

	mov	edx, DWORD PTR _i$9[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _i$9[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	mov	edx, DWORD PTR [ecx+edx]
	mov	ecx, DWORD PTR _BlockList$[ebp]
	add	edx, DWORD PTR [ecx+eax+8]
	mov	eax, DWORD PTR _i$9[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	mov	DWORD PTR [ecx+eax+16], edx

; 227  :         BlockList[i].Bottom = BlockList[i].Top + BlockList[i].Height;

	mov	edx, DWORD PTR _i$9[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _i$9[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	mov	edx, DWORD PTR [ecx+edx+4]
	mov	ecx, DWORD PTR _BlockList$[ebp]
	add	edx, DWORD PTR [ecx+eax+12]
	mov	eax, DWORD PTR _i$9[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	mov	DWORD PTR [ecx+eax+20], edx

; 228  :         BlockList[i].A = BlockList[i].BlockColor & 0xff;

	mov	edx, DWORD PTR _i$9[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _BlockList$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _i$9[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _BlockList$[ebp]
	mov	BYTE PTR [eax+edx+28], cl

; 229  :         BlockList[i].R = (BlockList[i].BlockColor & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _i$9[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _BlockList$[ebp]
	mov	eax, DWORD PTR [edx+ecx+24]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	ecx, DWORD PTR _i$9[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _BlockList$[ebp]
	mov	BYTE PTR [edx+ecx+29], al

; 230  :         BlockList[i].G = (BlockList[i].BlockColor & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _i$9[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	mov	edx, DWORD PTR [ecx+eax+24]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	eax, DWORD PTR _i$9[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	mov	BYTE PTR [ecx+eax+30], dl

; 231  :         BlockList[i].B = (BlockList[i].BlockColor & 0xff000000) >> 24;

	mov	edx, DWORD PTR _i$9[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _BlockList$[ebp]
	mov	ecx, DWORD PTR [eax+edx+24]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _i$9[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _BlockList$[ebp]
	mov	BYTE PTR [eax+edx+31], cl

; 232  :     }

	jmp	$LN2@DrawBlocks
$LN3@DrawBlocks:

; 233  : 
; 234  :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN7@DrawBlocks
$LN5@DrawBlocks:
	mov	ecx, DWORD PTR _Row$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$6[ebp], ecx
$LN7@DrawBlocks:
	mov	edx, DWORD PTR _Row$6[ebp]
	cmp	edx, DWORD PTR _TargetHeight$[ebp]
	jge	$LN6@DrawBlocks

; 235  :     {
; 236  :         int RowOffset = Row * TargetStride;

	mov	eax, DWORD PTR _Row$6[ebp]
	imul	eax, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], eax

; 237  :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN10@DrawBlocks
$LN8@DrawBlocks:
	mov	ecx, DWORD PTR _Column$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$5[ebp], ecx
$LN10@DrawBlocks:
	mov	edx, DWORD PTR _Column$5[ebp]
	cmp	edx, DWORD PTR _TargetWidth$[ebp]
	jge	$LN9@DrawBlocks

; 238  :         {
; 239  :             int Index = RowOffset + (Column * PixelSize);

	mov	eax, DWORD PTR _Column$5[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$7[ebp], eax

; 240  :             //BGRA
; 241  :             double Final[] = { 0.0, 0.0, 0.0, 0.0 };

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp+8], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp+16], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp+24], xmm0

; 242  :             int OverlapCount = 0;

	mov	DWORD PTR _OverlapCount$4[ebp], 0

; 243  :             BYTE MaxAlpha = 0x0;

	mov	BYTE PTR _MaxAlpha$10[ebp], 0

; 244  :             for (int BlockIndex = 0; BlockIndex < ColorBlockCount; BlockIndex++)

	mov	DWORD PTR _BlockIndex$8[ebp], 0
	jmp	SHORT $LN13@DrawBlocks
$LN11@DrawBlocks:
	mov	ecx, DWORD PTR _BlockIndex$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _BlockIndex$8[ebp], ecx
$LN13@DrawBlocks:
	mov	edx, DWORD PTR _BlockIndex$8[ebp]
	cmp	edx, DWORD PTR _ColorBlockCount$[ebp]
	jge	$LN12@DrawBlocks

; 245  :             {
; 246  :                 if (Row < BlockList[BlockIndex].Top)

	mov	eax, DWORD PTR _BlockIndex$8[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	mov	edx, DWORD PTR _Row$6[ebp]
	cmp	edx, DWORD PTR [ecx+eax+4]
	jge	SHORT $LN17@DrawBlocks

; 247  :                     continue;

	jmp	SHORT $LN11@DrawBlocks
$LN17@DrawBlocks:

; 248  :                 if (Row > BlockList[BlockIndex].Bottom)

	mov	eax, DWORD PTR _BlockIndex$8[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	mov	edx, DWORD PTR _Row$6[ebp]
	cmp	edx, DWORD PTR [ecx+eax+20]
	jle	SHORT $LN18@DrawBlocks

; 249  :                     continue;

	jmp	SHORT $LN11@DrawBlocks
$LN18@DrawBlocks:

; 250  :                 if (Column < BlockList[BlockIndex].Left)

	mov	eax, DWORD PTR _BlockIndex$8[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	mov	edx, DWORD PTR _Column$5[ebp]
	cmp	edx, DWORD PTR [ecx+eax]
	jge	SHORT $LN19@DrawBlocks

; 251  :                     continue;

	jmp	SHORT $LN11@DrawBlocks
$LN19@DrawBlocks:

; 252  :                 if (Column > BlockList[BlockIndex].Right)

	mov	eax, DWORD PTR _BlockIndex$8[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	mov	edx, DWORD PTR _Column$5[ebp]
	cmp	edx, DWORD PTR [ecx+eax+16]
	jle	SHORT $LN20@DrawBlocks

; 253  :                     continue;

	jmp	SHORT $LN11@DrawBlocks
$LN20@DrawBlocks:

; 254  : 
; 255  : #if TRUE
; 256  : #if TRUE
; 257  :                 double ARatio = (double)BlockList[BlockIndex].A / 255.0;

	mov	eax, DWORD PTR _BlockIndex$8[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	movzx	edx, BYTE PTR [ecx+eax+28]
	cvtsi2sd xmm0, edx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _ARatio$2[ebp], xmm0

; 258  :                 Final[0] += (double)((double)BlockList[BlockIndex].B * ARatio);

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _BlockIndex$8[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _BlockList$[ebp]
	movzx	edx, BYTE PTR [eax+edx+31]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR _ARatio$2[ebp]
	addsd	xmm0, QWORD PTR _Final$1[ebp+ecx]
	mov	eax, 8
	imul	ecx, eax, 0
	movsd	QWORD PTR _Final$1[ebp+ecx], xmm0

; 259  :                 Final[1] += (double)((double)BlockList[BlockIndex].G * ARatio);

	mov	edx, 8
	shl	edx, 0
	mov	eax, DWORD PTR _BlockIndex$8[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+30]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _ARatio$2[ebp]
	addsd	xmm0, QWORD PTR _Final$1[ebp+edx]
	mov	ecx, 8
	shl	ecx, 0
	movsd	QWORD PTR _Final$1[ebp+ecx], xmm0

; 260  :                 Final[2] += (double)((double)BlockList[BlockIndex].R * ARatio);

	mov	edx, 8
	shl	edx, 1
	mov	eax, DWORD PTR _BlockIndex$8[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _BlockList$[ebp]
	movzx	eax, BYTE PTR [ecx+eax+29]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _ARatio$2[ebp]
	addsd	xmm0, QWORD PTR _Final$1[ebp+edx]
	mov	ecx, 8
	shl	ecx, 1
	movsd	QWORD PTR _Final$1[ebp+ecx], xmm0

; 261  :                 Final[3] += (double)((double)BlockList[BlockIndex].A * ARatio);

	mov	edx, 8
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _BlockIndex$8[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _BlockList$[ebp]
	movzx	ecx, BYTE PTR [edx+ecx+28]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR _ARatio$2[ebp]
	addsd	xmm0, QWORD PTR _Final$1[ebp+eax]
	mov	edx, 8
	imul	eax, edx, 3
	movsd	QWORD PTR _Final$1[ebp+eax], xmm0

; 262  :                 if (BlockList[BlockIndex].A > MaxAlpha)

	mov	ecx, DWORD PTR _BlockIndex$8[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _BlockList$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+28]
	movzx	ecx, BYTE PTR _MaxAlpha$10[ebp]
	cmp	eax, ecx
	jle	SHORT $LN21@DrawBlocks

; 263  :                     MaxAlpha = BlockList[BlockIndex].A;

	mov	edx, DWORD PTR _BlockIndex$8[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _BlockList$[ebp]
	mov	cl, BYTE PTR [eax+edx+28]
	mov	BYTE PTR _MaxAlpha$10[ebp], cl
$LN21@DrawBlocks:

; 264  : #else
; 265  :                 Final[0] += (double)BlockList[BlockIndex].B;
; 266  :                 Final[1] += (double)BlockList[BlockIndex].G;
; 267  :                 Final[2] += (double)BlockList[BlockIndex].R;
; 268  :                 Final[3] += (double)BlockList[BlockIndex].A;
; 269  : #endif
; 270  : #else
; 271  :                 Final[0] += ((double)BlockList[BlockIndex].B / 255.0);
; 272  :                 Final[1] += ((double)BlockList[BlockIndex].G / 255.0);
; 273  :                 Final[2] += ((double)BlockList[BlockIndex].R / 255.0);
; 274  :                 Final[3] += ((double)BlockList[BlockIndex].A / 255.0);
; 275  : #endif
; 276  :                 OverlapCount++;

	mov	edx, DWORD PTR _OverlapCount$4[ebp]
	add	edx, 1
	mov	DWORD PTR _OverlapCount$4[ebp], edx

; 277  :             }

	jmp	$LN11@DrawBlocks
$LN12@DrawBlocks:

; 278  :             if (OverlapCount > 0)

	cmp	DWORD PTR _OverlapCount$4[ebp], 0
	jle	SHORT $LN22@DrawBlocks

; 279  :             {
; 280  : #if TRUE
; 281  :                 Buffer[Index + 0] = (BYTE)(Final[0] / OverlapCount);

	mov	eax, 8
	imul	ecx, eax, 0
	cvtsi2sd xmm0, DWORD PTR _OverlapCount$4[ebp]
	movsd	xmm1, QWORD PTR _Final$1[ebp+ecx]
	divsd	xmm1, xmm0
	cvttsd2si edx, xmm1
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [eax], dl

; 282  :                 Buffer[Index + 1] = (BYTE)(Final[1] / OverlapCount);

	mov	ecx, 8
	shl	ecx, 0
	cvtsi2sd xmm0, DWORD PTR _OverlapCount$4[ebp]
	movsd	xmm1, QWORD PTR _Final$1[ebp+ecx]
	divsd	xmm1, xmm0
	cvttsd2si edx, xmm1
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [eax+1], dl

; 283  :                 Buffer[Index + 2] = (BYTE)(Final[2] / OverlapCount);

	mov	ecx, 8
	shl	ecx, 1
	cvtsi2sd xmm0, DWORD PTR _OverlapCount$4[ebp]
	movsd	xmm1, QWORD PTR _Final$1[ebp+ecx]
	divsd	xmm1, xmm0
	cvttsd2si edx, xmm1
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [eax+2], dl

; 284  :                 Buffer[Index + 3] = MaxAlpha;// (BYTE)(Final[3] / OverlapCount);

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _MaxAlpha$10[ebp]
	mov	BYTE PTR [ecx+3], dl

; 285  : #else
; 286  :                 Final[0] /= OverlapCount;
; 287  :                 Final[1] /= OverlapCount;
; 288  :                 Final[2] /= OverlapCount;
; 289  :                 Final[3] /= OverlapCount;
; 290  :                 BYTE FinalB = (Final[0] * 255.0);
; 291  :                 BYTE FinalG = (Final[1] * 255.0);
; 292  :                 BYTE FinalR = (Final[2] * 255.0);
; 293  :                 BYTE FinalA = (Final[3] * 255.0);
; 294  :                 Buffer[Index + 0] = FinalB;
; 295  :                 Buffer[Index + 1] = FinalG;
; 296  :                 Buffer[Index + 2] = FinalR;
; 297  :                 Buffer[Index + 3] = FinalA;
; 298  : #endif
; 299  :             }
; 300  :             else

	jmp	SHORT $LN23@DrawBlocks
$LN22@DrawBlocks:

; 301  :             {
; 302  :                 //No blocks cover this pixel so draw the default color.
; 303  :                 Buffer[Index + 0] = DefaultB;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _DefaultB$[ebp]
	mov	BYTE PTR [eax], cl

; 304  :                 Buffer[Index + 1] = DefaultG;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _DefaultG$[ebp]
	mov	BYTE PTR [edx+1], al

; 305  :                 Buffer[Index + 2] = DefaultR;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _DefaultR$[ebp]
	mov	BYTE PTR [ecx+2], dl

; 306  :                 Buffer[Index + 3] = DefaultA;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _DefaultA$[ebp]
	mov	BYTE PTR [eax+3], cl
$LN23@DrawBlocks:

; 307  :             }
; 308  :         }

	jmp	$LN8@DrawBlocks
$LN9@DrawBlocks:

; 309  :     }

	jmp	$LN5@DrawBlocks
$LN6@DrawBlocks:

; 310  : 
; 311  :     return TRUE;

	mov	eax, 1
$LN1@DrawBlocks:

; 312  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_DrawBlocks@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_Src$ = -24						; size = 4
_RowOffset$1 = -20					; size = 4
_Dest$ = -16						; size = 4
_Index$2 = -12						; size = 4
_Column$3 = -8						; size = 4
_Row$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_HorizontalFrequency$ = 24				; size = 4
_VerticalFrequency$ = 28				; size = 4
_GridColor$ = 32					; size = 4
_OverlayGrid@28 PROC

; 164  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi

; 165  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@OverlayGri

; 166  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@OverlayGri
$LN8@OverlayGri:

; 167  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@OverlayGri

; 168  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@OverlayGri
$LN9@OverlayGri:

; 169  : 
; 170  :     UINT32 *Src = (UINT32 *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 171  :     UINT32 *Dest = (UINT32 *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 172  : 
; 173  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@OverlayGri
$LN2@OverlayGri:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@OverlayGri:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@OverlayGri

; 174  :     {
; 175  :         int RowOffset = Row * Width;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 176  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@OverlayGri
$LN5@OverlayGri:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@OverlayGri:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@OverlayGri

; 177  :         {
; 178  :             int Index = Column + RowOffset;

	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], ecx

; 179  :             if (
; 180  :                 (Row % VerticalFrequency == 0) ||

	mov	eax, DWORD PTR _Row$4[ebp]
	cdq
	idiv	DWORD PTR _VerticalFrequency$[ebp]
	test	edx, edx
	je	SHORT $LN12@OverlayGri
	mov	eax, DWORD PTR _Column$3[ebp]
	cdq
	idiv	DWORD PTR _HorizontalFrequency$[ebp]
	test	edx, edx
	jne	SHORT $LN10@OverlayGri
$LN12@OverlayGri:

; 181  :                 (Column % HorizontalFrequency == 0)
; 182  :                 )
; 183  :             {
; 184  :                 Dest[Index] = GridColor;

	mov	edx, DWORD PTR _Index$2[ebp]
	mov	eax, DWORD PTR _Dest$[ebp]
	mov	ecx, DWORD PTR _GridColor$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 185  :             }
; 186  :             else

	jmp	SHORT $LN11@OverlayGri
$LN10@OverlayGri:

; 187  :             {
; 188  :                 Dest[Index] = Src[Index];

	mov	edx, DWORD PTR _Index$2[ebp]
	mov	eax, DWORD PTR _Dest$[ebp]
	mov	ecx, DWORD PTR _Index$2[ebp]
	mov	esi, DWORD PTR _Src$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx
$LN11@OverlayGri:

; 189  :             }
; 190  :         }

	jmp	SHORT $LN5@OverlayGri
$LN6@OverlayGri:

; 191  :     }

	jmp	SHORT $LN2@OverlayGri
$LN3@OverlayGri:

; 192  : 
; 193  :     return Success;

	xor	eax, eax
$LN1@OverlayGri:

; 194  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_OverlayGrid@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_BottomIndex$1 = -36					; size = 4
_TopIndex$2 = -32					; size = 4
_RightIndex$3 = -28					; size = 4
_LeftIndex$4 = -24					; size = 4
_Src$ = -20						; size = 4
_RowOffset$5 = -16					; size = 4
_Row$6 = -12						; size = 4
_Dest$ = -8						; size = 4
_Column$7 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_Left$ = 24						; size = 4
_Top$ = 28						; size = 4
_Right$ = 32						; size = 4
_Bottom$ = 36						; size = 4
_RectangleColor$ = 40					; size = 4
_DrawRectangle@36 PROC

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 102  :     if (DrawRectangle_Validate(Source, Width, Height, Destination, Left, Top, Right, Bottom) != Success)

	mov	eax, DWORD PTR _Bottom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Top$[ebp]
	push	edx
	mov	eax, DWORD PTR _Left$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Destination$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_DrawRectangle_Validate@32
	test	eax, eax
	je	SHORT $LN8@DrawRectan

; 103  :         return FailedParameterValidation;

	mov	eax, 27					; 0000001bH
	jmp	$LN1@DrawRectan
$LN8@DrawRectan:

; 104  : 
; 105  :     UINT32 *Src = (UINT32 *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], edx

; 106  :     UINT32 *Dest = (UINT32 *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 107  : 
; 108  :     memcpy(Dest, Src, Width * Height * 4);

	mov	ecx, DWORD PTR _Width$[ebp]
	imul	ecx, DWORD PTR _Height$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _Src$[ebp]
	push	edx
	mov	eax, DWORD PTR _Dest$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 109  : 
; 110  :     //Draw the vertical lines first.
; 111  :     for (int Row = Top; Row <= Bottom; Row++)

	mov	ecx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$6[ebp], ecx
	jmp	SHORT $LN4@DrawRectan
$LN2@DrawRectan:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@DrawRectan:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN3@DrawRectan

; 112  :     {
; 113  :         int RowOffset = Row * Width;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$5[ebp], ecx

; 114  :         int LeftIndex = Left + RowOffset;

	mov	edx, DWORD PTR _Left$[ebp]
	add	edx, DWORD PTR _RowOffset$5[ebp]
	mov	DWORD PTR _LeftIndex$4[ebp], edx

; 115  :         Dest[LeftIndex] = RectangleColor;

	mov	eax, DWORD PTR _LeftIndex$4[ebp]
	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	edx, DWORD PTR _RectangleColor$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 116  :         int RightIndex = Right + RowOffset;

	mov	eax, DWORD PTR _Right$[ebp]
	add	eax, DWORD PTR _RowOffset$5[ebp]
	mov	DWORD PTR _RightIndex$3[ebp], eax

; 117  :         Dest[RightIndex] = RectangleColor;

	mov	ecx, DWORD PTR _RightIndex$3[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _RectangleColor$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 118  :     }

	jmp	SHORT $LN2@DrawRectan
$LN3@DrawRectan:

; 119  : 
; 120  :     //Draw the horizontal lines next.
; 121  :     for (int Column = Left; Column <= Right; Column++)

	mov	ecx, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$7[ebp], ecx
	jmp	SHORT $LN7@DrawRectan
$LN5@DrawRectan:
	mov	edx, DWORD PTR _Column$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$7[ebp], edx
$LN7@DrawRectan:
	mov	eax, DWORD PTR _Column$7[ebp]
	cmp	eax, DWORD PTR _Right$[ebp]
	jg	SHORT $LN6@DrawRectan

; 122  :     {
; 123  :         int TopIndex = (Top * Width) + Column;

	mov	ecx, DWORD PTR _Top$[ebp]
	imul	ecx, DWORD PTR _Width$[ebp]
	add	ecx, DWORD PTR _Column$7[ebp]
	mov	DWORD PTR _TopIndex$2[ebp], ecx

; 124  :         int BottomIndex = (Bottom * Width) + Column;

	mov	edx, DWORD PTR _Bottom$[ebp]
	imul	edx, DWORD PTR _Width$[ebp]
	add	edx, DWORD PTR _Column$7[ebp]
	mov	DWORD PTR _BottomIndex$1[ebp], edx

; 125  :         Dest[TopIndex] = RectangleColor;

	mov	eax, DWORD PTR _TopIndex$2[ebp]
	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	edx, DWORD PTR _RectangleColor$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 126  :         Dest[BottomIndex] = RectangleColor;

	mov	eax, DWORD PTR _BottomIndex$1[ebp]
	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	edx, DWORD PTR _RectangleColor$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 127  :     }

	jmp	SHORT $LN5@DrawRectan
$LN6@DrawRectan:

; 128  : 
; 129  :     return ErrorStackPushReturn(Success, "DrawRectangle");

	push	OFFSET $SG110334
	push	0
	call	_ErrorStackPushReturn@8
$LN1@DrawRectan:

; 130  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_DrawRectangle@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Destination$ = 20					; size = 4
_Left$ = 24						; size = 4
_Top$ = 28						; size = 4
_Right$ = 32						; size = 4
_Bottom$ = 36						; size = 4
_DrawRectangle_Validate@32 PROC

; 57   : {

	push	ebp
	mov	ebp, esp

; 58   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@DrawRectan

; 59   :         ErrorStackPushReturn2(NullPointer, "DrawRectangle", "Source is null.");

	push	OFFSET $SG110252
	push	OFFSET $SG110253
	push	3
	call	_ErrorStackPushReturn2@12
$LN2@DrawRectan:

; 60   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN3@DrawRectan

; 61   :         ErrorStackPushReturn2(NullPointer, "DrawRectangle", "Destination is null.");

	push	OFFSET $SG110255
	push	OFFSET $SG110256
	push	3
	call	_ErrorStackPushReturn2@12
$LN3@DrawRectan:

; 62   : 
; 63   :     if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN4@DrawRectan

; 64   :         ErrorStackPushReturn2(IndexOutOfRange, "DrawRectangle", "Left < 0");

	push	OFFSET $SG110258
	push	OFFSET $SG110259
	push	6
	call	_ErrorStackPushReturn2@12
$LN4@DrawRectan:

; 65   :     if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN5@DrawRectan

; 66   :         ErrorStackPushReturn2(IndexOutOfRange, "DrawRectangle", "Top < 0");

	push	OFFSET $SG110261
	push	OFFSET $SG110262
	push	6
	call	_ErrorStackPushReturn2@12
$LN5@DrawRectan:

; 67   :     if (Right > Width - 1)

	mov	eax, DWORD PTR _Width$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _Right$[ebp], eax
	jle	SHORT $LN6@DrawRectan

; 68   :         ErrorStackPushReturn2(IndexOutOfRange, "DrawRectangle", "Right > Width - 1");

	push	OFFSET $SG110264
	push	OFFSET $SG110265
	push	6
	call	_ErrorStackPushReturn2@12
$LN6@DrawRectan:

; 69   :     if (Bottom > Height - 1)

	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Bottom$[ebp], ecx
	jle	SHORT $LN7@DrawRectan

; 70   :         ErrorStackPushReturn2(IndexOutOfRange, "DrawRectangle", "Bottom > Height - 1");

	push	OFFSET $SG110267
	push	OFFSET $SG110268
	push	6
	call	_ErrorStackPushReturn2@12
$LN7@DrawRectan:

; 71   :     if (Left >= Right)

	mov	edx, DWORD PTR _Left$[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jl	SHORT $LN8@DrawRectan

; 72   :         ErrorStackPushReturn2(ComputedIndexOutOfRange, "DrawRectangle", "Left >= Right");

	push	OFFSET $SG110270
	push	OFFSET $SG110271
	push	19					; 00000013H
	call	_ErrorStackPushReturn2@12
$LN8@DrawRectan:

; 73   :     if (Top >= Bottom)

	mov	eax, DWORD PTR _Top$[ebp]
	cmp	eax, DWORD PTR _Bottom$[ebp]
	jl	SHORT $LN9@DrawRectan

; 74   :         ErrorStackPushReturn2(ComputedIndexOutOfRange, "DrawRectangle", "Top >= Bottom");

	push	OFFSET $SG110273
	push	OFFSET $SG110274
	push	19					; 00000013H
	call	_ErrorStackPushReturn2@12
$LN9@DrawRectan:

; 75   :     return Success;

	xor	eax, eax

; 76   : }

	pop	ebp
	ret	32					; 00000020H
_DrawRectangle_Validate@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_BottomIndex$1 = -32					; size = 4
_TopIndex$2 = -28					; size = 4
_RightIndex$3 = -24					; size = 4
_LeftIndex$4 = -20					; size = 4
_RowOffset$5 = -16					; size = 4
_Dest$ = -12						; size = 4
_Row$6 = -8						; size = 4
_Column$7 = -4						; size = 4
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Left$ = 20						; size = 4
_Top$ = 24						; size = 4
_Right$ = 28						; size = 4
_Bottom$ = 32						; size = 4
_RectangleColor$ = 36					; size = 4
_DrawRectangle2@32 PROC

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 135  :     if (DrawRectangle2_Validate(Destination, Width, Height, Left, Top, Right, Bottom) != Success)

	mov	eax, DWORD PTR _Bottom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Right$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Top$[ebp]
	push	edx
	mov	eax, DWORD PTR _Left$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	call	_DrawRectangle2_Validate@28
	test	eax, eax
	je	SHORT $LN8@DrawRectan

; 136  :         return FailedParameterValidation;

	mov	eax, 27					; 0000001bH
	jmp	$LN1@DrawRectan
$LN8@DrawRectan:

; 137  : 
; 138  :     UINT32 *Dest = (UINT32 *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 139  : 
; 140  :     //Draw the vertical lines first.
; 141  :     for (int Row = Top; Row <= Bottom; Row++)

	mov	edx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$6[ebp], edx
	jmp	SHORT $LN4@DrawRectan
$LN2@DrawRectan:
	mov	eax, DWORD PTR _Row$6[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$6[ebp], eax
$LN4@DrawRectan:
	mov	ecx, DWORD PTR _Row$6[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN3@DrawRectan

; 142  :     {
; 143  :         int RowOffset = Row * Width;

	mov	edx, DWORD PTR _Row$6[ebp]
	imul	edx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$5[ebp], edx

; 144  :         int LeftIndex = Left + RowOffset;

	mov	eax, DWORD PTR _Left$[ebp]
	add	eax, DWORD PTR _RowOffset$5[ebp]
	mov	DWORD PTR _LeftIndex$4[ebp], eax

; 145  :         Dest[LeftIndex] = RectangleColor;

	mov	ecx, DWORD PTR _LeftIndex$4[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _RectangleColor$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 146  :         int RightIndex = Right + RowOffset;

	mov	ecx, DWORD PTR _Right$[ebp]
	add	ecx, DWORD PTR _RowOffset$5[ebp]
	mov	DWORD PTR _RightIndex$3[ebp], ecx

; 147  :         Dest[RightIndex] = RectangleColor;

	mov	edx, DWORD PTR _RightIndex$3[ebp]
	mov	eax, DWORD PTR _Dest$[ebp]
	mov	ecx, DWORD PTR _RectangleColor$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 148  :     }

	jmp	SHORT $LN2@DrawRectan
$LN3@DrawRectan:

; 149  : 
; 150  :     //Draw the horizontal lines next.
; 151  :     for (int Column = Left; Column <= Right; Column++)

	mov	edx, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$7[ebp], edx
	jmp	SHORT $LN7@DrawRectan
$LN5@DrawRectan:
	mov	eax, DWORD PTR _Column$7[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$7[ebp], eax
$LN7@DrawRectan:
	mov	ecx, DWORD PTR _Column$7[ebp]
	cmp	ecx, DWORD PTR _Right$[ebp]
	jg	SHORT $LN6@DrawRectan

; 152  :     {
; 153  :         int TopIndex = (Top * Width) + Column;

	mov	edx, DWORD PTR _Top$[ebp]
	imul	edx, DWORD PTR _Width$[ebp]
	add	edx, DWORD PTR _Column$7[ebp]
	mov	DWORD PTR _TopIndex$2[ebp], edx

; 154  :         int BottomIndex = (Bottom * Width) + Column;

	mov	eax, DWORD PTR _Bottom$[ebp]
	imul	eax, DWORD PTR _Width$[ebp]
	add	eax, DWORD PTR _Column$7[ebp]
	mov	DWORD PTR _BottomIndex$1[ebp], eax

; 155  :         Dest[TopIndex] = RectangleColor;

	mov	ecx, DWORD PTR _TopIndex$2[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _RectangleColor$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 156  :         Dest[BottomIndex] = RectangleColor;

	mov	ecx, DWORD PTR _BottomIndex$1[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _RectangleColor$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 157  :     }

	jmp	SHORT $LN5@DrawRectan
$LN6@DrawRectan:

; 158  : 
; 159  :     return ErrorStackPushReturn(Success, "DrawRectangle2");

	push	OFFSET $SG110361
	push	0
	call	_ErrorStackPushReturn@8
$LN1@DrawRectan:

; 160  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_DrawRectangle2@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\render.cpp
_TEXT	SEGMENT
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Left$ = 20						; size = 4
_Top$ = 24						; size = 4
_Right$ = 28						; size = 4
_Bottom$ = 32						; size = 4
_DrawRectangle2_Validate@28 PROC

; 80   : {

	push	ebp
	mov	ebp, esp

; 81   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN2@DrawRectan

; 82   :         ErrorStackPushReturn2(NullPointer, "DrawRectangle2", "Destination is null.");

	push	OFFSET $SG110285
	push	OFFSET $SG110286
	push	3
	call	_ErrorStackPushReturn2@12
$LN2@DrawRectan:

; 83   : 
; 84   :     if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN3@DrawRectan

; 85   :         ErrorStackPushReturn2(IndexOutOfRange, "DrawRectangle2", "Left < 0");

	push	OFFSET $SG110288
	push	OFFSET $SG110289
	push	6
	call	_ErrorStackPushReturn2@12
$LN3@DrawRectan:

; 86   :     if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN4@DrawRectan

; 87   :         ErrorStackPushReturn2(IndexOutOfRange, "DrawRectangle2", "Top < 0");

	push	OFFSET $SG110291
	push	OFFSET $SG110292
	push	6
	call	_ErrorStackPushReturn2@12
$LN4@DrawRectan:

; 88   :     if (Right > Width - 1)

	mov	eax, DWORD PTR _Width$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _Right$[ebp], eax
	jle	SHORT $LN5@DrawRectan

; 89   :         ErrorStackPushReturn2(IndexOutOfRange, "DrawRectangle2", "Right > Width - 1");

	push	OFFSET $SG110294
	push	OFFSET $SG110295
	push	6
	call	_ErrorStackPushReturn2@12
$LN5@DrawRectan:

; 90   :     if (Bottom > Height - 1)

	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Bottom$[ebp], ecx
	jle	SHORT $LN6@DrawRectan

; 91   :         ErrorStackPushReturn2(IndexOutOfRange, "DrawRectangle2", "Bottom > Height - 1");

	push	OFFSET $SG110297
	push	OFFSET $SG110298
	push	6
	call	_ErrorStackPushReturn2@12
$LN6@DrawRectan:

; 92   :     if (Left >= Right)

	mov	edx, DWORD PTR _Left$[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jl	SHORT $LN7@DrawRectan

; 93   :         ErrorStackPushReturn2(ComputedIndexOutOfRange, "DrawRectangle2", "Left >= Right");

	push	OFFSET $SG110300
	push	OFFSET $SG110301
	push	19					; 00000013H
	call	_ErrorStackPushReturn2@12
$LN7@DrawRectan:

; 94   :     if (Top >= Bottom)

	mov	eax, DWORD PTR _Top$[ebp]
	cmp	eax, DWORD PTR _Bottom$[ebp]
	jl	SHORT $LN8@DrawRectan

; 95   :         ErrorStackPushReturn2(ComputedIndexOutOfRange, "DrawRectangle2", "Top >= Bottom");

	push	OFFSET $SG110303
	push	OFFSET $SG110304
	push	19					; 00000013H
	call	_ErrorStackPushReturn2@12
$LN8@DrawRectan:

; 96   :     return Success;

	xor	eax, eax

; 97   : }

	pop	ebp
	ret	28					; 0000001cH
_DrawRectangle2_Validate@28 ENDP
_TEXT	ENDS
END
