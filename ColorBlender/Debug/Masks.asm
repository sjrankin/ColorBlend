; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Masks.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_AlphaSolarize@28
PUBLIC	_AlphaMaskImage@24
PUBLIC	_MaskByColor@32
PUBLIC	_AlphaFromLuminance@24
PUBLIC	_MaskImageFromImageLuminance@36
PUBLIC	_ConditionalAlphaFromLuminance@36
PUBLIC	_SetAlphaChannel@24
PUBLIC	_SetAlphaChannelInPlace@20
PUBLIC	_ActionByFrequency@68
PUBLIC	?ApplyAlphaFromImage@@YGHPAX0HHH0@Z		; ApplyAlphaFromImage
PUBLIC	__real@3fb27bb2fec56d5d
PUBLIC	__real@3fcb367a0f9096bc
PUBLIC	__real@3fe6e2eb1c432ca5
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@406fe00000000000
EXTRN	_ColorLuminance@12:PROC
EXTRN	_SetPixelLuminance@20:PROC
EXTRN	_GetPixelLuminance@12:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe6e2eb1c432ca5
CONST	SEGMENT
__real@3fe6e2eb1c432ca5 DQ 03fe6e2eb1c432ca5r	; 0.7152
CONST	ENDS
;	COMDAT __real@3fcb367a0f9096bc
CONST	SEGMENT
__real@3fcb367a0f9096bc DQ 03fcb367a0f9096bcr	; 0.2126
CONST	ENDS
;	COMDAT __real@3fb27bb2fec56d5d
CONST	SEGMENT
__real@3fb27bb2fec56d5d DQ 03fb27bb2fec56d5dr	; 0.0722
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\masks.cpp
_TEXT	SEGMENT
_ASrc$ = -32						; size = 4
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Bse$ = -20						; size = 4
_Dest$ = -16						; size = 4
_Column$2 = -12						; size = 4
_Row$3 = -8						; size = 4
_Index$4 = -4						; size = 4
_Base$ = 8						; size = 4
_AlphaSource$ = 12					; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_Stride$ = 24						; size = 4
_Destination$ = 28					; size = 4
?ApplyAlphaFromImage@@YGHPAX0HHH0@Z PROC		; ApplyAlphaFromImage

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 407  :     if (Base == NULL)

	cmp	DWORD PTR _Base$[ebp], 0
	jne	SHORT $LN8@ApplyAlpha

; 408  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ApplyAlpha
$LN8@ApplyAlpha:

; 409  :     if (AlphaSource == NULL) 

	cmp	DWORD PTR _AlphaSource$[ebp], 0
	jne	SHORT $LN9@ApplyAlpha

; 410  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ApplyAlpha
$LN9@ApplyAlpha:

; 411  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN10@ApplyAlpha

; 412  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ApplyAlpha
$LN10@ApplyAlpha:

; 413  : 
; 414  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 415  :     BYTE *Bse = (BYTE *)Base;

	mov	ecx, DWORD PTR _Base$[ebp]
	mov	DWORD PTR _Bse$[ebp], ecx

; 416  :     BYTE *ASrc = (BYTE *)AlphaSource;

	mov	edx, DWORD PTR _AlphaSource$[ebp]
	mov	DWORD PTR _ASrc$[ebp], edx

; 417  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 418  : 
; 419  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ApplyAlpha
$LN2@ApplyAlpha:
	mov	eax, DWORD PTR _Row$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$3[ebp], eax
$LN4@ApplyAlpha:
	mov	ecx, DWORD PTR _Row$3[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@ApplyAlpha

; 420  :     {
; 421  :         int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$3[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 422  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ApplyAlpha
$LN5@ApplyAlpha:
	mov	eax, DWORD PTR _Column$2[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$2[ebp], eax
$LN7@ApplyAlpha:
	mov	ecx, DWORD PTR _Column$2[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@ApplyAlpha

; 423  :         {
; 424  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$2[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], edx

; 425  :             Dest[Index + 3] = ASrc[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _ASrc$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 426  :             Dest[Index + 2] = Bse[Index + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Bse$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 427  :             Dest[Index + 1] = Bse[Index + 1];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Bse$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 428  :             Dest[Index + 0] = Bse[Index + 0];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Bse$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 429  :         }

	jmp	SHORT $LN5@ApplyAlpha
$LN6@ApplyAlpha:

; 430  :     }

	jmp	$LN2@ApplyAlpha
$LN3@ApplyAlpha:

; 431  : 
; 432  :     return Success;

	xor	eax, eax
$LN1@ApplyAlpha:

; 433  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?ApplyAlphaFromImage@@YGHPAX0HHH0@Z ENDP		; ApplyAlphaFromImage
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\masks.cpp
_TEXT	SEGMENT
_Luminance$1 = -64					; size = 8
_Luminance$2 = -56					; size = 8
_RowOffset$3 = -48					; size = 4
_PixelSize$ = -44					; size = 4
tv155 = -40						; size = 4
_PerformAction$4 = -36					; size = 4
_Dest$ = -32						; size = 4
tv136 = -28						; size = 4
_Src$ = -24						; size = 4
_Column$5 = -20						; size = 4
_Row$6 = -16						; size = 4
_Index$7 = -12						; size = 4
_sB$ = -8						; size = 1
_sG$ = -7						; size = 1
_sR$ = -6						; size = 1
_sA$ = -5						; size = 1
_B$8 = -4						; size = 1
_G$9 = -3						; size = 1
_R$10 = -2						; size = 1
_A$11 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_FrequencyAction$ = 28					; size = 48
_ActionByFrequency@68 PROC

; 446  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 447  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN12@ActionByFr

; 448  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ActionByFr
$LN12@ActionByFr:

; 449  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN13@ActionByFr

; 450  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ActionByFr
$LN13@ActionByFr:

; 451  : 
; 452  :     if (FrequencyAction.HorizontalFrequency < 1)

	cmp	DWORD PTR _FrequencyAction$[ebp+28], 1
	jge	SHORT $LN14@ActionByFr

; 453  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ActionByFr
$LN14@ActionByFr:

; 454  :     if (FrequencyAction.VerticalFrequency < 1)

	cmp	DWORD PTR _FrequencyAction$[ebp+32], 1
	jge	SHORT $LN15@ActionByFr

; 455  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ActionByFr
$LN15@ActionByFr:

; 456  :     if (FrequencyAction.Action == NoAction)

	cmp	DWORD PTR _FrequencyAction$[ebp], 0
	jne	SHORT $LN16@ActionByFr

; 457  :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@ActionByFr
$LN16@ActionByFr:

; 458  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 459  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 460  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 461  : 
; 462  :     BYTE sA = (BYTE)((FrequencyAction.NewColor & 0xff000000) >> 24);

	mov	edx, DWORD PTR _FrequencyAction$[ebp+24]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _sA$[ebp], dl

; 463  :     BYTE sR = (BYTE)((FrequencyAction.NewColor & 0x00ff0000) >> 16);

	mov	eax, DWORD PTR _FrequencyAction$[ebp+24]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _sR$[ebp], al

; 464  :     BYTE sG = (BYTE)((FrequencyAction.NewColor & 0x0000ff00) >> 8);

	mov	ecx, DWORD PTR _FrequencyAction$[ebp+24]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _sG$[ebp], cl

; 465  :     BYTE sB = (BYTE)((FrequencyAction.NewColor & 0x000000ff) >> 0);

	mov	edx, DWORD PTR _FrequencyAction$[ebp+24]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _sB$[ebp], dl

; 466  : 
; 467  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@ActionByFr
$LN2@ActionByFr:
	mov	eax, DWORD PTR _Row$6[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$6[ebp], eax
$LN4@ActionByFr:
	mov	ecx, DWORD PTR _Row$6[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN3@ActionByFr

; 468  :     {
; 469  :         int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$6[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], edx

; 470  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@ActionByFr
$LN5@ActionByFr:
	mov	eax, DWORD PTR _Column$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$5[ebp], eax
$LN7@ActionByFr:
	mov	ecx, DWORD PTR _Column$5[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	$LN6@ActionByFr

; 471  :         {
; 472  :             BOOL PerformAction = FALSE;

	mov	DWORD PTR _PerformAction$4[ebp], 0

; 473  :             if (Column % FrequencyAction.HorizontalFrequency == 0)

	mov	eax, DWORD PTR _Column$5[ebp]
	cdq
	idiv	DWORD PTR _FrequencyAction$[ebp+28]
	test	edx, edx
	jne	SHORT $LN17@ActionByFr

; 474  :                 PerformAction = TRUE;

	mov	DWORD PTR _PerformAction$4[ebp], 1
$LN17@ActionByFr:

; 475  :             if (Row % FrequencyAction.VerticalFrequency == 0)

	mov	eax, DWORD PTR _Row$6[ebp]
	cdq
	idiv	DWORD PTR _FrequencyAction$[ebp+32]
	test	edx, edx
	jne	SHORT $LN18@ActionByFr

; 476  :                 PerformAction = TRUE;

	mov	DWORD PTR _PerformAction$4[ebp], 1
$LN18@ActionByFr:

; 477  : 
; 478  :             int Index = RowOffset + (Column * PixelSize);

	mov	edx, DWORD PTR _Column$5[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$7[ebp], edx

; 479  :             BYTE A = Src[Index + 3];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR _A$11[ebp], cl

; 480  :             BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$10[ebp], al

; 481  :             BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$9[ebp], dl

; 482  :             BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$8[ebp], cl

; 483  : 
; 484  :             if (PerformAction)

	cmp	DWORD PTR _PerformAction$4[ebp], 0
	je	$LN8@ActionByFr

; 485  :             {
; 486  :                 switch (FrequencyAction.Action)

	mov	edx, DWORD PTR _FrequencyAction$[ebp]
	mov	DWORD PTR tv136[ebp], edx
	mov	eax, DWORD PTR tv136[ebp]
	sub	eax, 1
	mov	DWORD PTR tv136[ebp], eax
	cmp	DWORD PTR tv136[ebp], 4
	ja	$LN30@ActionByFr
	mov	ecx, DWORD PTR tv136[ebp]
	jmp	DWORD PTR $LN32@ActionByFr[ecx*4]
$LN20@ActionByFr:

; 487  :                 {
; 488  :                 case SetTransparencyAction:
; 489  :                     A = FrequencyAction.NewAlpha;

	cvttsd2si edx, QWORD PTR _FrequencyAction$[ebp+8]
	mov	BYTE PTR _A$11[ebp], dl

; 490  :                     break;

	jmp	$LN8@ActionByFr
$LN21@ActionByFr:

; 491  : 
; 492  :                 case InvertAction:
; 493  :                     if (FrequencyAction.IncludeAlpha)

	cmp	DWORD PTR _FrequencyAction$[ebp+36], 0
	je	SHORT $LN22@ActionByFr

; 494  :                         A = ~A;

	movzx	eax, BYTE PTR _A$11[ebp]
	not	eax
	mov	BYTE PTR _A$11[ebp], al
$LN22@ActionByFr:

; 495  :                     R = ~R;

	movzx	ecx, BYTE PTR _R$10[ebp]
	not	ecx
	mov	BYTE PTR _R$10[ebp], cl

; 496  :                     G = ~G;

	movzx	edx, BYTE PTR _G$9[ebp]
	not	edx
	mov	BYTE PTR _G$9[ebp], dl

; 497  :                     B = ~B;

	movzx	eax, BYTE PTR _B$8[ebp]
	not	eax
	mov	BYTE PTR _B$8[ebp], al

; 498  :                     break;

	jmp	$LN8@ActionByFr
$LN23@ActionByFr:

; 499  : 
; 500  :                 case SetLuminanceAction:
; 501  :                     SetPixelLuminance(&R, &G, &B, FrequencyAction.NewLuminance);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _FrequencyAction$[ebp+16]
	movsd	QWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR _B$8[ebp]
	push	ecx
	lea	edx, DWORD PTR _G$9[ebp]
	push	edx
	lea	eax, DWORD PTR _R$10[ebp]
	push	eax
	call	_SetPixelLuminance@20

; 502  :                     break;

	jmp	$LN8@ActionByFr
$LN24@ActionByFr:

; 503  : 
; 504  :                 case SetColorAction:
; 505  :                     switch (FrequencyAction.ColorAlphaAction)

	mov	ecx, DWORD PTR _FrequencyAction$[ebp+40]
	mov	DWORD PTR tv155[ebp], ecx
	cmp	DWORD PTR tv155[ebp], 0
	je	SHORT $LN25@ActionByFr
	cmp	DWORD PTR tv155[ebp], 1
	je	SHORT $LN26@ActionByFr
	cmp	DWORD PTR tv155[ebp], 2
	je	SHORT $LN27@ActionByFr
	jmp	SHORT $LN28@ActionByFr
$LN25@ActionByFr:

; 506  :                     {
; 507  :                     case UseColorAlpha:
; 508  :                         A = sA;

	mov	dl, BYTE PTR _sA$[ebp]
	mov	BYTE PTR _A$11[ebp], dl

; 509  :                         break;

	jmp	SHORT $LN10@ActionByFr
$LN26@ActionByFr:

; 510  : 
; 511  :                     case UseSourceAlpha:
; 512  :                         //Already assigned.
; 513  :                         break;

	jmp	SHORT $LN10@ActionByFr
$LN27@ActionByFr:

; 514  : 
; 515  :                     case UseLuminanceProportionalAlpha:
; 516  :                     {
; 517  :                         double Luminance = GetPixelLuminance(R, G, B);

	movzx	eax, BYTE PTR _B$8[ebp]
	push	eax
	movzx	ecx, BYTE PTR _G$9[ebp]
	push	ecx
	movzx	edx, BYTE PTR _R$10[ebp]
	push	edx
	call	_GetPixelLuminance@12
	fstp	QWORD PTR _Luminance$2[ebp]

; 518  :                         A = Luminance / 1.0;

	movsd	xmm0, QWORD PTR _Luminance$2[ebp]
	divsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvttsd2si eax, xmm0
	mov	BYTE PTR _A$11[ebp], al

; 519  :                     }
; 520  :                     break;

	jmp	SHORT $LN10@ActionByFr
$LN28@ActionByFr:

; 521  : 
; 522  :                     default:
; 523  :                         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ActionByFr
$LN10@ActionByFr:

; 524  :                     }
; 525  :                     R = sR;

	mov	cl, BYTE PTR _sR$[ebp]
	mov	BYTE PTR _R$10[ebp], cl

; 526  :                     G = sG;

	mov	dl, BYTE PTR _sG$[ebp]
	mov	BYTE PTR _G$9[ebp], dl

; 527  :                     B = sB;

	mov	al, BYTE PTR _sB$[ebp]
	mov	BYTE PTR _B$8[ebp], al

; 528  :                     break;

	jmp	SHORT $LN8@ActionByFr
$LN29@ActionByFr:

; 529  : 
; 530  :                 case ProportionalTransparentAction:
; 531  :                 {
; 532  :                     double Luminance = GetPixelLuminance(R, G, B);

	movzx	ecx, BYTE PTR _B$8[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$9[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$10[ebp]
	push	eax
	call	_GetPixelLuminance@12
	fstp	QWORD PTR _Luminance$1[ebp]

; 533  :                     A = Luminance / 1.0;

	movsd	xmm0, QWORD PTR _Luminance$1[ebp]
	divsd	xmm0, QWORD PTR __real@3ff0000000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _A$11[ebp], cl

; 534  :                 }
; 535  :                 break;

	jmp	SHORT $LN8@ActionByFr
$LN30@ActionByFr:

; 536  : 
; 537  :                 default:
; 538  :                     return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@ActionByFr
$LN8@ActionByFr:

; 539  :                 }
; 540  :             }
; 541  : 
; 542  :             Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _A$11[ebp]
	mov	BYTE PTR [edx+3], al

; 543  :             Dest[Index + 2] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _R$10[ebp]
	mov	BYTE PTR [ecx+2], dl

; 544  :             Dest[Index + 1] = G;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR [eax+1], cl

; 545  :             Dest[Index + 0] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _B$8[ebp]
	mov	BYTE PTR [edx], al

; 546  :         }

	jmp	$LN5@ActionByFr
$LN6@ActionByFr:

; 547  :     }

	jmp	$LN2@ActionByFr
$LN3@ActionByFr:

; 548  : 
; 549  :     return Success;

	xor	eax, eax
$LN1@ActionByFr:

; 550  : }

	mov	esp, ebp
	pop	ebp
	ret	68					; 00000044H
	npad	2
$LN32@ActionByFr:
	DD	$LN20@ActionByFr
	DD	$LN21@ActionByFr
	DD	$LN23@ActionByFr
	DD	$LN24@ActionByFr
	DD	$LN29@ActionByFr
_ActionByFrequency@68 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\masks.cpp
_TEXT	SEGMENT
_Index$1 = -24						; size = 4
_Buf$ = -20						; size = 4
_RowOffset$2 = -16					; size = 4
_PixelSize$ = -12					; size = 4
_Column$3 = -8						; size = 4
_Row$4 = -4						; size = 4
_Buffer$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_NewAlpha$ = 24						; size = 1
_SetAlphaChannelInPlace@20 PROC

; 244  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 245  :     if (Buffer == NULL)

	cmp	DWORD PTR _Buffer$[ebp], 0
	jne	SHORT $LN8@SetAlphaCh

; 246  :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@SetAlphaCh
$LN8@SetAlphaCh:

; 247  : 
; 248  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 249  :     BYTE *Buf = (BYTE *)Buffer;

	mov	eax, DWORD PTR _Buffer$[ebp]
	mov	DWORD PTR _Buf$[ebp], eax

; 250  : 
; 251  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@SetAlphaCh
$LN2@SetAlphaCh:
	mov	ecx, DWORD PTR _Row$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$4[ebp], ecx
$LN4@SetAlphaCh:
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@SetAlphaCh

; 252  :     {
; 253  :         int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], eax

; 254  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@SetAlphaCh
$LN5@SetAlphaCh:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@SetAlphaCh:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@SetAlphaCh

; 255  :         {
; 256  :             int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$3[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$1[ebp], eax

; 257  :             Buf[Index + 3] = NewAlpha;

	mov	ecx, DWORD PTR _Buf$[ebp]
	add	ecx, DWORD PTR _Index$1[ebp]
	mov	dl, BYTE PTR _NewAlpha$[ebp]
	mov	BYTE PTR [ecx+3], dl

; 258  :         }

	jmp	SHORT $LN5@SetAlphaCh
$LN6@SetAlphaCh:

; 259  :     }

	jmp	SHORT $LN2@SetAlphaCh
$LN3@SetAlphaCh:

; 260  : 
; 261  :     return Success;

	xor	eax, eax
$LN1@SetAlphaCh:

; 262  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetAlphaChannelInPlace@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\masks.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Src$ = -20						; size = 4
_Dest$ = -16						; size = 4
_Column$2 = -12						; size = 4
_Row$3 = -8						; size = 4
_Index$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_NewAlpha$ = 28						; size = 1
_SetAlphaChannel@24 PROC

; 208  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 209  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@SetAlphaCh

; 210  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@SetAlphaCh
$LN8@SetAlphaCh:

; 211  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@SetAlphaCh

; 212  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@SetAlphaCh
$LN9@SetAlphaCh:

; 213  : 
; 214  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 215  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 216  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 217  : 
; 218  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@SetAlphaCh
$LN2@SetAlphaCh:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@SetAlphaCh:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@SetAlphaCh

; 219  :     {
; 220  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 221  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@SetAlphaCh
$LN5@SetAlphaCh:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@SetAlphaCh:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@SetAlphaCh

; 222  :         {
; 223  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 224  :             Dest[Index + 3] = NewAlpha;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _NewAlpha$[ebp]
	mov	BYTE PTR [edx+3], al

; 225  :             Dest[Index + 2] = Src[Index + 2];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 226  :             Dest[Index + 1] = Src[Index + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 227  :             Dest[Index + 0] = Src[Index + 0];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 228  :         }

	jmp	SHORT $LN5@SetAlphaCh
$LN6@SetAlphaCh:

; 229  :     }

	jmp	$LN2@SetAlphaCh
$LN3@SetAlphaCh:

; 230  : 
; 231  :     return Success;

	xor	eax, eax
$LN1@SetAlphaCh:

; 232  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_SetAlphaChannel@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\masks.cpp
_TEXT	SEGMENT
_PLuminance$1 = -48					; size = 8
_RowOffset$2 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_DoMask$3 = -32						; size = 4
_Column$4 = -28						; size = 4
_Row$5 = -24						; size = 4
_Src$ = -20						; size = 4
_Dest$ = -16						; size = 4
_Index$6 = -12						; size = 4
_MaskB$ = -7						; size = 1
_MaskG$ = -6						; size = 1
_MaskR$ = -5						; size = 1
_MaskA$ = -4						; size = 1
_R$7 = -3						; size = 1
_G$8 = -2						; size = 1
_B$9 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_LuminanceThreshold$ = 28				; size = 8
_Invert$ = 36						; size = 4
_MaskPixel$ = 40					; size = 4
_ConditionalAlphaFromLuminance@36 PROC

; 279  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 280  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@Conditiona

; 281  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@Conditiona
$LN8@Conditiona:

; 282  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@Conditiona

; 283  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@Conditiona
$LN9@Conditiona:

; 284  : 
; 285  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 286  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 287  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 288  :     BYTE MaskA = (MaskPixel & 0xff000000) >> 24;

	mov	edx, DWORD PTR _MaskPixel$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _MaskA$[ebp], dl

; 289  :     BYTE MaskR = (MaskPixel & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _MaskPixel$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _MaskR$[ebp], al

; 290  :     BYTE MaskG = (MaskPixel & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _MaskPixel$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _MaskG$[ebp], cl

; 291  :     BYTE MaskB = (MaskPixel & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _MaskPixel$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _MaskB$[ebp], dl

; 292  : 
; 293  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN4@Conditiona
$LN2@Conditiona:
	mov	eax, DWORD PTR _Row$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$5[ebp], eax
$LN4@Conditiona:
	mov	ecx, DWORD PTR _Row$5[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN3@Conditiona

; 294  :     {
; 295  :         int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$5[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], edx

; 296  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$4[ebp], 0
	jmp	SHORT $LN7@Conditiona
$LN5@Conditiona:
	mov	eax, DWORD PTR _Column$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$4[ebp], eax
$LN7@Conditiona:
	mov	ecx, DWORD PTR _Column$4[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	$LN6@Conditiona

; 297  :         {
; 298  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$4[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$6[ebp], edx

; 299  :             BYTE R = Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _R$7[ebp], cl

; 300  :             BYTE G = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _G$8[ebp], al

; 301  :             BYTE B = Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _B$9[ebp], dl

; 302  :             double PLuminance = ColorLuminance(R, G, B);

	movzx	eax, BYTE PTR _B$9[ebp]
	push	eax
	movzx	ecx, BYTE PTR _G$8[ebp]
	push	ecx
	movzx	edx, BYTE PTR _R$7[ebp]
	push	edx
	call	_ColorLuminance@12
	fstp	QWORD PTR _PLuminance$1[ebp]

; 303  :             BOOL DoMask = FALSE;

	mov	DWORD PTR _DoMask$3[ebp], 0

; 304  :             if (Invert)

	cmp	DWORD PTR _Invert$[ebp], 0
	je	SHORT $LN10@Conditiona

; 305  :             {
; 306  :                 if (PLuminance <= LuminanceThreshold)

	movsd	xmm0, QWORD PTR _LuminanceThreshold$[ebp]
	comisd	xmm0, QWORD PTR _PLuminance$1[ebp]
	jb	SHORT $LN12@Conditiona

; 307  :                     DoMask = TRUE;

	mov	DWORD PTR _DoMask$3[ebp], 1
$LN12@Conditiona:

; 308  :             }
; 309  :             else

	jmp	SHORT $LN13@Conditiona
$LN10@Conditiona:

; 310  :             {
; 311  :                 if (PLuminance >= LuminanceThreshold)

	movsd	xmm0, QWORD PTR _PLuminance$1[ebp]
	comisd	xmm0, QWORD PTR _LuminanceThreshold$[ebp]
	jb	SHORT $LN13@Conditiona

; 312  :                     DoMask = TRUE;

	mov	DWORD PTR _DoMask$3[ebp], 1
$LN13@Conditiona:

; 313  :             }
; 314  :             if (DoMask)

	cmp	DWORD PTR _DoMask$3[ebp], 0
	je	SHORT $LN14@Conditiona

; 315  :             {
; 316  :                 Dest[Index + 3] = MaskA;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _MaskA$[ebp]
	mov	BYTE PTR [eax+3], cl

; 317  :                 Dest[Index + 2] = MaskR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _MaskR$[ebp]
	mov	BYTE PTR [edx+2], al

; 318  :                 Dest[Index + 1] = MaskG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _MaskG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 319  :                 Dest[Index + 0] = MaskB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _MaskB$[ebp]
	mov	BYTE PTR [eax], cl

; 320  :             }
; 321  :             else

	jmp	SHORT $LN15@Conditiona
$LN14@Conditiona:

; 322  :             {
; 323  :                 Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 324  :                 Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 325  :                 Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 326  :                 Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
$LN15@Conditiona:

; 327  :             }
; 328  :         }

	jmp	$LN5@Conditiona
$LN6@Conditiona:

; 329  :     }

	jmp	$LN2@Conditiona
$LN3@Conditiona:

; 330  :     return Success;

	xor	eax, eax
$LN1@Conditiona:

; 331  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_ConditionalAlphaFromLuminance@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\masks.cpp
_TEXT	SEGMENT
_LumLevelLum$1 = -44					; size = 8
_RowOffset$2 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_LL$ = -28						; size = 4
_Bse$ = -24						; size = 4
_Column$3 = -20						; size = 4
_Row$4 = -16						; size = 4
_Dest$ = -12						; size = 4
_Index$5 = -8						; size = 4
_mB$ = -4						; size = 1
_mG$ = -3						; size = 1
_mR$ = -2						; size = 1
_mA$ = -1						; size = 1
_Base$ = 8						; size = 4
_LuminanceLayer$ = 12					; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_Stride$ = 24						; size = 4
_Destination$ = 28					; size = 4
_LuminanceThreshold$ = 32				; size = 8
_MaskedPixel$ = 40					; size = 4
_MaskImageFromImageLuminance@36 PROC

; 350  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 351  :     if (Base == NULL)

	cmp	DWORD PTR _Base$[ebp], 0
	jne	SHORT $LN8@MaskImageF

; 352  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MaskImageF
$LN8@MaskImageF:

; 353  :     if (LuminanceLayer == NULL)

	cmp	DWORD PTR _LuminanceLayer$[ebp], 0
	jne	SHORT $LN9@MaskImageF

; 354  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MaskImageF
$LN9@MaskImageF:

; 355  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN10@MaskImageF

; 356  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MaskImageF
$LN10@MaskImageF:

; 357  : 
; 358  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 359  :     BYTE *Bse = (BYTE *)Base;

	mov	ecx, DWORD PTR _Base$[ebp]
	mov	DWORD PTR _Bse$[ebp], ecx

; 360  :     BYTE *LL = (BYTE *)LuminanceLayer;

	mov	edx, DWORD PTR _LuminanceLayer$[ebp]
	mov	DWORD PTR _LL$[ebp], edx

; 361  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 362  : 
; 363  :     BYTE mA = (MaskedPixel & 0xff000000) >> 24;

	mov	eax, DWORD PTR _MaskedPixel$[ebp]
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	BYTE PTR _mA$[ebp], al

; 364  :     BYTE mR = (MaskedPixel & 0x00ff0000) >> 16;

	mov	ecx, DWORD PTR _MaskedPixel$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR _mR$[ebp], cl

; 365  :     BYTE mG = (MaskedPixel & 0x0000ff00) >> 8;

	mov	edx, DWORD PTR _MaskedPixel$[ebp]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _mG$[ebp], dl

; 366  :     BYTE mB = (MaskedPixel & 0x000000ff) >> 0;

	mov	eax, DWORD PTR _MaskedPixel$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _mB$[ebp], al

; 367  : 
; 368  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@MaskImageF
$LN2@MaskImageF:
	mov	ecx, DWORD PTR _Row$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$4[ebp], ecx
$LN4@MaskImageF:
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	$LN3@MaskImageF

; 369  :     {
; 370  :         int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], eax

; 371  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@MaskImageF
$LN5@MaskImageF:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@MaskImageF:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	$LN6@MaskImageF

; 372  :         {
; 373  :             int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$3[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], eax

; 374  :             double LumLevelLum = ColorLuminance(LL[Index + 2], LL[Index + 1], LL[Index + 1]);

	mov	ecx, DWORD PTR _LL$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	mov	eax, DWORD PTR _LL$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	push	ecx
	mov	edx, DWORD PTR _LL$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	call	_ColorLuminance@12
	fstp	QWORD PTR _LumLevelLum$1[ebp]

; 375  :             if (LumLevelLum < LuminanceThreshold)

	movsd	xmm0, QWORD PTR _LuminanceThreshold$[ebp]
	comisd	xmm0, QWORD PTR _LumLevelLum$1[ebp]
	jbe	SHORT $LN11@MaskImageF

; 376  :             {
; 377  :                 Dest[Index + 3] = Bse[Index + 3];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	edx, DWORD PTR _Bse$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 378  :                 Dest[Index + 2] = Bse[Index + 2];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	edx, DWORD PTR _Bse$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 379  :                 Dest[Index + 1] = Bse[Index + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	edx, DWORD PTR _Bse$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 380  :                 Dest[Index + 0] = Bse[Index + 0];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	edx, DWORD PTR _Bse$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 381  :             }
; 382  :             else

	jmp	SHORT $LN12@MaskImageF
$LN11@MaskImageF:

; 383  :             {
; 384  :                 Dest[Index + 3] = mA;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _mA$[ebp]
	mov	BYTE PTR [ecx+3], dl

; 385  :                 Dest[Index + 2] = mR;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _mR$[ebp]
	mov	BYTE PTR [eax+2], cl

; 386  :                 Dest[Index + 1] = mG;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _mG$[ebp]
	mov	BYTE PTR [edx+1], al

; 387  :                 Dest[Index + 0] = mB;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _mB$[ebp]
	mov	BYTE PTR [ecx], dl
$LN12@MaskImageF:

; 388  :             }
; 389  :         }

	jmp	$LN5@MaskImageF
$LN6@MaskImageF:

; 390  :     }

	jmp	$LN2@MaskImageF
$LN3@MaskImageF:

; 391  : 
; 392  :     return Success;

	xor	eax, eax
$LN1@MaskImageF:

; 393  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_MaskImageFromImageLuminance@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\masks.cpp
_TEXT	SEGMENT
_nB$1 = -72						; size = 8
_nG$2 = -64						; size = 8
_nR$3 = -56						; size = 8
tv132 = -48						; size = 8
_PixelLum$4 = -40					; size = 8
_RowOffset$5 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Dest$ = -24						; size = 4
_Column$6 = -20						; size = 4
_Row$7 = -16						; size = 4
_Src$ = -12						; size = 4
_Index$8 = -8						; size = 4
_FinalAlpha$9 = -4					; size = 1
_sB$10 = -3						; size = 1
_sG$11 = -2						; size = 1
_sR$12 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Invert$ = 28						; size = 4
_AlphaFromLuminance@24 PROC

; 160  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 161  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@AlphaFromL

; 162  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlphaFromL
$LN8@AlphaFromL:

; 163  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@AlphaFromL

; 164  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlphaFromL
$LN9@AlphaFromL:

; 165  : 
; 166  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 167  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 168  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 169  : 
; 170  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$7[ebp], 0
	jmp	SHORT $LN4@AlphaFromL
$LN2@AlphaFromL:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN4@AlphaFromL:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@AlphaFromL

; 171  :     {
; 172  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$5[ebp], ecx

; 173  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$6[ebp], 0
	jmp	SHORT $LN7@AlphaFromL
$LN5@AlphaFromL:
	mov	edx, DWORD PTR _Column$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$6[ebp], edx
$LN7@AlphaFromL:
	mov	eax, DWORD PTR _Column$6[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@AlphaFromL

; 174  :         {
; 175  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$6[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$5[ebp]
	mov	DWORD PTR _Index$8[ebp], ecx

; 176  :             BYTE sR = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _sR$12[ebp], al

; 177  :             double nR = (double)sR / 255.0;

	movzx	ecx, BYTE PTR _sR$12[ebp]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _nR$3[ebp], xmm0

; 178  :             BYTE sG = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _sG$11[ebp], al

; 179  :             double nG = (double)sG / 255.0;

	movzx	ecx, BYTE PTR _sG$11[ebp]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _nG$2[ebp], xmm0

; 180  :             BYTE sB = Src[Index + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _sB$10[ebp], al

; 181  :             double nB = (double)sB / 255.0;

	movzx	ecx, BYTE PTR _sB$10[ebp]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _nB$1[ebp], xmm0

; 182  :             double PixelLum = (0.2126 * nR) + (0.7152 * nG) + (0.0722 * nB);

	movsd	xmm0, QWORD PTR __real@3fcb367a0f9096bc
	mulsd	xmm0, QWORD PTR _nR$3[ebp]
	movsd	xmm1, QWORD PTR __real@3fe6e2eb1c432ca5
	mulsd	xmm1, QWORD PTR _nG$2[ebp]
	addsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@3fb27bb2fec56d5d
	mulsd	xmm1, QWORD PTR _nB$1[ebp]
	addsd	xmm0, xmm1
	movsd	QWORD PTR _PixelLum$4[ebp], xmm0

; 183  :             if (Invert)

	cmp	DWORD PTR _Invert$[ebp], 0
	je	SHORT $LN10@AlphaFromL

; 184  :                 PixelLum = 1.0 - PixelLum;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _PixelLum$4[ebp]
	movsd	QWORD PTR _PixelLum$4[ebp], xmm0
$LN10@AlphaFromL:

; 185  :             PixelLum *= 255.0;

	movsd	xmm0, QWORD PTR _PixelLum$4[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _PixelLum$4[ebp], xmm0

; 186  :             BYTE FinalAlpha = min(PixelLum, 0xff);

	movsd	xmm0, QWORD PTR __real@406fe00000000000
	comisd	xmm0, QWORD PTR _PixelLum$4[ebp]
	jbe	SHORT $LN12@AlphaFromL
	movsd	xmm0, QWORD PTR _PixelLum$4[ebp]
	movsd	QWORD PTR tv132[ebp], xmm0
	jmp	SHORT $LN13@AlphaFromL
$LN12@AlphaFromL:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv132[ebp], xmm0
$LN13@AlphaFromL:
	cvttsd2si edx, QWORD PTR tv132[ebp]
	mov	BYTE PTR _FinalAlpha$9[ebp], dl

; 187  :             Dest[Index + 3] = FinalAlpha;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR _FinalAlpha$9[ebp]
	mov	BYTE PTR [eax+3], cl

; 188  :             Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 189  :             Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 190  :             Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 191  :         }

	jmp	$LN5@AlphaFromL
$LN6@AlphaFromL:

; 192  :     }

	jmp	$LN2@AlphaFromL
$LN3@AlphaFromL:

; 193  : 
; 194  :     return Success;

	xor	eax, eax
$LN1@AlphaFromL:

; 195  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_AlphaFromLuminance@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\masks.cpp
_TEXT	SEGMENT
_RowOffset$1 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_Src$ = -32						; size = 4
_Column$2 = -28						; size = 4
_Row$3 = -24						; size = 4
_Dest$ = -20						; size = 4
_Index$4 = -16						; size = 4
_HighMaskB$ = -9					; size = 1
_LowMaskB$ = -8						; size = 1
_HighMaskG$ = -7					; size = 1
_LowMaskG$ = -6						; size = 1
_HighMaskR$ = -5					; size = 1
_LowMaskR$ = -4						; size = 1
_B$5 = -3						; size = 1
_G$6 = -2						; size = 1
_R$7 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_LowMaskColor$ = 28					; size = 4
_HighMaskColor$ = 32					; size = 4
_AlphaValue$ = 36					; size = 1
_MaskByColor@32 PROC

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 104  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@MaskByColo

; 105  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MaskByColo
$LN8@MaskByColo:

; 106  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@MaskByColo

; 107  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MaskByColo
$LN9@MaskByColo:

; 108  : 
; 109  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 110  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 111  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 112  : 
; 113  :     BYTE LowMaskR = (LowMaskColor & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _LowMaskColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _LowMaskR$[ebp], dl

; 114  :     BYTE LowMaskG = (LowMaskColor & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _LowMaskColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _LowMaskG$[ebp], al

; 115  :     BYTE LowMaskB = (LowMaskColor & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _LowMaskColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _LowMaskB$[ebp], cl

; 116  :     BYTE HighMaskR = (HighMaskColor & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _HighMaskColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _HighMaskR$[ebp], dl

; 117  :     BYTE HighMaskG = (HighMaskColor & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _HighMaskColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _HighMaskG$[ebp], al

; 118  :     BYTE HighMaskB = (HighMaskColor & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _HighMaskColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _HighMaskB$[ebp], cl

; 119  : 
; 120  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@MaskByColo
$LN2@MaskByColo:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@MaskByColo:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@MaskByColo

; 121  :     {
; 122  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 123  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@MaskByColo
$LN5@MaskByColo:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@MaskByColo:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@MaskByColo

; 124  :         {
; 125  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 126  :             BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$7[ebp], al

; 127  :             BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$6[ebp], dl

; 128  :             BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$5[ebp], cl

; 129  :             Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [edx+2], al

; 130  :             Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [ecx+1], dl

; 131  :             Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _B$5[ebp]
	mov	BYTE PTR [eax], cl

; 132  :             if (
; 133  :                 (R >= LowMaskR && R <= HighMaskR) &&
; 134  :                 (G >= LowMaskG && G <= HighMaskG) &&

	movzx	edx, BYTE PTR _R$7[ebp]
	movzx	eax, BYTE PTR _LowMaskR$[ebp]
	cmp	edx, eax
	jl	SHORT $LN10@MaskByColo
	movzx	ecx, BYTE PTR _R$7[ebp]
	movzx	edx, BYTE PTR _HighMaskR$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN10@MaskByColo
	movzx	eax, BYTE PTR _G$6[ebp]
	movzx	ecx, BYTE PTR _LowMaskG$[ebp]
	cmp	eax, ecx
	jl	SHORT $LN10@MaskByColo
	movzx	edx, BYTE PTR _G$6[ebp]
	movzx	eax, BYTE PTR _HighMaskG$[ebp]
	cmp	edx, eax
	jg	SHORT $LN10@MaskByColo
	movzx	ecx, BYTE PTR _B$5[ebp]
	movzx	edx, BYTE PTR _LowMaskB$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN10@MaskByColo
	movzx	eax, BYTE PTR _B$5[ebp]
	movzx	ecx, BYTE PTR _HighMaskB$[ebp]
	cmp	eax, ecx
	jg	SHORT $LN10@MaskByColo

; 135  :                 (B >= LowMaskB && B <= HighMaskB)
; 136  :                 )
; 137  :             {
; 138  :                 Dest[Index + 3] = AlphaValue;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _AlphaValue$[ebp]
	mov	BYTE PTR [edx+3], al

; 139  :             }
; 140  :             else

	jmp	SHORT $LN11@MaskByColo
$LN10@MaskByColo:

; 141  :             {
; 142  :                 Dest[Index + 3] = Src[Index + 3];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al
$LN11@MaskByColo:

; 143  :             }
; 144  :         }

	jmp	$LN5@MaskByColo
$LN6@MaskByColo:

; 145  :     }

	jmp	$LN2@MaskByColo
$LN3@MaskByColo:

; 146  : 
; 147  :     return Success;

	xor	eax, eax
$LN1@MaskByColo:

; 148  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_MaskByColor@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\masks.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Src$ = -20						; size = 4
_Column$2 = -16						; size = 4
_Row$3 = -12						; size = 4
_Dest$ = -8						; size = 4
_Index$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_AlphaLevel$ = 28					; size = 1
_AlphaMaskImage@24 PROC

; 59   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 60   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@AlphaMaskI

; 61   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlphaMaskI
$LN8@AlphaMaskI:

; 62   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@AlphaMaskI

; 63   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlphaMaskI
$LN9@AlphaMaskI:

; 64   : 
; 65   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 66   :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 67   :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 68   : 
; 69   :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@AlphaMaskI
$LN2@AlphaMaskI:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@AlphaMaskI:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@AlphaMaskI

; 70   :     {
; 71   :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 72   :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@AlphaMaskI
$LN5@AlphaMaskI:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@AlphaMaskI:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@AlphaMaskI

; 73   :         {
; 74   :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 75   :             Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 76   :             Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 77   :             Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 78   :             if (Dest[Index + 3] >= AlphaLevel)

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+3]
	movzx	ecx, BYTE PTR _AlphaLevel$[ebp]
	cmp	eax, ecx
	jl	SHORT $LN10@AlphaMaskI

; 79   :                 Dest[Index + 3] = 0xff;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH

; 80   :             else

	jmp	SHORT $LN11@AlphaMaskI
$LN10@AlphaMaskI:

; 81   :                 Dest[Index + 3] = 0x0;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [eax+3], 0
$LN11@AlphaMaskI:

; 82   :         }

	jmp	SHORT $LN5@AlphaMaskI
$LN6@AlphaMaskI:

; 83   :     }

	jmp	$LN2@AlphaMaskI
$LN3@AlphaMaskI:

; 84   : 
; 85   :     return Success;

	xor	eax, eax
$LN1@AlphaMaskI:

; 86   : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_AlphaMaskImage@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\masks.cpp
_TEXT	SEGMENT
_PixelLuminance$1 = -36					; size = 8
_RowOffset$2 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Column$3 = -20						; size = 4
_Row$4 = -16						; size = 4
_Dest$ = -12						; size = 4
_Src$ = -8						; size = 4
_Index$5 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Luminance$ = 28					; size = 8
_AlphaSolarize@28 PROC

; 17   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 18   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@AlphaSolar

; 19   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlphaSolar
$LN8@AlphaSolar:

; 20   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@AlphaSolar

; 21   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlphaSolar
$LN9@AlphaSolar:

; 22   : 
; 23   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 24   :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 25   :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 26   : 
; 27   :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@AlphaSolar
$LN2@AlphaSolar:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@AlphaSolar:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@AlphaSolar

; 28   :     {
; 29   :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 30   :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@AlphaSolar
$LN5@AlphaSolar:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@AlphaSolar:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@AlphaSolar

; 31   :         {
; 32   :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 33   :             Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 34   :             Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 35   :             Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 36   :             double PixelLuminance = ColorLuminance(Src[Index + 2], Src[Index + 1], Src[Index + 0]);

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_ColorLuminance@12
	fstp	QWORD PTR _PixelLuminance$1[ebp]

; 37   :             if (PixelLuminance < Luminance)

	movsd	xmm0, QWORD PTR _Luminance$[ebp]
	comisd	xmm0, QWORD PTR _PixelLuminance$1[ebp]
	jbe	SHORT $LN10@AlphaSolar

; 38   :                 Dest[Index + 3] = 0;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+3], 0

; 39   :             else

	jmp	SHORT $LN11@AlphaSolar
$LN10@AlphaSolar:

; 40   :                 Dest[Index + 3] = ~Dest[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	not	ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+3], cl
$LN11@AlphaSolar:

; 41   :         }

	jmp	$LN5@AlphaSolar
$LN6@AlphaSolar:

; 42   :     }

	jmp	$LN2@AlphaSolar
$LN3@AlphaSolar:

; 43   : 
; 44   :     return Success;

	xor	eax, eax
$LN1@AlphaSolar:

; 45   : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_AlphaSolarize@28 ENDP
_TEXT	ENDS
END
