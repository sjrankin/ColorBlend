; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\ImageManipulation.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_ChannelMerge@28
PUBLIC	_ChannelMergeAlpha@32
PUBLIC	_CombineChannels32@32
PUBLIC	_HSLChannelMerge@28
PUBLIC	_SplitImageIntoChannels@32
PUBLIC	_SplitImageIntoHSLChannels@32
PUBLIC	_RollingMeanChannels@28
PUBLIC	_RollingMeanChannels2@36
PUBLIC	_SortChannels2@32
PUBLIC	_SortChannels@32
PUBLIC	_SolarizeImage@32
PUBLIC	_AlphaSolarizeImage@28
PUBLIC	_AlphaSolarizeImage2@28
PUBLIC	_InvertImageRegion@48
PUBLIC	_InvertImage@24
PUBLIC	_ImageMeanColorRegion@36
PUBLIC	_ImageMeanColor@20
PUBLIC	_MeanImageColorRegion@44
PUBLIC	_MeanImageColor@20
PUBLIC	_BrightnessMapRegion@44
PUBLIC	_BrightnessMap@20
PUBLIC	_AutoContrastRegion@52
PUBLIC	_AutoContrast@28
PUBLIC	_AutoSaturateRegion@48
PUBLIC	_AutoSaturate@24
PUBLIC	_ColorThreshold0@36
PUBLIC	_ColorThreshold@36
PUBLIC	_ColorThreshold2@44
PUBLIC	_ColorThreshold3@28
PUBLIC	_SepiaToneRegion@44
PUBLIC	_SepiaTone@20
PUBLIC	_MeanImageColorValue@16
PUBLIC	_MeanImageColor2@28
PUBLIC	__real@3fbc28f5c28f5c29
PUBLIC	__real@3fc0c49ba5e353f8
PUBLIC	__real@3fc5810624dd2f1b
PUBLIC	__real@3fc83126e978d4fe
PUBLIC	__real@3fd16872b020c49c
PUBLIC	__real@3fd3333333333333
PUBLIC	__real@3fd65604189374bc
PUBLIC	__real@3fd926e978d4fdf4
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe116872b020c4a
PUBLIC	__real@3fe2e147ae147ae1
PUBLIC	__real@3fe5f3b645a1cac1
PUBLIC	__real@3fe89ba5e353f7cf
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4059000000000000
PUBLIC	__real@406fe00000000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_ColorLuminance@12:PROC
EXTRN	?NormalizedColorLuminance@@YGNEEEH@Z:PROC	; NormalizedColorLuminance
EXTRN	_ColorLuminance2@16:PROC
EXTRN	_GetPixelLuminance@12:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe89ba5e353f7cf
CONST	SEGMENT
__real@3fe89ba5e353f7cf DQ 03fe89ba5e353f7cfr	; 0.769
CONST	ENDS
;	COMDAT __real@3fe5f3b645a1cac1
CONST	SEGMENT
__real@3fe5f3b645a1cac1 DQ 03fe5f3b645a1cac1r	; 0.686
CONST	ENDS
;	COMDAT __real@3fe2e147ae147ae1
CONST	SEGMENT
__real@3fe2e147ae147ae1 DQ 03fe2e147ae147ae1r	; 0.59
CONST	ENDS
;	COMDAT __real@3fe116872b020c4a
CONST	SEGMENT
__real@3fe116872b020c4a DQ 03fe116872b020c4ar	; 0.534
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fd926e978d4fdf4
CONST	SEGMENT
__real@3fd926e978d4fdf4 DQ 03fd926e978d4fdf4r	; 0.393
CONST	ENDS
;	COMDAT __real@3fd65604189374bc
CONST	SEGMENT
__real@3fd65604189374bc DQ 03fd65604189374bcr	; 0.349
CONST	ENDS
;	COMDAT __real@3fd3333333333333
CONST	SEGMENT
__real@3fd3333333333333 DQ 03fd3333333333333r	; 0.3
CONST	ENDS
;	COMDAT __real@3fd16872b020c49c
CONST	SEGMENT
__real@3fd16872b020c49c DQ 03fd16872b020c49cr	; 0.272
CONST	ENDS
;	COMDAT __real@3fc83126e978d4fe
CONST	SEGMENT
__real@3fc83126e978d4fe DQ 03fc83126e978d4fer	; 0.189
CONST	ENDS
;	COMDAT __real@3fc5810624dd2f1b
CONST	SEGMENT
__real@3fc5810624dd2f1b DQ 03fc5810624dd2f1br	; 0.168
CONST	ENDS
;	COMDAT __real@3fc0c49ba5e353f8
CONST	SEGMENT
__real@3fc0c49ba5e353f8 DQ 03fc0c49ba5e353f8r	; 0.131
CONST	ENDS
;	COMDAT __real@3fbc28f5c28f5c29
CONST	SEGMENT
__real@3fbc28f5c28f5c29 DQ 03fbc28f5c28f5c29r	; 0.11
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_RowOffset$1 = -36					; size = 4
_PixelSize$ = -32					; size = 4
tv76 = -28						; size = 4
_Index$2 = -24						; size = 4
_Dest$ = -20						; size = 4
_Column$3 = -16						; size = 4
_Row$4 = -12						; size = 4
_CalculatedMeanColor$ = -8				; size = 4
_B$ = -4						; size = 1
_G$ = -3						; size = 1
_R$ = -2						; size = 1
_A$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_IgnoreAlpha$ = 28					; size = 4
_MeanColor$ = 32					; size = 4
_MeanImageColor2@28 PROC

; 1818 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1819 : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@MeanImageC

; 1820 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@MeanImageC
$LN8@MeanImageC:

; 1821 : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@MeanImageC

; 1822 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@MeanImageC
$LN9@MeanImageC:

; 1823 : 	UINT32 CalculatedMeanColor = MeanImageColorValue(Source, Width, Height, Stride);

	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_MeanImageColorValue@16
	mov	DWORD PTR _CalculatedMeanColor$[ebp], eax

; 1824 : 	BYTE A = IgnoreAlpha ? 0xff : (BYTE)((CalculatedMeanColor & 0xff000000) >> 24);

	cmp	DWORD PTR _IgnoreAlpha$[ebp], 0
	je	SHORT $LN11@MeanImageC
	mov	DWORD PTR tv76[ebp], 255		; 000000ffH
	jmp	SHORT $LN12@MeanImageC
$LN11@MeanImageC:
	mov	ecx, DWORD PTR _CalculatedMeanColor$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	movzx	edx, cl
	mov	DWORD PTR tv76[ebp], edx
$LN12@MeanImageC:
	mov	al, BYTE PTR tv76[ebp]
	mov	BYTE PTR _A$[ebp], al

; 1825 : 	BYTE R = (BYTE)((CalculatedMeanColor & 0x00ff0000) >> 16);

	mov	ecx, DWORD PTR _CalculatedMeanColor$[ebp]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR _R$[ebp], cl

; 1826 : 	BYTE G = (BYTE)((CalculatedMeanColor & 0x0000ff00) >> 8);

	mov	edx, DWORD PTR _CalculatedMeanColor$[ebp]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _G$[ebp], dl

; 1827 : 	BYTE B = (BYTE)((CalculatedMeanColor & 0x000000ff) >> 0);

	mov	eax, DWORD PTR _CalculatedMeanColor$[ebp]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _B$[ebp], al

; 1828 : 	*MeanColor = CalculatedMeanColor;

	mov	ecx, DWORD PTR _MeanColor$[ebp]
	mov	edx, DWORD PTR _CalculatedMeanColor$[ebp]
	mov	DWORD PTR [ecx], edx

; 1829 : 
; 1830 : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1831 : 	BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 1832 : 
; 1833 : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@MeanImageC
$LN2@MeanImageC:
	mov	ecx, DWORD PTR _Row$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$4[ebp], ecx
$LN4@MeanImageC:
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@MeanImageC

; 1834 : 	{
; 1835 : 		int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 1836 : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@MeanImageC
$LN5@MeanImageC:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@MeanImageC:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@MeanImageC

; 1837 : 		{
; 1838 : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$3[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], eax

; 1839 : 			Dest[Index + 3] = A;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	mov	dl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [ecx+3], dl

; 1840 : 			Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	mov	cl, BYTE PTR _R$[ebp]
	mov	BYTE PTR [eax+2], cl

; 1841 : 			Dest[Index + 1] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR _G$[ebp]
	mov	BYTE PTR [edx+1], al

; 1842 : 			Dest[Index + 0] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	mov	dl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [ecx], dl

; 1843 : 		}

	jmp	SHORT $LN5@MeanImageC
$LN6@MeanImageC:

; 1844 : 	}

	jmp	SHORT $LN2@MeanImageC
$LN3@MeanImageC:

; 1845 : 
; 1846 : 	return Success;

	xor	eax, eax
$LN1@MeanImageC:

; 1847 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_MeanImageColor2@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_B_Accumulator$ = -68					; size = 8
_G_Accumulator$ = -60					; size = 8
_R_Accumulator$ = -52					; size = 8
_A_Accumulator$ = -44					; size = 8
_Final$ = -36						; size = 4
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Count$ = -24						; size = 4
_Index$2 = -20						; size = 4
_Src$ = -16						; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_B$ = -4						; size = 1
_G$ = -3						; size = 1
_R$ = -2						; size = 1
_A$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_MeanImageColorValue@16 PROC

; 1770 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 1771 : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@MeanImageC

; 1772 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@MeanImageC
$LN8@MeanImageC:

; 1773 : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1774 : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1775 : 
; 1776 : 	double A_Accumulator = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _A_Accumulator$[ebp], xmm0

; 1777 : 	double R_Accumulator = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _R_Accumulator$[ebp], xmm0

; 1778 : 	double G_Accumulator = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _G_Accumulator$[ebp], xmm0

; 1779 : 	double B_Accumulator = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _B_Accumulator$[ebp], xmm0

; 1780 : 
; 1781 : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@MeanImageC
$LN2@MeanImageC:
	mov	ecx, DWORD PTR _Row$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$4[ebp], ecx
$LN4@MeanImageC:
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	$LN3@MeanImageC

; 1782 : 	{
; 1783 : 		int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 1784 : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@MeanImageC
$LN5@MeanImageC:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@MeanImageC:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@MeanImageC

; 1785 : 		{
; 1786 : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$3[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], eax

; 1787 : 			A_Accumulator += (double)Src[Index + 3];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	cvtsi2sd xmm0, edx
	addsd	xmm0, QWORD PTR _A_Accumulator$[ebp]
	movsd	QWORD PTR _A_Accumulator$[ebp], xmm0

; 1788 : 			R_Accumulator += (double)Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2sd xmm0, ecx
	addsd	xmm0, QWORD PTR _R_Accumulator$[ebp]
	movsd	QWORD PTR _R_Accumulator$[ebp], xmm0

; 1789 : 			G_Accumulator += (double)Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cvtsi2sd xmm0, eax
	addsd	xmm0, QWORD PTR _G_Accumulator$[ebp]
	movsd	QWORD PTR _G_Accumulator$[ebp], xmm0

; 1790 : 			B_Accumulator += (double)Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	cvtsi2sd xmm0, edx
	addsd	xmm0, QWORD PTR _B_Accumulator$[ebp]
	movsd	QWORD PTR _B_Accumulator$[ebp], xmm0

; 1791 : 		}

	jmp	SHORT $LN5@MeanImageC
$LN6@MeanImageC:

; 1792 : 	}

	jmp	$LN2@MeanImageC
$LN3@MeanImageC:

; 1793 : 
; 1794 : 	int Count = Width * Height;

	mov	eax, DWORD PTR _Width$[ebp]
	imul	eax, DWORD PTR _Height$[ebp]
	mov	DWORD PTR _Count$[ebp], eax

; 1795 : 	A_Accumulator = A_Accumulator / (double)Count;

	cvtsi2sd xmm0, DWORD PTR _Count$[ebp]
	movsd	xmm1, QWORD PTR _A_Accumulator$[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _A_Accumulator$[ebp], xmm1

; 1796 : 	R_Accumulator = R_Accumulator / (double)Count;

	cvtsi2sd xmm0, DWORD PTR _Count$[ebp]
	movsd	xmm1, QWORD PTR _R_Accumulator$[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _R_Accumulator$[ebp], xmm1

; 1797 : 	G_Accumulator = G_Accumulator / (double)Count;

	cvtsi2sd xmm0, DWORD PTR _Count$[ebp]
	movsd	xmm1, QWORD PTR _G_Accumulator$[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _G_Accumulator$[ebp], xmm1

; 1798 : 	B_Accumulator = B_Accumulator / (double)Count;

	cvtsi2sd xmm0, DWORD PTR _Count$[ebp]
	movsd	xmm1, QWORD PTR _B_Accumulator$[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _B_Accumulator$[ebp], xmm1

; 1799 : 	BYTE A = (BYTE)A_Accumulator;

	cvttsd2si ecx, QWORD PTR _A_Accumulator$[ebp]
	mov	BYTE PTR _A$[ebp], cl

; 1800 : 	BYTE R = (BYTE)R_Accumulator;

	cvttsd2si edx, QWORD PTR _R_Accumulator$[ebp]
	mov	BYTE PTR _R$[ebp], dl

; 1801 : 	BYTE G = (BYTE)G_Accumulator;

	cvttsd2si eax, QWORD PTR _G_Accumulator$[ebp]
	mov	BYTE PTR _G$[ebp], al

; 1802 : 	BYTE B = (BYTE)B_Accumulator;

	cvttsd2si ecx, QWORD PTR _B_Accumulator$[ebp]
	mov	BYTE PTR _B$[ebp], cl

; 1803 : 	UINT32 Final = (A << 24) | (R << 16) | (G << 8) | (B << 0);

	movzx	edx, BYTE PTR _A$[ebp]
	shl	edx, 24					; 00000018H
	movzx	eax, BYTE PTR _R$[ebp]
	shl	eax, 16					; 00000010H
	or	edx, eax
	movzx	ecx, BYTE PTR _G$[ebp]
	shl	ecx, 8
	or	edx, ecx
	movzx	eax, BYTE PTR _B$[ebp]
	or	edx, eax
	mov	DWORD PTR _Final$[ebp], edx

; 1804 : 	return Final;

	mov	eax, DWORD PTR _Final$[ebp]
$LN1@MeanImageC:

; 1805 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_MeanImageColorValue@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SepiaTone@20 PROC

; 945  : {

	push	ebp
	mov	ebp, esp

; 946  : #if 0
; 947  : 	if (Source == NULL)
; 948  : 		return NullPointer;
; 949  : 	if (Destination == NULL)
; 950  : 		return NullPointer;
; 951  : 
; 952  : 	int PixelSize = 4;
; 953  : 	BYTE *Src = (BYTE *)Source;
; 954  : 	BYTE *Dest = (BYTE *)Destination;
; 955  : 
; 956  : 	for (int Row = 0; Row < Height; Row++)
; 957  : 	{
; 958  : 		int RowOffset = Row * Stride;
; 959  : 		for (int Column = 0; Column < Width; Column++)
; 960  : 		{
; 961  : 			int Index = (Column * PixelSize) + RowOffset;
; 962  : 			BYTE R = Src[Index + 2];
; 963  : 			BYTE G = Src[Index + 1];
; 964  : 			BYTE B = Src[Index + 0];
; 965  : 
; 966  : 			Dest[Index + 3] = Src[Index + 3];
; 967  : 			Dest[Index + 2] = min(((double)R * 0.393) + ((double)G * 0.769) + ((double)B * 0.189), 255);
; 968  : 			Dest[Index + 1] = min(((double)R * 0.349) + ((double)G * 0.686) + ((double)B * 0.168), 255);
; 969  : 			Dest[Index + 0] = min(((double)R * 0.272) + ((double)G * 0.534) + ((double)B * 0.131), 255);
; 970  : 		}
; 971  : 	}
; 972  : 	return Success;
; 973  : #else
; 974  : 	return SepiaToneRegion(Source, Width, Height, Stride, Destination, 0, 0, Width - 1, Height - 1, TRUE, 0x0);

	push	0
	push	1
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_SepiaToneRegion@44

; 975  : #endif
; 976  : }

	pop	ebp
	ret	20					; 00000014H
_SepiaTone@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
tv221 = -60						; size = 8
tv193 = -52						; size = 8
tv165 = -44						; size = 8
_RowOffset$1 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_Row$2 = -28						; size = 4
_Column$3 = -24						; size = 4
_Src$ = -20						; size = 4
_Dest$ = -16						; size = 4
_Index$4 = -12						; size = 4
_NonOpB$ = -7						; size = 1
_NonOpG$ = -6						; size = 1
_NonOpR$ = -5						; size = 1
_NonOpA$ = -4						; size = 1
_B$5 = -3						; size = 1
_G$6 = -2						; size = 1
_R$7 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Left$ = 28						; size = 4
_Top$ = 32						; size = 4
_Right$ = 36						; size = 4
_Bottom$ = 40						; size = 4
_CopyOutOfRegion$ = 44					; size = 4
_PackedOut$ = 48					; size = 4
_SepiaToneRegion@44 PROC

; 874  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 875  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@SepiaToneR

; 876  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SepiaToneR
$LN8@SepiaToneR:

; 877  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@SepiaToneR

; 878  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SepiaToneR
$LN9@SepiaToneR:

; 879  : 	if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN10@SepiaToneR

; 880  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@SepiaToneR
$LN10@SepiaToneR:

; 881  : 	if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN11@SepiaToneR

; 882  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@SepiaToneR
$LN11@SepiaToneR:

; 883  : 	if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN12@SepiaToneR

; 884  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@SepiaToneR
$LN12@SepiaToneR:

; 885  : 	if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN13@SepiaToneR

; 886  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@SepiaToneR
$LN13@SepiaToneR:

; 887  : 
; 888  : 	BYTE NonOpA = (PackedOut & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _NonOpA$[ebp], dl

; 889  : 	BYTE NonOpR = (PackedOut & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedOut$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _NonOpR$[ebp], al

; 890  : 	BYTE NonOpG = (PackedOut & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedOut$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _NonOpG$[ebp], cl

; 891  : 	BYTE NonOpB = (PackedOut & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _NonOpB$[ebp], dl

; 892  : 
; 893  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 894  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 895  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 896  : 
; 897  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$2[ebp], 0
	jmp	SHORT $LN4@SepiaToneR
$LN2@SepiaToneR:
	mov	edx, DWORD PTR _Row$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$2[ebp], edx
$LN4@SepiaToneR:
	mov	eax, DWORD PTR _Row$2[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@SepiaToneR

; 898  : 	{
; 899  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$2[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 900  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@SepiaToneR
$LN5@SepiaToneR:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@SepiaToneR:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@SepiaToneR

; 901  : 		{
; 902  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 903  : 			BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$7[ebp], al

; 904  : 			BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$6[ebp], dl

; 905  : 			BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$5[ebp], cl

; 906  : 			if ((Column >= Left) && (Column <= Right) && (Row >= Top) && (Row <= Bottom))

	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _Left$[ebp]
	jl	$LN14@SepiaToneR
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _Right$[ebp]
	jg	$LN14@SepiaToneR
	mov	ecx, DWORD PTR _Row$2[ebp]
	cmp	ecx, DWORD PTR _Top$[ebp]
	jl	$LN14@SepiaToneR
	mov	edx, DWORD PTR _Row$2[ebp]
	cmp	edx, DWORD PTR _Bottom$[ebp]
	jg	$LN14@SepiaToneR

; 907  : 			{
; 908  : 				Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 909  : 				Dest[Index + 2] = min(((double)R * 0.393) + ((double)G * 0.769) + ((double)B * 0.189), 255);

	movzx	eax, BYTE PTR _R$7[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3fd926e978d4fdf4
	movzx	ecx, BYTE PTR _G$6[ebp]
	cvtsi2sd xmm1, ecx
	mulsd	xmm1, QWORD PTR __real@3fe89ba5e353f7cf
	addsd	xmm0, xmm1
	movzx	edx, BYTE PTR _B$5[ebp]
	cvtsi2sd xmm1, edx
	mulsd	xmm1, QWORD PTR __real@3fc83126e978d4fe
	addsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN19@SepiaToneR
	movzx	eax, BYTE PTR _R$7[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3fd926e978d4fdf4
	movzx	ecx, BYTE PTR _G$6[ebp]
	cvtsi2sd xmm1, ecx
	mulsd	xmm1, QWORD PTR __real@3fe89ba5e353f7cf
	addsd	xmm0, xmm1
	movzx	edx, BYTE PTR _B$5[ebp]
	cvtsi2sd xmm1, edx
	mulsd	xmm1, QWORD PTR __real@3fc83126e978d4fe
	addsd	xmm0, xmm1
	movsd	QWORD PTR tv165[ebp], xmm0
	jmp	SHORT $LN20@SepiaToneR
$LN19@SepiaToneR:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv165[ebp], xmm0
$LN20@SepiaToneR:
	cvttsd2si eax, QWORD PTR tv165[ebp]
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx+2], al

; 910  : 				Dest[Index + 1] = min(((double)R * 0.349) + ((double)G * 0.686) + ((double)B * 0.168), 255);

	movzx	edx, BYTE PTR _R$7[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR __real@3fd65604189374bc
	movzx	eax, BYTE PTR _G$6[ebp]
	cvtsi2sd xmm1, eax
	mulsd	xmm1, QWORD PTR __real@3fe5f3b645a1cac1
	addsd	xmm0, xmm1
	movzx	ecx, BYTE PTR _B$5[ebp]
	cvtsi2sd xmm1, ecx
	mulsd	xmm1, QWORD PTR __real@3fc5810624dd2f1b
	addsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN21@SepiaToneR
	movzx	edx, BYTE PTR _R$7[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR __real@3fd65604189374bc
	movzx	eax, BYTE PTR _G$6[ebp]
	cvtsi2sd xmm1, eax
	mulsd	xmm1, QWORD PTR __real@3fe5f3b645a1cac1
	addsd	xmm0, xmm1
	movzx	ecx, BYTE PTR _B$5[ebp]
	cvtsi2sd xmm1, ecx
	mulsd	xmm1, QWORD PTR __real@3fc5810624dd2f1b
	addsd	xmm0, xmm1
	movsd	QWORD PTR tv193[ebp], xmm0
	jmp	SHORT $LN22@SepiaToneR
$LN21@SepiaToneR:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv193[ebp], xmm0
$LN22@SepiaToneR:
	cvttsd2si edx, QWORD PTR tv193[ebp]
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [eax+1], dl

; 911  : 				Dest[Index + 0] = min(((double)R * 0.272) + ((double)G * 0.534) + ((double)B * 0.131), 255);

	movzx	ecx, BYTE PTR _R$7[ebp]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR __real@3fd16872b020c49c
	movzx	edx, BYTE PTR _G$6[ebp]
	cvtsi2sd xmm1, edx
	mulsd	xmm1, QWORD PTR __real@3fe116872b020c4a
	addsd	xmm0, xmm1
	movzx	eax, BYTE PTR _B$5[ebp]
	cvtsi2sd xmm1, eax
	mulsd	xmm1, QWORD PTR __real@3fc0c49ba5e353f8
	addsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN23@SepiaToneR
	movzx	ecx, BYTE PTR _R$7[ebp]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR __real@3fd16872b020c49c
	movzx	edx, BYTE PTR _G$6[ebp]
	cvtsi2sd xmm1, edx
	mulsd	xmm1, QWORD PTR __real@3fe116872b020c4a
	addsd	xmm0, xmm1
	movzx	eax, BYTE PTR _B$5[ebp]
	cvtsi2sd xmm1, eax
	mulsd	xmm1, QWORD PTR __real@3fc0c49ba5e353f8
	addsd	xmm0, xmm1
	movsd	QWORD PTR tv221[ebp], xmm0
	jmp	SHORT $LN24@SepiaToneR
$LN23@SepiaToneR:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv221[ebp], xmm0
$LN24@SepiaToneR:
	cvttsd2si ecx, QWORD PTR tv221[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx], cl

; 912  : 			}
; 913  : 			else

	jmp	SHORT $LN17@SepiaToneR
$LN14@SepiaToneR:

; 914  : 			{
; 915  : 				if (CopyOutOfRegion)

	cmp	DWORD PTR _CopyOutOfRegion$[ebp], 0
	je	SHORT $LN16@SepiaToneR

; 916  : 				{
; 917  : 					Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 918  : 					Dest[Index + 2] = Src[Index + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 919  : 					Dest[Index + 1] = Src[Index + 1];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 920  : 					Dest[Index + 0] = Src[Index + 0];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 921  : 				}
; 922  : 				else

	jmp	SHORT $LN17@SepiaToneR
$LN16@SepiaToneR:

; 923  : 				{
; 924  : 					Dest[Index + 3] = NonOpA;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _NonOpA$[ebp]
	mov	BYTE PTR [eax+3], cl

; 925  : 					Dest[Index + 2] = NonOpR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _NonOpR$[ebp]
	mov	BYTE PTR [edx+2], al

; 926  : 					Dest[Index + 1] = NonOpG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _NonOpG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 927  : 					Dest[Index + 0] = NonOpB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _NonOpB$[ebp]
	mov	BYTE PTR [eax], cl
$LN17@SepiaToneR:

; 928  : 				}
; 929  : 			}
; 930  : 		}

	jmp	$LN5@SepiaToneR
$LN6@SepiaToneR:

; 931  : 	}

	jmp	$LN2@SepiaToneR
$LN3@SepiaToneR:

; 932  : 	return Success;

	xor	eax, eax
$LN1@SepiaToneR:

; 933  : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_SepiaToneRegion@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_PixLuminance$1 = -68					; size = 8
$T2 = -60						; size = 4
_RowOffset$3 = -56					; size = 4
_PixelSize$ = -52					; size = 4
$T4 = -48						; size = 4
_Column$5 = -44						; size = 4
_Row$6 = -40						; size = 4
_ColorIndex$7 = -36					; size = 4
_Dest$ = -32						; size = 4
_Src$ = -28						; size = 4
_NodeIndex$8 = -24					; size = 4
_RawNodes$ = -20					; size = 4
_TNodes$ = -16						; size = 4
_Index$9 = -12						; size = 4
_i$10 = -8						; size = 4
_R$11 = -3						; size = 1
_G$12 = -2						; size = 1
_B$13 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_ThresholdList$ = 28					; size = 4
_ListCount$ = 32					; size = 4
_ColorThreshold3@28 PROC

; 1197 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi

; 1198 : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN14@ColorThres

; 1199 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ColorThres
$LN14@ColorThres:

; 1200 : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN15@ColorThres

; 1201 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ColorThres
$LN15@ColorThres:

; 1202 : 	if (ThresholdList == NULL)

	cmp	DWORD PTR _ThresholdList$[ebp], 0
	jne	SHORT $LN16@ColorThres

; 1203 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ColorThres
$LN16@ColorThres:

; 1204 : 	if (ListCount < 1)

	cmp	DWORD PTR _ListCount$[ebp], 1
	jge	SHORT $LN17@ColorThres

; 1205 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ColorThres
$LN17@ColorThres:

; 1206 : 
; 1207 : 	ThresholdListType *RawNodes = (ThresholdListType *)ThresholdList;

	mov	eax, DWORD PTR _ThresholdList$[ebp]
	mov	DWORD PTR _RawNodes$[ebp], eax

; 1208 : 	ThresholdNode *TNodes = new ThresholdNode[ListCount];

	xor	ecx, ecx
	mov	eax, DWORD PTR _ListCount$[ebp]
	mov	edx, 32					; 00000020H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _TNodes$[ebp], eax

; 1209 : 	for (int i = 0; i < ListCount; i++)

	mov	DWORD PTR _i$10[ebp], 0
	jmp	SHORT $LN4@ColorThres
$LN2@ColorThres:
	mov	ecx, DWORD PTR _i$10[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$10[ebp], ecx
$LN4@ColorThres:
	mov	edx, DWORD PTR _i$10[ebp]
	cmp	edx, DWORD PTR _ListCount$[ebp]
	jge	$LN3@ColorThres

; 1210 : 	{
; 1211 : 		if (RawNodes[i].LowThreshold >= RawNodes[i].HighThreshold)

	imul	eax, DWORD PTR _i$10[ebp], 24
	imul	ecx, DWORD PTR _i$10[ebp], 24
	mov	edx, DWORD PTR _RawNodes$[ebp]
	mov	esi, DWORD PTR _RawNodes$[ebp]
	movsd	xmm0, QWORD PTR [edx+eax]
	comisd	xmm0, QWORD PTR [esi+ecx+8]
	jb	SHORT $LN18@ColorThres

; 1212 : 		{
; 1213 : 			TNodes[i].IsValid = FALSE;

	mov	eax, DWORD PTR _i$10[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _TNodes$[ebp]
	mov	DWORD PTR [ecx+eax], 0

; 1214 : 			continue;

	jmp	SHORT $LN2@ColorThres
$LN18@ColorThres:

; 1215 : 		}
; 1216 : 		TNodes[i].IsValid = TRUE;

	mov	edx, DWORD PTR _i$10[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _TNodes$[ebp]
	mov	DWORD PTR [eax+edx], 1

; 1217 : 		TNodes[i].LowThreshold = RawNodes[i].LowThreshold;

	imul	ecx, DWORD PTR _i$10[ebp], 24
	mov	edx, DWORD PTR _i$10[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _TNodes$[ebp]
	mov	esi, DWORD PTR _RawNodes$[ebp]
	movsd	xmm0, QWORD PTR [esi+ecx]
	movsd	QWORD PTR [eax+edx+8], xmm0

; 1218 : 		TNodes[i].HighThreshold = RawNodes[i].HighThreshold;

	imul	ecx, DWORD PTR _i$10[ebp], 24
	mov	edx, DWORD PTR _i$10[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _TNodes$[ebp]
	mov	esi, DWORD PTR _RawNodes$[ebp]
	movsd	xmm0, QWORD PTR [esi+ecx+8]
	movsd	QWORD PTR [eax+edx+16], xmm0

; 1219 : 		TNodes[i].R = (RawNodes[i].PackedColor & 0x00ff0000) >> 16;

	imul	ecx, DWORD PTR _i$10[ebp], 24
	mov	edx, DWORD PTR _RawNodes$[ebp]
	mov	eax, DWORD PTR [edx+ecx+16]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _i$10[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _TNodes$[ebp]
	mov	BYTE PTR [edx+ecx+24], al

; 1220 : 		TNodes[i].G = (RawNodes[i].PackedColor & 0x0000ff00) >> 8;

	imul	eax, DWORD PTR _i$10[ebp], 24
	mov	ecx, DWORD PTR _RawNodes$[ebp]
	mov	edx, DWORD PTR [ecx+eax+16]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	eax, DWORD PTR _i$10[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _TNodes$[ebp]
	mov	BYTE PTR [ecx+eax+25], dl

; 1221 : 		TNodes[i].B = (RawNodes[i].PackedColor & 0x000000ff) >> 0;

	imul	edx, DWORD PTR _i$10[ebp], 24
	mov	eax, DWORD PTR _RawNodes$[ebp]
	mov	ecx, DWORD PTR [eax+edx+16]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _i$10[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _TNodes$[ebp]
	mov	BYTE PTR [eax+edx+26], cl

; 1222 : 	}

	jmp	$LN2@ColorThres
$LN3@ColorThres:

; 1223 : 
; 1224 : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1225 : 	BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 1226 : 	BYTE *Dest = (BYTE *)Destination;

	mov	edx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], edx

; 1227 : 
; 1228 : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN7@ColorThres
$LN5@ColorThres:
	mov	eax, DWORD PTR _Row$6[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$6[ebp], eax
$LN7@ColorThres:
	mov	ecx, DWORD PTR _Row$6[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN6@ColorThres

; 1229 : 	{
; 1230 : 		int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$6[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], edx

; 1231 : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN10@ColorThres
$LN8@ColorThres:
	mov	eax, DWORD PTR _Column$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$5[ebp], eax
$LN10@ColorThres:
	mov	ecx, DWORD PTR _Column$5[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	$LN9@ColorThres

; 1232 : 		{
; 1233 : 			int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$5[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$9[ebp], edx

; 1234 : 			Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 1235 : 			BYTE R = Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _R$11[ebp], cl

; 1236 : 			BYTE G = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _G$12[ebp], al

; 1237 : 			BYTE B = Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _B$13[ebp], dl

; 1238 : 			double PixLuminance = NormalizedColorLuminance(R, G, B, TRUE);

	push	1
	movzx	eax, BYTE PTR _B$13[ebp]
	push	eax
	movzx	ecx, BYTE PTR _G$12[ebp]
	push	ecx
	movzx	edx, BYTE PTR _R$11[ebp]
	push	edx
	call	?NormalizedColorLuminance@@YGNEEEH@Z	; NormalizedColorLuminance
	fstp	QWORD PTR _PixLuminance$1[ebp]

; 1239 : 			int ColorIndex = -1;

	mov	DWORD PTR _ColorIndex$7[ebp], -1

; 1240 : 			for (int NodeIndex = 0; NodeIndex < ListCount; NodeIndex++)

	mov	DWORD PTR _NodeIndex$8[ebp], 0
	jmp	SHORT $LN13@ColorThres
$LN11@ColorThres:
	mov	eax, DWORD PTR _NodeIndex$8[ebp]
	add	eax, 1
	mov	DWORD PTR _NodeIndex$8[ebp], eax
$LN13@ColorThres:
	mov	ecx, DWORD PTR _NodeIndex$8[ebp]
	cmp	ecx, DWORD PTR _ListCount$[ebp]
	jge	SHORT $LN12@ColorThres

; 1241 : 			{
; 1242 : 				if (!TNodes[NodeIndex].IsValid)

	mov	edx, DWORD PTR _NodeIndex$8[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _TNodes$[ebp]
	cmp	DWORD PTR [eax+edx], 0
	jne	SHORT $LN19@ColorThres

; 1243 : 					continue;

	jmp	SHORT $LN11@ColorThres
$LN19@ColorThres:

; 1244 : 				if ((PixLuminance >= TNodes[NodeIndex].LowThreshold) && (PixLuminance <= TNodes[NodeIndex].HighThreshold))

	mov	ecx, DWORD PTR _NodeIndex$8[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _TNodes$[ebp]
	movsd	xmm0, QWORD PTR _PixLuminance$1[ebp]
	comisd	xmm0, QWORD PTR [edx+ecx+8]
	jb	SHORT $LN20@ColorThres
	mov	eax, DWORD PTR _NodeIndex$8[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _TNodes$[ebp]
	movsd	xmm0, QWORD PTR [ecx+eax+16]
	comisd	xmm0, QWORD PTR _PixLuminance$1[ebp]
	jb	SHORT $LN20@ColorThres

; 1245 : 				{
; 1246 : 					ColorIndex = NodeIndex;

	mov	edx, DWORD PTR _NodeIndex$8[ebp]
	mov	DWORD PTR _ColorIndex$7[ebp], edx

; 1247 : 					break;

	jmp	SHORT $LN12@ColorThres
$LN20@ColorThres:

; 1248 : 				}
; 1249 : 			}

	jmp	SHORT $LN11@ColorThres
$LN12@ColorThres:

; 1250 : 			if (ColorIndex < 0)

	cmp	DWORD PTR _ColorIndex$7[ebp], 0
	jge	SHORT $LN21@ColorThres

; 1251 : 			{
; 1252 : 				Dest[Index + 2] = Src[Index + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 1253 : 				Dest[Index + 1] = Src[Index + 1];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 1254 : 				Dest[Index + 0] = Src[Index + 0];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 1255 : 			}
; 1256 : 			else

	jmp	SHORT $LN22@ColorThres
$LN21@ColorThres:

; 1257 : 			{
; 1258 : 				Dest[Index + 2] = TNodes[ColorIndex].R;

	mov	eax, DWORD PTR _ColorIndex$7[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	edx, DWORD PTR _TNodes$[ebp]
	mov	al, BYTE PTR [edx+eax+24]
	mov	BYTE PTR [ecx+2], al

; 1259 : 				Dest[Index + 1] = TNodes[ColorIndex].G;

	mov	ecx, DWORD PTR _ColorIndex$7[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _TNodes$[ebp]
	mov	cl, BYTE PTR [eax+ecx+25]
	mov	BYTE PTR [edx+1], cl

; 1260 : 				Dest[Index + 0] = TNodes[ColorIndex].B;

	mov	edx, DWORD PTR _ColorIndex$7[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	ecx, DWORD PTR _TNodes$[ebp]
	mov	dl, BYTE PTR [ecx+edx+26]
	mov	BYTE PTR [eax], dl
$LN22@ColorThres:

; 1261 : 			}
; 1262 : 		}

	jmp	$LN8@ColorThres
$LN9@ColorThres:

; 1263 : 	}

	jmp	$LN5@ColorThres
$LN6@ColorThres:

; 1264 : 
; 1265 : 	delete[] TNodes;

	mov	eax, DWORD PTR _TNodes$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 1266 : 	return Success;

	xor	eax, eax
$LN1@ColorThres:

; 1267 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_ColorThreshold3@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_PixLuminance$1 = -48					; size = 8
_RowOffset$2 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_Src$ = -32						; size = 4
_Column$3 = -28						; size = 4
_Row$4 = -24						; size = 4
_Dest$ = -20						; size = 4
_Index$5 = -16						; size = 4
_HighB$ = -9						; size = 1
_HighG$ = -8						; size = 1
_HighR$ = -7						; size = 1
_LowB$ = -6						; size = 1
_LowG$ = -5						; size = 1
_LowR$ = -4						; size = 1
_B$6 = -3						; size = 1
_G$7 = -2						; size = 1
_R$8 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_LowThreshold$ = 28					; size = 8
_PackedLowColor$ = 36					; size = 4
_HighThreshold$ = 40					; size = 8
_PackedHighColor$ = 48					; size = 4
_ColorThreshold2@44 PROC

; 1113 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 1114 : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ColorThres

; 1115 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ColorThres
$LN8@ColorThres:

; 1116 : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ColorThres

; 1117 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ColorThres
$LN9@ColorThres:

; 1118 : 
; 1119 : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1120 : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1121 : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1122 : 	BYTE LowR = (PackedLowColor & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _PackedLowColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _LowR$[ebp], dl

; 1123 : 	BYTE LowG = (PackedLowColor & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _PackedLowColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _LowG$[ebp], al

; 1124 : 	BYTE LowB = (PackedLowColor & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _PackedLowColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _LowB$[ebp], cl

; 1125 : 	BYTE HighR = (PackedHighColor & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _PackedHighColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _HighR$[ebp], dl

; 1126 : 	BYTE HighG = (PackedHighColor & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _PackedHighColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _HighG$[ebp], al

; 1127 : 	BYTE HighB = (PackedHighColor & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _PackedHighColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _HighB$[ebp], cl

; 1128 : 
; 1129 : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@ColorThres
$LN2@ColorThres:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@ColorThres:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@ColorThres

; 1130 : 	{
; 1131 : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 1132 : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@ColorThres
$LN5@ColorThres:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@ColorThres:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@ColorThres

; 1133 : 		{
; 1134 : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 1135 : 			Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1136 : 			BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$8[ebp], al

; 1137 : 			BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$7[ebp], dl

; 1138 : 			BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$6[ebp], cl

; 1139 : 			double PixLuminance = NormalizedColorLuminance(R, G, B, TRUE);

	push	1
	movzx	edx, BYTE PTR _B$6[ebp]
	push	edx
	movzx	eax, BYTE PTR _G$7[ebp]
	push	eax
	movzx	ecx, BYTE PTR _R$8[ebp]
	push	ecx
	call	?NormalizedColorLuminance@@YGNEEEH@Z	; NormalizedColorLuminance
	fstp	QWORD PTR _PixLuminance$1[ebp]

; 1140 : 			if (PixLuminance <= LowThreshold)

	movsd	xmm0, QWORD PTR _LowThreshold$[ebp]
	comisd	xmm0, QWORD PTR _PixLuminance$1[ebp]
	jb	SHORT $LN10@ColorThres

; 1141 : 			{
; 1142 : 				//Use the low threshold color.
; 1143 : 				Dest[Index + 2] = LowR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _LowR$[ebp]
	mov	BYTE PTR [edx+2], al

; 1144 : 				Dest[Index + 1] = LowG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _LowG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1145 : 				Dest[Index + 0] = LowB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _LowB$[ebp]
	mov	BYTE PTR [eax], cl

; 1146 : 			}
; 1147 : 			else

	jmp	SHORT $LN13@ColorThres
$LN10@ColorThres:

; 1148 : 				if (PixLuminance >= HighThreshold)

	movsd	xmm0, QWORD PTR _PixLuminance$1[ebp]
	comisd	xmm0, QWORD PTR _HighThreshold$[ebp]
	jb	SHORT $LN12@ColorThres

; 1149 : 				{
; 1150 : 					//Use the high threshold color.
; 1151 : 					Dest[Index + 2] = HighR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _HighR$[ebp]
	mov	BYTE PTR [edx+2], al

; 1152 : 					Dest[Index + 1] = HighG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _HighG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1153 : 					Dest[Index + 0] = HighB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _HighB$[ebp]
	mov	BYTE PTR [eax], cl

; 1154 : 				}
; 1155 : 				else

	jmp	SHORT $LN13@ColorThres
$LN12@ColorThres:

; 1156 : 				{
; 1157 : 					//Copy unmodified source data.
; 1158 : 					Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _R$8[ebp]
	mov	BYTE PTR [edx+2], al

; 1159 : 					Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _G$7[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1160 : 					Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _B$6[ebp]
	mov	BYTE PTR [eax], cl
$LN13@ColorThres:

; 1161 : 				}
; 1162 : 		}

	jmp	$LN5@ColorThres
$LN6@ColorThres:

; 1163 : 	}

	jmp	$LN2@ColorThres
$LN3@ColorThres:

; 1164 : 
; 1165 : 	return Success;

	xor	eax, eax
$LN1@ColorThres:

; 1166 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_ColorThreshold2@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_PixLuminance$1 = -48					; size = 8
_RowOffset$2 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_Src$ = -32						; size = 4
_Column$3 = -28						; size = 4
_Row$4 = -24						; size = 4
_Dest$ = -20						; size = 4
_Index$5 = -16						; size = 4
_HighB$ = -9						; size = 1
_HighG$ = -8						; size = 1
_HighR$ = -7						; size = 1
_LowB$ = -6						; size = 1
_LowG$ = -5						; size = 1
_LowR$ = -4						; size = 1
_R$6 = -3						; size = 1
_G$7 = -2						; size = 1
_B$8 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Threshold$ = 28					; size = 8
_PackedLowColor$ = 36					; size = 4
_PackedHighColor$ = 40					; size = 4
_ColorThreshold@36 PROC

; 1052 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 1053 : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ColorThres

; 1054 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ColorThres
$LN8@ColorThres:

; 1055 : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ColorThres

; 1056 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ColorThres
$LN9@ColorThres:

; 1057 : 
; 1058 : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1059 : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1060 : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1061 : 	BYTE LowR = (PackedLowColor & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _PackedLowColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _LowR$[ebp], dl

; 1062 : 	BYTE LowG = (PackedLowColor & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _PackedLowColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _LowG$[ebp], al

; 1063 : 	BYTE LowB = (PackedLowColor & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _PackedLowColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _LowB$[ebp], cl

; 1064 : 	BYTE HighR = (PackedHighColor & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _PackedHighColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _HighR$[ebp], dl

; 1065 : 	BYTE HighG = (PackedHighColor & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _PackedHighColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _HighG$[ebp], al

; 1066 : 	BYTE HighB = (PackedHighColor & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _PackedHighColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _HighB$[ebp], cl

; 1067 : 
; 1068 : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@ColorThres
$LN2@ColorThres:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@ColorThres:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@ColorThres

; 1069 : 	{
; 1070 : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 1071 : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@ColorThres
$LN5@ColorThres:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@ColorThres:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@ColorThres

; 1072 : 		{
; 1073 : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 1074 : 			Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1075 : 			BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$6[ebp], al

; 1076 : 			BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$7[ebp], dl

; 1077 : 			BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$8[ebp], cl

; 1078 : 			double PixLuminance = NormalizedColorLuminance(R, G, B, TRUE);

	push	1
	movzx	edx, BYTE PTR _B$8[ebp]
	push	edx
	movzx	eax, BYTE PTR _G$7[ebp]
	push	eax
	movzx	ecx, BYTE PTR _R$6[ebp]
	push	ecx
	call	?NormalizedColorLuminance@@YGNEEEH@Z	; NormalizedColorLuminance
	fstp	QWORD PTR _PixLuminance$1[ebp]

; 1079 : 			if (PixLuminance < Threshold)

	movsd	xmm0, QWORD PTR _Threshold$[ebp]
	comisd	xmm0, QWORD PTR _PixLuminance$1[ebp]
	jbe	SHORT $LN10@ColorThres

; 1080 : 			{
; 1081 : 				Dest[Index + 2] = LowR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _LowR$[ebp]
	mov	BYTE PTR [edx+2], al

; 1082 : 				Dest[Index + 1] = LowG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _LowG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1083 : 				Dest[Index + 0] = LowB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _LowB$[ebp]
	mov	BYTE PTR [eax], cl

; 1084 : 			}
; 1085 : 			else

	jmp	SHORT $LN11@ColorThres
$LN10@ColorThres:

; 1086 : 			{
; 1087 : 				Dest[Index + 2] = HighR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _HighR$[ebp]
	mov	BYTE PTR [edx+2], al

; 1088 : 				Dest[Index + 1] = HighG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _HighG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1089 : 				Dest[Index + 0] = HighB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _HighB$[ebp]
	mov	BYTE PTR [eax], cl
$LN11@ColorThres:

; 1090 : 			}
; 1091 : 		}

	jmp	$LN5@ColorThres
$LN6@ColorThres:

; 1092 : 	}

	jmp	$LN2@ColorThres
$LN3@ColorThres:

; 1093 : 
; 1094 : 	return Success;

	xor	eax, eax
$LN1@ColorThres:

; 1095 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_ColorThreshold@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_PixLuminance$1 = -56					; size = 8
_RowOffset$2 = -48					; size = 4
_PixelSize$ = -44					; size = 4
tv137 = -40						; size = 4
tv134 = -36						; size = 4
_ChangeColor$3 = -32					; size = 4
_Column$4 = -28						; size = 4
_Row$5 = -24						; size = 4
_Src$ = -20						; size = 4
_Dest$ = -16						; size = 4
_Index$6 = -12						; size = 4
_TColorB$ = -6						; size = 1
_TColorG$ = -5						; size = 1
_TColorR$ = -4						; size = 1
_R$7 = -3						; size = 1
_G$8 = -2						; size = 1
_B$9 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Threshold$ = 28					; size = 8
_PackedColor$ = 36					; size = 4
_InvertThreshold$ = 40					; size = 4
_ColorThreshold0@36 PROC

; 992  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 993  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ColorThres

; 994  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ColorThres
$LN8@ColorThres:

; 995  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ColorThres

; 996  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ColorThres
$LN9@ColorThres:

; 997  : 
; 998  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 999  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1000 : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1001 : 	BYTE TColorR = (PackedColor & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _PackedColor$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _TColorR$[ebp], dl

; 1002 : 	BYTE TColorG = (PackedColor & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _PackedColor$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _TColorG$[ebp], al

; 1003 : 	BYTE TColorB = (PackedColor & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _PackedColor$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _TColorB$[ebp], cl

; 1004 : 
; 1005 : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN4@ColorThres
$LN2@ColorThres:
	mov	edx, DWORD PTR _Row$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$5[ebp], edx
$LN4@ColorThres:
	mov	eax, DWORD PTR _Row$5[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@ColorThres

; 1006 : 	{
; 1007 : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$5[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 1008 : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$4[ebp], 0
	jmp	SHORT $LN7@ColorThres
$LN5@ColorThres:
	mov	edx, DWORD PTR _Column$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$4[ebp], edx
$LN7@ColorThres:
	mov	eax, DWORD PTR _Column$4[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@ColorThres

; 1009 : 		{
; 1010 : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$4[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$6[ebp], ecx

; 1011 : 			Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1012 : 			BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$7[ebp], al

; 1013 : 			BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$8[ebp], dl

; 1014 : 			BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$9[ebp], cl

; 1015 : 			double PixLuminance = NormalizedColorLuminance(R, G, B, TRUE);

	push	1
	movzx	edx, BYTE PTR _B$9[ebp]
	push	edx
	movzx	eax, BYTE PTR _G$8[ebp]
	push	eax
	movzx	ecx, BYTE PTR _R$7[ebp]
	push	ecx
	call	?NormalizedColorLuminance@@YGNEEEH@Z	; NormalizedColorLuminance
	fstp	QWORD PTR _PixLuminance$1[ebp]

; 1016 : 			BOOL ChangeColor = PixLuminance < Threshold;

	movsd	xmm0, QWORD PTR _Threshold$[ebp]
	comisd	xmm0, QWORD PTR _PixLuminance$1[ebp]
	jbe	SHORT $LN14@ColorThres
	mov	DWORD PTR tv134[ebp], 1
	jmp	SHORT $LN15@ColorThres
$LN14@ColorThres:
	mov	DWORD PTR tv134[ebp], 0
$LN15@ColorThres:
	mov	edx, DWORD PTR tv134[ebp]
	mov	DWORD PTR _ChangeColor$3[ebp], edx

; 1017 : 			if (InvertThreshold)

	cmp	DWORD PTR _InvertThreshold$[ebp], 0
	je	SHORT $LN10@ColorThres

; 1018 : 				ChangeColor = !ChangeColor;

	cmp	DWORD PTR _ChangeColor$3[ebp], 0
	jne	SHORT $LN16@ColorThres
	mov	DWORD PTR tv137[ebp], 1
	jmp	SHORT $LN17@ColorThres
$LN16@ColorThres:
	mov	DWORD PTR tv137[ebp], 0
$LN17@ColorThres:
	mov	eax, DWORD PTR tv137[ebp]
	mov	DWORD PTR _ChangeColor$3[ebp], eax
$LN10@ColorThres:

; 1019 : 			Dest[Index + 3] = Src[Index + 3];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 1020 : 			if (ChangeColor)

	cmp	DWORD PTR _ChangeColor$3[ebp], 0
	je	SHORT $LN11@ColorThres

; 1021 : 			{
; 1022 : 				Dest[Index + 2] = TColorR;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _TColorR$[ebp]
	mov	BYTE PTR [ecx+2], dl

; 1023 : 				Dest[Index + 1] = TColorG;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _TColorG$[ebp]
	mov	BYTE PTR [eax+1], cl

; 1024 : 				Dest[Index + 0] = TColorB;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _TColorB$[ebp]
	mov	BYTE PTR [edx], al

; 1025 : 			}
; 1026 : 			else

	jmp	SHORT $LN12@ColorThres
$LN11@ColorThres:

; 1027 : 			{
; 1028 : 				Dest[Index + 2] = Src[Index + 2];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 1029 : 				Dest[Index + 1] = Src[Index + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 1030 : 				Dest[Index + 0] = Src[Index + 0];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
$LN12@ColorThres:

; 1031 : 			}
; 1032 : 		}

	jmp	$LN5@ColorThres
$LN6@ColorThres:

; 1033 : 	}

	jmp	$LN2@ColorThres
$LN3@ColorThres:

; 1034 : 
; 1035 : 	return Success;

	xor	eax, eax
$LN1@ColorThres:

; 1036 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_ColorThreshold0@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Saturation$ = 28					; size = 4
_AutoSaturate@24 PROC

; 1377 : {

	push	ebp
	mov	ebp, esp

; 1378 : 	return AutoSaturateRegion(Source, Width, Height, Stride, Destination, Saturation, 0, 0, Width - 1, Height - 1, TRUE, 0x0);

	push	0
	push	1
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Saturation$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_AutoSaturateRegion@48

; 1379 : }

	pop	ebp
	ret	24					; 00000018H
_AutoSaturate@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
tv252 = -140						; size = 8
tv251 = -132						; size = 8
tv244 = -124						; size = 8
tv237 = -116						; size = 8
tv236 = -108						; size = 8
tv229 = -100						; size = 8
tv190 = -92						; size = 8
tv189 = -84						; size = 8
tv182 = -76						; size = 8
_BY1$1 = -68						; size = 4
_GY1$2 = -64						; size = 4
_RY1$3 = -60						; size = 4
_RowOffset$4 = -56					; size = 4
_PixelSize$ = -52					; size = 4
_BY$5 = -48						; size = 4
_GY$6 = -44						; size = 4
_RY$7 = -40						; size = 4
_Y$8 = -36						; size = 8
_Row$9 = -28						; size = 4
_Column$10 = -24					; size = 4
_NonOpB$ = -20						; size = 1
_NonOpG$ = -19						; size = 1
_NonOpR$ = -18						; size = 1
_NonOpA$ = -17						; size = 1
_Src$ = -16						; size = 4
_Dest$ = -12						; size = 4
_Index$11 = -8						; size = 4
_B$12 = -3						; size = 1
_G$13 = -2						; size = 1
_R$14 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Saturation$ = 28					; size = 4
_Left$ = 32						; size = 4
_Top$ = 36						; size = 4
_Right$ = 40						; size = 4
_Bottom$ = 44						; size = 4
_CopyOutOfRegion$ = 48					; size = 4
_PackedOut$ = 52					; size = 4
_AutoSaturateRegion@48 PROC

; 1290 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH

; 1291 : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@AutoSatura

; 1292 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AutoSatura
$LN8@AutoSatura:

; 1293 : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@AutoSatura

; 1294 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AutoSatura
$LN9@AutoSatura:

; 1295 : 	if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN10@AutoSatura

; 1296 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@AutoSatura
$LN10@AutoSatura:

; 1297 : 	if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN11@AutoSatura

; 1298 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@AutoSatura
$LN11@AutoSatura:

; 1299 : 	if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN12@AutoSatura

; 1300 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@AutoSatura
$LN12@AutoSatura:

; 1301 : 	if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN13@AutoSatura

; 1302 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@AutoSatura
$LN13@AutoSatura:

; 1303 : 
; 1304 : 	BYTE NonOpA = (PackedOut & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _NonOpA$[ebp], dl

; 1305 : 	BYTE NonOpR = (PackedOut & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedOut$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _NonOpR$[ebp], al

; 1306 : 	BYTE NonOpG = (PackedOut & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedOut$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _NonOpG$[ebp], cl

; 1307 : 	BYTE NonOpB = (PackedOut & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _NonOpB$[ebp], dl

; 1308 : 
; 1309 : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1310 : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1311 : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1312 : 
; 1313 : 	for (int Row = Top; Row <= Bottom; Row++)

	mov	edx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$9[ebp], edx
	jmp	SHORT $LN4@AutoSatura
$LN2@AutoSatura:
	mov	eax, DWORD PTR _Row$9[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$9[ebp], eax
$LN4@AutoSatura:
	mov	ecx, DWORD PTR _Row$9[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	$LN3@AutoSatura

; 1314 : 	{
; 1315 : 		int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$9[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], edx

; 1316 : 		for (int Column = Left; Column <= Right; Column++)

	mov	eax, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$10[ebp], eax
	jmp	SHORT $LN7@AutoSatura
$LN5@AutoSatura:
	mov	ecx, DWORD PTR _Column$10[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$10[ebp], ecx
$LN7@AutoSatura:
	mov	edx, DWORD PTR _Column$10[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	$LN6@AutoSatura

; 1317 : 		{
; 1318 : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$10[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$11[ebp], eax

; 1319 : 			if ((Column >= Left) && (Column <= Right) && (Row >= Top) && (Row <= Bottom))

	mov	ecx, DWORD PTR _Column$10[ebp]
	cmp	ecx, DWORD PTR _Left$[ebp]
	jl	$LN14@AutoSatura
	mov	edx, DWORD PTR _Column$10[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	$LN14@AutoSatura
	mov	eax, DWORD PTR _Row$9[ebp]
	cmp	eax, DWORD PTR _Top$[ebp]
	jl	$LN14@AutoSatura
	mov	ecx, DWORD PTR _Row$9[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	$LN14@AutoSatura

; 1320 : 			{
; 1321 : 				BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$11[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$14[ebp], al

; 1322 : 				BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$11[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$13[ebp], dl

; 1323 : 				BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$11[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$12[ebp], cl

; 1324 : 				double Y = (0.3 * R) + (0.59 * G) + (0.11 * B);

	movzx	edx, BYTE PTR _R$14[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR __real@3fd3333333333333
	movzx	eax, BYTE PTR _G$13[ebp]
	cvtsi2sd xmm1, eax
	mulsd	xmm1, QWORD PTR __real@3fe2e147ae147ae1
	addsd	xmm0, xmm1
	movzx	ecx, BYTE PTR _B$12[ebp]
	cvtsi2sd xmm1, ecx
	mulsd	xmm1, QWORD PTR __real@3fbc28f5c28f5c29
	addsd	xmm0, xmm1
	movsd	QWORD PTR _Y$8[ebp], xmm0

; 1325 : 
; 1326 : 				__int32 RY1 = ((int)(70 * (int)R - 59 * (int)G - 11 * (int)B) / 100);

	movzx	edx, BYTE PTR _R$14[ebp]
	imul	eax, edx, 70
	movzx	ecx, BYTE PTR _G$13[ebp]
	imul	edx, ecx, 59
	sub	eax, edx
	movzx	ecx, BYTE PTR _B$12[ebp]
	imul	edx, ecx, 11
	sub	eax, edx
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _RY1$3[ebp], eax

; 1327 : 				__int32 GY1 = ((int)(-30 * (int)R + 41 * (int)G - 11 * (int)B) / 100);

	movzx	edx, BYTE PTR _R$14[ebp]
	imul	eax, edx, -30
	movzx	ecx, BYTE PTR _G$13[ebp]
	imul	edx, ecx, 41
	add	eax, edx
	movzx	ecx, BYTE PTR _B$12[ebp]
	imul	edx, ecx, 11
	sub	eax, edx
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _GY1$2[ebp], eax

; 1328 : 				__int32 BY1 = ((int)(-30 * (int)R - 59 * (int)G + 89 * (int)B) / 100);

	movzx	edx, BYTE PTR _R$14[ebp]
	imul	eax, edx, -30
	movzx	ecx, BYTE PTR _G$13[ebp]
	imul	edx, ecx, 59
	sub	eax, edx
	movzx	ecx, BYTE PTR _B$12[ebp]
	imul	edx, ecx, 89
	add	eax, edx
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _BY1$1[ebp], eax

; 1329 : 
; 1330 : 				__int32 RY = (RY1 * Saturation) / 100;

	mov	eax, DWORD PTR _RY1$3[ebp]
	imul	eax, DWORD PTR _Saturation$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _RY$7[ebp], eax

; 1331 : 				__int32 GY = (GY1 * Saturation) / 100;

	mov	eax, DWORD PTR _GY1$2[ebp]
	imul	eax, DWORD PTR _Saturation$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _GY$6[ebp], eax

; 1332 : 				__int32 BY = (BY1 * Saturation) / 100;

	mov	eax, DWORD PTR _BY1$1[ebp]
	imul	eax, DWORD PTR _Saturation$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	DWORD PTR _BY$5[ebp], eax

; 1333 : 
; 1334 : 				R = min(max(RY + Y, 255), 0);

	cvtsi2sd xmm0, DWORD PTR _RY$7[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	comisd	xmm0, QWORD PTR __real@406fe00000000000
	jbe	SHORT $LN19@AutoSatura
	cvtsi2sd xmm0, DWORD PTR _RY$7[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	movsd	QWORD PTR tv182[ebp], xmm0
	jmp	SHORT $LN20@AutoSatura
$LN19@AutoSatura:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv182[ebp], xmm0
$LN20@AutoSatura:
	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR tv182[ebp]
	jbe	SHORT $LN23@AutoSatura
	cvtsi2sd xmm0, DWORD PTR _RY$7[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	comisd	xmm0, QWORD PTR __real@406fe00000000000
	jbe	SHORT $LN21@AutoSatura
	cvtsi2sd xmm0, DWORD PTR _RY$7[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	movsd	QWORD PTR tv189[ebp], xmm0
	jmp	SHORT $LN22@AutoSatura
$LN21@AutoSatura:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv189[ebp], xmm0
$LN22@AutoSatura:
	movsd	xmm0, QWORD PTR tv189[ebp]
	movsd	QWORD PTR tv190[ebp], xmm0
	jmp	SHORT $LN24@AutoSatura
$LN23@AutoSatura:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv190[ebp], xmm0
$LN24@AutoSatura:
	cvttsd2si edx, QWORD PTR tv190[ebp]
	mov	BYTE PTR _R$14[ebp], dl

; 1335 : 				G = min(max(GY + Y, 255), 0);

	cvtsi2sd xmm0, DWORD PTR _GY$6[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	comisd	xmm0, QWORD PTR __real@406fe00000000000
	jbe	SHORT $LN25@AutoSatura
	cvtsi2sd xmm0, DWORD PTR _GY$6[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	movsd	QWORD PTR tv229[ebp], xmm0
	jmp	SHORT $LN26@AutoSatura
$LN25@AutoSatura:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv229[ebp], xmm0
$LN26@AutoSatura:
	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR tv229[ebp]
	jbe	SHORT $LN29@AutoSatura
	cvtsi2sd xmm0, DWORD PTR _GY$6[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	comisd	xmm0, QWORD PTR __real@406fe00000000000
	jbe	SHORT $LN27@AutoSatura
	cvtsi2sd xmm0, DWORD PTR _GY$6[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	movsd	QWORD PTR tv236[ebp], xmm0
	jmp	SHORT $LN28@AutoSatura
$LN27@AutoSatura:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv236[ebp], xmm0
$LN28@AutoSatura:
	movsd	xmm0, QWORD PTR tv236[ebp]
	movsd	QWORD PTR tv237[ebp], xmm0
	jmp	SHORT $LN30@AutoSatura
$LN29@AutoSatura:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv237[ebp], xmm0
$LN30@AutoSatura:
	cvttsd2si eax, QWORD PTR tv237[ebp]
	mov	BYTE PTR _G$13[ebp], al

; 1336 : 				B = min(max(BY + Y, 255), 0);

	cvtsi2sd xmm0, DWORD PTR _BY$5[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	comisd	xmm0, QWORD PTR __real@406fe00000000000
	jbe	SHORT $LN31@AutoSatura
	cvtsi2sd xmm0, DWORD PTR _BY$5[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	movsd	QWORD PTR tv244[ebp], xmm0
	jmp	SHORT $LN32@AutoSatura
$LN31@AutoSatura:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv244[ebp], xmm0
$LN32@AutoSatura:
	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR tv244[ebp]
	jbe	SHORT $LN35@AutoSatura
	cvtsi2sd xmm0, DWORD PTR _BY$5[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	comisd	xmm0, QWORD PTR __real@406fe00000000000
	jbe	SHORT $LN33@AutoSatura
	cvtsi2sd xmm0, DWORD PTR _BY$5[ebp]
	addsd	xmm0, QWORD PTR _Y$8[ebp]
	movsd	QWORD PTR tv251[ebp], xmm0
	jmp	SHORT $LN34@AutoSatura
$LN33@AutoSatura:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv251[ebp], xmm0
$LN34@AutoSatura:
	movsd	xmm0, QWORD PTR tv251[ebp]
	movsd	QWORD PTR tv252[ebp], xmm0
	jmp	SHORT $LN36@AutoSatura
$LN35@AutoSatura:
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv252[ebp], xmm0
$LN36@AutoSatura:
	cvttsd2si ecx, QWORD PTR tv252[ebp]
	mov	BYTE PTR _B$12[ebp], cl

; 1337 : 
; 1338 : 				Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$11[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$11[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1339 : 				Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$11[ebp]
	mov	al, BYTE PTR _R$14[ebp]
	mov	BYTE PTR [edx+2], al

; 1340 : 				Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$11[ebp]
	mov	dl, BYTE PTR _G$13[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1341 : 				Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$11[ebp]
	mov	cl, BYTE PTR _B$12[ebp]
	mov	BYTE PTR [eax], cl

; 1342 : 			}
; 1343 : 			else

	jmp	SHORT $LN17@AutoSatura
$LN14@AutoSatura:

; 1344 : 			{
; 1345 : 				if (CopyOutOfRegion)

	cmp	DWORD PTR _CopyOutOfRegion$[ebp], 0
	je	SHORT $LN16@AutoSatura

; 1346 : 				{
; 1347 : 					Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$11[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$11[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1348 : 					Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$11[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$11[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 1349 : 					Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$11[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$11[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 1350 : 					Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$11[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$11[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 1351 : 				}
; 1352 : 				else

	jmp	SHORT $LN17@AutoSatura
$LN16@AutoSatura:

; 1353 : 				{
; 1354 : 					Dest[Index + 3] = NonOpA;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$11[ebp]
	mov	al, BYTE PTR _NonOpA$[ebp]
	mov	BYTE PTR [edx+3], al

; 1355 : 					Dest[Index + 2] = NonOpR;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$11[ebp]
	mov	dl, BYTE PTR _NonOpR$[ebp]
	mov	BYTE PTR [ecx+2], dl

; 1356 : 					Dest[Index + 1] = NonOpG;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$11[ebp]
	mov	cl, BYTE PTR _NonOpG$[ebp]
	mov	BYTE PTR [eax+1], cl

; 1357 : 					Dest[Index + 0] = NonOpB;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$11[ebp]
	mov	al, BYTE PTR _NonOpB$[ebp]
	mov	BYTE PTR [edx], al
$LN17@AutoSatura:

; 1358 : 				}
; 1359 : 			}
; 1360 : 		}

	jmp	$LN5@AutoSatura
$LN6@AutoSatura:

; 1361 : 	}

	jmp	$LN2@AutoSatura
$LN3@AutoSatura:

; 1362 : 
; 1363 : 	return Success;

	xor	eax, eax
$LN1@AutoSatura:

; 1364 : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_AutoSaturateRegion@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Contrast$ = 28						; size = 8
_AutoContrast@28 PROC

; 1492 : {

	push	ebp
	mov	ebp, esp

; 1493 : 	return AutoContrastRegion(Source, Width, Height, Stride, Destination, Contrast, 0, 0, Width - 1, Height - 1, FALSE, 0x0);

	push	0
	push	0
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _Contrast$[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_AutoContrastRegion@52

; 1494 : }

	pop	ebp
	ret	28					; 0000001cH
_AutoContrast@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_ContrastTable$ = -308					; size = 256
_RowOffset$1 = -52					; size = 4
_PixelSize$ = -48					; size = 4
_working_contast$ = -44					; size = 8
_index$2 = -36						; size = 4
_Row$3 = -32						; size = 4
_Column$4 = -28						; size = 4
_NonOpB$ = -24						; size = 1
_NonOpG$ = -23						; size = 1
_NonOpR$ = -22						; size = 1
_NonOpA$ = -21						; size = 1
_working_value$ = -20					; size = 8
_Src$ = -12						; size = 4
_Dest$ = -8						; size = 4
_Index$5 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Contrast$ = 28						; size = 8
_Left$ = 36						; size = 4
_Top$ = 40						; size = 4
_Right$ = 44						; size = 4
_Bottom$ = 48						; size = 4
_CopyOutOfRegion$ = 52					; size = 4
_PackedOut$ = 56					; size = 4
_AutoContrastRegion@52 PROC

; 1402 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H

; 1403 : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN11@AutoContra

; 1404 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AutoContra
$LN11@AutoContra:

; 1405 : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN12@AutoContra

; 1406 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AutoContra
$LN12@AutoContra:

; 1407 : 	if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN13@AutoContra

; 1408 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@AutoContra
$LN13@AutoContra:

; 1409 : 	if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN14@AutoContra

; 1410 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@AutoContra
$LN14@AutoContra:

; 1411 : 	if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN15@AutoContra

; 1412 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@AutoContra
$LN15@AutoContra:

; 1413 : 	if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN16@AutoContra

; 1414 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@AutoContra
$LN16@AutoContra:

; 1415 : 
; 1416 : 	BYTE NonOpA = (PackedOut & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _NonOpA$[ebp], dl

; 1417 : 	BYTE NonOpR = (PackedOut & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedOut$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _NonOpR$[ebp], al

; 1418 : 	BYTE NonOpG = (PackedOut & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedOut$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _NonOpG$[ebp], cl

; 1419 : 	BYTE NonOpB = (PackedOut & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _NonOpB$[ebp], dl

; 1420 : 
; 1421 : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1422 : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1423 : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1424 : 
; 1425 : 	BYTE ContrastTable[256];
; 1426 : 	double working_contast = (100.0 + Contrast) / 100.0;

	movsd	xmm0, QWORD PTR __real@4059000000000000
	addsd	xmm0, QWORD PTR _Contrast$[ebp]
	divsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR _working_contast$[ebp], xmm0

; 1427 : 	working_contast *= working_contast;

	movsd	xmm0, QWORD PTR _working_contast$[ebp]
	mulsd	xmm0, QWORD PTR _working_contast$[ebp]
	movsd	QWORD PTR _working_contast$[ebp], xmm0

; 1428 : 	double working_value = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _working_value$[ebp], xmm0

; 1429 : 
; 1430 : 	for (int index = 0; index < 256; index++)

	mov	DWORD PTR _index$2[ebp], 0
	jmp	SHORT $LN4@AutoContra
$LN2@AutoContra:
	mov	edx, DWORD PTR _index$2[ebp]
	add	edx, 1
	mov	DWORD PTR _index$2[ebp], edx
$LN4@AutoContra:
	cmp	DWORD PTR _index$2[ebp], 256		; 00000100H
	jge	$LN3@AutoContra

; 1431 : 	{
; 1432 : 		working_value = (double)index;

	cvtsi2sd xmm0, DWORD PTR _index$2[ebp]
	movsd	QWORD PTR _working_value$[ebp], xmm0

; 1433 : 		working_value /= 255.0;

	movsd	xmm0, QWORD PTR _working_value$[ebp]
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _working_value$[ebp], xmm0

; 1434 : 		working_value -= 0.5;

	movsd	xmm0, QWORD PTR _working_value$[ebp]
	subsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR _working_value$[ebp], xmm0

; 1435 : 		working_value *= working_contast;

	movsd	xmm0, QWORD PTR _working_value$[ebp]
	mulsd	xmm0, QWORD PTR _working_contast$[ebp]
	movsd	QWORD PTR _working_value$[ebp], xmm0

; 1436 : 		working_value += 0.5;

	movsd	xmm0, QWORD PTR _working_value$[ebp]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR _working_value$[ebp], xmm0

; 1437 : 		working_value *= 255;

	movsd	xmm0, QWORD PTR _working_value$[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _working_value$[ebp], xmm0

; 1438 : 		if (working_value < 0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _working_value$[ebp]
	jbe	SHORT $LN17@AutoContra

; 1439 : 			working_value = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _working_value$[ebp], xmm0
$LN17@AutoContra:

; 1440 : 		if (working_value > 255)

	movsd	xmm0, QWORD PTR _working_value$[ebp]
	comisd	xmm0, QWORD PTR __real@406fe00000000000
	jbe	SHORT $LN18@AutoContra

; 1441 : 			working_value = 255;

	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _working_value$[ebp], xmm0
$LN18@AutoContra:

; 1442 : 		ContrastTable[index] = (BYTE)working_value;

	cvttsd2si eax, QWORD PTR _working_value$[ebp]
	mov	ecx, DWORD PTR _index$2[ebp]
	mov	BYTE PTR _ContrastTable$[ebp+ecx], al

; 1443 : 	}

	jmp	$LN2@AutoContra
$LN3@AutoContra:

; 1444 : 
; 1445 : 	for (int Row = Top; Row <= Bottom; Row++)

	mov	edx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$3[ebp], edx
	jmp	SHORT $LN7@AutoContra
$LN5@AutoContra:
	mov	eax, DWORD PTR _Row$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$3[ebp], eax
$LN7@AutoContra:
	mov	ecx, DWORD PTR _Row$3[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	$LN6@AutoContra

; 1446 : 	{
; 1447 : 		int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$3[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 1448 : 		for (int Column = Left; Column <= Right; Column++)

	mov	eax, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$4[ebp], eax
	jmp	SHORT $LN10@AutoContra
$LN8@AutoContra:
	mov	ecx, DWORD PTR _Column$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$4[ebp], ecx
$LN10@AutoContra:
	mov	edx, DWORD PTR _Column$4[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	$LN9@AutoContra

; 1449 : 		{
; 1450 : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$4[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$5[ebp], eax

; 1451 : 			if ((Column >= Left) && (Column <= Right) && (Row >= Top) && (Row <= Bottom))

	mov	ecx, DWORD PTR _Column$4[ebp]
	cmp	ecx, DWORD PTR _Left$[ebp]
	jl	SHORT $LN19@AutoContra
	mov	edx, DWORD PTR _Column$4[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	SHORT $LN19@AutoContra
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Top$[ebp]
	jl	SHORT $LN19@AutoContra
	mov	ecx, DWORD PTR _Row$3[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN19@AutoContra

; 1452 : 			{
; 1453 : 				Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1454 : 				Dest[Index + 2] = ContrastTable[Src[Index + 2]];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx+2]
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _ContrastTable$[ebp+eax]
	mov	BYTE PTR [ecx+2], dl

; 1455 : 				Dest[Index + 1] = ContrastTable[Src[Index + 1]];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _ContrastTable$[ebp+ecx]
	mov	BYTE PTR [edx+1], al

; 1456 : 				Dest[Index + 0] = ContrastTable[Src[Index + 0]];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _ContrastTable$[ebp+edx]
	mov	BYTE PTR [eax], cl

; 1457 : 			}
; 1458 : 			else

	jmp	SHORT $LN22@AutoContra
$LN19@AutoContra:

; 1459 : 			{
; 1460 : 				if (CopyOutOfRegion)

	cmp	DWORD PTR _CopyOutOfRegion$[ebp], 0
	je	SHORT $LN21@AutoContra

; 1461 : 				{
; 1462 : 					Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1463 : 					Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 1464 : 					Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 1465 : 					Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 1466 : 				}
; 1467 : 				else

	jmp	SHORT $LN22@AutoContra
$LN21@AutoContra:

; 1468 : 				{
; 1469 : 					Dest[Index + 3] = NonOpA;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _NonOpA$[ebp]
	mov	BYTE PTR [edx+3], al

; 1470 : 					Dest[Index + 2] = NonOpR;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _NonOpR$[ebp]
	mov	BYTE PTR [ecx+2], dl

; 1471 : 					Dest[Index + 1] = NonOpG;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _NonOpG$[ebp]
	mov	BYTE PTR [eax+1], cl

; 1472 : 					Dest[Index + 0] = NonOpB;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _NonOpB$[ebp]
	mov	BYTE PTR [edx], al
$LN22@AutoContra:

; 1473 : 				}
; 1474 : 			}
; 1475 : 		}

	jmp	$LN8@AutoContra
$LN9@AutoContra:

; 1476 : 	}

	jmp	$LN5@AutoContra
$LN6@AutoContra:

; 1477 : 
; 1478 : 	return Success;

	xor	eax, eax
$LN1@AutoContra:

; 1479 : }

	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
_AutoContrastRegion@52 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_BrightnessMap@20 PROC

; 1587 : {

	push	ebp
	mov	ebp, esp

; 1588 : 	return BrightnessMapRegion(Source, Width, Height, Stride, Destination, 0, 0, Width - 1, Height - 1, FALSE, 0x0);

	push	0
	push	0
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_BrightnessMapRegion@44

; 1589 : }

	pop	ebp
	ret	20					; 00000014H
_BrightnessMap@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_PixLuminance$1 = -44					; size = 8
_RowOffset$2 = -36					; size = 4
_PixelSize$ = -32					; size = 4
_Row$3 = -28						; size = 4
_Column$4 = -24						; size = 4
_Src$ = -20						; size = 4
_Dest$ = -16						; size = 4
_Index$5 = -12						; size = 4
_NonOpB$ = -5						; size = 1
_NonOpG$ = -4						; size = 1
_NonOpR$ = -3						; size = 1
_NonOpA$ = -2						; size = 1
_FinalLuminance$6 = -1					; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Left$ = 28						; size = 4
_Top$ = 32						; size = 4
_Right$ = 36						; size = 4
_Bottom$ = 40						; size = 4
_CopyOutOfRegion$ = 44					; size = 4
_PackedOut$ = 48					; size = 4
_BrightnessMapRegion@44 PROC

; 1515 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1516 : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@Brightness

; 1517 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@Brightness
$LN8@Brightness:

; 1518 : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@Brightness

; 1519 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@Brightness
$LN9@Brightness:

; 1520 : 	if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN10@Brightness

; 1521 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@Brightness
$LN10@Brightness:

; 1522 : 	if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN11@Brightness

; 1523 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@Brightness
$LN11@Brightness:

; 1524 : 	if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN12@Brightness

; 1525 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@Brightness
$LN12@Brightness:

; 1526 : 	if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN13@Brightness

; 1527 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@Brightness
$LN13@Brightness:

; 1528 : 
; 1529 : 	BYTE NonOpA = (PackedOut & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _NonOpA$[ebp], dl

; 1530 : 	BYTE NonOpR = (PackedOut & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedOut$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _NonOpR$[ebp], al

; 1531 : 	BYTE NonOpG = (PackedOut & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedOut$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _NonOpG$[ebp], cl

; 1532 : 	BYTE NonOpB = (PackedOut & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _NonOpB$[ebp], dl

; 1533 : 
; 1534 : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1535 : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1536 : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1537 : 
; 1538 : 	for (int Row = Top; Row <= Bottom; Row++)

	mov	edx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$3[ebp], edx
	jmp	SHORT $LN4@Brightness
$LN2@Brightness:
	mov	eax, DWORD PTR _Row$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$3[ebp], eax
$LN4@Brightness:
	mov	ecx, DWORD PTR _Row$3[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	$LN3@Brightness

; 1539 : 	{
; 1540 : 		int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$3[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], edx

; 1541 : 		for (int Column = Left; Column <= Right; Column++)

	mov	eax, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$4[ebp], eax
	jmp	SHORT $LN7@Brightness
$LN5@Brightness:
	mov	ecx, DWORD PTR _Column$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$4[ebp], ecx
$LN7@Brightness:
	mov	edx, DWORD PTR _Column$4[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	$LN6@Brightness

; 1542 : 		{
; 1543 : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$4[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], eax

; 1544 : 			if ((Column >= Left) && (Column <= Right) && (Row >= Top) && (Row <= Bottom))

	mov	ecx, DWORD PTR _Column$4[ebp]
	cmp	ecx, DWORD PTR _Left$[ebp]
	jl	$LN14@Brightness
	mov	edx, DWORD PTR _Column$4[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	$LN14@Brightness
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Top$[ebp]
	jl	SHORT $LN14@Brightness
	mov	ecx, DWORD PTR _Row$3[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN14@Brightness

; 1545 : 			{
; 1546 : 				double PixLuminance = GetPixelLuminance(Src[Index + 2], Src[Index + 1], Src[Index + 0]);

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_GetPixelLuminance@12
	fstp	QWORD PTR _PixLuminance$1[ebp]

; 1547 : 				//                double PixLuminance = ColorLuminance(Src[Index + 2], Src[Index + 1], Src[Index + 0]);
; 1548 : 				BYTE FinalLuminance = (BYTE)(255.0 * PixLuminance);

	movsd	xmm0, QWORD PTR __real@406fe00000000000
	mulsd	xmm0, QWORD PTR _PixLuminance$1[ebp]
	cvttsd2si edx, xmm0
	mov	BYTE PTR _FinalLuminance$6[ebp], dl

; 1549 : 				Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 1550 : 				Dest[Index + 2] = FinalLuminance;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _FinalLuminance$6[ebp]
	mov	BYTE PTR [eax+2], cl

; 1551 : 				Dest[Index + 1] = FinalLuminance;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _FinalLuminance$6[ebp]
	mov	BYTE PTR [edx+1], al

; 1552 : 				Dest[Index + 0] = FinalLuminance;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _FinalLuminance$6[ebp]
	mov	BYTE PTR [ecx], dl

; 1553 : 			}
; 1554 : 			else

	jmp	SHORT $LN17@Brightness
$LN14@Brightness:

; 1555 : 			{
; 1556 : 				if (CopyOutOfRegion)

	cmp	DWORD PTR _CopyOutOfRegion$[ebp], 0
	je	SHORT $LN16@Brightness

; 1557 : 				{
; 1558 : 					Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 1559 : 					Dest[Index + 2] = Src[Index + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 1560 : 					Dest[Index + 1] = Src[Index + 1];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 1561 : 					Dest[Index + 0] = Src[Index + 0];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 1562 : 				}
; 1563 : 				else

	jmp	SHORT $LN17@Brightness
$LN16@Brightness:

; 1564 : 				{
; 1565 : 					Dest[Index + 3] = NonOpA;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _NonOpA$[ebp]
	mov	BYTE PTR [eax+3], cl

; 1566 : 					Dest[Index + 2] = NonOpR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _NonOpR$[ebp]
	mov	BYTE PTR [edx+2], al

; 1567 : 					Dest[Index + 1] = NonOpG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _NonOpG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1568 : 					Dest[Index + 0] = NonOpB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _NonOpB$[ebp]
	mov	BYTE PTR [eax], cl
$LN17@Brightness:

; 1569 : 				}
; 1570 : 			}
; 1571 : 		}

	jmp	$LN5@Brightness
$LN6@Brightness:

; 1572 : 	}

	jmp	$LN2@Brightness
$LN3@Brightness:

; 1573 : 
; 1574 : 	return Success;

	xor	eax, eax
$LN1@Brightness:

; 1575 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_BrightnessMapRegion@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_MeanImageColor@20 PROC

; 1758 : {

	push	ebp
	mov	ebp, esp

; 1759 : 	return MeanImageColorRegion(Source, Width, Height, Stride, Destination, 0, 0, Width - 1, Height - 1, TRUE, 0x0);

	push	0
	push	1
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_MeanImageColorRegion@44

; 1760 : }

	pop	ebp
	ret	20					; 00000014H
_MeanImageColor@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Result$ = -48						; size = 4
_RowOffset$1 = -44					; size = 4
_PixelSize$ = -40					; size = 4
_PackedMean$ = -36					; size = 4
_Row$2 = -32						; size = 4
_Column$3 = -28						; size = 4
_Src$ = -24						; size = 4
_Dest$ = -20						; size = 4
_Index$4 = -16						; size = 4
_B$5 = -12						; size = 1
_G$6 = -11						; size = 1
_R$7 = -10						; size = 1
_mA$ = -9						; size = 1
_NonOpB$ = -8						; size = 1
_NonOpG$ = -7						; size = 1
_NonOpR$ = -6						; size = 1
_NonOpA$ = -5						; size = 1
_mB$ = -4						; size = 1
_mG$ = -3						; size = 1
_mR$ = -2						; size = 1
_A$8 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Left$ = 28						; size = 4
_Top$ = 32						; size = 4
_Right$ = 36						; size = 4
_Bottom$ = 40						; size = 4
_CopyOutOfRegion$ = 44					; size = 4
_PackedOut$ = 48					; size = 4
_MeanImageColorRegion@44 PROC

; 1678 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 1679 : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@MeanImageC

; 1680 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@MeanImageC
$LN8@MeanImageC:

; 1681 : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@MeanImageC

; 1682 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@MeanImageC
$LN9@MeanImageC:

; 1683 : 	if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN10@MeanImageC

; 1684 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@MeanImageC
$LN10@MeanImageC:

; 1685 : 	if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN11@MeanImageC

; 1686 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@MeanImageC
$LN11@MeanImageC:

; 1687 : 	if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN12@MeanImageC

; 1688 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@MeanImageC
$LN12@MeanImageC:

; 1689 : 	if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN13@MeanImageC

; 1690 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@MeanImageC
$LN13@MeanImageC:

; 1691 : 
; 1692 : 	BYTE NonOpA = (PackedOut & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _NonOpA$[ebp], dl

; 1693 : 	BYTE NonOpR = (PackedOut & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedOut$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _NonOpR$[ebp], al

; 1694 : 	BYTE NonOpG = (PackedOut & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedOut$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _NonOpG$[ebp], cl

; 1695 : 	BYTE NonOpB = (PackedOut & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _NonOpB$[ebp], dl

; 1696 : 
; 1697 : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1698 : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1699 : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1700 : 
; 1701 : 	UINT32 PackedMean = 0x0;

	mov	DWORD PTR _PackedMean$[ebp], 0

; 1702 : 	int Result = ImageMeanColor(Source, Width, Height, Stride, &PackedMean);

	lea	edx, DWORD PTR _PackedMean$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_ImageMeanColor@20
	mov	DWORD PTR _Result$[ebp], eax

; 1703 : 	BYTE mA = (PackedMean & 0xff000000) >> 24;

	mov	ecx, DWORD PTR _PackedMean$[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _mA$[ebp], cl

; 1704 : 	BYTE mR = (PackedMean & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _PackedMean$[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _mR$[ebp], dl

; 1705 : 	BYTE mG = (PackedMean & 0x0000ff00) >> 8;

	mov	eax, DWORD PTR _PackedMean$[ebp]
	and	eax, 65280				; 0000ff00H
	shr	eax, 8
	mov	BYTE PTR _mG$[ebp], al

; 1706 : 	BYTE mB = (PackedMean & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _PackedMean$[ebp]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _mB$[ebp], cl

; 1707 : 
; 1708 : 	for (int Row = Top; Row <= Bottom; Row++)

	mov	edx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$2[ebp], edx
	jmp	SHORT $LN4@MeanImageC
$LN2@MeanImageC:
	mov	eax, DWORD PTR _Row$2[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$2[ebp], eax
$LN4@MeanImageC:
	mov	ecx, DWORD PTR _Row$2[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	$LN3@MeanImageC

; 1709 : 	{
; 1710 : 		int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$2[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 1711 : 		for (int Column = Left; Column <= Right; Column++)

	mov	eax, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$3[ebp], eax
	jmp	SHORT $LN7@MeanImageC
$LN5@MeanImageC:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@MeanImageC:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	$LN6@MeanImageC

; 1712 : 		{
; 1713 : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$3[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 1714 : 			BYTE A = Src[Index + 3];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR _A$8[ebp], dl

; 1715 : 			BYTE R = Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _R$7[ebp], cl

; 1716 : 			BYTE G = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _G$6[ebp], al

; 1717 : 			BYTE B = Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _B$5[ebp], dl

; 1718 : 			if ((Column >= Left) && (Column <= Right) && (Row >= Top) && (Row <= Bottom))

	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _Left$[ebp]
	jl	SHORT $LN14@MeanImageC
	mov	ecx, DWORD PTR _Column$3[ebp]
	cmp	ecx, DWORD PTR _Right$[ebp]
	jg	SHORT $LN14@MeanImageC
	mov	edx, DWORD PTR _Row$2[ebp]
	cmp	edx, DWORD PTR _Top$[ebp]
	jl	SHORT $LN14@MeanImageC
	mov	eax, DWORD PTR _Row$2[ebp]
	cmp	eax, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN14@MeanImageC

; 1719 : 			{
; 1720 : 				Dest[Index + 3] = A;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 1721 : 				Dest[Index + 2] = mR;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _mR$[ebp]
	mov	BYTE PTR [eax+2], cl

; 1722 : 				Dest[Index + 1] = mG;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _mG$[ebp]
	mov	BYTE PTR [edx+1], al

; 1723 : 				Dest[Index + 0] = mB;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _mB$[ebp]
	mov	BYTE PTR [ecx], dl

; 1724 : 			}
; 1725 : 			else

	jmp	SHORT $LN15@MeanImageC
$LN14@MeanImageC:

; 1726 : 			{
; 1727 : 				if (CopyOutOfRegion)

	cmp	DWORD PTR _CopyOutOfRegion$[ebp], 0
	je	SHORT $LN16@MeanImageC

; 1728 : 				{
; 1729 : 					Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 1730 : 					Dest[Index + 2] = Src[Index + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 1731 : 					Dest[Index + 1] = Src[Index + 1];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 1732 : 					Dest[Index + 0] = Src[Index + 0];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 1733 : 				}
; 1734 : 				else

	jmp	SHORT $LN15@MeanImageC
$LN16@MeanImageC:

; 1735 : 				{
; 1736 : 					Dest[Index + 3] = NonOpA;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _NonOpA$[ebp]
	mov	BYTE PTR [eax+3], cl

; 1737 : 					Dest[Index + 2] = NonOpR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _NonOpR$[ebp]
	mov	BYTE PTR [edx+2], al

; 1738 : 					Dest[Index + 1] = NonOpG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _NonOpG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 1739 : 					Dest[Index + 0] = NonOpB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _NonOpB$[ebp]
	mov	BYTE PTR [eax], cl
$LN15@MeanImageC:

; 1740 : 				}
; 1741 : 			}
; 1742 : 		}

	jmp	$LN5@MeanImageC
$LN6@MeanImageC:

; 1743 : 	}

	jmp	$LN2@MeanImageC
$LN3@MeanImageC:

; 1744 : 
; 1745 : 	return Success;

	xor	eax, eax
$LN1@MeanImageC:

; 1746 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_MeanImageColorRegion@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_PackedMeanColor$ = 24					; size = 4
_ImageMeanColor@20 PROC

; 1655 : {

	push	ebp
	mov	ebp, esp

; 1656 : 	return ImageMeanColorRegion(Source, Width, Height, Stride, PackedMeanColor, 0, 0, Width - 1, Height - 1);

	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _PackedMeanColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_ImageMeanColorRegion@36

; 1657 : }

	pop	ebp
	ret	20					; 00000014H
_ImageMeanColor@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
tv169 = -100						; size = 8
tv160 = -92						; size = 8
tv151 = -84						; size = 8
tv142 = -76						; size = 8
_BlueSum$ = -68						; size = 8
_GreenSum$ = -60					; size = 8
_RedSum$ = -52						; size = 8
_AlphaSum$ = -44					; size = 8
_TotalPixels$ = -36					; size = 8
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Index$2 = -20						; size = 4
_Src$ = -16						; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_B$ = -4						; size = 1
_G$ = -3						; size = 1
_R$ = -2						; size = 1
_A$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_PackedMeanColor$ = 24					; size = 4
_Left$ = 28						; size = 4
_Top$ = 32						; size = 4
_Right$ = 36						; size = 4
_Bottom$ = 40						; size = 4
_ImageMeanColorRegion@36 PROC

; 1602 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 1603 : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ImageMeanC

; 1604 : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageMeanC
$LN8@ImageMeanC:

; 1605 : 	if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN9@ImageMeanC

; 1606 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ImageMeanC
$LN9@ImageMeanC:

; 1607 : 	if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN10@ImageMeanC

; 1608 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ImageMeanC
$LN10@ImageMeanC:

; 1609 : 	if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN11@ImageMeanC

; 1610 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ImageMeanC
$LN11@ImageMeanC:

; 1611 : 	if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN12@ImageMeanC

; 1612 : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ImageMeanC
$LN12@ImageMeanC:

; 1613 : 
; 1614 : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1615 : 	BYTE *Src = (BYTE *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], edx

; 1616 : 	double AlphaSum = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _AlphaSum$[ebp], xmm0

; 1617 : 	double RedSum = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _RedSum$[ebp], xmm0

; 1618 : 	double GreenSum = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _GreenSum$[ebp], xmm0

; 1619 : 	double BlueSum = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _BlueSum$[ebp], xmm0

; 1620 : 
; 1621 : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@ImageMeanC
$LN2@ImageMeanC:
	mov	eax, DWORD PTR _Row$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$4[ebp], eax
$LN4@ImageMeanC:
	mov	ecx, DWORD PTR _Row$4[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN3@ImageMeanC

; 1622 : 	{
; 1623 : 		int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$4[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 1624 : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@ImageMeanC
$LN5@ImageMeanC:
	mov	eax, DWORD PTR _Column$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$3[ebp], eax
$LN7@ImageMeanC:
	mov	ecx, DWORD PTR _Column$3[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@ImageMeanC

; 1625 : 		{
; 1626 : 			int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$3[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], edx

; 1627 : 			AlphaSum += Src[Index + 3];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	cvtsi2sd xmm0, ecx
	addsd	xmm0, QWORD PTR _AlphaSum$[ebp]
	movsd	QWORD PTR _AlphaSum$[ebp], xmm0

; 1628 : 			RedSum += Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	movzx	eax, BYTE PTR [edx+2]
	cvtsi2sd xmm0, eax
	addsd	xmm0, QWORD PTR _RedSum$[ebp]
	movsd	QWORD PTR _RedSum$[ebp], xmm0

; 1629 : 			GreenSum += Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cvtsi2sd xmm0, edx
	addsd	xmm0, QWORD PTR _GreenSum$[ebp]
	movsd	QWORD PTR _GreenSum$[ebp], xmm0

; 1630 : 			BlueSum += Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2sd xmm0, ecx
	addsd	xmm0, QWORD PTR _BlueSum$[ebp]
	movsd	QWORD PTR _BlueSum$[ebp], xmm0

; 1631 : 		}

	jmp	SHORT $LN5@ImageMeanC
$LN6@ImageMeanC:

; 1632 : 	}

	jmp	$LN2@ImageMeanC
$LN3@ImageMeanC:

; 1633 : 
; 1634 : 	double TotalPixels = Width * Height * Stride;

	mov	edx, DWORD PTR _Width$[ebp]
	imul	edx, DWORD PTR _Height$[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	cvtsi2sd xmm0, edx
	movsd	QWORD PTR _TotalPixels$[ebp], xmm0

; 1635 : 	BYTE A = (BYTE)min(((AlphaSum / TotalPixels) * 100.0), 255);

	movsd	xmm0, QWORD PTR _AlphaSum$[ebp]
	divsd	xmm0, QWORD PTR _TotalPixels$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN14@ImageMeanC
	movsd	xmm0, QWORD PTR _AlphaSum$[ebp]
	divsd	xmm0, QWORD PTR _TotalPixels$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR tv142[ebp], xmm0
	jmp	SHORT $LN15@ImageMeanC
$LN14@ImageMeanC:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv142[ebp], xmm0
$LN15@ImageMeanC:
	cvttsd2si eax, QWORD PTR tv142[ebp]
	mov	BYTE PTR _A$[ebp], al

; 1636 : 	BYTE R = (BYTE)min(((RedSum / TotalPixels) * 100.0), 255);

	movsd	xmm0, QWORD PTR _RedSum$[ebp]
	divsd	xmm0, QWORD PTR _TotalPixels$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN16@ImageMeanC
	movsd	xmm0, QWORD PTR _RedSum$[ebp]
	divsd	xmm0, QWORD PTR _TotalPixels$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR tv151[ebp], xmm0
	jmp	SHORT $LN17@ImageMeanC
$LN16@ImageMeanC:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv151[ebp], xmm0
$LN17@ImageMeanC:
	cvttsd2si ecx, QWORD PTR tv151[ebp]
	mov	BYTE PTR _R$[ebp], cl

; 1637 : 	BYTE G = (BYTE)min(((GreenSum / TotalPixels) * 100.0), 255);

	movsd	xmm0, QWORD PTR _GreenSum$[ebp]
	divsd	xmm0, QWORD PTR _TotalPixels$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN18@ImageMeanC
	movsd	xmm0, QWORD PTR _GreenSum$[ebp]
	divsd	xmm0, QWORD PTR _TotalPixels$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR tv160[ebp], xmm0
	jmp	SHORT $LN19@ImageMeanC
$LN18@ImageMeanC:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv160[ebp], xmm0
$LN19@ImageMeanC:
	cvttsd2si edx, QWORD PTR tv160[ebp]
	mov	BYTE PTR _G$[ebp], dl

; 1638 : 	BYTE B = (BYTE)min(((BlueSum / TotalPixels) * 100.0), 255);

	movsd	xmm0, QWORD PTR _BlueSum$[ebp]
	divsd	xmm0, QWORD PTR _TotalPixels$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	comisd	xmm1, xmm0
	jbe	SHORT $LN20@ImageMeanC
	movsd	xmm0, QWORD PTR _BlueSum$[ebp]
	divsd	xmm0, QWORD PTR _TotalPixels$[ebp]
	mulsd	xmm0, QWORD PTR __real@4059000000000000
	movsd	QWORD PTR tv169[ebp], xmm0
	jmp	SHORT $LN21@ImageMeanC
$LN20@ImageMeanC:
	movsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR tv169[ebp], xmm0
$LN21@ImageMeanC:
	cvttsd2si eax, QWORD PTR tv169[ebp]
	mov	BYTE PTR _B$[ebp], al

; 1639 : 
; 1640 : 	*PackedMeanColor = (A << 24) | (R << 16) | (G << 8) | B;

	movzx	ecx, BYTE PTR _A$[ebp]
	shl	ecx, 24					; 00000018H
	movzx	edx, BYTE PTR _R$[ebp]
	shl	edx, 16					; 00000010H
	or	ecx, edx
	movzx	eax, BYTE PTR _G$[ebp]
	shl	eax, 8
	or	ecx, eax
	movzx	edx, BYTE PTR _B$[ebp]
	or	ecx, edx
	mov	eax, DWORD PTR _PackedMeanColor$[ebp]
	mov	DWORD PTR [eax], ecx

; 1641 : 
; 1642 : 	return Success;

	xor	eax, eax
$LN1@ImageMeanC:

; 1643 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_ImageMeanColorRegion@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_IncludeAlpha$ = 28					; size = 1
_InvertImage@24 PROC

; 237  : {

	push	ebp
	mov	ebp, esp

; 238  : 	return InvertImageRegion(Source, Width, Height, Stride, Destination, IncludeAlpha, 0, 0, Width - 1, Height - 1, FALSE, 0x0);

	push	0
	push	0
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	movzx	edx, BYTE PTR _IncludeAlpha$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_InvertImageRegion@48

; 239  : }

	pop	ebp
	ret	24					; 00000018H
_InvertImage@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Row$2 = -24						; size = 4
_Column$3 = -20						; size = 4
_Buffer$ = -16						; size = 4
_Dest$ = -12						; size = 4
_Index$4 = -8						; size = 4
_NonOpB$ = -4						; size = 1
_NonOpG$ = -3						; size = 1
_NonOpR$ = -2						; size = 1
_NonOpA$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_IncludeAlpha$ = 28					; size = 1
_Left$ = 32						; size = 4
_Top$ = 36						; size = 4
_Right$ = 40						; size = 4
_Bottom$ = 44						; size = 4
_CopyOutOfRegion$ = 48					; size = 4
_PackedOut$ = 52					; size = 4
_InvertImageRegion@48 PROC

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 167  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@InvertImag

; 168  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@InvertImag
$LN8@InvertImag:

; 169  : 	if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN9@InvertImag

; 170  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@InvertImag
$LN9@InvertImag:

; 171  : 	if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN10@InvertImag

; 172  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@InvertImag
$LN10@InvertImag:

; 173  : 	if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN11@InvertImag

; 174  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@InvertImag
$LN11@InvertImag:

; 175  : 	if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN12@InvertImag

; 176  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@InvertImag
$LN12@InvertImag:

; 177  : 
; 178  : 	BYTE NonOpA = (PackedOut & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _NonOpA$[ebp], dl

; 179  : 	BYTE NonOpR = (PackedOut & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedOut$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _NonOpR$[ebp], al

; 180  : 	BYTE NonOpG = (PackedOut & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedOut$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _NonOpG$[ebp], cl

; 181  : 	BYTE NonOpB = (PackedOut & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _NonOpB$[ebp], dl

; 182  : 
; 183  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 184  : 	BYTE *Buffer = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 185  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 186  : 
; 187  : 	for (int Row = Top; Row <= Bottom; Row++)

	mov	edx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$2[ebp], edx
	jmp	SHORT $LN4@InvertImag
$LN2@InvertImag:
	mov	eax, DWORD PTR _Row$2[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$2[ebp], eax
$LN4@InvertImag:
	mov	ecx, DWORD PTR _Row$2[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	$LN3@InvertImag

; 188  : 	{
; 189  : 		int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$2[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 190  : 		for (int Column = Left; Column <= Right; Column++)

	mov	eax, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$3[ebp], eax
	jmp	SHORT $LN7@InvertImag
$LN5@InvertImag:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@InvertImag:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	$LN6@InvertImag

; 191  : 		{
; 192  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$3[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 193  : 			if ((Column >= Left) && (Column <= Right) && (Row >= Top) && (Row <= Bottom))

	mov	ecx, DWORD PTR _Column$3[ebp]
	cmp	ecx, DWORD PTR _Left$[ebp]
	jl	$LN13@InvertImag
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	$LN13@InvertImag
	mov	eax, DWORD PTR _Row$2[ebp]
	cmp	eax, DWORD PTR _Top$[ebp]
	jl	$LN13@InvertImag
	mov	ecx, DWORD PTR _Row$2[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN13@InvertImag

; 194  : 			{
; 195  : 				if (IncludeAlpha)

	movzx	edx, BYTE PTR _IncludeAlpha$[ebp]
	test	edx, edx
	je	SHORT $LN15@InvertImag

; 196  : 					Dest[Index + 3] = 0xff - Buffer[Index + 3];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [eax+3], dl

; 197  : 				else

	jmp	SHORT $LN16@InvertImag
$LN15@InvertImag:

; 198  : 					Dest[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH
$LN16@InvertImag:

; 199  : 				Dest[Index + 2] = 0xff - Buffer[Index + 2];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+2]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx+2], cl

; 200  : 				Dest[Index + 1] = 0xff - Buffer[Index + 1];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [eax+1], dl

; 201  : 				Dest[Index + 0] = 0xff - Buffer[Index + 0];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx], al

; 202  : 			}
; 203  : 			else

	jmp	SHORT $LN14@InvertImag
$LN13@InvertImag:

; 204  : 			{
; 205  : 				if (CopyOutOfRegion)

	cmp	DWORD PTR _CopyOutOfRegion$[ebp], 0
	je	SHORT $LN17@InvertImag

; 206  : 				{
; 207  : 					Dest[Index + 3] = Buffer[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 208  : 					Dest[Index + 2] = Buffer[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 209  : 					Dest[Index + 1] = Buffer[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 210  : 					Dest[Index + 0] = Buffer[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 211  : 				}
; 212  : 				else

	jmp	SHORT $LN14@InvertImag
$LN17@InvertImag:

; 213  : 				{
; 214  : 					Dest[Index + 3] = NonOpA;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _NonOpA$[ebp]
	mov	BYTE PTR [edx+3], al

; 215  : 					Dest[Index + 2] = NonOpR;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _NonOpR$[ebp]
	mov	BYTE PTR [ecx+2], dl

; 216  : 					Dest[Index + 1] = NonOpG;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _NonOpG$[ebp]
	mov	BYTE PTR [eax+1], cl

; 217  : 					Dest[Index + 0] = NonOpB;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _NonOpB$[ebp]
	mov	BYTE PTR [edx], al
$LN14@InvertImag:

; 218  : 				}
; 219  : 			}
; 220  : 		}

	jmp	$LN5@InvertImag
$LN6@InvertImag:

; 221  : 	}

	jmp	$LN2@InvertImag
$LN3@InvertImag:

; 222  : 
; 223  : 	return Success;

	xor	eax, eax
$LN1@InvertImag:

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_InvertImageRegion@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_PixelLuminance$1 = -32					; size = 8
_RowOffset$2 = -24					; size = 4
_PixelSize$ = -20					; size = 4
_Index$3 = -16						; size = 4
_Buffer$ = -12						; size = 4
_Column$4 = -8						; size = 4
_Row$5 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Threshold$ = 24					; size = 8
_SolarAlpha$ = 32					; size = 1
_AlphaSolarizeImage2@28 PROC

; 118  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 119  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@AlphaSolar

; 120  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlphaSolar
$LN8@AlphaSolar:

; 121  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 122  : 	BYTE *Buffer = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 123  : 	if (Threshold < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _Threshold$[ebp]
	jbe	SHORT $LN9@AlphaSolar

; 124  : 		Threshold = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Threshold$[ebp], xmm0
$LN9@AlphaSolar:

; 125  : 	if (Threshold > 1.0)

	movsd	xmm0, QWORD PTR _Threshold$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN10@AlphaSolar

; 126  : 		Threshold = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _Threshold$[ebp], xmm0
$LN10@AlphaSolar:

; 127  : 
; 128  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN4@AlphaSolar
$LN2@AlphaSolar:
	mov	ecx, DWORD PTR _Row$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$5[ebp], ecx
$LN4@AlphaSolar:
	mov	edx, DWORD PTR _Row$5[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@AlphaSolar

; 129  : 	{
; 130  : 		int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$5[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], eax

; 131  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$4[ebp], 0
	jmp	SHORT $LN7@AlphaSolar
$LN5@AlphaSolar:
	mov	ecx, DWORD PTR _Column$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$4[ebp], ecx
$LN7@AlphaSolar:
	mov	edx, DWORD PTR _Column$4[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@AlphaSolar

; 132  : 		{
; 133  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$4[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$3[ebp], eax

; 134  : 			double PixelLuminance = ColorLuminance2(Buffer[Index + 2], Buffer[Index + 1], Buffer[Index + 0], TRUE);

	push	1
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$3[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$3[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	push	ecx
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$3[ebp]
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	call	_ColorLuminance2@16
	fstp	QWORD PTR _PixelLuminance$1[ebp]

; 135  : 			if (PixelLuminance >= Threshold)

	movsd	xmm0, QWORD PTR _PixelLuminance$1[ebp]
	comisd	xmm0, QWORD PTR _Threshold$[ebp]
	jb	SHORT $LN11@AlphaSolar

; 136  : 			{
; 137  : 				Buffer[Index + 3] = SolarAlpha;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$3[ebp]
	mov	dl, BYTE PTR _SolarAlpha$[ebp]
	mov	BYTE PTR [ecx+3], dl
$LN11@AlphaSolar:

; 138  : 			}
; 139  : 		}

	jmp	SHORT $LN5@AlphaSolar
$LN6@AlphaSolar:

; 140  : 	}

	jmp	$LN2@AlphaSolar
$LN3@AlphaSolar:

; 141  : 
; 142  : 	return Success;

	xor	eax, eax
$LN1@AlphaSolar:

; 143  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_AlphaSolarizeImage2@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Test$1 = -48						; size = 8
_PixelLuminance$2 = -40					; size = 8
tv90 = -32						; size = 8
_RowOffset$3 = -24					; size = 4
_PixelSize$ = -20					; size = 4
_Column$4 = -16						; size = 4
_Row$5 = -12						; size = 4
_Index$6 = -8						; size = 4
_Buffer$ = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Threshold$ = 24					; size = 8
_Invert$ = 32						; size = 4
_AlphaSolarizeImage@28 PROC

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 77   : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@AlphaSolar

; 78   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@AlphaSolar
$LN8@AlphaSolar:

; 79   : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 80   : 	BYTE *Buffer = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 81   : 	if (Threshold < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _Threshold$[ebp]
	jbe	SHORT $LN9@AlphaSolar

; 82   : 		Threshold = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Threshold$[ebp], xmm0
$LN9@AlphaSolar:

; 83   : 	if (Threshold > 1.0)

	movsd	xmm0, QWORD PTR _Threshold$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN10@AlphaSolar

; 84   : 		Threshold = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _Threshold$[ebp], xmm0
$LN10@AlphaSolar:

; 85   : 
; 86   : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN4@AlphaSolar
$LN2@AlphaSolar:
	mov	ecx, DWORD PTR _Row$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$5[ebp], ecx
$LN4@AlphaSolar:
	mov	edx, DWORD PTR _Row$5[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	$LN3@AlphaSolar

; 87   : 	{
; 88   : 		int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$5[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], eax

; 89   : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$4[ebp], 0
	jmp	SHORT $LN7@AlphaSolar
$LN5@AlphaSolar:
	mov	ecx, DWORD PTR _Column$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$4[ebp], ecx
$LN7@AlphaSolar:
	mov	edx, DWORD PTR _Column$4[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	$LN6@AlphaSolar

; 90   : 		{
; 91   : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$4[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$6[ebp], eax

; 92   : 			double PixelLuminance = ColorLuminance2(Buffer[Index + 2], Buffer[Index + 1], Buffer[Index + 0], TRUE);

	push	1
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	push	ecx
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	call	_ColorLuminance2@16
	fstp	QWORD PTR _PixelLuminance$2[ebp]

; 93   : 			double Test = Invert ? 1.0 - Threshold : Threshold;

	cmp	DWORD PTR _Invert$[ebp], 0
	je	SHORT $LN13@AlphaSolar
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _Threshold$[ebp]
	movsd	QWORD PTR tv90[ebp], xmm0
	jmp	SHORT $LN14@AlphaSolar
$LN13@AlphaSolar:
	movsd	xmm0, QWORD PTR _Threshold$[ebp]
	movsd	QWORD PTR tv90[ebp], xmm0
$LN14@AlphaSolar:
	movsd	xmm0, QWORD PTR tv90[ebp]
	movsd	QWORD PTR _Test$1[ebp], xmm0

; 94   : 			if (PixelLuminance >= Test)

	movsd	xmm0, QWORD PTR _PixelLuminance$2[ebp]
	comisd	xmm0, QWORD PTR _Test$1[ebp]
	jb	SHORT $LN11@AlphaSolar

; 95   : 			{
; 96   : 				Buffer[Index + 3] = 0xff - Buffer[Index + 3];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	BYTE PTR [ecx+3], al
$LN11@AlphaSolar:

; 97   : 			}
; 98   : 		}

	jmp	$LN5@AlphaSolar
$LN6@AlphaSolar:

; 99   : 	}

	jmp	$LN2@AlphaSolar
$LN3@AlphaSolar:

; 100  : 
; 101  : 	return Success;

	xor	eax, eax
$LN1@AlphaSolar:

; 102  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_AlphaSolarizeImage@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Test$1 = -52						; size = 8
_PixelLuminance$2 = -44					; size = 8
tv90 = -36						; size = 8
_RowOffset$3 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Column$4 = -20						; size = 4
_Row$5 = -16						; size = 4
_Dest$ = -12						; size = 4
_Src$ = -8						; size = 4
_Index$6 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Threshold$ = 28					; size = 8
_Invert$ = 36						; size = 4
_SolarizeImage@32 PROC

; 20   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 21   : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@SolarizeIm

; 22   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SolarizeIm
$LN8@SolarizeIm:

; 23   : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@SolarizeIm

; 24   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SolarizeIm
$LN9@SolarizeIm:

; 25   : 
; 26   : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 27   : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 28   : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 29   : 	if (Threshold < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _Threshold$[ebp]
	jbe	SHORT $LN10@SolarizeIm

; 30   : 		Threshold = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Threshold$[ebp], xmm0
$LN10@SolarizeIm:

; 31   : 	if (Threshold > 1.0)

	movsd	xmm0, QWORD PTR _Threshold$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN11@SolarizeIm

; 32   : 		Threshold = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _Threshold$[ebp], xmm0
$LN11@SolarizeIm:

; 33   : 
; 34   : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN4@SolarizeIm
$LN2@SolarizeIm:
	mov	edx, DWORD PTR _Row$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$5[ebp], edx
$LN4@SolarizeIm:
	mov	eax, DWORD PTR _Row$5[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@SolarizeIm

; 35   : 	{
; 36   : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$5[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], ecx

; 37   : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$4[ebp], 0
	jmp	SHORT $LN7@SolarizeIm
$LN5@SolarizeIm:
	mov	edx, DWORD PTR _Column$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$4[ebp], edx
$LN7@SolarizeIm:
	mov	eax, DWORD PTR _Column$4[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@SolarizeIm

; 38   : 		{
; 39   : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$4[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$6[ebp], ecx

; 40   : 			double PixelLuminance = ColorLuminance(Src[Index + 2], Src[Index + 1], Src[Index + 0]);

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_ColorLuminance@12
	fstp	QWORD PTR _PixelLuminance$2[ebp]

; 41   : 			//double PixelLuminance = NormalizedColorLuminance(Src[Index + 2], Src[Index + 1], Src[Index + 0], TRUE);
; 42   : 			double Test = Invert ? 1.0 - Threshold : Threshold;

	cmp	DWORD PTR _Invert$[ebp], 0
	je	SHORT $LN15@SolarizeIm
	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _Threshold$[ebp]
	movsd	QWORD PTR tv90[ebp], xmm0
	jmp	SHORT $LN16@SolarizeIm
$LN15@SolarizeIm:
	movsd	xmm0, QWORD PTR _Threshold$[ebp]
	movsd	QWORD PTR tv90[ebp], xmm0
$LN16@SolarizeIm:
	movsd	xmm0, QWORD PTR tv90[ebp]
	movsd	QWORD PTR _Test$1[ebp], xmm0

; 43   : 			Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 44   : 			if (PixelLuminance >= Test)

	movsd	xmm0, QWORD PTR _PixelLuminance$2[ebp]
	comisd	xmm0, QWORD PTR _Test$1[ebp]
	jb	SHORT $LN12@SolarizeIm

; 45   : 			{
; 46   : 				Dest[Index + 2] = 0xff - Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	movzx	eax, BYTE PTR [edx+2]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	BYTE PTR [edx+2], cl

; 47   : 				Dest[Index + 1] = 0xff - Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	BYTE PTR [eax+1], dl

; 48   : 				Dest[Index + 0] = 0xff - Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	BYTE PTR [ecx], al

; 49   : 			}
; 50   : 			else

	jmp	SHORT $LN13@SolarizeIm
$LN12@SolarizeIm:

; 51   : 			{
; 52   : 				Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 53   : 				Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 54   : 				Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
$LN13@SolarizeIm:

; 55   : 			}
; 56   : 		}

	jmp	$LN5@SolarizeIm
$LN6@SolarizeIm:

; 57   : 	}

	jmp	$LN2@SolarizeIm
$LN3@SolarizeIm:

; 58   : 
; 59   : 	return Success;

	xor	eax, eax
$LN1@SolarizeIm:

; 60   : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_SolarizeImage@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_RowOffset$1 = -48					; size = 4
_PixelSize$ = -44					; size = 4
tv181 = -40						; size = 4
_Src$ = -36						; size = 4
_Column$2 = -32						; size = 4
_Row$3 = -28						; size = 4
_Dest$ = -24						; size = 4
_Index$4 = -20						; size = 4
tv160 = -15						; size = 1
tv153 = -14						; size = 1
tv146 = -13						; size = 1
tv139 = -12						; size = 1
tv138 = -11						; size = 1
tv132 = -10						; size = 1
tv95 = -9						; size = 1
tv94 = -8						; size = 1
tv88 = -7						; size = 1
_Smallest$5 = -6					; size = 1
_Middle$6 = -5						; size = 1
_Biggest$7 = -4						; size = 1
_R$8 = -3						; size = 1
_G$9 = -2						; size = 1
_B$10 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SortHow$ = 28						; size = 4
_StoreSortHowAsAlpha$ = 32				; size = 4
_InvertAlpha$ = 36					; size = 4
_SortChannels@32 PROC

; 765  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 766  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN10@SortChanne

; 767  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SortChanne
$LN10@SortChanne:

; 768  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN11@SortChanne

; 769  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SortChanne
$LN11@SortChanne:

; 770  : 	if ((SortHow < SortRGB) || (SortHow > SortBGR))

	cmp	DWORD PTR _SortHow$[ebp], 0
	jl	SHORT $LN13@SortChanne
	cmp	DWORD PTR _SortHow$[ebp], 5
	jle	SHORT $LN12@SortChanne
$LN13@SortChanne:

; 771  : 		return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@SortChanne
$LN12@SortChanne:

; 772  : 
; 773  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 774  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 775  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 776  : 
; 777  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@SortChanne
$LN2@SortChanne:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@SortChanne:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@SortChanne

; 778  : 	{
; 779  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 780  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@SortChanne
$LN5@SortChanne:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@SortChanne:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@SortChanne

; 781  : 		{
; 782  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 783  : 			BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$8[ebp], al

; 784  : 			BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$9[ebp], dl

; 785  : 			BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$10[ebp], cl

; 786  : 			BYTE Biggest = max(R, max(G, B));

	movzx	edx, BYTE PTR _G$9[ebp]
	movzx	eax, BYTE PTR _B$10[ebp]
	cmp	edx, eax
	jle	SHORT $LN28@SortChanne
	mov	cl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv88[ebp], cl
	jmp	SHORT $LN29@SortChanne
$LN28@SortChanne:
	mov	dl, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv88[ebp], dl
$LN29@SortChanne:
	movzx	eax, BYTE PTR _R$8[ebp]
	movzx	ecx, BYTE PTR tv88[ebp]
	cmp	eax, ecx
	jle	SHORT $LN32@SortChanne
	mov	dl, BYTE PTR _R$8[ebp]
	mov	BYTE PTR tv95[ebp], dl
	jmp	SHORT $LN33@SortChanne
$LN32@SortChanne:
	movzx	eax, BYTE PTR _G$9[ebp]
	movzx	ecx, BYTE PTR _B$10[ebp]
	cmp	eax, ecx
	jle	SHORT $LN30@SortChanne
	mov	dl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv94[ebp], dl
	jmp	SHORT $LN31@SortChanne
$LN30@SortChanne:
	mov	al, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv94[ebp], al
$LN31@SortChanne:
	mov	cl, BYTE PTR tv94[ebp]
	mov	BYTE PTR tv95[ebp], cl
$LN33@SortChanne:
	mov	dl, BYTE PTR tv95[ebp]
	mov	BYTE PTR _Biggest$7[ebp], dl

; 787  : 			BYTE Smallest = min(R, min(G, B));

	movzx	eax, BYTE PTR _G$9[ebp]
	movzx	ecx, BYTE PTR _B$10[ebp]
	cmp	eax, ecx
	jge	SHORT $LN34@SortChanne
	mov	dl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv132[ebp], dl
	jmp	SHORT $LN35@SortChanne
$LN34@SortChanne:
	mov	al, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv132[ebp], al
$LN35@SortChanne:
	movzx	ecx, BYTE PTR _R$8[ebp]
	movzx	edx, BYTE PTR tv132[ebp]
	cmp	ecx, edx
	jge	SHORT $LN38@SortChanne
	mov	al, BYTE PTR _R$8[ebp]
	mov	BYTE PTR tv139[ebp], al
	jmp	SHORT $LN39@SortChanne
$LN38@SortChanne:
	movzx	ecx, BYTE PTR _G$9[ebp]
	movzx	edx, BYTE PTR _B$10[ebp]
	cmp	ecx, edx
	jge	SHORT $LN36@SortChanne
	mov	al, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv138[ebp], al
	jmp	SHORT $LN37@SortChanne
$LN36@SortChanne:
	mov	cl, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv138[ebp], cl
$LN37@SortChanne:
	mov	dl, BYTE PTR tv138[ebp]
	mov	BYTE PTR tv139[ebp], dl
$LN39@SortChanne:
	mov	al, BYTE PTR tv139[ebp]
	mov	BYTE PTR _Smallest$5[ebp], al

; 788  : 			BYTE Middle = 0;

	mov	BYTE PTR _Middle$6[ebp], 0

; 789  : 			if (R == Biggest)

	movzx	ecx, BYTE PTR _R$8[ebp]
	movzx	edx, BYTE PTR _Biggest$7[ebp]
	cmp	ecx, edx
	jne	SHORT $LN14@SortChanne

; 790  : 			{
; 791  : 				Middle = max(G, B);

	movzx	eax, BYTE PTR _G$9[ebp]
	movzx	ecx, BYTE PTR _B$10[ebp]
	cmp	eax, ecx
	jle	SHORT $LN40@SortChanne
	mov	dl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv146[ebp], dl
	jmp	SHORT $LN41@SortChanne
$LN40@SortChanne:
	mov	al, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv146[ebp], al
$LN41@SortChanne:
	mov	cl, BYTE PTR tv146[ebp]
	mov	BYTE PTR _Middle$6[ebp], cl
$LN14@SortChanne:

; 792  : 			}
; 793  : 			if (G == Biggest)

	movzx	edx, BYTE PTR _G$9[ebp]
	movzx	eax, BYTE PTR _Biggest$7[ebp]
	cmp	edx, eax
	jne	SHORT $LN15@SortChanne

; 794  : 			{
; 795  : 				Middle = max(R, B);

	movzx	ecx, BYTE PTR _R$8[ebp]
	movzx	edx, BYTE PTR _B$10[ebp]
	cmp	ecx, edx
	jle	SHORT $LN42@SortChanne
	mov	al, BYTE PTR _R$8[ebp]
	mov	BYTE PTR tv153[ebp], al
	jmp	SHORT $LN43@SortChanne
$LN42@SortChanne:
	mov	cl, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv153[ebp], cl
$LN43@SortChanne:
	mov	dl, BYTE PTR tv153[ebp]
	mov	BYTE PTR _Middle$6[ebp], dl
$LN15@SortChanne:

; 796  : 			}
; 797  : 			if (B == Biggest)

	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Biggest$7[ebp]
	cmp	eax, ecx
	jne	SHORT $LN16@SortChanne

; 798  : 			{
; 799  : 				Middle = max(R, G);

	movzx	edx, BYTE PTR _R$8[ebp]
	movzx	eax, BYTE PTR _G$9[ebp]
	cmp	edx, eax
	jle	SHORT $LN44@SortChanne
	mov	cl, BYTE PTR _R$8[ebp]
	mov	BYTE PTR tv160[ebp], cl
	jmp	SHORT $LN45@SortChanne
$LN44@SortChanne:
	mov	dl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv160[ebp], dl
$LN45@SortChanne:
	mov	al, BYTE PTR tv160[ebp]
	mov	BYTE PTR _Middle$6[ebp], al
$LN16@SortChanne:

; 800  : 			}
; 801  : 			if (StoreSortHowAsAlpha)

	cmp	DWORD PTR _StoreSortHowAsAlpha$[ebp], 0
	je	SHORT $LN17@SortChanne

; 802  : 				Dest[Index + 3] = SortHow;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _SortHow$[ebp]
	mov	BYTE PTR [ecx+3], dl

; 803  : 			else

	jmp	SHORT $LN18@SortChanne
$LN17@SortChanne:

; 804  : 				Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl
$LN18@SortChanne:

; 805  : 			if (InvertAlpha)

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN19@SortChanne

; 806  : 				Dest[Index + 3] = 0xff - Dest[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [eax+3], dl
$LN19@SortChanne:

; 807  : 			switch (SortHow)

	mov	ecx, DWORD PTR _SortHow$[ebp]
	mov	DWORD PTR tv181[ebp], ecx
	cmp	DWORD PTR tv181[ebp], 5
	ja	$LN26@SortChanne
	mov	edx, DWORD PTR tv181[ebp]
	jmp	DWORD PTR $LN46@SortChanne[edx*4]
$LN20@SortChanne:

; 808  : 			{
; 809  : 			case SortRGB:
; 810  : 				Dest[Index + 2] = Biggest;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Biggest$7[ebp]
	mov	BYTE PTR [eax+2], cl

; 811  : 				Dest[Index + 1] = Middle;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Middle$6[ebp]
	mov	BYTE PTR [edx+1], al

; 812  : 				Dest[Index + 0] = Smallest;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _Smallest$5[ebp]
	mov	BYTE PTR [ecx], dl

; 813  : 				break;

	jmp	$LN8@SortChanne
$LN21@SortChanne:

; 814  : 
; 815  : 			case SortRBG:
; 816  : 				Dest[Index + 2] = Biggest;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Biggest$7[ebp]
	mov	BYTE PTR [eax+2], cl

; 817  : 				Dest[Index + 0] = Middle;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Middle$6[ebp]
	mov	BYTE PTR [edx], al

; 818  : 				Dest[Index + 1] = Smallest;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _Smallest$5[ebp]
	mov	BYTE PTR [ecx+1], dl

; 819  : 				break;

	jmp	$LN8@SortChanne
$LN22@SortChanne:

; 820  : 
; 821  : 			case SortGRB:
; 822  : 				Dest[Index + 1] = Biggest;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Biggest$7[ebp]
	mov	BYTE PTR [eax+1], cl

; 823  : 				Dest[Index + 2] = Middle;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Middle$6[ebp]
	mov	BYTE PTR [edx+2], al

; 824  : 				Dest[Index + 0] = Smallest;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _Smallest$5[ebp]
	mov	BYTE PTR [ecx], dl

; 825  : 				break;

	jmp	SHORT $LN8@SortChanne
$LN23@SortChanne:

; 826  : 
; 827  : 			case SortGBR:
; 828  : 				Dest[Index + 1] = Biggest;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Biggest$7[ebp]
	mov	BYTE PTR [eax+1], cl

; 829  : 				Dest[Index + 0] = Middle;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Middle$6[ebp]
	mov	BYTE PTR [edx], al

; 830  : 				Dest[Index + 2] = Smallest;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _Smallest$5[ebp]
	mov	BYTE PTR [ecx+2], dl

; 831  : 				break;

	jmp	SHORT $LN8@SortChanne
$LN24@SortChanne:

; 832  : 
; 833  : 			case SortBRG:
; 834  : 				Dest[Index + 0] = Biggest;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Biggest$7[ebp]
	mov	BYTE PTR [eax], cl

; 835  : 				Dest[Index + 2] = Middle;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Middle$6[ebp]
	mov	BYTE PTR [edx+2], al

; 836  : 				Dest[Index + 1] = Smallest;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _Smallest$5[ebp]
	mov	BYTE PTR [ecx+1], dl

; 837  : 				break;

	jmp	SHORT $LN8@SortChanne
$LN25@SortChanne:

; 838  : 
; 839  : 			case SortBGR:
; 840  : 				Dest[Index + 0] = Biggest;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Biggest$7[ebp]
	mov	BYTE PTR [eax], cl

; 841  : 				Dest[Index + 1] = Middle;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Middle$6[ebp]
	mov	BYTE PTR [edx+1], al

; 842  : 				Dest[Index + 2] = Smallest;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _Smallest$5[ebp]
	mov	BYTE PTR [ecx+2], dl

; 843  : 				break;

	jmp	SHORT $LN8@SortChanne
$LN26@SortChanne:

; 844  : 
; 845  : 			default:
; 846  : 				return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@SortChanne
$LN8@SortChanne:

; 847  : 			}
; 848  : 		}

	jmp	$LN5@SortChanne
$LN6@SortChanne:

; 849  : 	}

	jmp	$LN2@SortChanne
$LN3@SortChanne:

; 850  : 
; 851  : 	return Success;

	xor	eax, eax
$LN1@SortChanne:

; 852  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	2
$LN46@SortChanne:
	DD	$LN20@SortChanne
	DD	$LN21@SortChanne
	DD	$LN22@SortChanne
	DD	$LN23@SortChanne
	DD	$LN24@SortChanne
	DD	$LN25@SortChanne
_SortChannels@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_RowOffset$1 = -44					; size = 4
_PixelSize$ = -40					; size = 4
_Dest$ = -36						; size = 4
_Src$ = -32						; size = 4
_Column$2 = -28						; size = 4
_Row$3 = -24						; size = 4
_Index$4 = -20						; size = 4
_Smallest$5 = -15					; size = 1
tv158 = -14						; size = 1
tv151 = -13						; size = 1
tv144 = -12						; size = 1
tv137 = -11						; size = 1
tv136 = -10						; size = 1
tv130 = -9						; size = 1
tv93 = -8						; size = 1
tv92 = -7						; size = 1
tv86 = -6						; size = 1
_Middle$6 = -5						; size = 1
_Biggest$7 = -4						; size = 1
_R$8 = -3						; size = 1
_G$9 = -2						; size = 1
_B$10 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_UseLuminance$ = 28					; size = 4
_LuminanceThreshold$ = 32				; size = 8
_SortChannels2@32 PROC

; 706  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 707  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@SortChanne

; 708  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SortChanne
$LN8@SortChanne:

; 709  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@SortChanne

; 710  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SortChanne
$LN9@SortChanne:

; 711  : 
; 712  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 713  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 714  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 715  : 
; 716  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@SortChanne
$LN2@SortChanne:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@SortChanne:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@SortChanne

; 717  : 	{
; 718  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 719  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@SortChanne
$LN5@SortChanne:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@SortChanne:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@SortChanne

; 720  : 		{
; 721  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 722  : 			BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$8[ebp], al

; 723  : 			BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$9[ebp], dl

; 724  : 			BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$10[ebp], cl

; 725  : 			BYTE Biggest = max(R, max(G, B));

	movzx	edx, BYTE PTR _G$9[ebp]
	movzx	eax, BYTE PTR _B$10[ebp]
	cmp	edx, eax
	jle	SHORT $LN14@SortChanne
	mov	cl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv86[ebp], cl
	jmp	SHORT $LN15@SortChanne
$LN14@SortChanne:
	mov	dl, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv86[ebp], dl
$LN15@SortChanne:
	movzx	eax, BYTE PTR _R$8[ebp]
	movzx	ecx, BYTE PTR tv86[ebp]
	cmp	eax, ecx
	jle	SHORT $LN18@SortChanne
	mov	dl, BYTE PTR _R$8[ebp]
	mov	BYTE PTR tv93[ebp], dl
	jmp	SHORT $LN19@SortChanne
$LN18@SortChanne:
	movzx	eax, BYTE PTR _G$9[ebp]
	movzx	ecx, BYTE PTR _B$10[ebp]
	cmp	eax, ecx
	jle	SHORT $LN16@SortChanne
	mov	dl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv92[ebp], dl
	jmp	SHORT $LN17@SortChanne
$LN16@SortChanne:
	mov	al, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv92[ebp], al
$LN17@SortChanne:
	mov	cl, BYTE PTR tv92[ebp]
	mov	BYTE PTR tv93[ebp], cl
$LN19@SortChanne:
	mov	dl, BYTE PTR tv93[ebp]
	mov	BYTE PTR _Biggest$7[ebp], dl

; 726  : 			BYTE Smallest = min(R, min(G, B));

	movzx	eax, BYTE PTR _G$9[ebp]
	movzx	ecx, BYTE PTR _B$10[ebp]
	cmp	eax, ecx
	jge	SHORT $LN20@SortChanne
	mov	dl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv130[ebp], dl
	jmp	SHORT $LN21@SortChanne
$LN20@SortChanne:
	mov	al, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv130[ebp], al
$LN21@SortChanne:
	movzx	ecx, BYTE PTR _R$8[ebp]
	movzx	edx, BYTE PTR tv130[ebp]
	cmp	ecx, edx
	jge	SHORT $LN24@SortChanne
	mov	al, BYTE PTR _R$8[ebp]
	mov	BYTE PTR tv137[ebp], al
	jmp	SHORT $LN25@SortChanne
$LN24@SortChanne:
	movzx	ecx, BYTE PTR _G$9[ebp]
	movzx	edx, BYTE PTR _B$10[ebp]
	cmp	ecx, edx
	jge	SHORT $LN22@SortChanne
	mov	al, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv136[ebp], al
	jmp	SHORT $LN23@SortChanne
$LN22@SortChanne:
	mov	cl, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv136[ebp], cl
$LN23@SortChanne:
	mov	dl, BYTE PTR tv136[ebp]
	mov	BYTE PTR tv137[ebp], dl
$LN25@SortChanne:
	mov	al, BYTE PTR tv137[ebp]
	mov	BYTE PTR _Smallest$5[ebp], al

; 727  : 			BYTE Middle = 0;

	mov	BYTE PTR _Middle$6[ebp], 0

; 728  : 			if (R == Biggest)

	movzx	ecx, BYTE PTR _R$8[ebp]
	movzx	edx, BYTE PTR _Biggest$7[ebp]
	cmp	ecx, edx
	jne	SHORT $LN10@SortChanne

; 729  : 			{
; 730  : 				Middle = max(G, B);

	movzx	eax, BYTE PTR _G$9[ebp]
	movzx	ecx, BYTE PTR _B$10[ebp]
	cmp	eax, ecx
	jle	SHORT $LN26@SortChanne
	mov	dl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv144[ebp], dl
	jmp	SHORT $LN27@SortChanne
$LN26@SortChanne:
	mov	al, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv144[ebp], al
$LN27@SortChanne:
	mov	cl, BYTE PTR tv144[ebp]
	mov	BYTE PTR _Middle$6[ebp], cl
$LN10@SortChanne:

; 731  : 			}
; 732  : 			if (G == Biggest)

	movzx	edx, BYTE PTR _G$9[ebp]
	movzx	eax, BYTE PTR _Biggest$7[ebp]
	cmp	edx, eax
	jne	SHORT $LN11@SortChanne

; 733  : 			{
; 734  : 				Middle = max(R, B);

	movzx	ecx, BYTE PTR _R$8[ebp]
	movzx	edx, BYTE PTR _B$10[ebp]
	cmp	ecx, edx
	jle	SHORT $LN28@SortChanne
	mov	al, BYTE PTR _R$8[ebp]
	mov	BYTE PTR tv151[ebp], al
	jmp	SHORT $LN29@SortChanne
$LN28@SortChanne:
	mov	cl, BYTE PTR _B$10[ebp]
	mov	BYTE PTR tv151[ebp], cl
$LN29@SortChanne:
	mov	dl, BYTE PTR tv151[ebp]
	mov	BYTE PTR _Middle$6[ebp], dl
$LN11@SortChanne:

; 735  : 			}
; 736  : 			if (B == Biggest)

	movzx	eax, BYTE PTR _B$10[ebp]
	movzx	ecx, BYTE PTR _Biggest$7[ebp]
	cmp	eax, ecx
	jne	SHORT $LN12@SortChanne

; 737  : 			{
; 738  : 				Middle = max(R, G);

	movzx	edx, BYTE PTR _R$8[ebp]
	movzx	eax, BYTE PTR _G$9[ebp]
	cmp	edx, eax
	jle	SHORT $LN30@SortChanne
	mov	cl, BYTE PTR _R$8[ebp]
	mov	BYTE PTR tv158[ebp], cl
	jmp	SHORT $LN31@SortChanne
$LN30@SortChanne:
	mov	dl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR tv158[ebp], dl
$LN31@SortChanne:
	mov	al, BYTE PTR tv158[ebp]
	mov	BYTE PTR _Middle$6[ebp], al
$LN12@SortChanne:

; 739  : 			}
; 740  : 			Dest[Index + 3] = Src[Index + 3];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 741  : 			Dest[Index + 2] = Biggest;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _Biggest$7[ebp]
	mov	BYTE PTR [ecx+2], dl

; 742  : 			Dest[Index + 1] = Middle;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Middle$6[ebp]
	mov	BYTE PTR [eax+1], cl

; 743  : 			Dest[Index + 0] = Smallest;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Smallest$5[ebp]
	mov	BYTE PTR [edx], al

; 744  : 		}

	jmp	$LN5@SortChanne
$LN6@SortChanne:

; 745  : 	}

	jmp	$LN2@SortChanne
$LN3@SortChanne:

; 746  : 
; 747  : 	return Success;

	xor	eax, eax
$LN1@SortChanne:

; 748  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_SortChannels2@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_MaxIndex$ = -144					; size = 4
_LoopStart$1 = -140					; size = 4
_LoopStart$2 = -136					; size = 4
_LoopStart$3 = -132					; size = 4
_LoopStart$4 = -128					; size = 4
_LoopStart$5 = -124					; size = 4
_UniformWindowSize$ = -120				; size = 4
_RowOffset$6 = -116					; size = 4
_PixelSize$ = -112					; size = 4
tv266 = -108						; size = 4
tv217 = -104						; size = 4
tv200 = -100						; size = 4
tv183 = -96						; size = 4
tv136 = -92						; size = 4
tv80 = -88						; size = 4
tv78 = -84						; size = 4
tv76 = -80						; size = 4
tv71 = -76						; size = 4
tv69 = -72						; size = 4
tv67 = -68						; size = 4
_Dest$ = -64						; size = 4
_ASum$7 = -60						; size = 4
_WIndex$8 = -56						; size = 4
_WIndex$9 = -52						; size = 4
_WIndex$10 = -48					; size = 4
_WIndex$11 = -44					; size = 4
_Column$12 = -40					; size = 4
_Row$13 = -36						; size = 4
_BSum$14 = -32						; size = 4
_GSum$15 = -28						; size = 4
_WIndex$16 = -24					; size = 4
_RSum$17 = -20						; size = 4
_A$18 = -13						; size = 1
_Src$ = -12						; size = 4
_B$19 = -7						; size = 1
_G$20 = -6						; size = 1
_R$21 = -5						; size = 1
_Index$22 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_AlphaWindowSize$ = 28					; size = 4
_RedWindowSize$ = 32					; size = 4
_GreenWindowSize$ = 36					; size = 4
_BlueWindowSize$ = 40					; size = 4
_RollingMeanChannels2@36 PROC

; 584  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H

; 585  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN23@RollingMea

; 586  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RollingMea
$LN23@RollingMea:

; 587  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN24@RollingMea

; 588  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RollingMea
$LN24@RollingMea:

; 589  : 	if (AlphaWindowSize == RedWindowSize == GreenWindowSize == BlueWindowSize == 0)

	mov	eax, DWORD PTR _AlphaWindowSize$[ebp]
	cmp	eax, DWORD PTR _RedWindowSize$[ebp]
	jne	SHORT $LN33@RollingMea
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN34@RollingMea
$LN33@RollingMea:
	mov	DWORD PTR tv67[ebp], 0
$LN34@RollingMea:
	mov	ecx, DWORD PTR tv67[ebp]
	cmp	ecx, DWORD PTR _GreenWindowSize$[ebp]
	jne	SHORT $LN35@RollingMea
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN36@RollingMea
$LN35@RollingMea:
	mov	DWORD PTR tv69[ebp], 0
$LN36@RollingMea:
	mov	edx, DWORD PTR tv69[ebp]
	cmp	edx, DWORD PTR _BlueWindowSize$[ebp]
	jne	SHORT $LN37@RollingMea
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN38@RollingMea
$LN37@RollingMea:
	mov	DWORD PTR tv71[ebp], 0
$LN38@RollingMea:
	cmp	DWORD PTR tv71[ebp], 0
	jne	SHORT $LN25@RollingMea

; 590  : 		return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@RollingMea
$LN25@RollingMea:

; 591  : 
; 592  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 593  : 	BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 594  : 	BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 595  : 	__int32 MaxIndex = (Width * Stride) * Height;

	mov	edx, DWORD PTR _Width$[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	imul	edx, DWORD PTR _Height$[ebp]
	mov	DWORD PTR _MaxIndex$[ebp], edx

; 596  : 	BOOL UniformWindowSize = (AlphaWindowSize == RedWindowSize == GreenWindowSize == BlueWindowSize) ? TRUE : FALSE;

	mov	eax, DWORD PTR _AlphaWindowSize$[ebp]
	cmp	eax, DWORD PTR _RedWindowSize$[ebp]
	jne	SHORT $LN39@RollingMea
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN40@RollingMea
$LN39@RollingMea:
	mov	DWORD PTR tv76[ebp], 0
$LN40@RollingMea:
	mov	ecx, DWORD PTR tv76[ebp]
	cmp	ecx, DWORD PTR _GreenWindowSize$[ebp]
	jne	SHORT $LN41@RollingMea
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN42@RollingMea
$LN41@RollingMea:
	mov	DWORD PTR tv78[ebp], 0
$LN42@RollingMea:
	mov	edx, DWORD PTR tv78[ebp]
	cmp	edx, DWORD PTR _BlueWindowSize$[ebp]
	jne	SHORT $LN43@RollingMea
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN44@RollingMea
$LN43@RollingMea:
	mov	DWORD PTR tv80[ebp], 0
$LN44@RollingMea:
	mov	eax, DWORD PTR tv80[ebp]
	mov	DWORD PTR _UniformWindowSize$[ebp], eax

; 597  : 
; 598  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$13[ebp], 0
	jmp	SHORT $LN4@RollingMea
$LN2@RollingMea:
	mov	ecx, DWORD PTR _Row$13[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$13[ebp], ecx
$LN4@RollingMea:
	mov	edx, DWORD PTR _Row$13[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	$LN3@RollingMea

; 599  : 	{
; 600  : 		int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$13[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$6[ebp], eax

; 601  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$12[ebp], 0
	jmp	SHORT $LN7@RollingMea
$LN5@RollingMea:
	mov	ecx, DWORD PTR _Column$12[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$12[ebp], ecx
$LN7@RollingMea:
	mov	edx, DWORD PTR _Column$12[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	$LN6@RollingMea

; 602  : 		{
; 603  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$12[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$6[ebp]
	mov	DWORD PTR _Index$22[ebp], eax

; 604  : 			BYTE A = Src[Index + 3];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$22[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR _A$18[ebp], dl

; 605  : 			BYTE R = Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$22[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _R$21[ebp], cl

; 606  : 			BYTE G = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$22[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _G$20[ebp], al

; 607  : 			BYTE B = Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$22[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _B$19[ebp], dl

; 608  : 			int ASum = 0;

	mov	DWORD PTR _ASum$7[ebp], 0

; 609  : 			int RSum = 0;

	mov	DWORD PTR _RSum$17[ebp], 0

; 610  : 			int GSum = 0;

	mov	DWORD PTR _GSum$15[ebp], 0

; 611  : 			int BSum = 0;

	mov	DWORD PTR _BSum$14[ebp], 0

; 612  : 
; 613  : 			if (UniformWindowSize)

	cmp	DWORD PTR _UniformWindowSize$[ebp], 0
	je	$LN26@RollingMea

; 614  : 			{
; 615  : 				int LoopStart = Index - AlphaWindowSize >= 0 ? Index - AlphaWindowSize : 0;

	mov	eax, DWORD PTR _Index$22[ebp]
	sub	eax, DWORD PTR _AlphaWindowSize$[ebp]
	js	SHORT $LN45@RollingMea
	mov	ecx, DWORD PTR _Index$22[ebp]
	sub	ecx, DWORD PTR _AlphaWindowSize$[ebp]
	mov	DWORD PTR tv136[ebp], ecx
	jmp	SHORT $LN46@RollingMea
$LN45@RollingMea:
	mov	DWORD PTR tv136[ebp], 0
$LN46@RollingMea:
	mov	edx, DWORD PTR tv136[ebp]
	mov	DWORD PTR _LoopStart$5[ebp], edx

; 616  : 				for (int WIndex = LoopStart; WIndex <= Index; WIndex++)

	mov	eax, DWORD PTR _LoopStart$5[ebp]
	mov	DWORD PTR _WIndex$16[ebp], eax
	jmp	SHORT $LN10@RollingMea
$LN8@RollingMea:
	mov	ecx, DWORD PTR _WIndex$16[ebp]
	add	ecx, 1
	mov	DWORD PTR _WIndex$16[ebp], ecx
$LN10@RollingMea:
	mov	edx, DWORD PTR _WIndex$16[ebp]
	cmp	edx, DWORD PTR _Index$22[ebp]
	jg	SHORT $LN9@RollingMea

; 617  : 				{
; 618  : 					ASum += Src[WIndex + 3];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _WIndex$16[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	add	ecx, DWORD PTR _ASum$7[ebp]
	mov	DWORD PTR _ASum$7[ebp], ecx

; 619  : 					RSum += Src[WIndex + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _WIndex$16[ebp]
	movzx	eax, BYTE PTR [edx+2]
	add	eax, DWORD PTR _RSum$17[ebp]
	mov	DWORD PTR _RSum$17[ebp], eax

; 620  : 					GSum += Src[WIndex + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _WIndex$16[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	add	edx, DWORD PTR _GSum$15[ebp]
	mov	DWORD PTR _GSum$15[ebp], edx

; 621  : 					BSum += Src[WIndex + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _WIndex$16[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _BSum$14[ebp]
	mov	DWORD PTR _BSum$14[ebp], ecx

; 622  : 				}

	jmp	SHORT $LN8@RollingMea
$LN9@RollingMea:

; 623  : 				A = (BYTE)((double)ASum / (double)AlphaWindowSize);

	cvtsi2sd xmm0, DWORD PTR _ASum$7[ebp]
	cvtsi2sd xmm1, DWORD PTR _AlphaWindowSize$[ebp]
	divsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	BYTE PTR _A$18[ebp], dl

; 624  : 				R = (BYTE)((double)RSum / (double)AlphaWindowSize);

	cvtsi2sd xmm0, DWORD PTR _RSum$17[ebp]
	cvtsi2sd xmm1, DWORD PTR _AlphaWindowSize$[ebp]
	divsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	BYTE PTR _R$21[ebp], al

; 625  : 				G = (BYTE)((double)GSum / (double)AlphaWindowSize);

	cvtsi2sd xmm0, DWORD PTR _GSum$15[ebp]
	cvtsi2sd xmm1, DWORD PTR _AlphaWindowSize$[ebp]
	divsd	xmm0, xmm1
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _G$20[ebp], cl

; 626  : 				B = (BYTE)((double)BSum / (double)AlphaWindowSize);

	cvtsi2sd xmm0, DWORD PTR _BSum$14[ebp]
	cvtsi2sd xmm1, DWORD PTR _AlphaWindowSize$[ebp]
	divsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	BYTE PTR _B$19[ebp], dl

; 627  : 			}
; 628  : 			else

	jmp	$LN31@RollingMea
$LN26@RollingMea:

; 629  : 			{
; 630  : 				if (AlphaWindowSize > 0)

	cmp	DWORD PTR _AlphaWindowSize$[ebp], 0
	jle	SHORT $LN28@RollingMea

; 631  : 				{
; 632  : 					int LoopStart = Index - RedWindowSize >= 0 ? Index - RedWindowSize : 0;

	mov	eax, DWORD PTR _Index$22[ebp]
	sub	eax, DWORD PTR _RedWindowSize$[ebp]
	js	SHORT $LN47@RollingMea
	mov	ecx, DWORD PTR _Index$22[ebp]
	sub	ecx, DWORD PTR _RedWindowSize$[ebp]
	mov	DWORD PTR tv183[ebp], ecx
	jmp	SHORT $LN48@RollingMea
$LN47@RollingMea:
	mov	DWORD PTR tv183[ebp], 0
$LN48@RollingMea:
	mov	edx, DWORD PTR tv183[ebp]
	mov	DWORD PTR _LoopStart$4[ebp], edx

; 633  : 					for (int WIndex = LoopStart; WIndex <= Index; WIndex++)

	mov	eax, DWORD PTR _LoopStart$4[ebp]
	mov	DWORD PTR _WIndex$11[ebp], eax
	jmp	SHORT $LN13@RollingMea
$LN11@RollingMea:
	mov	ecx, DWORD PTR _WIndex$11[ebp]
	add	ecx, 1
	mov	DWORD PTR _WIndex$11[ebp], ecx
$LN13@RollingMea:
	mov	edx, DWORD PTR _WIndex$11[ebp]
	cmp	edx, DWORD PTR _Index$22[ebp]
	jg	SHORT $LN12@RollingMea

; 634  : 						RSum += Src[WIndex + 3];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _WIndex$11[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	add	ecx, DWORD PTR _RSum$17[ebp]
	mov	DWORD PTR _RSum$17[ebp], ecx
	jmp	SHORT $LN11@RollingMea
$LN12@RollingMea:

; 635  : 					R = (BYTE)((double)RSum / (double)AlphaWindowSize);

	cvtsi2sd xmm0, DWORD PTR _RSum$17[ebp]
	cvtsi2sd xmm1, DWORD PTR _AlphaWindowSize$[ebp]
	divsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	BYTE PTR _R$21[ebp], dl
$LN28@RollingMea:

; 636  : 				}
; 637  : 				if (RedWindowSize > 0)

	cmp	DWORD PTR _RedWindowSize$[ebp], 0
	jle	SHORT $LN29@RollingMea

; 638  : 				{
; 639  : 					int LoopStart = Index - RedWindowSize >= 0 ? Index - RedWindowSize : 0;

	mov	eax, DWORD PTR _Index$22[ebp]
	sub	eax, DWORD PTR _RedWindowSize$[ebp]
	js	SHORT $LN49@RollingMea
	mov	ecx, DWORD PTR _Index$22[ebp]
	sub	ecx, DWORD PTR _RedWindowSize$[ebp]
	mov	DWORD PTR tv200[ebp], ecx
	jmp	SHORT $LN50@RollingMea
$LN49@RollingMea:
	mov	DWORD PTR tv200[ebp], 0
$LN50@RollingMea:
	mov	edx, DWORD PTR tv200[ebp]
	mov	DWORD PTR _LoopStart$3[ebp], edx

; 640  : 					for (int WIndex = LoopStart; WIndex <= Index; WIndex++)

	mov	eax, DWORD PTR _LoopStart$3[ebp]
	mov	DWORD PTR _WIndex$10[ebp], eax
	jmp	SHORT $LN16@RollingMea
$LN14@RollingMea:
	mov	ecx, DWORD PTR _WIndex$10[ebp]
	add	ecx, 1
	mov	DWORD PTR _WIndex$10[ebp], ecx
$LN16@RollingMea:
	mov	edx, DWORD PTR _WIndex$10[ebp]
	cmp	edx, DWORD PTR _Index$22[ebp]
	jg	SHORT $LN15@RollingMea

; 641  : 						RSum += Src[WIndex + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _WIndex$10[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	add	ecx, DWORD PTR _RSum$17[ebp]
	mov	DWORD PTR _RSum$17[ebp], ecx
	jmp	SHORT $LN14@RollingMea
$LN15@RollingMea:

; 642  : 					R = (BYTE)((double)GSum / (double)RedWindowSize);

	cvtsi2sd xmm0, DWORD PTR _GSum$15[ebp]
	cvtsi2sd xmm1, DWORD PTR _RedWindowSize$[ebp]
	divsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	BYTE PTR _R$21[ebp], dl
$LN29@RollingMea:

; 643  : 				}
; 644  : 				if (GreenWindowSize > 0)

	cmp	DWORD PTR _GreenWindowSize$[ebp], 0
	jle	SHORT $LN30@RollingMea

; 645  : 				{
; 646  : 					int LoopStart = Index - GreenWindowSize >= 0 ? Index - GreenWindowSize : 0;

	mov	eax, DWORD PTR _Index$22[ebp]
	sub	eax, DWORD PTR _GreenWindowSize$[ebp]
	js	SHORT $LN51@RollingMea
	mov	ecx, DWORD PTR _Index$22[ebp]
	sub	ecx, DWORD PTR _GreenWindowSize$[ebp]
	mov	DWORD PTR tv217[ebp], ecx
	jmp	SHORT $LN52@RollingMea
$LN51@RollingMea:
	mov	DWORD PTR tv217[ebp], 0
$LN52@RollingMea:
	mov	edx, DWORD PTR tv217[ebp]
	mov	DWORD PTR _LoopStart$2[ebp], edx

; 647  : 					for (int WIndex = LoopStart; WIndex <= Index; WIndex++)

	mov	eax, DWORD PTR _LoopStart$2[ebp]
	mov	DWORD PTR _WIndex$9[ebp], eax
	jmp	SHORT $LN19@RollingMea
$LN17@RollingMea:
	mov	ecx, DWORD PTR _WIndex$9[ebp]
	add	ecx, 1
	mov	DWORD PTR _WIndex$9[ebp], ecx
$LN19@RollingMea:
	mov	edx, DWORD PTR _WIndex$9[ebp]
	cmp	edx, DWORD PTR _Index$22[ebp]
	jg	SHORT $LN18@RollingMea

; 648  : 						GSum += Src[WIndex + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _WIndex$9[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	add	ecx, DWORD PTR _GSum$15[ebp]
	mov	DWORD PTR _GSum$15[ebp], ecx
	jmp	SHORT $LN17@RollingMea
$LN18@RollingMea:

; 649  : 					G = (BYTE)((double)GSum / (double)GreenWindowSize);

	cvtsi2sd xmm0, DWORD PTR _GSum$15[ebp]
	cvtsi2sd xmm1, DWORD PTR _GreenWindowSize$[ebp]
	divsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	BYTE PTR _G$20[ebp], dl
$LN30@RollingMea:

; 650  : 				}
; 651  : 				if (BlueWindowSize > 0)

	cmp	DWORD PTR _BlueWindowSize$[ebp], 0
	jle	SHORT $LN31@RollingMea

; 652  : 				{
; 653  : 					int LoopStart = Index - BlueWindowSize >= 0 ? Index - BlueWindowSize : 0;

	mov	eax, DWORD PTR _Index$22[ebp]
	sub	eax, DWORD PTR _BlueWindowSize$[ebp]
	js	SHORT $LN53@RollingMea
	mov	ecx, DWORD PTR _Index$22[ebp]
	sub	ecx, DWORD PTR _BlueWindowSize$[ebp]
	mov	DWORD PTR tv266[ebp], ecx
	jmp	SHORT $LN54@RollingMea
$LN53@RollingMea:
	mov	DWORD PTR tv266[ebp], 0
$LN54@RollingMea:
	mov	edx, DWORD PTR tv266[ebp]
	mov	DWORD PTR _LoopStart$1[ebp], edx

; 654  : 					for (int WIndex = LoopStart; WIndex <= Index; WIndex++)

	mov	eax, DWORD PTR _LoopStart$1[ebp]
	mov	DWORD PTR _WIndex$8[ebp], eax
	jmp	SHORT $LN22@RollingMea
$LN20@RollingMea:
	mov	ecx, DWORD PTR _WIndex$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _WIndex$8[ebp], ecx
$LN22@RollingMea:
	mov	edx, DWORD PTR _WIndex$8[ebp]
	cmp	edx, DWORD PTR _Index$22[ebp]
	jg	SHORT $LN21@RollingMea

; 655  : 						BSum += Src[WIndex + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _WIndex$8[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _BSum$14[ebp]
	mov	DWORD PTR _BSum$14[ebp], ecx
	jmp	SHORT $LN20@RollingMea
$LN21@RollingMea:

; 656  : 					B = (BYTE)((double)ASum / (double)BlueWindowSize);

	cvtsi2sd xmm0, DWORD PTR _ASum$7[ebp]
	cvtsi2sd xmm1, DWORD PTR _BlueWindowSize$[ebp]
	divsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	BYTE PTR _B$19[ebp], dl
$LN31@RollingMea:

; 657  : 				}
; 658  : 			}
; 659  : 
; 660  : 			Dest[Index + 3] = A;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$22[ebp]
	mov	cl, BYTE PTR _A$18[ebp]
	mov	BYTE PTR [eax+3], cl

; 661  : 			Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$22[ebp]
	mov	al, BYTE PTR _R$21[ebp]
	mov	BYTE PTR [edx+2], al

; 662  : 			Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$22[ebp]
	mov	dl, BYTE PTR _G$20[ebp]
	mov	BYTE PTR [ecx+1], dl

; 663  : 			Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$22[ebp]
	mov	cl, BYTE PTR _B$19[ebp]
	mov	BYTE PTR [eax], cl

; 664  : 		}

	jmp	$LN5@RollingMea
$LN6@RollingMea:

; 665  : 	}

	jmp	$LN2@RollingMea
$LN3@RollingMea:

; 666  : 
; 667  : 	return Success;

	xor	eax, eax
$LN1@RollingMea:

; 668  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_RollingMeanChannels2@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
tv69 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_WindowSize$ = 28					; size = 4
_IncludeAlpha$ = 32					; size = 4
_RollingMeanChannels@28 PROC

; 689  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 690  : 	return RollingMeanChannels2(Source, Width, Height, Stride, Destination,

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN3@RollingMea
	mov	eax, DWORD PTR _WindowSize$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@RollingMea
$LN3@RollingMea:
	mov	DWORD PTR tv69[ebp], 0
$LN4@RollingMea:
	mov	ecx, DWORD PTR _WindowSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _WindowSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _WindowSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	mov	edx, DWORD PTR _Destination$[ebp]
	push	edx
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_RollingMeanChannels2@36

; 691  : 		IncludeAlpha ? WindowSize : 0, WindowSize, WindowSize, WindowSize);
; 692  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_RollingMeanChannels@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_RowOffset$1 = -52					; size = 4
_PixelSize$ = -48					; size = 4
_HasAlpha$ = -44					; size = 4
tv71 = -40						; size = 4
tv69 = -36						; size = 4
_Alpha$ = -32						; size = 4
_Hue$ = -28						; size = 4
_Saturation$ = -24					; size = 4
_Luminance$ = -20					; size = 4
_Column$2 = -16						; size = 4
_Row$3 = -12						; size = 4
_Src$ = -8						; size = 4
_Index$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_AlphaDest$ = 24					; size = 4
_HueDest$ = 28						; size = 4
_SaturationDest$ = 32					; size = 4
_LuminanceDest$ = 36					; size = 4
_SplitImageIntoHSLChannels@32 PROC

; 522  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 523  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@SplitImage

; 524  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SplitImage
$LN8@SplitImage:

; 525  : 	if (HueDest == NULL)

	cmp	DWORD PTR _HueDest$[ebp], 0
	jne	SHORT $LN9@SplitImage

; 526  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SplitImage
$LN9@SplitImage:

; 527  : 	if (SaturationDest == NULL)

	cmp	DWORD PTR _SaturationDest$[ebp], 0
	jne	SHORT $LN10@SplitImage

; 528  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SplitImage
$LN10@SplitImage:

; 529  : 	if (LuminanceDest == NULL)

	cmp	DWORD PTR _LuminanceDest$[ebp], 0
	jne	SHORT $LN11@SplitImage

; 530  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SplitImage
$LN11@SplitImage:

; 531  : 	BOOL HasAlpha = AlphaDest == NULL ? FALSE : TRUE;

	cmp	DWORD PTR _AlphaDest$[ebp], 0
	jne	SHORT $LN14@SplitImage
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN15@SplitImage
$LN14@SplitImage:
	mov	DWORD PTR tv69[ebp], 1
$LN15@SplitImage:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _HasAlpha$[ebp], eax

; 532  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 533  : 	BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 534  : 	BYTE *Hue = (BYTE *)HueDest;

	mov	edx, DWORD PTR _HueDest$[ebp]
	mov	DWORD PTR _Hue$[ebp], edx

; 535  : 	BYTE *Saturation = (BYTE *)SaturationDest;

	mov	eax, DWORD PTR _SaturationDest$[ebp]
	mov	DWORD PTR _Saturation$[ebp], eax

; 536  : 	BYTE *Luminance = (BYTE *)LuminanceDest;

	mov	ecx, DWORD PTR _LuminanceDest$[ebp]
	mov	DWORD PTR _Luminance$[ebp], ecx

; 537  : 	BYTE *Alpha = HasAlpha ? (BYTE *)AlphaDest : NULL;

	cmp	DWORD PTR _HasAlpha$[ebp], 0
	je	SHORT $LN16@SplitImage
	mov	edx, DWORD PTR _AlphaDest$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN17@SplitImage
$LN16@SplitImage:
	mov	DWORD PTR tv71[ebp], 0
$LN17@SplitImage:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _Alpha$[ebp], eax

; 538  : 
; 539  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@SplitImage
$LN2@SplitImage:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@SplitImage:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	$LN3@SplitImage

; 540  : 	{
; 541  : 		int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 542  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@SplitImage
$LN5@SplitImage:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@SplitImage:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	$LN6@SplitImage

; 543  : 		{
; 544  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$2[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 545  : 			Luminance[Index + 0] = Src[Index + 0];

	mov	ecx, DWORD PTR _Luminance$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 546  : 			Luminance[Index + 1] = Src[Index + 0];

	mov	ecx, DWORD PTR _Luminance$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+1], al

; 547  : 			Luminance[Index + 2] = Src[Index + 0];

	mov	ecx, DWORD PTR _Luminance$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+2], al

; 548  : 
; 549  : 			Saturation[Index + 0] = Src[Index + 1];

	mov	ecx, DWORD PTR _Saturation$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx], al

; 550  : 			Saturation[Index + 1] = Src[Index + 1];

	mov	ecx, DWORD PTR _Saturation$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 551  : 			Saturation[Index + 2] = Src[Index + 1];

	mov	ecx, DWORD PTR _Saturation$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+2], al

; 552  : 
; 553  : 			Hue[Index + 0] = Src[Index + 2];

	mov	ecx, DWORD PTR _Hue$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx], al

; 554  : 			Hue[Index + 1] = Src[Index + 2];

	mov	ecx, DWORD PTR _Hue$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+1], al

; 555  : 			Hue[Index + 2] = Src[Index + 2];

	mov	ecx, DWORD PTR _Hue$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 556  : 
; 557  : 			if (HasAlpha)

	cmp	DWORD PTR _HasAlpha$[ebp], 0
	je	SHORT $LN12@SplitImage

; 558  : 			{
; 559  : 				Alpha[Index + 0] = Src[Index + 3];

	mov	ecx, DWORD PTR _Alpha$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx], al

; 560  : 				Alpha[Index + 1] = Src[Index + 3];

	mov	ecx, DWORD PTR _Alpha$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+1], al

; 561  : 				Alpha[Index + 2] = Src[Index + 3];

	mov	ecx, DWORD PTR _Alpha$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+2], al
$LN12@SplitImage:

; 562  : 			}
; 563  : 		}

	jmp	$LN5@SplitImage
$LN6@SplitImage:

; 564  : 	}

	jmp	$LN2@SplitImage
$LN3@SplitImage:

; 565  : 
; 566  : 	return Success;

	xor	eax, eax
$LN1@SplitImage:

; 567  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_SplitImageIntoHSLChannels@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_RowOffset$1 = -52					; size = 4
_PixelSize$ = -48					; size = 4
_HasAlpha$ = -44					; size = 4
tv71 = -40						; size = 4
tv69 = -36						; size = 4
_Alpha$ = -32						; size = 4
_Red$ = -28						; size = 4
_Green$ = -24						; size = 4
_Blue$ = -20						; size = 4
_Column$2 = -16						; size = 4
_Row$3 = -12						; size = 4
_Src$ = -8						; size = 4
_Index$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_AlphaDest$ = 24					; size = 4
_RedDest$ = 28						; size = 4
_GreenDest$ = 32					; size = 4
_BlueDest$ = 36						; size = 4
_SplitImageIntoChannels@32 PROC

; 461  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 462  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@SplitImage

; 463  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SplitImage
$LN8@SplitImage:

; 464  : 	if (RedDest == NULL)

	cmp	DWORD PTR _RedDest$[ebp], 0
	jne	SHORT $LN9@SplitImage

; 465  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SplitImage
$LN9@SplitImage:

; 466  : 	if (GreenDest == NULL)

	cmp	DWORD PTR _GreenDest$[ebp], 0
	jne	SHORT $LN10@SplitImage

; 467  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SplitImage
$LN10@SplitImage:

; 468  : 	if (BlueDest == NULL)

	cmp	DWORD PTR _BlueDest$[ebp], 0
	jne	SHORT $LN11@SplitImage

; 469  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@SplitImage
$LN11@SplitImage:

; 470  : 	BOOL HasAlpha = AlphaDest == NULL ? FALSE : TRUE;

	cmp	DWORD PTR _AlphaDest$[ebp], 0
	jne	SHORT $LN14@SplitImage
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN15@SplitImage
$LN14@SplitImage:
	mov	DWORD PTR tv69[ebp], 1
$LN15@SplitImage:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _HasAlpha$[ebp], eax

; 471  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 472  : 	BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 473  : 	BYTE *Red = (BYTE *)RedDest;

	mov	edx, DWORD PTR _RedDest$[ebp]
	mov	DWORD PTR _Red$[ebp], edx

; 474  : 	BYTE *Green = (BYTE *)GreenDest;

	mov	eax, DWORD PTR _GreenDest$[ebp]
	mov	DWORD PTR _Green$[ebp], eax

; 475  : 	BYTE *Blue = (BYTE *)BlueDest;

	mov	ecx, DWORD PTR _BlueDest$[ebp]
	mov	DWORD PTR _Blue$[ebp], ecx

; 476  : 	BYTE *Alpha = HasAlpha ? (BYTE *)AlphaDest : NULL;

	cmp	DWORD PTR _HasAlpha$[ebp], 0
	je	SHORT $LN16@SplitImage
	mov	edx, DWORD PTR _AlphaDest$[ebp]
	mov	DWORD PTR tv71[ebp], edx
	jmp	SHORT $LN17@SplitImage
$LN16@SplitImage:
	mov	DWORD PTR tv71[ebp], 0
$LN17@SplitImage:
	mov	eax, DWORD PTR tv71[ebp]
	mov	DWORD PTR _Alpha$[ebp], eax

; 477  : 
; 478  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@SplitImage
$LN2@SplitImage:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@SplitImage:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	$LN3@SplitImage

; 479  : 	{
; 480  : 		int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 481  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@SplitImage
$LN5@SplitImage:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@SplitImage:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	$LN6@SplitImage

; 482  : 		{
; 483  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$2[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 484  : 			Blue[Index + 0] = Src[Index + 0];

	mov	ecx, DWORD PTR _Blue$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 485  : 			Blue[Index + 1] = Src[Index + 0];

	mov	ecx, DWORD PTR _Blue$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+1], al

; 486  : 			Blue[Index + 2] = Src[Index + 0];

	mov	ecx, DWORD PTR _Blue$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+2], al

; 487  : 
; 488  : 			Green[Index + 0] = Src[Index + 1];

	mov	ecx, DWORD PTR _Green$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx], al

; 489  : 			Green[Index + 1] = Src[Index + 1];

	mov	ecx, DWORD PTR _Green$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 490  : 			Green[Index + 2] = Src[Index + 1];

	mov	ecx, DWORD PTR _Green$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+2], al

; 491  : 
; 492  : 			Red[Index + 0] = Src[Index + 2];

	mov	ecx, DWORD PTR _Red$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx], al

; 493  : 			Red[Index + 1] = Src[Index + 2];

	mov	ecx, DWORD PTR _Red$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+1], al

; 494  : 			Red[Index + 2] = Src[Index + 2];

	mov	ecx, DWORD PTR _Red$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 495  : 
; 496  : 			if (HasAlpha)

	cmp	DWORD PTR _HasAlpha$[ebp], 0
	je	SHORT $LN12@SplitImage

; 497  : 			{
; 498  : 				Alpha[Index + 0] = Src[Index + 3];

	mov	ecx, DWORD PTR _Alpha$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx], al

; 499  : 				Alpha[Index + 1] = Src[Index + 3];

	mov	ecx, DWORD PTR _Alpha$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+1], al

; 500  : 				Alpha[Index + 2] = Src[Index + 3];

	mov	ecx, DWORD PTR _Alpha$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+2], al
$LN12@SplitImage:

; 501  : 			}
; 502  : 		}

	jmp	$LN5@SplitImage
$LN6@SplitImage:

; 503  : 	}

	jmp	$LN2@SplitImage
$LN3@SplitImage:

; 504  : 
; 505  : 	return Success;

	xor	eax, eax
$LN1@SplitImage:

; 506  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_SplitImageIntoChannels@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Hue$ = -36						; size = 4
_Saturation$ = -32					; size = 4
_Luminance$ = -28					; size = 4
_RowOffset$1 = -24					; size = 4
_PixelSize$ = -20					; size = 4
_Dest$ = -16						; size = 4
_Column$2 = -12						; size = 4
_Row$3 = -8						; size = 4
_Index$4 = -4						; size = 4
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_HueChannel$ = 24					; size = 4
_SaturationChannel$ = 28				; size = 4
_LuminanceChannel$ = 32					; size = 4
_HSLChannelMerge@28 PROC

; 415  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 416  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@HSLChannel

; 417  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@HSLChannel
$LN8@HSLChannel:

; 418  : 	if (HueChannel == NULL)

	cmp	DWORD PTR _HueChannel$[ebp], 0
	jne	SHORT $LN9@HSLChannel

; 419  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@HSLChannel
$LN9@HSLChannel:

; 420  : 	if (SaturationChannel == NULL)

	cmp	DWORD PTR _SaturationChannel$[ebp], 0
	jne	SHORT $LN10@HSLChannel

; 421  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@HSLChannel
$LN10@HSLChannel:

; 422  : 	if (LuminanceChannel == NULL)

	cmp	DWORD PTR _LuminanceChannel$[ebp], 0
	jne	SHORT $LN11@HSLChannel

; 423  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@HSLChannel
$LN11@HSLChannel:

; 424  : 
; 425  : 	BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 426  : 	BYTE *Hue = (BYTE *)HueChannel;

	mov	ecx, DWORD PTR _HueChannel$[ebp]
	mov	DWORD PTR _Hue$[ebp], ecx

; 427  : 	BYTE *Saturation = (BYTE *)SaturationChannel;

	mov	edx, DWORD PTR _SaturationChannel$[ebp]
	mov	DWORD PTR _Saturation$[ebp], edx

; 428  : 	BYTE *Luminance = (BYTE *)LuminanceChannel;

	mov	eax, DWORD PTR _LuminanceChannel$[ebp]
	mov	DWORD PTR _Luminance$[ebp], eax

; 429  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 430  : 
; 431  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@HSLChannel
$LN2@HSLChannel:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@HSLChannel:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@HSLChannel

; 432  : 	{
; 433  : 		int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 434  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@HSLChannel
$LN5@HSLChannel:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@HSLChannel:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@HSLChannel

; 435  : 		{
; 436  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$2[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 437  : 			Dest[Index + 0] = Luminance[Index + 0];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Luminance$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 438  : 			Dest[Index + 1] = Saturation[Index + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Saturation$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 439  : 			Dest[Index + 2] = Hue[Index + 2];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Hue$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 440  : 			Dest[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH

; 441  : 		}

	jmp	SHORT $LN5@HSLChannel
$LN6@HSLChannel:

; 442  : 	}

	jmp	$LN2@HSLChannel
$LN3@HSLChannel:

; 443  : 
; 444  : 	return Success;

	xor	eax, eax
$LN1@HSLChannel:

; 445  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_HSLChannelMerge@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Ch1$ = -40						; size = 4
_Ch2$ = -36						; size = 4
_Ch3$ = -32						; size = 4
_Ch4$ = -28						; size = 4
_RowOffset$1 = -24					; size = 4
_PixelSize$ = -20					; size = 4
_Dest$ = -16						; size = 4
_Column$2 = -12						; size = 4
_Row$3 = -8						; size = 4
_Index$4 = -4						; size = 4
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Channel1$ = 24						; size = 4
_Channel2$ = 28						; size = 4
_Channel3$ = 32						; size = 4
_Channel4$ = 36						; size = 4
_CombineChannels32@32 PROC

; 267  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 268  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@CombineCha

; 269  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CombineCha
$LN8@CombineCha:

; 270  : 	if (Channel1 == NULL)

	cmp	DWORD PTR _Channel1$[ebp], 0
	jne	SHORT $LN9@CombineCha

; 271  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CombineCha
$LN9@CombineCha:

; 272  : 	if (Channel2 == NULL)

	cmp	DWORD PTR _Channel2$[ebp], 0
	jne	SHORT $LN10@CombineCha

; 273  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CombineCha
$LN10@CombineCha:

; 274  : 	if (Channel3 == NULL)

	cmp	DWORD PTR _Channel3$[ebp], 0
	jne	SHORT $LN11@CombineCha

; 275  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CombineCha
$LN11@CombineCha:

; 276  : 	if (Channel4 == NULL)

	cmp	DWORD PTR _Channel4$[ebp], 0
	jne	SHORT $LN12@CombineCha

; 277  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@CombineCha
$LN12@CombineCha:

; 278  : 
; 279  : 	BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 280  : 	BYTE *Ch1 = (BYTE *)Channel1;

	mov	ecx, DWORD PTR _Channel1$[ebp]
	mov	DWORD PTR _Ch1$[ebp], ecx

; 281  : 	BYTE *Ch2 = (BYTE *)Channel2;

	mov	edx, DWORD PTR _Channel2$[ebp]
	mov	DWORD PTR _Ch2$[ebp], edx

; 282  : 	BYTE *Ch3 = (BYTE *)Channel3;

	mov	eax, DWORD PTR _Channel3$[ebp]
	mov	DWORD PTR _Ch3$[ebp], eax

; 283  : 	BYTE *Ch4 = (BYTE *)Channel4;

	mov	ecx, DWORD PTR _Channel4$[ebp]
	mov	DWORD PTR _Ch4$[ebp], ecx

; 284  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 285  : 
; 286  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@CombineCha
$LN2@CombineCha:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@CombineCha:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@CombineCha

; 287  : 	{
; 288  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 289  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@CombineCha
$LN5@CombineCha:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@CombineCha:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@CombineCha

; 290  : 		{
; 291  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 292  : 			Dest[Index + 0] = Ch4[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Ch4$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 293  : 			Dest[Index + 1] = Ch3[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Ch3$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 294  : 			Dest[Index + 2] = Ch2[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Ch2$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 295  : 			Dest[Index + 3] = Ch1[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Ch1$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 296  : 		}

	jmp	SHORT $LN5@CombineCha
$LN6@CombineCha:

; 297  : 	}

	jmp	$LN2@CombineCha
$LN3@CombineCha:

; 298  : 
; 299  : 	return Success;

	xor	eax, eax
$LN1@CombineCha:

; 300  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_CombineChannels32@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Alpha$ = -40						; size = 4
_Red$ = -36						; size = 4
_Green$ = -32						; size = 4
_Blue$ = -28						; size = 4
_RowOffset$1 = -24					; size = 4
_PixelSize$ = -20					; size = 4
_Dest$ = -16						; size = 4
_Column$2 = -12						; size = 4
_Row$3 = -8						; size = 4
_Index$4 = -4						; size = 4
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_AlphaChannel$ = 24					; size = 4
_RedChannel$ = 28					; size = 4
_GreenChannel$ = 32					; size = 4
_BlueChannel$ = 36					; size = 4
_ChannelMergeAlpha@32 PROC

; 367  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 368  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@ChannelMer

; 369  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelMer
$LN8@ChannelMer:

; 370  : 	if (AlphaChannel == NULL)

	cmp	DWORD PTR _AlphaChannel$[ebp], 0
	jne	SHORT $LN9@ChannelMer

; 371  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelMer
$LN9@ChannelMer:

; 372  : 	if (RedChannel == NULL)

	cmp	DWORD PTR _RedChannel$[ebp], 0
	jne	SHORT $LN10@ChannelMer

; 373  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelMer
$LN10@ChannelMer:

; 374  : 	if (GreenChannel == NULL)

	cmp	DWORD PTR _GreenChannel$[ebp], 0
	jne	SHORT $LN11@ChannelMer

; 375  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelMer
$LN11@ChannelMer:

; 376  : 	if (BlueChannel == NULL)

	cmp	DWORD PTR _BlueChannel$[ebp], 0
	jne	SHORT $LN12@ChannelMer

; 377  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelMer
$LN12@ChannelMer:

; 378  : 
; 379  : 	BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 380  : 	BYTE *Alpha = (BYTE *)AlphaChannel;

	mov	ecx, DWORD PTR _AlphaChannel$[ebp]
	mov	DWORD PTR _Alpha$[ebp], ecx

; 381  : 	BYTE *Red = (BYTE *)RedChannel;

	mov	edx, DWORD PTR _RedChannel$[ebp]
	mov	DWORD PTR _Red$[ebp], edx

; 382  : 	BYTE *Green = (BYTE *)GreenChannel;

	mov	eax, DWORD PTR _GreenChannel$[ebp]
	mov	DWORD PTR _Green$[ebp], eax

; 383  : 	BYTE *Blue = (BYTE *)BlueChannel;

	mov	ecx, DWORD PTR _BlueChannel$[ebp]
	mov	DWORD PTR _Blue$[ebp], ecx

; 384  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 385  : 
; 386  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ChannelMer
$LN2@ChannelMer:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@ChannelMer:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@ChannelMer

; 387  : 	{
; 388  : 		int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 389  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ChannelMer
$LN5@ChannelMer:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@ChannelMer:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@ChannelMer

; 390  : 		{
; 391  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 392  : 			Dest[Index + 0] = Blue[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Blue$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 393  : 			Dest[Index + 1] = Green[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Green$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 394  : 			Dest[Index + 2] = Red[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Red$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 395  : 			Dest[Index + 3] = Alpha[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Alpha$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 396  : 		}

	jmp	SHORT $LN5@ChannelMer
$LN6@ChannelMer:

; 397  : 	}

	jmp	$LN2@ChannelMer
$LN3@ChannelMer:

; 398  : 
; 399  : 	return Success;

	xor	eax, eax
$LN1@ChannelMer:

; 400  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_ChannelMergeAlpha@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\imagemanipulation.cpp
_TEXT	SEGMENT
_Red$ = -36						; size = 4
_Green$ = -32						; size = 4
_Blue$ = -28						; size = 4
_RowOffset$1 = -24					; size = 4
_PixelSize$ = -20					; size = 4
_Dest$ = -16						; size = 4
_Column$2 = -12						; size = 4
_Row$3 = -8						; size = 4
_Index$4 = -4						; size = 4
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_RedChannel$ = 24					; size = 4
_GreenChannel$ = 28					; size = 4
_BlueChannel$ = 32					; size = 4
_ChannelMerge@28 PROC

; 315  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 316  : #if 0
; 317  : 	BYTE *NotUsed = new BYTE[Height * Stride];
; 318  : 	return CombineChannels32(Destination, Width, Height, Stride, BlueChannel, GreenChannel, RedChannel, NotUsed);
; 319  : 	delete[] NotUsed;
; 320  : #else
; 321  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN8@ChannelMer

; 322  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelMer
$LN8@ChannelMer:

; 323  : 	if (RedChannel == NULL)

	cmp	DWORD PTR _RedChannel$[ebp], 0
	jne	SHORT $LN9@ChannelMer

; 324  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelMer
$LN9@ChannelMer:

; 325  : 	if (GreenChannel == NULL)

	cmp	DWORD PTR _GreenChannel$[ebp], 0
	jne	SHORT $LN10@ChannelMer

; 326  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelMer
$LN10@ChannelMer:

; 327  : 	if (BlueChannel == NULL)

	cmp	DWORD PTR _BlueChannel$[ebp], 0
	jne	SHORT $LN11@ChannelMer

; 328  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelMer
$LN11@ChannelMer:

; 329  : 
; 330  : 	BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 331  : 	BYTE *Red = (BYTE *)RedChannel;

	mov	ecx, DWORD PTR _RedChannel$[ebp]
	mov	DWORD PTR _Red$[ebp], ecx

; 332  : 	BYTE *Green = (BYTE *)GreenChannel;

	mov	edx, DWORD PTR _GreenChannel$[ebp]
	mov	DWORD PTR _Green$[ebp], edx

; 333  : 	BYTE *Blue = (BYTE *)BlueChannel;

	mov	eax, DWORD PTR _BlueChannel$[ebp]
	mov	DWORD PTR _Blue$[ebp], eax

; 334  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 335  : 
; 336  : 	for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ChannelMer
$LN2@ChannelMer:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@ChannelMer:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@ChannelMer

; 337  : 	{
; 338  : 		int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 339  : 		for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ChannelMer
$LN5@ChannelMer:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@ChannelMer:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@ChannelMer

; 340  : 		{
; 341  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$2[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 342  : 			Dest[Index + 0] = Blue[Index + 0];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Blue$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 343  : 			Dest[Index + 1] = Green[Index + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Green$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 344  : 			Dest[Index + 2] = Red[Index + 2];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Red$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 345  : 			Dest[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH

; 346  : 		}

	jmp	SHORT $LN5@ChannelMer
$LN6@ChannelMer:

; 347  : 	}

	jmp	$LN2@ChannelMer
$LN3@ChannelMer:

; 348  : 
; 349  : 	return Success;

	xor	eax, eax
$LN1@ChannelMer:

; 350  : #endif
; 351  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_ChannelMerge@28 ENDP
_TEXT	ENDS
END
