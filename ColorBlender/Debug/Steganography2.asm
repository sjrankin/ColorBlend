; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Steganography2.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?Masks@@3PAEA					; Masks
PUBLIC	?ReverseMasks@@3PAEA				; ReverseMasks
PUBLIC	?MarkerID@@3PAEA				; MarkerID
_DATA	SEGMENT
?Masks@@3PAEA DB 00H					; Masks
	DB	01H
	DB	03H
	DB	07H
	DB	0fH
	DB	01fH
	DB	03fH
	DB	07fH
?ReverseMasks@@3PAEA DB 0ffH				; ReverseMasks
	DB	0feH
	DB	0fcH
	DB	0f8H
	DB	0f0H
	DB	0e0H
	DB	0c0H
	DB	080H
?MarkerID@@3PAEA DB 0d8H				; MarkerID
	DB	06fH
	DB	0c5H
	DB	09dH
	DB	081H
	DB	09bH
	DB	04dH
	DB	058H
	DB	09aH
	DB	0ebH
	DB	0aaH
	DB	04cH
	DB	0b4H
	DB	05H
	DB	048H
	DB	05eH
_DATA	ENDS
PUBLIC	_SteganographyAddStream@68
PUBLIC	_SteganographyAddConstant@60
PUBLIC	_SteganographyAddString@64
PUBLIC	_SteganographyFastAddString@40
PUBLIC	_SteganographyAddImage@72
PUBLIC	_SteganographyFastAddImage@48
PUBLIC	_SteganographyGetConstant@44
PUBLIC	_SteganographyPresent@8
PUBLIC	_ExtractSteganographicHeader@12
PUBLIC	_GetSteganographicType@8
PUBLIC	?MergePixelData@@YGEEEE@Z			; MergePixelData
PUBLIC	?ExtractPixelData@@YGEEE@Z			; ExtractPixelData
PUBLIC	?CreateStream@@YGPAEPAEHHPAH@Z			; CreateStream
PUBLIC	?SteganographyAddBinaryData@@YGHPAXHHH0HHH0HHHHHHH@Z ; SteganographyAddBinaryData
PUBLIC	?BinaryMatch@@YGHPAEH@Z				; BinaryMatch
PUBLIC	?SearchForSteganographicHeader@@YGHPAXHPAH@Z	; SearchForSteganographicHeader
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp___errno:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_Source$ = 8						; size = 4
_SourceSize$ = 12					; size = 4
_HeaderLocation$ = 16					; size = 4
?SearchForSteganographicHeader@@YGHPAXHPAH@Z PROC	; SearchForSteganographicHeader

; 284  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 285  :     for (int i = 0; i < SourceSize - 16; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@SearchForS
$LN2@SearchForS:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@SearchForS:
	mov	ecx, DWORD PTR _SourceSize$[ebp]
	sub	ecx, 16					; 00000010H
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@SearchForS

; 286  :         if (BinaryMatch((BYTE *)Source, i))

	mov	edx, DWORD PTR _i$1[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	?BinaryMatch@@YGHPAEH@Z			; BinaryMatch
	test	eax, eax
	je	SHORT $LN5@SearchForS

; 287  :         {
; 288  :             *HeaderLocation = i;

	mov	ecx, DWORD PTR _HeaderLocation$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	DWORD PTR [ecx], edx

; 289  :             return HeaderPresent;

	mov	eax, 100				; 00000064H
	jmp	SHORT $LN1@SearchForS
$LN5@SearchForS:

; 290  :         }

	jmp	SHORT $LN2@SearchForS
$LN3@SearchForS:

; 291  :     *HeaderLocation = NULL;

	mov	eax, DWORD PTR _HeaderLocation$[ebp]
	mov	DWORD PTR [eax], 0

; 292  :     return NotPresent;

	xor	eax, eax
$LN1@SearchForS:

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SearchForSteganographicHeader@@YGHPAXHPAH@Z ENDP	; SearchForSteganographicHeader
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_Start$ = -8						; size = 4
_i$1 = -4						; size = 4
_Source$ = 8						; size = 4
_Offset$ = 12						; size = 4
?BinaryMatch@@YGHPAEH@Z PROC				; BinaryMatch

; 268  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 269  :     if (Offset < 0)

	cmp	DWORD PTR _Offset$[ebp], 0
	jge	SHORT $LN5@BinaryMatc

; 270  :         return HeaderNotFound;

	mov	eax, 17					; 00000011H
	jmp	SHORT $LN1@BinaryMatc
$LN5@BinaryMatc:

; 271  :     unsigned Start = Offset;

	mov	eax, DWORD PTR _Offset$[ebp]
	mov	DWORD PTR _Start$[ebp], eax

; 272  :     for (unsigned i = Start; i < Start + sizeof(SteganographicHeader); i++)

	mov	ecx, DWORD PTR _Start$[ebp]
	mov	DWORD PTR _i$1[ebp], ecx
	jmp	SHORT $LN4@BinaryMatc
$LN2@BinaryMatc:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN4@BinaryMatc:
	mov	eax, DWORD PTR _Start$[ebp]
	add	eax, 52					; 00000034H
	cmp	DWORD PTR _i$1[ebp], eax
	jae	SHORT $LN3@BinaryMatc

; 273  :         if (Source[i] != MarkerID[i - Offset])

	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _i$1[ebp]
	sub	eax, DWORD PTR _Offset$[ebp]
	movzx	ecx, BYTE PTR ?MarkerID@@3PAEA[eax]
	cmp	edx, ecx
	je	SHORT $LN6@BinaryMatc

; 274  :             return NotPresent;

	xor	eax, eax
	jmp	SHORT $LN1@BinaryMatc
$LN6@BinaryMatc:

; 275  :     return HeaderPresent;

	jmp	SHORT $LN2@BinaryMatc
$LN3@BinaryMatc:
	mov	eax, 100				; 00000064H
$LN1@BinaryMatc:

; 276  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?BinaryMatch@@YGHPAEH@Z ENDP				; BinaryMatch
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_BinaryStream$ = -4					; size = 4
_SourceImage$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Final$ = 24						; size = 4
_FinalWidth$ = 28					; size = 4
_FinalHeight$ = 32					; size = 4
_FinalStride$ = 36					; size = 4
_Binary$ = 40						; size = 4
_BinaryLength$ = 44					; size = 4
_Offset$ = 48						; size = 4
_UseRed$ = 52						; size = 4
_UseGreen$ = 56						; size = 4
_UseBlue$ = 60						; size = 4
_MaskSize$ = 64						; size = 4
_HeaderOffset$ = 68					; size = 4
?SteganographyAddBinaryData@@YGHPAXHHH0HHH0HHHHHHH@Z PROC ; SteganographyAddBinaryData

; 250  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 251  :     BYTE *BinaryStream = (BYTE *)Binary;

	mov	eax, DWORD PTR _Binary$[ebp]
	mov	DWORD PTR _BinaryStream$[ebp], eax

; 252  :     return SteganographyAddStream(SourceImage, SourceWidth, SourceHeight, SourceStride,

	push	3
	mov	ecx, DWORD PTR _HeaderOffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _MaskSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _UseBlue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _UseGreen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _UseRed$[ebp]
	push	edx
	mov	eax, DWORD PTR _Offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _BinaryLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _BinaryStream$[ebp]
	push	edx
	mov	eax, DWORD PTR _FinalStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _FinalHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _FinalWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Final$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SourceStride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _SourceWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SourceImage$[ebp]
	push	ecx
	call	_SteganographyAddStream@68

; 253  :         Final, FinalWidth, FinalHeight, FinalStride,
; 254  :         BinaryStream, BinaryLength,
; 255  :         Offset, UseRed, UseGreen, UseBlue,
; 256  :         MaskSize, HeaderOffset, BinaryData);
; 257  : }

	mov	esp, ebp
	pop	ebp
	ret	64					; 00000040H
?SteganographyAddBinaryData@@YGHPAXHHH0HHH0HHHHHHH@Z ENDP ; SteganographyAddBinaryData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
$T1 = -20						; size = 4
_TStream$ = -16						; size = 4
_i$2 = -12						; size = 4
_TIndex$ = -8						; size = 4
_B4$3 = -4						; size = 1
_B3$4 = -3						; size = 1
_B2$5 = -2						; size = 1
_B1$6 = -1						; size = 1
_Raw$ = 8						; size = 4
_RawLength$ = 12					; size = 4
_MaskSize$ = 16						; size = 4
_StreamLength$ = 20					; size = 4
?CreateStream@@YGPAEPAEHHPAH@Z PROC			; CreateStream

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 76   :     //    *StreamLength = (__int32)(RawLength * ((8.0 / (double)MaskSize) + 1));
; 77   :     *StreamLength = RawLength * 4;

	mov	eax, DWORD PTR _RawLength$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _StreamLength$[ebp]
	mov	DWORD PTR [ecx], eax

; 78   :     BYTE *TStream = new BYTE[*StreamLength];

	mov	edx, DWORD PTR _StreamLength$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR _TStream$[ebp], ecx

; 79   : 
; 80   :     __int32 TIndex = 0;

	mov	DWORD PTR _TIndex$[ebp], 0

; 81   :     for (int i = 0;i < RawLength; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@CreateStre
$LN2@CreateStre:
	mov	edx, DWORD PTR _i$2[ebp]
	add	edx, 1
	mov	DWORD PTR _i$2[ebp], edx
$LN4@CreateStre:
	mov	eax, DWORD PTR _i$2[ebp]
	cmp	eax, DWORD PTR _RawLength$[ebp]
	jge	$LN3@CreateStre

; 82   :     {
; 83   :         BYTE B1 = (Raw[i] & 0xc0) >> 6;

	mov	ecx, DWORD PTR _Raw$[ebp]
	add	ecx, DWORD PTR _i$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 192				; 000000c0H
	sar	edx, 6
	mov	BYTE PTR _B1$6[ebp], dl

; 84   :         BYTE B2 = (Raw[i] & 0x30) >> 4;

	mov	eax, DWORD PTR _Raw$[ebp]
	add	eax, DWORD PTR _i$2[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 48					; 00000030H
	sar	ecx, 4
	mov	BYTE PTR _B2$5[ebp], cl

; 85   :         BYTE B3 = (Raw[i] & 0x0c) >> 2;

	mov	edx, DWORD PTR _Raw$[ebp]
	add	edx, DWORD PTR _i$2[ebp]
	movzx	eax, BYTE PTR [edx]
	and	eax, 12					; 0000000cH
	sar	eax, 2
	mov	BYTE PTR _B3$4[ebp], al

; 86   :         BYTE B4 = (Raw[i] & 0x03);

	mov	ecx, DWORD PTR _Raw$[ebp]
	add	ecx, DWORD PTR _i$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	and	edx, 3
	mov	BYTE PTR _B4$3[ebp], dl

; 87   :         TStream[TIndex++] = MergePixelData(Raw[i], B1, 2);

	push	2
	movzx	eax, BYTE PTR _B1$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _Raw$[ebp]
	add	ecx, DWORD PTR _i$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?MergePixelData@@YGEEEE@Z		; MergePixelData
	mov	ecx, DWORD PTR _TStream$[ebp]
	add	ecx, DWORD PTR _TIndex$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _TIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _TIndex$[ebp], edx

; 88   :         TStream[TIndex++] = MergePixelData(Raw[i], B2, 2);

	push	2
	movzx	eax, BYTE PTR _B2$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _Raw$[ebp]
	add	ecx, DWORD PTR _i$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?MergePixelData@@YGEEEE@Z		; MergePixelData
	mov	ecx, DWORD PTR _TStream$[ebp]
	add	ecx, DWORD PTR _TIndex$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _TIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _TIndex$[ebp], edx

; 89   :         TStream[TIndex++] = MergePixelData(Raw[i], B3, 2);

	push	2
	movzx	eax, BYTE PTR _B3$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _Raw$[ebp]
	add	ecx, DWORD PTR _i$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?MergePixelData@@YGEEEE@Z		; MergePixelData
	mov	ecx, DWORD PTR _TStream$[ebp]
	add	ecx, DWORD PTR _TIndex$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _TIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _TIndex$[ebp], edx

; 90   :         TStream[TIndex++] = MergePixelData(Raw[i], B4, 2);

	push	2
	movzx	eax, BYTE PTR _B4$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _Raw$[ebp]
	add	ecx, DWORD PTR _i$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?MergePixelData@@YGEEEE@Z		; MergePixelData
	mov	ecx, DWORD PTR _TStream$[ebp]
	add	ecx, DWORD PTR _TIndex$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _TIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _TIndex$[ebp], edx

; 91   :     }

	jmp	$LN2@CreateStre
$LN3@CreateStre:

; 92   : 
; 93   :     return TStream;

	mov	eax, DWORD PTR _TStream$[ebp]

; 94   : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CreateStream@@YGPAEPAEHHPAH@Z ENDP			; CreateStream
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
;	COMDAT ?ExtractPixelData@@YGEEE@Z
_TEXT	SEGMENT
_Final$ = -1						; size = 1
_Source$ = 8						; size = 1
_MaskSize$ = 12						; size = 1
?ExtractPixelData@@YGEEE@Z PROC				; ExtractPixelData, COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 68   :     if (MaskSize > 7 || MaskSize < 0)

	movzx	eax, BYTE PTR _MaskSize$[ebp]
	cmp	eax, 7
	jg	SHORT $LN3@ExtractPix
	movzx	ecx, BYTE PTR _MaskSize$[ebp]
	test	ecx, ecx
	jge	SHORT $LN2@ExtractPix
$LN3@ExtractPix:

; 69   :         return 0;

	xor	al, al
	jmp	SHORT $LN1@ExtractPix
$LN2@ExtractPix:

; 70   :     BYTE Final = Source & Masks[MaskSize];

	movzx	edx, BYTE PTR _Source$[ebp]
	movzx	eax, BYTE PTR _MaskSize$[ebp]
	movzx	ecx, BYTE PTR ?Masks@@3PAEA[eax]
	and	edx, ecx
	mov	BYTE PTR _Final$[ebp], dl

; 71   :     return Final;

	mov	al, BYTE PTR _Final$[ebp]
$LN1@ExtractPix:

; 72   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ExtractPixelData@@YGEEE@Z ENDP				; ExtractPixelData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
;	COMDAT ?MergePixelData@@YGEEEE@Z
_TEXT	SEGMENT
_Final$ = -1						; size = 1
_Original$ = 8						; size = 1
_Source$ = 12						; size = 1
_MaskSize$ = 16						; size = 1
?MergePixelData@@YGEEEE@Z PROC				; MergePixelData, COMDAT

; 51   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 52   :     if (MaskSize > 7 || MaskSize < 0)

	movzx	eax, BYTE PTR _MaskSize$[ebp]
	cmp	eax, 7
	jg	SHORT $LN3@MergePixel
	movzx	ecx, BYTE PTR _MaskSize$[ebp]
	test	ecx, ecx
	jge	SHORT $LN2@MergePixel
$LN3@MergePixel:

; 53   :         return 0;

	xor	al, al
	jmp	SHORT $LN1@MergePixel
$LN2@MergePixel:

; 54   :     BYTE Final = Original & ReverseMasks[MaskSize];

	movzx	edx, BYTE PTR _Original$[ebp]
	movzx	eax, BYTE PTR _MaskSize$[ebp]
	movzx	ecx, BYTE PTR ?ReverseMasks@@3PAEA[eax]
	and	edx, ecx
	mov	BYTE PTR _Final$[ebp], dl

; 55   :     Source &= Masks[MaskSize];

	movzx	edx, BYTE PTR _MaskSize$[ebp]
	movzx	eax, BYTE PTR ?Masks@@3PAEA[edx]
	movzx	ecx, BYTE PTR _Source$[ebp]
	and	ecx, eax
	mov	BYTE PTR _Source$[ebp], cl

; 56   :     Final |= Source;

	movzx	edx, BYTE PTR _Source$[ebp]
	movzx	eax, BYTE PTR _Final$[ebp]
	or	eax, edx
	mov	BYTE PTR _Final$[ebp], al

; 57   :     return Final;

	mov	al, BYTE PTR _Final$[ebp]
$LN1@MergePixel:

; 58   : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MergePixelData@@YGEEEE@Z ENDP				; MergePixelData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_Header$ = -56						; size = 52
tv68 = -4						; size = 4
_Source$ = 8						; size = 4
_Offset$ = 12						; size = 4
_GetSteganographicType@8 PROC

; 296  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 297  :     if (!SteganographyPresent(Source, Offset))

	mov	eax, DWORD PTR _Offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_SteganographyPresent@8
	test	eax, eax
	jne	SHORT $LN4@GetStegano

; 298  :         return NotPresent;

	xor	eax, eax
	jmp	SHORT $LN1@GetStegano
$LN4@GetStegano:

; 299  :     struct SteganographicHeader Header;
; 300  :     ExtractSteganographicHeader(Source, Offset, &Header);

	lea	edx, DWORD PTR _Header$[ebp]
	push	edx
	mov	eax, DWORD PTR _Offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_ExtractSteganographicHeader@12

; 301  :     switch (Header.DataType)

	mov	edx, DWORD PTR _Header$[ebp+16]
	mov	DWORD PTR tv68[ebp], edx
	mov	eax, DWORD PTR tv68[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 3
	ja	SHORT $LN2@GetStegano
	mov	ecx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN10@GetStegano[ecx*4]
$LN5@GetStegano:

; 302  :     {
; 303  :     case ImageData:
; 304  :         return ImagePresent;

	mov	eax, 1
	jmp	SHORT $LN1@GetStegano
$LN6@GetStegano:

; 305  : 
; 306  :     case TextData:
; 307  :         return TextPresent;

	mov	eax, 2
	jmp	SHORT $LN1@GetStegano
$LN7@GetStegano:

; 308  : 
; 309  :     case BinaryData:
; 310  :         return BinaryPresent;

	mov	eax, 3
	jmp	SHORT $LN1@GetStegano
$LN8@GetStegano:

; 311  : 
; 312  :     case ConstantData:
; 313  :         return ConstantPresent;

	mov	eax, 4
	jmp	SHORT $LN1@GetStegano
$LN2@GetStegano:

; 314  :     }
; 315  :     return UnknownPresent;

	mov	eax, 99					; 00000063H
$LN1@GetStegano:

; 316  : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN10@GetStegano:
	DD	$LN5@GetStegano
	DD	$LN6@GetStegano
	DD	$LN7@GetStegano
	DD	$LN8@GetStegano
_GetSteganographicType@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Offset$ = 12						; size = 4
_Header$ = 16						; size = 4
_ExtractSteganographicHeader@12 PROC

; 33   : {

	push	ebp
	mov	ebp, esp

; 34   :     memcpy_s(Header, sizeof(SteganographicHeader), Source, sizeof(SteganographicHeader));

	push	52					; 00000034H
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	push	52					; 00000034H
	mov	ecx, DWORD PTR _Header$[ebp]
	push	ecx
	call	_memcpy_s
	add	esp, 16					; 00000010H

; 35   :     return Success;

	xor	eax, eax

; 36   : }

	pop	ebp
	ret	12					; 0000000cH
_ExtractSteganographicHeader@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_HeaderOffset$ = 12					; size = 4
_SteganographyPresent@8 PROC

; 279  : {

	push	ebp
	mov	ebp, esp

; 280  :     return BinaryMatch((BYTE *)Source, HeaderOffset);

	mov	eax, DWORD PTR _HeaderOffset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	?BinaryMatch@@YGHPAEH@Z			; BinaryMatch

; 281  : }

	pop	ebp
	ret	8
_SteganographyPresent@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_Header$ = -68						; size = 52
_FirstIndex$ = -16					; size = 4
_Source$ = -12						; size = 4
tv139 = -5						; size = 1
_B4$ = -4						; size = 1
_B3$ = -3						; size = 1
_B2$ = -2						; size = 1
_B1$ = -1						; size = 1
_SourceImage$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Offset$ = 24						; size = 4
_UseRed$ = 28						; size = 4
_UseGreen$ = 32						; size = 4
_UseBlue$ = 36						; size = 4
_MaskSize$ = 40						; size = 4
_HeaderOffset$ = 44					; size = 4
_Constant$ = 48						; size = 4
_SteganographyGetConstant@44 PROC

; 321  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 322  :     *Constant = NULL;

	mov	eax, DWORD PTR _Constant$[ebp]
	mov	BYTE PTR [eax], 0

; 323  :     if (!SteganographyPresent(SourceImage, Offset))

	mov	ecx, DWORD PTR _Offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceImage$[ebp]
	push	edx
	call	_SteganographyPresent@8
	test	eax, eax
	jne	SHORT $LN2@Steganogra

; 324  :         return HeaderNotFound;

	mov	eax, 17					; 00000011H
	jmp	$LN1@Steganogra
$LN2@Steganogra:

; 325  :     struct SteganographicHeader Header;
; 326  :     ExtractSteganographicHeader(SourceImage, Offset, &Header);

	lea	eax, DWORD PTR _Header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceImage$[ebp]
	push	edx
	call	_ExtractSteganographicHeader@12

; 327  :     if (Header.DataType != ConstantData)

	cmp	DWORD PTR _Header$[ebp+16], 4
	je	SHORT $LN3@Steganogra

; 328  :         return HeaderBadDataType;

	mov	eax, 18					; 00000012H
	jmp	$LN1@Steganogra
$LN3@Steganogra:

; 329  :     int FirstIndex = Offset + sizeof(SteganographicHeader);

	mov	eax, DWORD PTR _Offset$[ebp]
	add	eax, 52					; 00000034H
	mov	DWORD PTR _FirstIndex$[ebp], eax

; 330  :     BYTE *Source = (BYTE *)SourceImage;

	mov	ecx, DWORD PTR _SourceImage$[ebp]
	mov	DWORD PTR _Source$[ebp], ecx

; 331  :     BYTE B1 = Source[FirstIndex];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _FirstIndex$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B1$[ebp], al

; 332  :     B1 = ExtractPixelData(B1, MaskSize);

	movzx	ecx, BYTE PTR _MaskSize$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _B1$[ebp]
	push	edx
	call	?ExtractPixelData@@YGEEE@Z		; ExtractPixelData
	mov	BYTE PTR _B1$[ebp], al

; 333  :     BYTE B2 = Source[FirstIndex + 1];

	mov	eax, DWORD PTR _Source$[ebp]
	add	eax, DWORD PTR _FirstIndex$[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _B2$[ebp], cl

; 334  :     B2 = ExtractPixelData(B2, MaskSize);

	movzx	edx, BYTE PTR _MaskSize$[ebp]
	push	edx
	movzx	eax, BYTE PTR _B2$[ebp]
	push	eax
	call	?ExtractPixelData@@YGEEE@Z		; ExtractPixelData
	mov	BYTE PTR _B2$[ebp], al

; 335  :     BYTE B3 = Source[FirstIndex + 2];

	mov	ecx, DWORD PTR _Source$[ebp]
	add	ecx, DWORD PTR _FirstIndex$[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _B3$[ebp], dl

; 336  :     B3 = ExtractPixelData(B3, MaskSize);

	movzx	eax, BYTE PTR _MaskSize$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B3$[ebp]
	push	ecx
	call	?ExtractPixelData@@YGEEE@Z		; ExtractPixelData
	mov	BYTE PTR _B3$[ebp], al

; 337  :     BYTE B4 = Source[FirstIndex + 3];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _FirstIndex$[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _B4$[ebp], al

; 338  :     B4 = ExtractPixelData(B4, MaskSize);

	movzx	ecx, BYTE PTR _MaskSize$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _B4$[ebp]
	push	edx
	call	?ExtractPixelData@@YGEEE@Z		; ExtractPixelData
	mov	BYTE PTR _B4$[ebp], al

; 339  :     *Constant = (B1 << 6) || (B2 << 4) || (B3 << 2) || B4;

	movzx	eax, BYTE PTR _B1$[ebp]
	shl	eax, 6
	test	eax, eax
	jne	SHORT $LN5@Steganogra
	movzx	ecx, BYTE PTR _B2$[ebp]
	shl	ecx, 4
	test	ecx, ecx
	jne	SHORT $LN5@Steganogra
	movzx	edx, BYTE PTR _B3$[ebp]
	shl	edx, 2
	test	edx, edx
	jne	SHORT $LN5@Steganogra
	movzx	eax, BYTE PTR _B4$[ebp]
	test	eax, eax
	jne	SHORT $LN5@Steganogra
	mov	BYTE PTR tv139[ebp], 0
	jmp	SHORT $LN6@Steganogra
$LN5@Steganogra:
	mov	BYTE PTR tv139[ebp], 1
$LN6@Steganogra:
	mov	ecx, DWORD PTR _Constant$[ebp]
	mov	dl, BYTE PTR tv139[ebp]
	mov	BYTE PTR [ecx], dl

; 340  :     return Success;

	xor	eax, eax
$LN1@Steganogra:

; 341  : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_SteganographyGetConstant@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_SourceImage$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Target$ = 24						; size = 4
_TargetWidth$ = 28					; size = 4
_TargetHeight$ = 32					; size = 4
_TargetStride$ = 36					; size = 4
_Final$ = 40						; size = 4
_FinalWidth$ = 44					; size = 4
_FinalHeight$ = 48					; size = 4
_FinalStride$ = 52					; size = 4
_SteganographyFastAddImage@48 PROC

; 237  : {

	push	ebp
	mov	ebp, esp

; 238  :     return SteganographyAddImage(SourceImage, SourceWidth, SourceHeight, SourceStride,

	push	0
	push	2
	push	1
	push	1
	push	1
	push	0
	mov	eax, DWORD PTR _FinalStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _FinalHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _FinalWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Final$[ebp]
	push	eax
	mov	ecx, DWORD PTR _TargetStride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _TargetHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _TargetWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Target$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceStride$[ebp]
	push	edx
	mov	eax, DWORD PTR _SourceHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SourceWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceImage$[ebp]
	push	edx
	call	_SteganographyAddImage@72

; 239  :         Target, TargetWidth, TargetHeight, TargetStride,
; 240  :         Final, FinalWidth, FinalHeight, FinalStride,
; 241  :         0, TRUE, TRUE, TRUE,
; 242  :         2, 0);
; 243  : }

	pop	ebp
	ret	48					; 00000030H
_SteganographyFastAddImage@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_StreamSource$ = -8					; size = 4
_ImageByteLength$ = -4					; size = 4
_SourceImage$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Target$ = 24						; size = 4
_TargetWidth$ = 28					; size = 4
_TargetHeight$ = 32					; size = 4
_TargetStride$ = 36					; size = 4
_Final$ = 40						; size = 4
_FinalWidth$ = 44					; size = 4
_FinalHeight$ = 48					; size = 4
_FinalStride$ = 52					; size = 4
_Offset$ = 56						; size = 4
_UseRed$ = 60						; size = 4
_UseGreen$ = 64						; size = 4
_UseBlue$ = 68						; size = 4
_MaskSize$ = 72						; size = 4
_HeaderOffset$ = 76					; size = 4
_SteganographyAddImage@72 PROC

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 225  :     BYTE *StreamSource = (BYTE *)SourceImage;

	mov	eax, DWORD PTR _SourceImage$[ebp]
	mov	DWORD PTR _StreamSource$[ebp], eax

; 226  :     __int32 ImageByteLength = SourceWidth * SourceWidth * SourceStride;

	mov	ecx, DWORD PTR _SourceWidth$[ebp]
	imul	ecx, DWORD PTR _SourceWidth$[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _ImageByteLength$[ebp], ecx

; 227  :     return SteganographyAddStream(Target, TargetWidth, TargetHeight, TargetStride,

	push	1
	mov	edx, DWORD PTR _HeaderOffset$[ebp]
	push	edx
	mov	eax, DWORD PTR _MaskSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _UseBlue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _UseGreen$[ebp]
	push	edx
	mov	eax, DWORD PTR _UseRed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ImageByteLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _StreamSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _FinalStride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _FinalHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _FinalWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Final$[ebp]
	push	ecx
	mov	edx, DWORD PTR _TargetStride$[ebp]
	push	edx
	mov	eax, DWORD PTR _TargetHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _TargetWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Target$[ebp]
	push	edx
	call	_SteganographyAddStream@68

; 228  :         Final, FinalWidth, FinalHeight, FinalStride,
; 229  :         StreamSource, ImageByteLength,
; 230  :         Offset, UseRed, UseGreen, UseBlue,
; 231  :         MaskSize, HeaderOffset, ImageData);
; 232  : }

	mov	esp, ebp
	pop	ebp
	ret	72					; 00000048H
_SteganographyAddImage@72 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_SourceImage$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeader$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Final$ = 24						; size = 4
_FinalWidth$ = 28					; size = 4
_FinalHeight$ = 32					; size = 4
_FinalStride$ = 36					; size = 4
_Message$ = 40						; size = 4
_MessageLength$ = 44					; size = 4
_SteganographyFastAddString@40 PROC

; 213  : {

	push	ebp
	mov	ebp, esp

; 214  :     return SteganographyAddString(SourceImage, SourceWidth, SourceHeader, SourceStride,

	push	0
	push	2
	push	1
	push	1
	push	1
	push	0
	mov	eax, DWORD PTR _MessageLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Message$[ebp]
	push	ecx
	mov	edx, DWORD PTR _FinalStride$[ebp]
	push	edx
	mov	eax, DWORD PTR _FinalHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _FinalWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Final$[ebp]
	push	edx
	mov	eax, DWORD PTR _SourceStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SourceHeader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _SourceImage$[ebp]
	push	eax
	call	_SteganographyAddString@64

; 215  :         Final, FinalWidth, FinalHeight, FinalStride,
; 216  :         Message, MessageLength, 0, TRUE, TRUE, TRUE, 2, 0);
; 217  : }

	pop	ebp
	ret	40					; 00000028H
_SteganographyFastAddString@40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_SStream$ = -4						; size = 4
_SourceImage$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Final$ = 24						; size = 4
_FinalWidth$ = 28					; size = 4
_FinalHeight$ = 32					; size = 4
_FinalStride$ = 36					; size = 4
_Message$ = 40						; size = 4
_MessageLength$ = 44					; size = 4
_Offset$ = 48						; size = 4
_UseRed$ = 52						; size = 4
_UseGreen$ = 56						; size = 4
_UseBlue$ = 60						; size = 4
_MaskSize$ = 64						; size = 4
_HeaderOffset$ = 68					; size = 4
_SteganographyAddString@64 PROC

; 201  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 202  :     BYTE *SStream = (BYTE *)Message;

	mov	eax, DWORD PTR _Message$[ebp]
	mov	DWORD PTR _SStream$[ebp], eax

; 203  :     return SteganographyAddStream(SourceImage, SourceWidth, SourceHeight, SourceStride,

	push	2
	mov	ecx, DWORD PTR _HeaderOffset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _MaskSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _UseBlue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _UseGreen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _UseRed$[ebp]
	push	edx
	mov	eax, DWORD PTR _Offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _MessageLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SStream$[ebp]
	push	edx
	mov	eax, DWORD PTR _FinalStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _FinalHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _FinalWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Final$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SourceStride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _SourceWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SourceImage$[ebp]
	push	ecx
	call	_SteganographyAddStream@68

; 204  :         Final, FinalWidth, FinalHeight, FinalStride,
; 205  :         SStream, MessageLength,
; 206  :         Offset, UseRed, UseGreen, UseBlue,
; 207  :         MaskSize, HeaderOffset, TextData);
; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	64					; 00000040H
_SteganographyAddString@64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_Header$ = -88						; size = 52
_Final$ = -36						; size = 4
_HeaderStream$ = -32					; size = 4
_Source$ = -28						; size = 4
_SourceImageSize$ = -24					; size = 4
_HeaderStreamLength$ = -20				; size = 4
_HeaderStreamIndex$ = -16				; size = 4
_k$1 = -12						; size = 4
_i$2 = -8						; size = 4
_SourceByte$3 = -1					; size = 1
_SourceImage$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_FinalImage$ = 24					; size = 4
_FinalWidth$ = 28					; size = 4
_FinalHeight$ = 32					; size = 4
_FinalStride$ = 36					; size = 4
_Constant$ = 40						; size = 1
_Offset$ = 44						; size = 4
_UseRed$ = 48						; size = 4
_UseGreen$ = 52						; size = 4
_UseBlue$ = 56						; size = 4
_MaskSize$ = 60						; size = 4
_HeaderOffset$ = 64					; size = 4
_SteganographyAddConstant@60 PROC

; 154  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 155  :     BYTE *Source = (BYTE *)SourceImage;

	mov	eax, DWORD PTR _SourceImage$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 156  :     BYTE *Final = (BYTE *)FinalImage;

	mov	ecx, DWORD PTR _FinalImage$[ebp]
	mov	DWORD PTR _Final$[ebp], ecx

; 157  : 
; 158  :     SteganographicHeader Header;
; 159  :     for (int i = 0; i < 16; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@Steganogra
$LN2@Steganogra:
	mov	edx, DWORD PTR _i$2[ebp]
	add	edx, 1
	mov	DWORD PTR _i$2[ebp], edx
$LN4@Steganogra:
	cmp	DWORD PTR _i$2[ebp], 16			; 00000010H
	jge	SHORT $LN3@Steganogra

; 160  :         Header.Marker[i] = MarkerID[i];

	mov	eax, DWORD PTR _i$2[ebp]
	mov	ecx, DWORD PTR _i$2[ebp]
	mov	dl, BYTE PTR ?MarkerID@@3PAEA[ecx]
	mov	BYTE PTR _Header$[ebp+eax], dl
	jmp	SHORT $LN2@Steganogra
$LN3@Steganogra:

; 161  :     Header.DataType = ConstantData;

	mov	DWORD PTR _Header$[ebp+16], 4

; 162  :     Header.DataOffset = Offset;

	mov	eax, DWORD PTR _Offset$[ebp]
	mov	DWORD PTR _Header$[ebp+20], eax

; 163  :     Header.DataLength = 0;

	mov	DWORD PTR _Header$[ebp+24], 0

; 164  :     Header.MaskSize = MaskSize;

	mov	ecx, DWORD PTR _MaskSize$[ebp]
	mov	DWORD PTR _Header$[ebp+28], ecx

; 165  :     Header.UseRed = UseRed;

	mov	dl, BYTE PTR _UseRed$[ebp]
	mov	BYTE PTR _Header$[ebp+44], dl

; 166  :     Header.UseGreen = UseGreen;

	mov	al, BYTE PTR _UseGreen$[ebp]
	mov	BYTE PTR _Header$[ebp+45], al

; 167  :     Header.UseBlue = UseBlue;

	mov	cl, BYTE PTR _UseBlue$[ebp]
	mov	BYTE PTR _Header$[ebp+46], cl

; 168  :     Header.ImageHeight = 0;

	mov	DWORD PTR _Header$[ebp+36], 0

; 169  :     Header.ImageWidth = 0;

	mov	DWORD PTR _Header$[ebp+32], 0

; 170  :     Header.ImageStride = 0;

	mov	DWORD PTR _Header$[ebp+40], 0

; 171  :     Header.HeaderVersion = 0x100;

	mov	DWORD PTR _Header$[ebp+48], 256		; 00000100H

; 172  : 
; 173  :     __int32 SourceImageSize = (SourceWidth * SourceHeight) * SourceStride;

	mov	edx, DWORD PTR _SourceWidth$[ebp]
	imul	edx, DWORD PTR _SourceHeight$[ebp]
	imul	edx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _SourceImageSize$[ebp], edx

; 174  :     __int32 HeaderStreamLength = 0;

	mov	DWORD PTR _HeaderStreamLength$[ebp], 0

; 175  :     BYTE *HeaderStream = CreateStream((BYTE *)&Header, sizeof(Header), MaskSize, &HeaderStreamLength);

	lea	eax, DWORD PTR _HeaderStreamLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _MaskSize$[ebp]
	push	ecx
	push	52					; 00000034H
	lea	edx, DWORD PTR _Header$[ebp]
	push	edx
	call	?CreateStream@@YGPAEPAEHHPAH@Z		; CreateStream
	mov	DWORD PTR _HeaderStream$[ebp], eax

; 176  :     __int32 HeaderStreamIndex = 0;

	mov	DWORD PTR _HeaderStreamIndex$[ebp], 0

; 177  : 
; 178  :     for (int k = 0; k < SourceImageSize; k++)

	mov	DWORD PTR _k$1[ebp], 0
	jmp	SHORT $LN7@Steganogra
$LN5@Steganogra:
	mov	eax, DWORD PTR _k$1[ebp]
	add	eax, 1
	mov	DWORD PTR _k$1[ebp], eax
$LN7@Steganogra:
	mov	ecx, DWORD PTR _k$1[ebp]
	cmp	ecx, DWORD PTR _SourceImageSize$[ebp]
	jge	SHORT $LN6@Steganogra

; 179  :     {
; 180  :         BYTE SourceByte = Source[k];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _k$1[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _SourceByte$3[ebp], al

; 181  :         if (HeaderStreamIndex < HeaderStreamLength)

	mov	ecx, DWORD PTR _HeaderStreamIndex$[ebp]
	cmp	ecx, DWORD PTR _HeaderStreamLength$[ebp]
	jge	SHORT $LN8@Steganogra

; 182  :         {
; 183  :             MergePixelData(SourceByte, HeaderStream[HeaderStreamIndex], MaskSize);

	movzx	edx, BYTE PTR _MaskSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _HeaderStream$[ebp]
	add	eax, DWORD PTR _HeaderStreamIndex$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	movzx	edx, BYTE PTR _SourceByte$3[ebp]
	push	edx
	call	?MergePixelData@@YGEEEE@Z		; MergePixelData

; 184  :             HeaderStreamIndex++;

	mov	eax, DWORD PTR _HeaderStreamIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _HeaderStreamIndex$[ebp], eax

; 185  :         }
; 186  :         else

	jmp	SHORT $LN9@Steganogra
$LN8@Steganogra:

; 187  :         {
; 188  :             MergePixelData(SourceByte, Constant, MaskSize);

	movzx	ecx, BYTE PTR _MaskSize$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _Constant$[ebp]
	push	edx
	movzx	eax, BYTE PTR _SourceByte$3[ebp]
	push	eax
	call	?MergePixelData@@YGEEEE@Z		; MergePixelData
$LN9@Steganogra:

; 189  :         }
; 190  :         Final[k] = SourceByte;

	mov	ecx, DWORD PTR _Final$[ebp]
	add	ecx, DWORD PTR _k$1[ebp]
	mov	dl, BYTE PTR _SourceByte$3[ebp]
	mov	BYTE PTR [ecx], dl

; 191  :     }

	jmp	SHORT $LN5@Steganogra
$LN6@Steganogra:

; 192  : 
; 193  :     return Success;

	xor	eax, eax

; 194  : }

	mov	esp, ebp
	pop	ebp
	ret	60					; 0000003cH
_SteganographyAddConstant@60 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\steganography2.cpp
_TEXT	SEGMENT
_Header$ = -108						; size = 52
$T1 = -56						; size = 4
$T2 = -52						; size = 4
_Final$ = -48						; size = 4
_Source$ = -44						; size = 4
_SourceImageSize$ = -40					; size = 4
_MainStream$ = -36					; size = 4
_HeaderStream$ = -32					; size = 4
_FinalStreamLength$ = -28				; size = 4
_HeaderStreamLength$ = -24				; size = 4
_MainStreamIndex$ = -20					; size = 4
_HeaderStreamIndex$ = -16				; size = 4
_k$3 = -12						; size = 4
_i$4 = -8						; size = 4
_SourceByte$5 = -1					; size = 1
_SourceImage$ = 8					; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_FinalImage$ = 24					; size = 4
_FinalWidth$ = 28					; size = 4
_FinalHeight$ = 32					; size = 4
_FinalStride$ = 36					; size = 4
_StreamSource$ = 40					; size = 4
_StreamLength$ = 44					; size = 4
_DataOffset$ = 48					; size = 4
_UseRed$ = 52						; size = 4
_UseGreen$ = 56						; size = 4
_UseBlue$ = 60						; size = 4
_MaskSize$ = 64						; size = 4
_HeaderOffset$ = 68					; size = 4
_DataType$ = 72						; size = 4
_SteganographyAddStream@68 PROC

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH

; 102  :     SteganographicHeader Header;
; 103  :     for (int i = 0; i < 16; i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN4@Steganogra
$LN2@Steganogra:
	mov	eax, DWORD PTR _i$4[ebp]
	add	eax, 1
	mov	DWORD PTR _i$4[ebp], eax
$LN4@Steganogra:
	cmp	DWORD PTR _i$4[ebp], 16			; 00000010H
	jge	SHORT $LN3@Steganogra

; 104  :         Header.Marker[i] = MarkerID[i];

	mov	ecx, DWORD PTR _i$4[ebp]
	mov	edx, DWORD PTR _i$4[ebp]
	mov	al, BYTE PTR ?MarkerID@@3PAEA[edx]
	mov	BYTE PTR _Header$[ebp+ecx], al
	jmp	SHORT $LN2@Steganogra
$LN3@Steganogra:

; 105  :     Header.DataType = DataType;

	mov	ecx, DWORD PTR _DataType$[ebp]
	mov	DWORD PTR _Header$[ebp+16], ecx

; 106  :     Header.DataOffset = DataOffset;

	mov	edx, DWORD PTR _DataOffset$[ebp]
	mov	DWORD PTR _Header$[ebp+20], edx

; 107  :     Header.DataLength = StreamLength;

	mov	eax, DWORD PTR _StreamLength$[ebp]
	mov	DWORD PTR _Header$[ebp+24], eax

; 108  :     Header.MaskSize = MaskSize;

	mov	ecx, DWORD PTR _MaskSize$[ebp]
	mov	DWORD PTR _Header$[ebp+28], ecx

; 109  :     Header.UseRed = UseRed;

	mov	dl, BYTE PTR _UseRed$[ebp]
	mov	BYTE PTR _Header$[ebp+44], dl

; 110  :     Header.UseGreen = UseGreen;

	mov	al, BYTE PTR _UseGreen$[ebp]
	mov	BYTE PTR _Header$[ebp+45], al

; 111  :     Header.UseBlue = UseBlue;

	mov	cl, BYTE PTR _UseBlue$[ebp]
	mov	BYTE PTR _Header$[ebp+46], cl

; 112  :     Header.ImageHeight = SourceHeight;

	mov	edx, DWORD PTR _SourceHeight$[ebp]
	mov	DWORD PTR _Header$[ebp+36], edx

; 113  :     Header.ImageWidth = SourceHeight;

	mov	eax, DWORD PTR _SourceHeight$[ebp]
	mov	DWORD PTR _Header$[ebp+32], eax

; 114  :     Header.ImageStride = SourceStride;

	mov	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _Header$[ebp+40], ecx

; 115  :     Header.HeaderVersion = 0x100;

	mov	DWORD PTR _Header$[ebp+48], 256		; 00000100H

; 116  : 
; 117  :     __int32 HeaderStreamLength = 0;

	mov	DWORD PTR _HeaderStreamLength$[ebp], 0

; 118  :     BYTE *HeaderStream = CreateStream((BYTE *)&Header, sizeof(Header), MaskSize, &HeaderStreamLength);

	lea	edx, DWORD PTR _HeaderStreamLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _MaskSize$[ebp]
	push	eax
	push	52					; 00000034H
	lea	ecx, DWORD PTR _Header$[ebp]
	push	ecx
	call	?CreateStream@@YGPAEPAEHHPAH@Z		; CreateStream
	mov	DWORD PTR _HeaderStream$[ebp], eax

; 119  :     __int32 FinalStreamLength = 0;

	mov	DWORD PTR _FinalStreamLength$[ebp], 0

; 120  :     BYTE *MainStream = CreateStream(StreamSource, StreamLength, MaskSize, &FinalStreamLength);

	lea	edx, DWORD PTR _FinalStreamLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _MaskSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _StreamLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _StreamSource$[ebp]
	push	edx
	call	?CreateStream@@YGPAEPAEHHPAH@Z		; CreateStream
	mov	DWORD PTR _MainStream$[ebp], eax

; 121  : 
; 122  :     BYTE *Source = (BYTE *)SourceImage;

	mov	eax, DWORD PTR _SourceImage$[ebp]
	mov	DWORD PTR _Source$[ebp], eax

; 123  :     BYTE *Final = (BYTE *)FinalImage;

	mov	ecx, DWORD PTR _FinalImage$[ebp]
	mov	DWORD PTR _Final$[ebp], ecx

; 124  :     __int32 HeaderStreamIndex = 0;

	mov	DWORD PTR _HeaderStreamIndex$[ebp], 0

; 125  :     __int32 MainStreamIndex = 0;

	mov	DWORD PTR _MainStreamIndex$[ebp], 0

; 126  :     __int32 SourceImageSize = (SourceWidth * SourceHeight) * SourceStride;

	mov	edx, DWORD PTR _SourceWidth$[ebp]
	imul	edx, DWORD PTR _SourceHeight$[ebp]
	imul	edx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _SourceImageSize$[ebp], edx

; 127  :     for (int k = 0; k < SourceImageSize; k++)

	mov	DWORD PTR _k$3[ebp], 0
	jmp	SHORT $LN7@Steganogra
$LN5@Steganogra:
	mov	eax, DWORD PTR _k$3[ebp]
	add	eax, 1
	mov	DWORD PTR _k$3[ebp], eax
$LN7@Steganogra:
	mov	ecx, DWORD PTR _k$3[ebp]
	cmp	ecx, DWORD PTR _SourceImageSize$[ebp]
	jge	SHORT $LN6@Steganogra

; 128  :     {
; 129  :         BYTE SourceByte = Source[k];

	mov	edx, DWORD PTR _Source$[ebp]
	add	edx, DWORD PTR _k$3[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _SourceByte$5[ebp], al

; 130  :         if (HeaderStreamIndex < HeaderStreamLength)

	mov	ecx, DWORD PTR _HeaderStreamIndex$[ebp]
	cmp	ecx, DWORD PTR _HeaderStreamLength$[ebp]
	jge	SHORT $LN8@Steganogra

; 131  :         {
; 132  :             MergePixelData(SourceByte, HeaderStream[HeaderStreamIndex], MaskSize);

	movzx	edx, BYTE PTR _MaskSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _HeaderStream$[ebp]
	add	eax, DWORD PTR _HeaderStreamIndex$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	movzx	edx, BYTE PTR _SourceByte$5[ebp]
	push	edx
	call	?MergePixelData@@YGEEEE@Z		; MergePixelData

; 133  :             HeaderStreamIndex++;

	mov	eax, DWORD PTR _HeaderStreamIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _HeaderStreamIndex$[ebp], eax
$LN8@Steganogra:

; 134  :         }
; 135  :         if (MainStreamIndex < FinalStreamLength)

	mov	ecx, DWORD PTR _MainStreamIndex$[ebp]
	cmp	ecx, DWORD PTR _FinalStreamLength$[ebp]
	jge	SHORT $LN9@Steganogra

; 136  :         {
; 137  :             MergePixelData(SourceByte, MainStream[MainStreamIndex], MaskSize);

	movzx	edx, BYTE PTR _MaskSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _MainStream$[ebp]
	add	eax, DWORD PTR _MainStreamIndex$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	movzx	edx, BYTE PTR _SourceByte$5[ebp]
	push	edx
	call	?MergePixelData@@YGEEEE@Z		; MergePixelData

; 138  :             MainStreamIndex++;

	mov	eax, DWORD PTR _MainStreamIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _MainStreamIndex$[ebp], eax
$LN9@Steganogra:

; 139  :         }
; 140  :         Final[k] = SourceByte;

	mov	ecx, DWORD PTR _Final$[ebp]
	add	ecx, DWORD PTR _k$3[ebp]
	mov	dl, BYTE PTR _SourceByte$5[ebp]
	mov	BYTE PTR [ecx], dl

; 141  :     }

	jmp	SHORT $LN5@Steganogra
$LN6@Steganogra:

; 142  : 
; 143  :     delete[] HeaderStream;

	mov	eax, DWORD PTR _HeaderStream$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 144  :     delete[] MainStream;

	mov	edx, DWORD PTR _MainStream$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 145  : 
; 146  :     return Success;

	xor	eax, eax

; 147  : }

	mov	esp, ebp
	pop	ebp
	ret	68					; 00000044H
_SteganographyAddStream@68 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
_TEXT	SEGMENT
__Expr_val$1 = -24					; size = 4
__Expr_val$2 = -20					; size = 4
__Expr_val$3 = -16					; size = 4
tv79 = -12						; size = 4
tv75 = -8						; size = 4
tv66 = -4						; size = 4
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memcpy_s PROC

; 41   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 42   :         if (_SourceSize == 0)

	cmp	DWORD PTR __SourceSize$[ebp], 0
	jne	SHORT $LN2@memcpy_s

; 43   :         {
; 44   :             return 0;

	xor	eax, eax
	jmp	$LN1@memcpy_s
$LN2@memcpy_s:

; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

	cmp	DWORD PTR __Destination$[ebp], 0
	je	SHORT $LN9@memcpy_s
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN10@memcpy_s
$LN9@memcpy_s:
	mov	DWORD PTR tv66[ebp], 0
$LN10@memcpy_s:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR __Expr_val$3[ebp], eax
	cmp	DWORD PTR __Expr_val$3[ebp], 0
	jne	SHORT $LN3@memcpy_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 22					; 00000016H
	jmp	$LN1@memcpy_s
$LN3@memcpy_s:

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

	cmp	DWORD PTR __Source$[ebp], 0
	je	SHORT $LN5@memcpy_s
	mov	ecx, DWORD PTR __DestinationSize$[ebp]
	cmp	ecx, DWORD PTR __SourceSize$[ebp]
	jae	$LN4@memcpy_s
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

	mov	edx, DWORD PTR __DestinationSize$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR __Destination$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

	cmp	DWORD PTR __Source$[ebp], 0
	je	SHORT $LN11@memcpy_s
	mov	DWORD PTR tv75[ebp], 1
	jmp	SHORT $LN12@memcpy_s
$LN11@memcpy_s:
	mov	DWORD PTR tv75[ebp], 0
$LN12@memcpy_s:
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR __Expr_val$2[ebp], ecx
	cmp	DWORD PTR __Expr_val$2[ebp], 0
	jne	SHORT $LN6@memcpy_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 22			; 00000016H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 22					; 00000016H
	jmp	SHORT $LN1@memcpy_s
$LN6@memcpy_s:

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

	mov	edx, DWORD PTR __DestinationSize$[ebp]
	cmp	edx, DWORD PTR __SourceSize$[ebp]
	jb	SHORT $LN13@memcpy_s
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN14@memcpy_s
$LN13@memcpy_s:
	mov	DWORD PTR tv79[ebp], 0
$LN14@memcpy_s:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR __Expr_val$1[ebp], eax
	cmp	DWORD PTR __Expr_val$1[ebp], 0
	jne	SHORT $LN7@memcpy_s
	call	DWORD PTR __imp___errno
	mov	DWORD PTR [eax], 34			; 00000022H
	call	DWORD PTR __imp___invalid_parameter_noinfo
	mov	eax, 34					; 00000022H
	jmp	SHORT $LN1@memcpy_s
$LN7@memcpy_s:

; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;

	mov	eax, 22					; 00000016H
	jmp	SHORT $LN1@memcpy_s
$LN4@memcpy_s:

; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

	mov	ecx, DWORD PTR __SourceSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Source$[ebp]
	push	edx
	mov	eax, DWORD PTR __Destination$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 60   :         return 0;

	xor	eax, eax
$LN1@memcpy_s:

; 61   :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_memcpy_s ENDP
_TEXT	ENDS
END
