; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Gradients.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?MakeColor@@YGXHHHHNHPAUPureColorStruct@@PAUAbsolutePointStruct@@PAE22@Z ; MakeColor
PUBLIC	_Gradient@24
PUBLIC	?GradientX@@YGHPAXHHH0H@Z			; GradientX
PUBLIC	?ColorPercent@@YGXNEEEPAE00_N@Z			; ColorPercent
PUBLIC	__real@4000000000000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	?Distance@@YGNHHHH@Z:PROC			; Distance
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\gradients.cpp
_TEXT	SEGMENT
_Percent$ = 8						; size = 8
_inR$ = 16						; size = 1
_inG$ = 20						; size = 1
_inB$ = 24						; size = 1
_outR$ = 28						; size = 4
_outG$ = 32						; size = 4
_outB$ = 36						; size = 4
_Invert$ = 40						; size = 1
?ColorPercent@@YGXNEEEPAE00_N@Z PROC			; ColorPercent

; 66   : {

	push	ebp
	mov	ebp, esp

; 67   :     *outR = (byte)(Percent*(double)inR);

	movzx	eax, BYTE PTR _inR$[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _Percent$[ebp]
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _outR$[ebp]
	mov	BYTE PTR [edx], cl

; 68   :     *outG = (byte)(Percent*(double)inG);

	movzx	eax, BYTE PTR _inG$[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _Percent$[ebp]
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _outG$[ebp]
	mov	BYTE PTR [edx], cl

; 69   :     *outB = (byte)(Percent*(double)inB);

	movzx	eax, BYTE PTR _inB$[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _Percent$[ebp]
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _outB$[ebp]
	mov	BYTE PTR [edx], cl

; 70   :     if (Invert)

	movzx	eax, BYTE PTR _Invert$[ebp]
	test	eax, eax
	je	SHORT $LN2@ColorPerce

; 71   :     {
; 72   :         *outR = 0xff - *outR;

	mov	ecx, DWORD PTR _outR$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	ecx, DWORD PTR _outR$[ebp]
	mov	BYTE PTR [ecx], al

; 73   :         *outG = 0xff - *outG;

	mov	edx, DWORD PTR _outG$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	edx, DWORD PTR _outG$[ebp]
	mov	BYTE PTR [edx], cl

; 74   :         *outB = 0xff - *outB;

	mov	eax, DWORD PTR _outB$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	eax, DWORD PTR _outB$[ebp]
	mov	BYTE PTR [eax], dl
$LN2@ColorPerce:

; 75   :     }
; 76   : }

	pop	ebp
	ret	36					; 00000024H
?ColorPercent@@YGXNEEEPAE00_N@Z ENDP			; ColorPercent
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\gradients.cpp
_TEXT	SEGMENT
_d$1 = -64						; size = 8
tv229 = -56						; size = 8
_Index$2 = -48						; size = 4
_Buffer$ = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
_RowIndex$5 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Distances$6 = -24					; size = 4
_Row$7 = -20						; size = 4
_Column$8 = -16						; size = 4
_g$9 = -12						; size = 4
_GradientPoints$ = -8					; size = 4
_i$10 = -4						; size = 4
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_GradientColorList$ = 24				; size = 4
_GradientColorCount$ = 28				; size = 4
?GradientX@@YGHPAXHHH0H@Z PROC				; GradientX

; 8    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 9    :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN14@GradientX

; 10   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@GradientX
$LN14@GradientX:

; 11   :     if (GradientColorList == NULL)

	cmp	DWORD PTR _GradientColorList$[ebp], 0
	jne	SHORT $LN15@GradientX

; 12   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@GradientX
$LN15@GradientX:

; 13   : 
; 14   :     BYTE * Buffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 15   :     GradientColor *GradientPoints = (GradientColor *)GradientColorList;

	mov	ecx, DWORD PTR _GradientColorList$[ebp]
	mov	DWORD PTR _GradientPoints$[ebp], ecx

; 16   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 17   : 
; 18   :     for (int i = 0; i < GradientColorCount; i++)

	mov	DWORD PTR _i$10[ebp], 0
	jmp	SHORT $LN4@GradientX
$LN2@GradientX:
	mov	edx, DWORD PTR _i$10[ebp]
	add	edx, 1
	mov	DWORD PTR _i$10[ebp], edx
$LN4@GradientX:
	mov	eax, DWORD PTR _i$10[ebp]
	cmp	eax, DWORD PTR _GradientColorCount$[ebp]
	jge	$LN3@GradientX

; 19   :     {
; 20   :         if (GradientPoints[i].AbsolutePoint)

	imul	ecx, DWORD PTR _i$10[ebp], 40
	mov	edx, DWORD PTR _GradientPoints$[ebp]
	cmp	DWORD PTR [edx+ecx+24], 0
	je	SHORT $LN16@GradientX

; 21   :         {
; 22   :             GradientPoints[i].FinalX = GradientPoints[i].X;

	imul	eax, DWORD PTR _i$10[ebp], 40
	mov	ecx, DWORD PTR _GradientPoints$[ebp]
	cvttsd2si edx, QWORD PTR [ecx+eax+8]
	imul	eax, DWORD PTR _i$10[ebp], 40
	mov	ecx, DWORD PTR _GradientPoints$[ebp]
	mov	DWORD PTR [ecx+eax+28], edx

; 23   :             GradientPoints[i].FinalY = GradientPoints[i].Y;

	imul	edx, DWORD PTR _i$10[ebp], 40
	mov	eax, DWORD PTR _GradientPoints$[ebp]
	cvttsd2si ecx, QWORD PTR [eax+edx+16]
	imul	edx, DWORD PTR _i$10[ebp], 40
	mov	eax, DWORD PTR _GradientPoints$[ebp]
	mov	DWORD PTR [eax+edx+32], ecx

; 24   :         }
; 25   :         else

	jmp	SHORT $LN17@GradientX
$LN16@GradientX:

; 26   :         {
; 27   :             GradientPoints[i].FinalX = (__int32)(GradientPoints[i].X / (double)TargetWidth);

	imul	ecx, DWORD PTR _i$10[ebp], 40
	cvtsi2sd xmm0, DWORD PTR _TargetWidth$[ebp]
	mov	edx, DWORD PTR _GradientPoints$[ebp]
	movsd	xmm1, QWORD PTR [edx+ecx+8]
	divsd	xmm1, xmm0
	cvttsd2si eax, xmm1
	imul	ecx, DWORD PTR _i$10[ebp], 40
	mov	edx, DWORD PTR _GradientPoints$[ebp]
	mov	DWORD PTR [edx+ecx+28], eax

; 28   :             GradientPoints[i].FinalY = (__int32)(GradientPoints[i].Y / (double)TargetHeight);

	imul	eax, DWORD PTR _i$10[ebp], 40
	cvtsi2sd xmm0, DWORD PTR _TargetHeight$[ebp]
	mov	ecx, DWORD PTR _GradientPoints$[ebp]
	movsd	xmm1, QWORD PTR [ecx+eax+16]
	divsd	xmm1, xmm0
	cvttsd2si edx, xmm1
	imul	eax, DWORD PTR _i$10[ebp], 40
	mov	ecx, DWORD PTR _GradientPoints$[ebp]
	mov	DWORD PTR [ecx+eax+32], edx
$LN17@GradientX:

; 29   :         }
; 30   :     }

	jmp	$LN2@GradientX
$LN3@GradientX:

; 31   : 
; 32   :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$7[ebp], 0
	jmp	SHORT $LN7@GradientX
$LN5@GradientX:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN7@GradientX:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _TargetHeight$[ebp]
	jge	$LN6@GradientX

; 33   :     {
; 34   :         int RowIndex = Row * TargetStride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowIndex$5[ebp], ecx

; 35   :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$8[ebp], 0
	jmp	SHORT $LN10@GradientX
$LN8@GradientX:
	mov	edx, DWORD PTR _Column$8[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$8[ebp], edx
$LN10@GradientX:
	mov	eax, DWORD PTR _Column$8[ebp]
	cmp	eax, DWORD PTR _TargetWidth$[ebp]
	jge	$LN9@GradientX

; 36   :         {
; 37   :             int Index = RowIndex + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$8[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowIndex$5[ebp]
	mov	DWORD PTR _Index$2[ebp], ecx

; 38   :             double *Distances = new double[GradientColorCount];

	xor	ecx, ecx
	mov	eax, DWORD PTR _GradientColorCount$[ebp]
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _Distances$6[ebp], eax

; 39   : 
; 40   :             for (int g = 0; g < GradientColorCount; g++)

	mov	DWORD PTR _g$9[ebp], 0
	jmp	SHORT $LN13@GradientX
$LN11@GradientX:
	mov	ecx, DWORD PTR _g$9[ebp]
	add	ecx, 1
	mov	DWORD PTR _g$9[ebp], ecx
$LN13@GradientX:
	mov	edx, DWORD PTR _g$9[ebp]
	cmp	edx, DWORD PTR _GradientColorCount$[ebp]
	jge	SHORT $LN12@GradientX

; 41   :             {
; 42   :                 double d = sqrt(pow((double)Column - (double)GradientPoints[g].FinalX, 2) +

	cvtsi2sd xmm0, DWORD PTR _Column$8[ebp]
	imul	eax, DWORD PTR _g$9[ebp], 40
	mov	ecx, DWORD PTR _GradientPoints$[ebp]
	cvtsi2sd xmm1, DWORD PTR [ecx+eax+28]
	subsd	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	cvtsi2sd xmm1, DWORD PTR _Row$7[ebp]
	imul	edx, DWORD PTR _g$9[ebp], 40
	mov	eax, DWORD PTR _GradientPoints$[ebp]
	cvtsi2sd xmm2, DWORD PTR [eax+edx+32]
	subsd	xmm1, xmm2
	movsd	QWORD PTR tv229[ebp], xmm0
	movaps	xmm0, xmm1
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	movsd	xmm1, QWORD PTR tv229[ebp]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	call	__libm_sse2_sqrt_precise
	movsd	QWORD PTR _d$1[ebp], xmm0

; 43   :                     pow((double)Row - (double)GradientPoints[g].FinalY, 2));
; 44   :                 Distances[g] = d;

	mov	ecx, DWORD PTR _g$9[ebp]
	mov	edx, DWORD PTR _Distances$6[ebp]
	movsd	xmm0, QWORD PTR _d$1[ebp]
	movsd	QWORD PTR [edx+ecx*8], xmm0

; 45   :             }

	jmp	$LN11@GradientX
$LN12@GradientX:

; 46   : 
; 47   :             delete[] Distances;

	mov	eax, DWORD PTR _Distances$6[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	ecx, DWORD PTR $T3[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 48   :         }

	jmp	$LN8@GradientX
$LN9@GradientX:

; 49   :     }

	jmp	$LN5@GradientX
$LN6@GradientX:

; 50   :     return Success;

	xor	eax, eax
$LN1@GradientX:

; 51   : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?GradientX@@YGHPAXHHH0H@Z ENDP				; GradientX
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\gradients.cpp
_TEXT	SEGMENT
_Index$1 = -28						; size = 4
_ColorList$ = -24					; size = 4
_Buffer$ = -20						; size = 4
_RowIndex$2 = -16					; size = 4
_PixelSize$ = -12					; size = 4
_Column$3 = -8						; size = 4
_Row$4 = -4						; size = 4
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_PureColorList$ = 24					; size = 4
_PureColorCount$ = 28					; size = 4
_Gradient@24 PROC

; 117  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 118  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@Gradient

; 119  :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@Gradient
$LN8@Gradient:

; 120  :     if (PureColorList == NULL)

	cmp	DWORD PTR _PureColorList$[ebp], 0
	jne	SHORT $LN9@Gradient

; 121  :         return NullPointer;

	mov	eax, 3
	jmp	SHORT $LN1@Gradient
$LN9@Gradient:

; 122  : 
; 123  :     BYTE * Buffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 124  :     PureColorStruct *ColorList = (PureColorStruct *)PureColorList;

	mov	ecx, DWORD PTR _PureColorList$[ebp]
	mov	DWORD PTR _ColorList$[ebp], ecx

; 125  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 126  : 
; 127  :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@Gradient
$LN2@Gradient:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@Gradient:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _TargetHeight$[ebp]
	jge	SHORT $LN3@Gradient

; 128  :     {
; 129  :         int RowIndex = Row * TargetStride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowIndex$2[ebp], ecx

; 130  :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@Gradient
$LN5@Gradient:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@Gradient:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _TargetWidth$[ebp]
	jge	SHORT $LN6@Gradient

; 131  :         {
; 132  :             int Index = RowIndex + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowIndex$2[ebp]
	mov	DWORD PTR _Index$1[ebp], ecx

; 133  :         }

	jmp	SHORT $LN5@Gradient
$LN6@Gradient:

; 134  :     }

	jmp	SHORT $LN2@Gradient
$LN3@Gradient:

; 135  :     return Success;

	xor	eax, eax
$LN1@Gradient:

; 136  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_Gradient@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\gradients.cpp
_TEXT	SEGMENT
_DistPercent$1 = -36					; size = 8
_Dist$2 = -28						; size = 8
_BAccumulator$ = -20					; size = 4
_GAccumulator$ = -16					; size = 4
_RAccumulator$ = -12					; size = 4
_i$3 = -8						; size = 4
_cB$4 = -3						; size = 1
_cG$5 = -2						; size = 1
_cR$6 = -1						; size = 1
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_Hypotenuse$ = 24					; size = 8
_PointCount$ = 32					; size = 4
_Colors$ = 36						; size = 4
_Points$ = 40						; size = 4
_FinalR$ = 44						; size = 4
_FinalG$ = 48						; size = 4
_FinalB$ = 52						; size = 4
?MakeColor@@YGXHHHHNHPAUPureColorStruct@@PAUAbsolutePointStruct@@PAE22@Z PROC ; MakeColor

; 94   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 95   :     int RAccumulator = 0;

	mov	DWORD PTR _RAccumulator$[ebp], 0

; 96   :     int GAccumulator = 0;

	mov	DWORD PTR _GAccumulator$[ebp], 0

; 97   :     int BAccumulator = 0;

	mov	DWORD PTR _BAccumulator$[ebp], 0

; 98   :     for (int i = 0; i < PointCount; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@MakeColor
$LN2@MakeColor:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@MakeColor:
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR _PointCount$[ebp]
	jge	$LN3@MakeColor

; 99   :     {
; 100  :         double Dist = Distance(X, Y, Points[i].X, Points[i].Y);

	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _Points$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	push	ecx
	mov	edx, DWORD PTR _i$3[ebp]
	mov	eax, DWORD PTR _Points$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR _Y$[ebp]
	push	edx
	mov	eax, DWORD PTR _X$[ebp]
	push	eax
	call	?Distance@@YGNHHHH@Z			; Distance
	fstp	QWORD PTR _Dist$2[ebp]

; 101  :         double DistPercent = (Hypotenuse - Dist) / Hypotenuse;

	movsd	xmm0, QWORD PTR _Hypotenuse$[ebp]
	subsd	xmm0, QWORD PTR _Dist$2[ebp]
	divsd	xmm0, QWORD PTR _Hypotenuse$[ebp]
	movsd	QWORD PTR _DistPercent$1[ebp], xmm0

; 102  :         byte cR = 0;

	mov	BYTE PTR _cR$6[ebp], 0

; 103  :         byte cG = 0;

	mov	BYTE PTR _cG$5[ebp], 0

; 104  :         byte cB = 0;

	mov	BYTE PTR _cB$4[ebp], 0

; 105  :         ColorPercent(DistPercent, Colors[i].Red, Colors[i].Green, Colors[i].Blue, &cR, &cG, &cB, false);

	push	0
	lea	ecx, DWORD PTR _cB$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _cG$5[ebp]
	push	edx
	lea	eax, DWORD PTR _cR$6[ebp]
	push	eax
	imul	ecx, DWORD PTR _i$3[ebp], 5
	mov	edx, DWORD PTR _Colors$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+4]
	push	eax
	imul	ecx, DWORD PTR _i$3[ebp], 5
	mov	edx, DWORD PTR _Colors$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+3]
	push	eax
	imul	ecx, DWORD PTR _i$3[ebp], 5
	mov	edx, DWORD PTR _Colors$[ebp]
	movzx	eax, BYTE PTR [edx+ecx+2]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _DistPercent$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?ColorPercent@@YGXNEEEPAE00_N@Z		; ColorPercent

; 106  :         RAccumulator += cR;

	movzx	ecx, BYTE PTR _cR$6[ebp]
	add	ecx, DWORD PTR _RAccumulator$[ebp]
	mov	DWORD PTR _RAccumulator$[ebp], ecx

; 107  :         GAccumulator += cG;

	movzx	edx, BYTE PTR _cG$5[ebp]
	add	edx, DWORD PTR _GAccumulator$[ebp]
	mov	DWORD PTR _GAccumulator$[ebp], edx

; 108  :         BAccumulator += cB;

	movzx	eax, BYTE PTR _cB$4[ebp]
	add	eax, DWORD PTR _BAccumulator$[ebp]
	mov	DWORD PTR _BAccumulator$[ebp], eax

; 109  :     }

	jmp	$LN2@MakeColor
$LN3@MakeColor:

; 110  :     *FinalR = (byte)(RAccumulator / PointCount);

	mov	eax, DWORD PTR _RAccumulator$[ebp]
	cdq
	idiv	DWORD PTR _PointCount$[ebp]
	mov	ecx, DWORD PTR _FinalR$[ebp]
	mov	BYTE PTR [ecx], al

; 111  :     *FinalG = (byte)(GAccumulator / PointCount);

	mov	eax, DWORD PTR _GAccumulator$[ebp]
	cdq
	idiv	DWORD PTR _PointCount$[ebp]
	mov	edx, DWORD PTR _FinalG$[ebp]
	mov	BYTE PTR [edx], al

; 112  :     *FinalB = (byte)(BAccumulator / PointCount);

	mov	eax, DWORD PTR _BAccumulator$[ebp]
	cdq
	idiv	DWORD PTR _PointCount$[ebp]
	mov	ecx, DWORD PTR _FinalB$[ebp]
	mov	BYTE PTR [ecx], al

; 113  : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
?MakeColor@@YGXHHHHNHPAUPureColorStruct@@PAUAbsolutePointStruct@@PAE22@Z ENDP ; MakeColor
_TEXT	ENDS
END
