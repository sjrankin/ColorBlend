; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Analyze.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG110250 DB	'RegionMeanColor', 00H
$SG110253 DB	'Horizontal too small.', 00H
	ORG $+2
$SG110254 DB	'RegionMeanColor', 00H
$SG110257 DB	'Horizontal too big.', 00H
$SG110258 DB	'RegionMeanColor', 00H
$SG110261 DB	'Vertical too small.', 00H
$SG110262 DB	'RegionMeanColor', 00H
$SG110265 DB	'Vertical too big', 00H
	ORG $+3
$SG110266 DB	'RegionMeanColor', 00H
$SG110268 DB	'Left greater than right.', 00H
	ORG $+3
$SG110269 DB	'RegionMeanColor', 00H
$SG110271 DB	'Top greater than bottom.', 00H
	ORG $+3
$SG110272 DB	'RegionMeanColor', 00H
$SG110277 DB	'RegionMeanColor', 00H
$SG110313 DB	'RegionBrightestColor', 00H
	ORG $+3
$SG110316 DB	'Horizontal too small.', 00H
	ORG $+2
$SG110317 DB	'RegionBrightestColor', 00H
	ORG $+3
$SG110320 DB	'Horizontal too big.', 00H
$SG110321 DB	'RegionBrightestColor', 00H
	ORG $+3
$SG110324 DB	'Vertical too small.', 00H
$SG110325 DB	'RegionBrightestColor', 00H
	ORG $+3
$SG110328 DB	'Vertical too big', 00H
	ORG $+3
$SG110329 DB	'RegionBrightestColor', 00H
	ORG $+3
$SG110331 DB	'Left greater than right.', 00H
	ORG $+3
$SG110332 DB	'RegionBrightestColor', 00H
	ORG $+3
$SG110334 DB	'Top greater than bottom.', 00H
	ORG $+3
$SG110335 DB	'RegionBrightestColor', 00H
	ORG $+3
$SG110338 DB	'RegionBrightestColor', 00H
	ORG $+3
$SG110339 DB	'RegionBrightestColor', 00H
	ORG $+3
$SG110375 DB	'RegionDarkestColor', 00H
	ORG $+1
$SG110378 DB	'Horizontal too small.', 00H
	ORG $+2
$SG110379 DB	'RegionDarkestColor', 00H
	ORG $+1
$SG110382 DB	'Horizontal too big.', 00H
$SG110383 DB	'RegionDarkestColor', 00H
	ORG $+1
$SG110386 DB	'Vertical too small.', 00H
$SG110387 DB	'RegionDarkestColor', 00H
	ORG $+1
$SG110390 DB	'Vertical too big', 00H
	ORG $+3
$SG110391 DB	'RegionDarkestColor', 00H
	ORG $+1
$SG110393 DB	'Left greater than right.', 00H
	ORG $+3
$SG110394 DB	'RegionDarkestColor', 00H
	ORG $+1
$SG110396 DB	'Top greater than bottom.', 00H
	ORG $+3
$SG110397 DB	'RegionDarkestColor', 00H
	ORG $+1
$SG110400 DB	'RegionDarkestColor', 00H
	ORG $+1
$SG110401 DB	'RegionDarkestColor', 00H
	ORG $+1
$SG110432 DB	'RegionLuminanceValue', 00H
	ORG $+3
$SG110435 DB	'Horizontal too small.', 00H
	ORG $+2
$SG110436 DB	'RegionLuminanceValue', 00H
	ORG $+3
$SG110439 DB	'Horizontal too big.', 00H
$SG110440 DB	'RegionLuminanceValue', 00H
	ORG $+3
$SG110443 DB	'Vertical too small.', 00H
$SG110444 DB	'RegionLuminanceValue', 00H
	ORG $+3
$SG110447 DB	'Vertical too big', 00H
	ORG $+3
$SG110448 DB	'RegionLuminanceValue', 00H
	ORG $+3
$SG110450 DB	'Left greater than right.', 00H
	ORG $+3
$SG110451 DB	'RegionLuminanceValue', 00H
	ORG $+3
$SG110453 DB	'Top greater than bottom.', 00H
	ORG $+3
$SG110454 DB	'RegionLuminanceValue', 00H
	ORG $+3
$SG110456 DB	'RegionLuminanceValue', 00H
	ORG $+3
$SG110457 DB	'RegionLuminanceValue', 00H
	ORG $+3
$SG110526 DB	'RegionMedianColor', 00H
	ORG $+2
$SG110529 DB	'Horizontal too small.', 00H
	ORG $+2
$SG110530 DB	'RegionMedianColor', 00H
	ORG $+2
$SG110533 DB	'Horizontal too big.', 00H
$SG110534 DB	'RegionMedianColor', 00H
	ORG $+2
$SG110537 DB	'Vertical too small.', 00H
$SG110538 DB	'RegionMedianColor', 00H
	ORG $+2
$SG110541 DB	'Vertical too big', 00H
	ORG $+3
$SG110542 DB	'RegionMedianColor', 00H
	ORG $+2
$SG110544 DB	'Left greater than right.', 00H
	ORG $+3
$SG110545 DB	'RegionMedianColor', 00H
	ORG $+2
$SG110547 DB	'Top greater than bottom.', 00H
	ORG $+3
$SG110548 DB	'RegionMedianColor', 00H
	ORG $+2
$SG110552 DB	'RegionMedianColor', 00H
CONST	ENDS
PUBLIC	_RegionMeanColor@64
PUBLIC	_RegionMedianColor@36
PUBLIC	_RegionBrightestColor@36
PUBLIC	_RegionDarkestColor@36
PUBLIC	_RegionLuminanceValue@36
PUBLIC	?Int32Comparer@@YAHPBX0@Z			; Int32Comparer
PUBLIC	__real@4024000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@bff0000000000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__qsort:PROC
EXTRN	_GetPixelLuminance@12:PROC
EXTRN	_ErrorStackPushReturn@8:PROC
EXTRN	_ErrorStackPushReturn2@12:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\analyze.cpp
_TEXT	SEGMENT
_arg1$ = 8						; size = 4
_arg2$ = 12						; size = 4
?Int32Comparer@@YAHPBX0@Z PROC				; Int32Comparer

; 245  : {

	push	ebp
	mov	ebp, esp

; 246  :     return (*(int*)arg1 - *(int*)arg2);

	mov	eax, DWORD PTR _arg1$[ebp]
	mov	ecx, DWORD PTR _arg2$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]

; 247  : }

	pop	ebp
	ret	0
?Int32Comparer@@YAHPBX0@Z ENDP				; Int32Comparer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\analyze.cpp
_TEXT	SEGMENT
_MeanLuminance$ = -56					; size = 8
tv218 = -48						; size = 8
_Luminance$ = -40					; size = 8
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Index$2 = -24						; size = 4
_Src$ = -20						; size = 4
_ColorCount$ = -16					; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_L$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_RegionX1$ = 24						; size = 4
_RegionY1$ = 28						; size = 4
_RegionX2$ = 32						; size = 4
_RegionY2$ = 36						; size = 4
_LuminanceAsColor$ = 40					; size = 4
_RegionLuminanceValue@36 PROC

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 202  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RegionLumi

; 203  :         return ErrorStackPushReturn(NullPointer, "RegionLuminanceValue");

	push	OFFSET $SG110432
	push	3
	call	_ErrorStackPushReturn@8
	jmp	$LN1@RegionLumi
$LN8@RegionLumi:

; 204  :     if (RegionX1 < 0 || RegionX2 < 0)

	cmp	DWORD PTR _RegionX1$[ebp], 0
	jl	SHORT $LN10@RegionLumi
	cmp	DWORD PTR _RegionX2$[ebp], 0
	jge	SHORT $LN9@RegionLumi
$LN10@RegionLumi:

; 205  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionLuminanceValue", "Horizontal too small.");

	push	OFFSET $SG110435
	push	OFFSET $SG110436
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionLumi
$LN9@RegionLumi:

; 206  :     if (RegionX1 >= Width || RegionX2 >= Width)

	mov	eax, DWORD PTR _RegionX1$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN12@RegionLumi
	mov	ecx, DWORD PTR _RegionX2$[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jl	SHORT $LN11@RegionLumi
$LN12@RegionLumi:

; 207  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionLuminanceValue", "Horizontal too big.");

	push	OFFSET $SG110439
	push	OFFSET $SG110440
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionLumi
$LN11@RegionLumi:

; 208  :     if (RegionY1 < 0 || RegionY2 < 0)

	cmp	DWORD PTR _RegionY1$[ebp], 0
	jl	SHORT $LN14@RegionLumi
	cmp	DWORD PTR _RegionY2$[ebp], 0
	jge	SHORT $LN13@RegionLumi
$LN14@RegionLumi:

; 209  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionLuminanceValue", "Vertical too small.");

	push	OFFSET $SG110443
	push	OFFSET $SG110444
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionLumi
$LN13@RegionLumi:

; 210  :     if (RegionY1 >= Height || RegionY2 >= Height)

	mov	edx, DWORD PTR _RegionY1$[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN16@RegionLumi
	mov	eax, DWORD PTR _RegionY2$[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jl	SHORT $LN15@RegionLumi
$LN16@RegionLumi:

; 211  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionLuminanceValue", "Vertical too big");

	push	OFFSET $SG110447
	push	OFFSET $SG110448
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionLumi
$LN15@RegionLumi:

; 212  :     if (RegionX1 >= RegionX2)

	mov	ecx, DWORD PTR _RegionX1$[ebp]
	cmp	ecx, DWORD PTR _RegionX2$[ebp]
	jl	SHORT $LN17@RegionLumi

; 213  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionLuminanceValue", "Left greater than right.");

	push	OFFSET $SG110450
	push	OFFSET $SG110451
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionLumi
$LN17@RegionLumi:

; 214  :     if (RegionY1 >= RegionY2)

	mov	edx, DWORD PTR _RegionY1$[ebp]
	cmp	edx, DWORD PTR _RegionY2$[ebp]
	jl	SHORT $LN18@RegionLumi

; 215  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionLuminanceValue", "Top greater than bottom.");

	push	OFFSET $SG110453
	push	OFFSET $SG110454
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionLumi
$LN18@RegionLumi:

; 216  : 
; 217  :     __int32 ColorCount = 0;

	mov	DWORD PTR _ColorCount$[ebp], 0

; 218  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 219  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 220  :     double Luminance = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Luminance$[ebp], xmm0

; 221  : 
; 222  :     for (int Row = RegionY1; Row <= RegionY2; Row++)

	mov	ecx, DWORD PTR _RegionY1$[ebp]
	mov	DWORD PTR _Row$4[ebp], ecx
	jmp	SHORT $LN4@RegionLumi
$LN2@RegionLumi:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@RegionLumi:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _RegionY2$[ebp]
	jg	SHORT $LN3@RegionLumi

; 223  :     {
; 224  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 225  :         for (int Column = RegionX1; Column <= RegionX2; Column++)

	mov	edx, DWORD PTR _RegionX1$[ebp]
	mov	DWORD PTR _Column$3[ebp], edx
	jmp	SHORT $LN7@RegionLumi
$LN5@RegionLumi:
	mov	eax, DWORD PTR _Column$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$3[ebp], eax
$LN7@RegionLumi:
	mov	ecx, DWORD PTR _Column$3[ebp]
	cmp	ecx, DWORD PTR _RegionX2$[ebp]
	jg	SHORT $LN6@RegionLumi

; 226  :         {
; 227  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$3[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], edx

; 228  :             Luminance += GetPixelLuminance(Src[Index + 2], Src[Index + 1], Src[Index + 0]);

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	call	_GetPixelLuminance@12
	fstp	QWORD PTR tv218[ebp]
	movsd	xmm0, QWORD PTR tv218[ebp]
	addsd	xmm0, QWORD PTR _Luminance$[ebp]
	movsd	QWORD PTR _Luminance$[ebp], xmm0

; 229  :             ColorCount++;

	mov	eax, DWORD PTR _ColorCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _ColorCount$[ebp], eax

; 230  :         }

	jmp	SHORT $LN5@RegionLumi
$LN6@RegionLumi:

; 231  :     }

	jmp	$LN2@RegionLumi
$LN3@RegionLumi:

; 232  : 
; 233  :     if (ColorCount < 1)

	cmp	DWORD PTR _ColorCount$[ebp], 1
	jge	SHORT $LN19@RegionLumi

; 234  :         return ErrorStackPushReturn(NoPixelsSelected, "RegionLuminanceValue");

	push	OFFSET $SG110456
	push	20					; 00000014H
	call	_ErrorStackPushReturn@8
	jmp	SHORT $LN1@RegionLumi
$LN19@RegionLumi:

; 235  : 
; 236  :     double MeanLuminance = Luminance / ColorCount;

	cvtsi2sd xmm0, DWORD PTR _ColorCount$[ebp]
	movsd	xmm1, QWORD PTR _Luminance$[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _MeanLuminance$[ebp], xmm1

; 237  :     BYTE L = (BYTE)(MeanLuminance * 255.0);

	movsd	xmm0, QWORD PTR _MeanLuminance$[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _L$[ebp], cl

; 238  : 
; 239  :     *LuminanceAsColor = (0xff << 24) | (L << 16) | (L << 8) | L;

	movzx	edx, BYTE PTR _L$[ebp]
	shl	edx, 16					; 00000010H
	or	edx, -16777216				; ff000000H
	movzx	eax, BYTE PTR _L$[ebp]
	shl	eax, 8
	or	edx, eax
	movzx	ecx, BYTE PTR _L$[ebp]
	or	edx, ecx
	mov	eax, DWORD PTR _LuminanceAsColor$[ebp]
	mov	DWORD PTR [eax], edx

; 240  : 
; 241  :     return ErrorStackPushReturn(Success, "RegionLuminanceValue");

	push	OFFSET $SG110457
	push	0
	call	_ErrorStackPushReturn@8
$LN1@RegionLumi:

; 242  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_RegionLuminanceValue@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\analyze.cpp
_TEXT	SEGMENT
_Luminance$ = -60					; size = 8
_ScratchLuminance$1 = -52				; size = 8
_Alpha$ = -44						; size = 4
_RowOffset$2 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_Blue$ = -32						; size = 4
_Green$ = -28						; size = 4
_Red$ = -24						; size = 4
_ColorCount$ = -20					; size = 4
_Column$3 = -16						; size = 4
_Row$4 = -12						; size = 4
_Index$5 = -8						; size = 4
_Src$ = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_RegionX1$ = 24						; size = 4
_RegionY1$ = 28						; size = 4
_RegionX2$ = 32						; size = 4
_RegionY2$ = 36						; size = 4
_PackedDarkestColor$ = 40				; size = 4
_RegionDarkestColor@36 PROC

; 147  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 148  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RegionDark

; 149  :         return ErrorStackPushReturn(NullPointer, "RegionDarkestColor");

	push	OFFSET $SG110375
	push	3
	call	_ErrorStackPushReturn@8
	jmp	$LN1@RegionDark
$LN8@RegionDark:

; 150  :     if (RegionX1 < 0 || RegionX2 < 0)

	cmp	DWORD PTR _RegionX1$[ebp], 0
	jl	SHORT $LN10@RegionDark
	cmp	DWORD PTR _RegionX2$[ebp], 0
	jge	SHORT $LN9@RegionDark
$LN10@RegionDark:

; 151  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionDarkestColor", "Horizontal too small.");

	push	OFFSET $SG110378
	push	OFFSET $SG110379
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionDark
$LN9@RegionDark:

; 152  :     if (RegionX1 >= Width || RegionX2 >= Width)

	mov	eax, DWORD PTR _RegionX1$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN12@RegionDark
	mov	ecx, DWORD PTR _RegionX2$[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jl	SHORT $LN11@RegionDark
$LN12@RegionDark:

; 153  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionDarkestColor", "Horizontal too big.");

	push	OFFSET $SG110382
	push	OFFSET $SG110383
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionDark
$LN11@RegionDark:

; 154  :     if (RegionY1 < 0 || RegionY2 < 0)

	cmp	DWORD PTR _RegionY1$[ebp], 0
	jl	SHORT $LN14@RegionDark
	cmp	DWORD PTR _RegionY2$[ebp], 0
	jge	SHORT $LN13@RegionDark
$LN14@RegionDark:

; 155  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionDarkestColor", "Vertical too small.");

	push	OFFSET $SG110386
	push	OFFSET $SG110387
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionDark
$LN13@RegionDark:

; 156  :     if (RegionY1 >= Height || RegionY2 >= Height)

	mov	edx, DWORD PTR _RegionY1$[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN16@RegionDark
	mov	eax, DWORD PTR _RegionY2$[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jl	SHORT $LN15@RegionDark
$LN16@RegionDark:

; 157  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionDarkestColor", "Vertical too big");

	push	OFFSET $SG110390
	push	OFFSET $SG110391
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionDark
$LN15@RegionDark:

; 158  :     if (RegionX1 >= RegionX2)

	mov	ecx, DWORD PTR _RegionX1$[ebp]
	cmp	ecx, DWORD PTR _RegionX2$[ebp]
	jl	SHORT $LN17@RegionDark

; 159  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionDarkestColor", "Left greater than right.");

	push	OFFSET $SG110393
	push	OFFSET $SG110394
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionDark
$LN17@RegionDark:

; 160  :     if (RegionY1 >= RegionY2)

	mov	edx, DWORD PTR _RegionY1$[ebp]
	cmp	edx, DWORD PTR _RegionY2$[ebp]
	jl	SHORT $LN18@RegionDark

; 161  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionDarkestColor", "Top greater than bottom.");

	push	OFFSET $SG110396
	push	OFFSET $SG110397
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionDark
$LN18@RegionDark:

; 162  : 
; 163  :     __int32 Alpha = 0;

	mov	DWORD PTR _Alpha$[ebp], 0

; 164  :     __int32 Red = 0;

	mov	DWORD PTR _Red$[ebp], 0

; 165  :     __int32 Green = 0;

	mov	DWORD PTR _Green$[ebp], 0

; 166  :     __int32 Blue = 0;

	mov	DWORD PTR _Blue$[ebp], 0

; 167  :     __int32 ColorCount = 0;

	mov	DWORD PTR _ColorCount$[ebp], 0

; 168  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 169  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 170  :     double Luminance = 10.0;

	movsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR _Luminance$[ebp], xmm0

; 171  : 
; 172  :     for (int Row = RegionY1; Row <= RegionY2; Row++)

	mov	ecx, DWORD PTR _RegionY1$[ebp]
	mov	DWORD PTR _Row$4[ebp], ecx
	jmp	SHORT $LN4@RegionDark
$LN2@RegionDark:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@RegionDark:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _RegionY2$[ebp]
	jg	$LN3@RegionDark

; 173  :     {
; 174  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 175  :         for (int Column = RegionX1; Column <= RegionX2; Column++)

	mov	edx, DWORD PTR _RegionX1$[ebp]
	mov	DWORD PTR _Column$3[ebp], edx
	jmp	SHORT $LN7@RegionDark
$LN5@RegionDark:
	mov	eax, DWORD PTR _Column$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$3[ebp], eax
$LN7@RegionDark:
	mov	ecx, DWORD PTR _Column$3[ebp]
	cmp	ecx, DWORD PTR _RegionX2$[ebp]
	jg	SHORT $LN6@RegionDark

; 176  :         {
; 177  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$3[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], edx

; 178  :             double ScratchLuminance = GetPixelLuminance(Src[Index + 2], Src[Index + 1], Src[Index + 0]);

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	call	_GetPixelLuminance@12
	fstp	QWORD PTR _ScratchLuminance$1[ebp]

; 179  :             if (ScratchLuminance < Luminance)

	movsd	xmm0, QWORD PTR _Luminance$[ebp]
	comisd	xmm0, QWORD PTR _ScratchLuminance$1[ebp]
	jbe	SHORT $LN19@RegionDark

; 180  :             {
; 181  :                 Red = Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	DWORD PTR _Red$[ebp], ecx

; 182  :                 Green = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx+1]
	mov	DWORD PTR _Green$[ebp], eax

; 183  :                 Blue = Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _Blue$[ebp], edx

; 184  :                 Luminance = ScratchLuminance;

	movsd	xmm0, QWORD PTR _ScratchLuminance$1[ebp]
	movsd	QWORD PTR _Luminance$[ebp], xmm0
$LN19@RegionDark:

; 185  :             }
; 186  :             ColorCount++;

	mov	eax, DWORD PTR _ColorCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _ColorCount$[ebp], eax

; 187  :         }

	jmp	$LN5@RegionDark
$LN6@RegionDark:

; 188  :     }

	jmp	$LN2@RegionDark
$LN3@RegionDark:

; 189  : 
; 190  :     if (ColorCount < 1)

	cmp	DWORD PTR _ColorCount$[ebp], 1
	jge	SHORT $LN20@RegionDark

; 191  :         return ErrorStackPushReturn(NoPixelsSelected, "RegionDarkestColor");

	push	OFFSET $SG110400
	push	20					; 00000014H
	call	_ErrorStackPushReturn@8
	jmp	SHORT $LN1@RegionDark
$LN20@RegionDark:

; 192  : 
; 193  :     *PackedDarkestColor = (0xff << 24) | ((BYTE)Red << 16) | ((BYTE)Green << 8) | (BYTE)Blue;

	movzx	ecx, BYTE PTR _Red$[ebp]
	shl	ecx, 16					; 00000010H
	or	ecx, -16777216				; ff000000H
	movzx	edx, BYTE PTR _Green$[ebp]
	shl	edx, 8
	or	ecx, edx
	movzx	eax, BYTE PTR _Blue$[ebp]
	or	ecx, eax
	mov	edx, DWORD PTR _PackedDarkestColor$[ebp]
	mov	DWORD PTR [edx], ecx

; 194  : 
; 195  :     return ErrorStackPushReturn(Success, "RegionDarkestColor");

	push	OFFSET $SG110401
	push	0
	call	_ErrorStackPushReturn@8
$LN1@RegionDark:

; 196  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_RegionDarkestColor@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\analyze.cpp
_TEXT	SEGMENT
_Luminance$ = -60					; size = 8
_ScratchLuminance$1 = -52				; size = 8
_Alpha$ = -44						; size = 4
_RowOffset$2 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_Blue$ = -32						; size = 4
_Green$ = -28						; size = 4
_Red$ = -24						; size = 4
_ColorCount$ = -20					; size = 4
_Column$3 = -16						; size = 4
_Row$4 = -12						; size = 4
_Index$5 = -8						; size = 4
_Src$ = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_RegionX1$ = 24						; size = 4
_RegionY1$ = 28						; size = 4
_RegionX2$ = 32						; size = 4
_RegionY2$ = 36						; size = 4
_PackedBrightestColor$ = 40				; size = 4
_RegionBrightestColor@36 PROC

; 93   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 94   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RegionBrig

; 95   :         return ErrorStackPushReturn(NullPointer, "RegionBrightestColor");

	push	OFFSET $SG110313
	push	3
	call	_ErrorStackPushReturn@8
	jmp	$LN1@RegionBrig
$LN8@RegionBrig:

; 96   :     if (RegionX1 < 0 || RegionX2 < 0)

	cmp	DWORD PTR _RegionX1$[ebp], 0
	jl	SHORT $LN10@RegionBrig
	cmp	DWORD PTR _RegionX2$[ebp], 0
	jge	SHORT $LN9@RegionBrig
$LN10@RegionBrig:

; 97   :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionBrightestColor", "Horizontal too small.");

	push	OFFSET $SG110316
	push	OFFSET $SG110317
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionBrig
$LN9@RegionBrig:

; 98   :     if (RegionX1 >= Width || RegionX2 >= Width)

	mov	eax, DWORD PTR _RegionX1$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN12@RegionBrig
	mov	ecx, DWORD PTR _RegionX2$[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jl	SHORT $LN11@RegionBrig
$LN12@RegionBrig:

; 99   :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionBrightestColor", "Horizontal too big.");

	push	OFFSET $SG110320
	push	OFFSET $SG110321
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionBrig
$LN11@RegionBrig:

; 100  :     if (RegionY1 < 0 || RegionY2 < 0)

	cmp	DWORD PTR _RegionY1$[ebp], 0
	jl	SHORT $LN14@RegionBrig
	cmp	DWORD PTR _RegionY2$[ebp], 0
	jge	SHORT $LN13@RegionBrig
$LN14@RegionBrig:

; 101  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionBrightestColor", "Vertical too small.");

	push	OFFSET $SG110324
	push	OFFSET $SG110325
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionBrig
$LN13@RegionBrig:

; 102  :     if (RegionY1 >= Height || RegionY2 >= Height)

	mov	edx, DWORD PTR _RegionY1$[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN16@RegionBrig
	mov	eax, DWORD PTR _RegionY2$[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jl	SHORT $LN15@RegionBrig
$LN16@RegionBrig:

; 103  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionBrightestColor", "Vertical too big");

	push	OFFSET $SG110328
	push	OFFSET $SG110329
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionBrig
$LN15@RegionBrig:

; 104  :     if (RegionX1 >= RegionX2)

	mov	ecx, DWORD PTR _RegionX1$[ebp]
	cmp	ecx, DWORD PTR _RegionX2$[ebp]
	jl	SHORT $LN17@RegionBrig

; 105  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionBrightestColor", "Left greater than right.");

	push	OFFSET $SG110331
	push	OFFSET $SG110332
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionBrig
$LN17@RegionBrig:

; 106  :     if (RegionY1 >= RegionY2)

	mov	edx, DWORD PTR _RegionY1$[ebp]
	cmp	edx, DWORD PTR _RegionY2$[ebp]
	jl	SHORT $LN18@RegionBrig

; 107  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionBrightestColor", "Top greater than bottom.");

	push	OFFSET $SG110334
	push	OFFSET $SG110335
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionBrig
$LN18@RegionBrig:

; 108  : 
; 109  :     __int32 Alpha = 0;

	mov	DWORD PTR _Alpha$[ebp], 0

; 110  :     __int32 Red = 0;

	mov	DWORD PTR _Red$[ebp], 0

; 111  :     __int32 Green = 0;

	mov	DWORD PTR _Green$[ebp], 0

; 112  :     __int32 Blue = 0;

	mov	DWORD PTR _Blue$[ebp], 0

; 113  :     __int32 ColorCount = 0;

	mov	DWORD PTR _ColorCount$[ebp], 0

; 114  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 115  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 116  :     double Luminance = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Luminance$[ebp], xmm0

; 117  : 
; 118  :     for (int Row = RegionY1; Row <= RegionY2; Row++)

	mov	ecx, DWORD PTR _RegionY1$[ebp]
	mov	DWORD PTR _Row$4[ebp], ecx
	jmp	SHORT $LN4@RegionBrig
$LN2@RegionBrig:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@RegionBrig:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _RegionY2$[ebp]
	jg	$LN3@RegionBrig

; 119  :     {
; 120  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 121  :         for (int Column = RegionX1; Column <= RegionX2; Column++)

	mov	edx, DWORD PTR _RegionX1$[ebp]
	mov	DWORD PTR _Column$3[ebp], edx
	jmp	SHORT $LN7@RegionBrig
$LN5@RegionBrig:
	mov	eax, DWORD PTR _Column$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$3[ebp], eax
$LN7@RegionBrig:
	mov	ecx, DWORD PTR _Column$3[ebp]
	cmp	ecx, DWORD PTR _RegionX2$[ebp]
	jg	SHORT $LN6@RegionBrig

; 122  :         {
; 123  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$3[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], edx

; 124  :             double ScratchLuminance = GetPixelLuminance(Src[Index + 2], Src[Index + 1], Src[Index + 0]);

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	call	_GetPixelLuminance@12
	fstp	QWORD PTR _ScratchLuminance$1[ebp]

; 125  :             if (ScratchLuminance > Luminance)

	movsd	xmm0, QWORD PTR _ScratchLuminance$1[ebp]
	comisd	xmm0, QWORD PTR _Luminance$[ebp]
	jbe	SHORT $LN19@RegionBrig

; 126  :             {
; 127  :                 Red = Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	DWORD PTR _Red$[ebp], ecx

; 128  :                 Green = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx+1]
	mov	DWORD PTR _Green$[ebp], eax

; 129  :                 Blue = Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _Blue$[ebp], edx

; 130  :                 Luminance = ScratchLuminance;

	movsd	xmm0, QWORD PTR _ScratchLuminance$1[ebp]
	movsd	QWORD PTR _Luminance$[ebp], xmm0
$LN19@RegionBrig:

; 131  :             }
; 132  :             ColorCount++;

	mov	eax, DWORD PTR _ColorCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _ColorCount$[ebp], eax

; 133  :         }

	jmp	$LN5@RegionBrig
$LN6@RegionBrig:

; 134  :     }

	jmp	$LN2@RegionBrig
$LN3@RegionBrig:

; 135  : 
; 136  :     if (ColorCount < 1)

	cmp	DWORD PTR _ColorCount$[ebp], 1
	jge	SHORT $LN20@RegionBrig

; 137  :         return ErrorStackPushReturn(NoPixelsSelected, "RegionBrightestColor");

	push	OFFSET $SG110338
	push	20					; 00000014H
	call	_ErrorStackPushReturn@8
	jmp	SHORT $LN1@RegionBrig
$LN20@RegionBrig:

; 138  : 
; 139  :     *PackedBrightestColor = (0xff << 24) | ((BYTE)Red << 16) | ((BYTE)Green << 8) | (BYTE)Blue;

	movzx	ecx, BYTE PTR _Red$[ebp]
	shl	ecx, 16					; 00000010H
	or	ecx, -16777216				; ff000000H
	movzx	edx, BYTE PTR _Green$[ebp]
	shl	edx, 8
	or	ecx, edx
	movzx	eax, BYTE PTR _Blue$[ebp]
	or	ecx, eax
	mov	edx, DWORD PTR _PackedBrightestColor$[ebp]
	mov	DWORD PTR [edx], ecx

; 140  : 
; 141  :     return ErrorStackPushReturn(Success, "RegionBrightestColor");

	push	OFFSET $SG110339
	push	0
	call	_ErrorStackPushReturn@8
$LN1@RegionBrig:

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_RegionBrightestColor@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\analyze.cpp
_TEXT	SEGMENT
$T1 = -96						; size = 4
$T2 = -92						; size = 4
$T3 = -88						; size = 4
$T4 = -84						; size = 4
_RowOffset$5 = -80					; size = 4
_PixelSize$ = -76					; size = 4
$T6 = -72						; size = 4
$T7 = -68						; size = 4
$T8 = -64						; size = 4
$T9 = -60						; size = 4
_HighIndex$10 = -56					; size = 4
_LowIndex$11 = -52					; size = 4
_Index$12 = -48						; size = 4
_Index$13 = -44						; size = 4
_Src$ = -40						; size = 4
_Column$14 = -36					; size = 4
_Row$15 = -32						; size = 4
_ArraySize$ = -28					; size = 4
_BlueAccumulator$ = -24					; size = 4
_GreenAccumulator$ = -20				; size = 4
_RedAccumulator$ = -16					; size = 4
_AlphaAccumulator$ = -12				; size = 4
_ColorCount$ = -8					; size = 4
_B$ = -4						; size = 1
_G$ = -3						; size = 1
_R$ = -2						; size = 1
_A$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_RegionX1$ = 24						; size = 4
_RegionY1$ = 28						; size = 4
_RegionX2$ = 32						; size = 4
_RegionY2$ = 36						; size = 4
_PackedMedianColor$ = 40				; size = 4
_RegionMedianColor@36 PROC

; 252  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 253  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RegionMedi

; 254  :         return ErrorStackPushReturn(NullPointer, "RegionMedianColor");

	push	OFFSET $SG110526
	push	3
	call	_ErrorStackPushReturn@8
	jmp	$LN1@RegionMedi
$LN8@RegionMedi:

; 255  :     if (RegionX1 < 0 || RegionX2 < 0)

	cmp	DWORD PTR _RegionX1$[ebp], 0
	jl	SHORT $LN10@RegionMedi
	cmp	DWORD PTR _RegionX2$[ebp], 0
	jge	SHORT $LN9@RegionMedi
$LN10@RegionMedi:

; 256  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMedianColor", "Horizontal too small.");

	push	OFFSET $SG110529
	push	OFFSET $SG110530
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMedi
$LN9@RegionMedi:

; 257  :     if (RegionX1 >= Width || RegionX2 >= Width)

	mov	eax, DWORD PTR _RegionX1$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN12@RegionMedi
	mov	ecx, DWORD PTR _RegionX2$[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jl	SHORT $LN11@RegionMedi
$LN12@RegionMedi:

; 258  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMedianColor", "Horizontal too big.");

	push	OFFSET $SG110533
	push	OFFSET $SG110534
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMedi
$LN11@RegionMedi:

; 259  :     if (RegionY1 < 0 || RegionY2 < 0)

	cmp	DWORD PTR _RegionY1$[ebp], 0
	jl	SHORT $LN14@RegionMedi
	cmp	DWORD PTR _RegionY2$[ebp], 0
	jge	SHORT $LN13@RegionMedi
$LN14@RegionMedi:

; 260  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMedianColor", "Vertical too small.");

	push	OFFSET $SG110537
	push	OFFSET $SG110538
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMedi
$LN13@RegionMedi:

; 261  :     if (RegionY1 >= Height || RegionY2 >= Height)

	mov	edx, DWORD PTR _RegionY1$[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN16@RegionMedi
	mov	eax, DWORD PTR _RegionY2$[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jl	SHORT $LN15@RegionMedi
$LN16@RegionMedi:

; 262  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMedianColor", "Vertical too big");

	push	OFFSET $SG110541
	push	OFFSET $SG110542
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMedi
$LN15@RegionMedi:

; 263  :     if (RegionX1 >= RegionX2)

	mov	ecx, DWORD PTR _RegionX1$[ebp]
	cmp	ecx, DWORD PTR _RegionX2$[ebp]
	jl	SHORT $LN17@RegionMedi

; 264  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMedianColor", "Left greater than right.");

	push	OFFSET $SG110544
	push	OFFSET $SG110545
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMedi
$LN17@RegionMedi:

; 265  :     if (RegionY1 >= RegionY2)

	mov	edx, DWORD PTR _RegionY1$[ebp]
	cmp	edx, DWORD PTR _RegionY2$[ebp]
	jl	SHORT $LN18@RegionMedi

; 266  :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMedianColor", "Top greater than bottom.");

	push	OFFSET $SG110547
	push	OFFSET $SG110548
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMedi
$LN18@RegionMedi:

; 267  : 
; 268  :     __int32 ColorCount = 0;

	mov	DWORD PTR _ColorCount$[ebp], 0

; 269  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 270  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 271  :     int ArraySize = (RegionX2 - RegionX1 + 1) * (RegionY2 - RegionY1 + 1);

	mov	ecx, DWORD PTR _RegionX2$[ebp]
	sub	ecx, DWORD PTR _RegionX1$[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _RegionY2$[ebp]
	sub	edx, DWORD PTR _RegionY1$[ebp]
	add	edx, 1
	imul	ecx, edx
	mov	DWORD PTR _ArraySize$[ebp], ecx

; 272  :     __int32 *RedAccumulator = new __int32[ArraySize];

	xor	ecx, ecx
	mov	eax, DWORD PTR _ArraySize$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	eax, DWORD PTR $T9[ebp]
	mov	DWORD PTR _RedAccumulator$[ebp], eax

; 273  :     __int32 *GreenAccumulator = new __int32[ArraySize];

	xor	ecx, ecx
	mov	eax, DWORD PTR _ArraySize$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	eax, DWORD PTR $T8[ebp]
	mov	DWORD PTR _GreenAccumulator$[ebp], eax

; 274  :     __int32 *BlueAccumulator = new __int32[ArraySize];

	xor	ecx, ecx
	mov	eax, DWORD PTR _ArraySize$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	eax, DWORD PTR $T7[ebp]
	mov	DWORD PTR _BlueAccumulator$[ebp], eax

; 275  :     __int32 *AlphaAccumulator = new __int32[ArraySize];

	xor	ecx, ecx
	mov	eax, DWORD PTR _ArraySize$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T6[ebp], eax
	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _AlphaAccumulator$[ebp], eax

; 276  : 
; 277  :     for (int Row = RegionY1; Row <= RegionY2; Row++)

	mov	ecx, DWORD PTR _RegionY1$[ebp]
	mov	DWORD PTR _Row$15[ebp], ecx
	jmp	SHORT $LN4@RegionMedi
$LN2@RegionMedi:
	mov	edx, DWORD PTR _Row$15[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$15[ebp], edx
$LN4@RegionMedi:
	mov	eax, DWORD PTR _Row$15[ebp]
	cmp	eax, DWORD PTR _RegionY2$[ebp]
	jg	$LN3@RegionMedi

; 278  :     {
; 279  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$15[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$5[ebp], ecx

; 280  :         for (int Column = RegionX1; Column <= RegionX2; Column++)

	mov	edx, DWORD PTR _RegionX1$[ebp]
	mov	DWORD PTR _Column$14[ebp], edx
	jmp	SHORT $LN7@RegionMedi
$LN5@RegionMedi:
	mov	eax, DWORD PTR _Column$14[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$14[ebp], eax
$LN7@RegionMedi:
	mov	ecx, DWORD PTR _Column$14[ebp]
	cmp	ecx, DWORD PTR _RegionX2$[ebp]
	jg	SHORT $LN6@RegionMedi

; 281  :         {
; 282  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$14[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$5[ebp]
	mov	DWORD PTR _Index$13[ebp], edx

; 283  :             AlphaAccumulator[ColorCount] = Src[Index + 3];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$13[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	mov	edx, DWORD PTR _ColorCount$[ebp]
	mov	eax, DWORD PTR _AlphaAccumulator$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 284  :             RedAccumulator[ColorCount] = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$13[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	mov	eax, DWORD PTR _ColorCount$[ebp]
	mov	ecx, DWORD PTR _RedAccumulator$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 285  :             GreenAccumulator[ColorCount] = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$13[ebp]
	movzx	eax, BYTE PTR [edx+1]
	mov	ecx, DWORD PTR _ColorCount$[ebp]
	mov	edx, DWORD PTR _GreenAccumulator$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 286  :             BlueAccumulator[ColorCount] = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$13[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _ColorCount$[ebp]
	mov	eax, DWORD PTR _BlueAccumulator$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 287  :             ColorCount++;

	mov	ecx, DWORD PTR _ColorCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ColorCount$[ebp], ecx

; 288  :         }

	jmp	SHORT $LN5@RegionMedi
$LN6@RegionMedi:

; 289  :     }

	jmp	$LN2@RegionMedi
$LN3@RegionMedi:

; 290  : 
; 291  :     if (ColorCount < 2)

	cmp	DWORD PTR _ColorCount$[ebp], 2
	jge	SHORT $LN19@RegionMedi

; 292  :     {
; 293  :         delete[] RedAccumulator;

	mov	edx, DWORD PTR _RedAccumulator$[ebp]
	mov	DWORD PTR $T4[ebp], edx
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 294  :         delete[] GreenAccumulator;

	mov	ecx, DWORD PTR _GreenAccumulator$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 295  :         delete[] BlueAccumulator;

	mov	eax, DWORD PTR _BlueAccumulator$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 296  :         delete[] AlphaAccumulator;

	mov	edx, DWORD PTR _AlphaAccumulator$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 297  :         return NoPixelsSelected;

	mov	eax, 20					; 00000014H
	jmp	$LN1@RegionMedi
$LN19@RegionMedi:

; 298  :     }
; 299  : 
; 300  :     qsort((void *)RedAccumulator, ColorCount, sizeof(__int32), Int32Comparer);

	push	OFFSET ?Int32Comparer@@YAHPBX0@Z	; Int32Comparer
	push	4
	mov	ecx, DWORD PTR _ColorCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _RedAccumulator$[ebp]
	push	edx
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 301  :     qsort((void *)GreenAccumulator, ColorCount, sizeof(__int32), Int32Comparer);

	push	OFFSET ?Int32Comparer@@YAHPBX0@Z	; Int32Comparer
	push	4
	mov	eax, DWORD PTR _ColorCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _GreenAccumulator$[ebp]
	push	ecx
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 302  :     qsort((void *)BlueAccumulator, ColorCount, sizeof(__int32), Int32Comparer);

	push	OFFSET ?Int32Comparer@@YAHPBX0@Z	; Int32Comparer
	push	4
	mov	edx, DWORD PTR _ColorCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _BlueAccumulator$[ebp]
	push	eax
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 303  :     qsort((void *)AlphaAccumulator, ColorCount, sizeof(__int32), Int32Comparer);

	push	OFFSET ?Int32Comparer@@YAHPBX0@Z	; Int32Comparer
	push	4
	mov	ecx, DWORD PTR _ColorCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AlphaAccumulator$[ebp]
	push	edx
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 304  : 
; 305  :     BYTE A = 0;

	mov	BYTE PTR _A$[ebp], 0

; 306  :     BYTE R = 0;

	mov	BYTE PTR _R$[ebp], 0

; 307  :     BYTE G = 0;

	mov	BYTE PTR _G$[ebp], 0

; 308  :     BYTE B = 0;

	mov	BYTE PTR _B$[ebp], 0

; 309  : 
; 310  :     if (ColorCount % 2 == 1)

	mov	eax, DWORD PTR _ColorCount$[ebp]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN23@RegionMedi
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN23@RegionMedi:
	cmp	eax, 1
	jne	SHORT $LN20@RegionMedi

; 311  :     {
; 312  :         int Index = (ColorCount / 2) + 1;

	mov	eax, DWORD PTR _ColorCount$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1
	mov	DWORD PTR _Index$12[ebp], eax

; 313  :         A = AlphaAccumulator[Index];

	mov	ecx, DWORD PTR _Index$12[ebp]
	mov	edx, DWORD PTR _AlphaAccumulator$[ebp]
	mov	al, BYTE PTR [edx+ecx*4]
	mov	BYTE PTR _A$[ebp], al

; 314  :         R = RedAccumulator[Index];

	mov	ecx, DWORD PTR _Index$12[ebp]
	mov	edx, DWORD PTR _RedAccumulator$[ebp]
	mov	al, BYTE PTR [edx+ecx*4]
	mov	BYTE PTR _R$[ebp], al

; 315  :         G = GreenAccumulator[Index];

	mov	ecx, DWORD PTR _Index$12[ebp]
	mov	edx, DWORD PTR _GreenAccumulator$[ebp]
	mov	al, BYTE PTR [edx+ecx*4]
	mov	BYTE PTR _G$[ebp], al

; 316  :         B = BlueAccumulator[Index];

	mov	ecx, DWORD PTR _Index$12[ebp]
	mov	edx, DWORD PTR _BlueAccumulator$[ebp]
	mov	al, BYTE PTR [edx+ecx*4]
	mov	BYTE PTR _B$[ebp], al

; 317  :     }
; 318  :     else

	jmp	$LN21@RegionMedi
$LN20@RegionMedi:

; 319  :     {
; 320  :         int LowIndex = (ColorCount / 2) - 1;

	mov	eax, DWORD PTR _ColorCount$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 1
	mov	DWORD PTR _LowIndex$11[ebp], eax

; 321  :         int HighIndex = (ColorCount / 2) + 1;

	mov	eax, DWORD PTR _ColorCount$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1
	mov	DWORD PTR _HighIndex$10[ebp], eax

; 322  :         A = (BYTE)((AlphaAccumulator[LowIndex] + AlphaAccumulator[HighIndex]) / 2);

	mov	ecx, DWORD PTR _LowIndex$11[ebp]
	mov	edx, DWORD PTR _AlphaAccumulator$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _HighIndex$10[ebp]
	mov	edx, DWORD PTR _AlphaAccumulator$[ebp]
	add	eax, DWORD PTR [edx+ecx*4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _A$[ebp], al

; 323  :         R = (BYTE)((RedAccumulator[LowIndex] + RedAccumulator[HighIndex]) / 2);

	mov	eax, DWORD PTR _LowIndex$11[ebp]
	mov	ecx, DWORD PTR _RedAccumulator$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _HighIndex$10[ebp]
	mov	ecx, DWORD PTR _RedAccumulator$[ebp]
	add	eax, DWORD PTR [ecx+edx*4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _R$[ebp], al

; 324  :         G = (BYTE)((GreenAccumulator[LowIndex] + GreenAccumulator[HighIndex]) / 2);

	mov	edx, DWORD PTR _LowIndex$11[ebp]
	mov	eax, DWORD PTR _GreenAccumulator$[ebp]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	ecx, DWORD PTR _HighIndex$10[ebp]
	mov	edx, DWORD PTR _GreenAccumulator$[ebp]
	add	eax, DWORD PTR [edx+ecx*4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _G$[ebp], al

; 325  :         B = (BYTE)((BlueAccumulator[LowIndex] + BlueAccumulator[HighIndex]) / 2);

	mov	eax, DWORD PTR _LowIndex$11[ebp]
	mov	ecx, DWORD PTR _BlueAccumulator$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	edx, DWORD PTR _HighIndex$10[ebp]
	mov	ecx, DWORD PTR _BlueAccumulator$[ebp]
	add	eax, DWORD PTR [ecx+edx*4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	BYTE PTR _B$[ebp], al
$LN21@RegionMedi:

; 326  :     }
; 327  : 
; 328  :     *PackedMedianColor = (A << 24) | (R << 16) | (G << 8) | B;

	movzx	edx, BYTE PTR _A$[ebp]
	shl	edx, 24					; 00000018H
	movzx	eax, BYTE PTR _R$[ebp]
	shl	eax, 16					; 00000010H
	or	edx, eax
	movzx	ecx, BYTE PTR _G$[ebp]
	shl	ecx, 8
	or	edx, ecx
	movzx	eax, BYTE PTR _B$[ebp]
	or	edx, eax
	mov	ecx, DWORD PTR _PackedMedianColor$[ebp]
	mov	DWORD PTR [ecx], edx

; 329  : 
; 330  :     return ErrorStackPushReturn(Success, "RegionMedianColor");

	push	OFFSET $SG110552
	push	0
	call	_ErrorStackPushReturn@8
$LN1@RegionMedi:

; 331  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_RegionMedianColor@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\analyze.cpp
_TEXT	SEGMENT
_PixLum$1 = -56						; size = 8
_RowOffset$2 = -48					; size = 4
_PixelSize$ = -44					; size = 4
_Blue$ = -40						; size = 4
_Green$ = -36						; size = 4
_Red$ = -32						; size = 4
_Alpha$ = -28						; size = 4
_Row$3 = -24						; size = 4
_Column$4 = -20						; size = 4
_ColorCount$ = -16					; size = 4
_Index$5 = -12						; size = 4
_Src$ = -8						; size = 4
_B$ = -4						; size = 1
_G$ = -3						; size = 1
_R$ = -2						; size = 1
_A$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_RegionX1$ = 24						; size = 4
_RegionY1$ = 28						; size = 4
_RegionX2$ = 32						; size = 4
_RegionY2$ = 36						; size = 4
_PackedMeanColor$ = 40					; size = 4
_GetHighlight$ = 44					; size = 4
_BrightestLuminance$ = 48				; size = 4
_DarkestLuminance$ = 52					; size = 4
_BrightX$ = 56						; size = 4
_BrightY$ = 60						; size = 4
_DarkX$ = 64						; size = 4
_DarkY$ = 68						; size = 4
_RegionMeanColor@64 PROC

; 16   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 17   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RegionMean

; 18   :         return ErrorStackPushReturn(NullPointer, "RegionMeanColor");

	push	OFFSET $SG110250
	push	3
	call	_ErrorStackPushReturn@8
	jmp	$LN1@RegionMean
$LN8@RegionMean:

; 19   :     if (RegionX1 < 0 || RegionX2 < 0)

	cmp	DWORD PTR _RegionX1$[ebp], 0
	jl	SHORT $LN10@RegionMean
	cmp	DWORD PTR _RegionX2$[ebp], 0
	jge	SHORT $LN9@RegionMean
$LN10@RegionMean:

; 20   :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMeanColor", "Horizontal too small.");

	push	OFFSET $SG110253
	push	OFFSET $SG110254
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMean
$LN9@RegionMean:

; 21   :     if (RegionX1 >= Width || RegionX2 >= Width)

	mov	eax, DWORD PTR _RegionX1$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN12@RegionMean
	mov	ecx, DWORD PTR _RegionX2$[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jl	SHORT $LN11@RegionMean
$LN12@RegionMean:

; 22   :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMeanColor", "Horizontal too big.");

	push	OFFSET $SG110257
	push	OFFSET $SG110258
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMean
$LN11@RegionMean:

; 23   :     if (RegionY1 < 0 || RegionY2 < 0)

	cmp	DWORD PTR _RegionY1$[ebp], 0
	jl	SHORT $LN14@RegionMean
	cmp	DWORD PTR _RegionY2$[ebp], 0
	jge	SHORT $LN13@RegionMean
$LN14@RegionMean:

; 24   :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMeanColor", "Vertical too small.");

	push	OFFSET $SG110261
	push	OFFSET $SG110262
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMean
$LN13@RegionMean:

; 25   :     if (RegionY1 >= Height || RegionY2 >= Height)

	mov	edx, DWORD PTR _RegionY1$[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN16@RegionMean
	mov	eax, DWORD PTR _RegionY2$[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jl	SHORT $LN15@RegionMean
$LN16@RegionMean:

; 26   :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMeanColor", "Vertical too big");

	push	OFFSET $SG110265
	push	OFFSET $SG110266
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMean
$LN15@RegionMean:

; 27   :     if (RegionX1 >= RegionX2)

	mov	ecx, DWORD PTR _RegionX1$[ebp]
	cmp	ecx, DWORD PTR _RegionX2$[ebp]
	jl	SHORT $LN17@RegionMean

; 28   :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMeanColor", "Left greater than right.");

	push	OFFSET $SG110268
	push	OFFSET $SG110269
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMean
$LN17@RegionMean:

; 29   :     if (RegionY1 >= RegionY2)

	mov	edx, DWORD PTR _RegionY1$[ebp]
	cmp	edx, DWORD PTR _RegionY2$[ebp]
	jl	SHORT $LN18@RegionMean

; 30   :         return ErrorStackPushReturn2(IndexOutOfRange, "RegionMeanColor", "Top greater than bottom.");

	push	OFFSET $SG110271
	push	OFFSET $SG110272
	push	6
	call	_ErrorStackPushReturn2@12
	jmp	$LN1@RegionMean
$LN18@RegionMean:

; 31   : 
; 32   :     *BrightX = -1;

	mov	eax, DWORD PTR _BrightX$[ebp]
	mov	DWORD PTR [eax], -1

; 33   :     *BrightY = -1;

	mov	ecx, DWORD PTR _BrightY$[ebp]
	mov	DWORD PTR [ecx], -1

; 34   :     *DarkX = -1;

	mov	edx, DWORD PTR _DarkX$[ebp]
	mov	DWORD PTR [edx], -1

; 35   :     *DarkY = -1;

	mov	eax, DWORD PTR _DarkY$[ebp]
	mov	DWORD PTR [eax], -1

; 36   :     *BrightestLuminance = -1.0;

	mov	ecx, DWORD PTR _BrightestLuminance$[ebp]
	movsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR [ecx], xmm0

; 37   :     *DarkestLuminance = 1000.0;

	mov	edx, DWORD PTR _DarkestLuminance$[ebp]
	movsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR [edx], xmm0

; 38   : 
; 39   :     __int32 Alpha = 0;

	mov	DWORD PTR _Alpha$[ebp], 0

; 40   :     __int32 Red = 0;

	mov	DWORD PTR _Red$[ebp], 0

; 41   :     __int32 Green = 0;

	mov	DWORD PTR _Green$[ebp], 0

; 42   :     __int32 Blue = 0;

	mov	DWORD PTR _Blue$[ebp], 0

; 43   :     __int32 ColorCount = 0;

	mov	DWORD PTR _ColorCount$[ebp], 0

; 44   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 45   :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 46   : 
; 47   :     for (int Row = RegionY1; Row <= RegionY2; Row++)

	mov	ecx, DWORD PTR _RegionY1$[ebp]
	mov	DWORD PTR _Row$3[ebp], ecx
	jmp	SHORT $LN4@RegionMean
$LN2@RegionMean:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@RegionMean:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _RegionY2$[ebp]
	jg	$LN3@RegionMean

; 48   :     {
; 49   :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 50   :         for (int Column = RegionX1; Column <= RegionX2; Column++)

	mov	edx, DWORD PTR _RegionX1$[ebp]
	mov	DWORD PTR _Column$4[ebp], edx
	jmp	SHORT $LN7@RegionMean
$LN5@RegionMean:
	mov	eax, DWORD PTR _Column$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$4[ebp], eax
$LN7@RegionMean:
	mov	ecx, DWORD PTR _Column$4[ebp]
	cmp	ecx, DWORD PTR _RegionX2$[ebp]
	jg	$LN6@RegionMean

; 51   :         {
; 52   :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$4[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], edx

; 53   :             Alpha += Src[Index + 3];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	add	ecx, DWORD PTR _Alpha$[ebp]
	mov	DWORD PTR _Alpha$[ebp], ecx

; 54   :             Red += Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx+2]
	add	eax, DWORD PTR _Red$[ebp]
	mov	DWORD PTR _Red$[ebp], eax

; 55   :             Green += Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	add	edx, DWORD PTR _Green$[ebp]
	mov	DWORD PTR _Green$[ebp], edx

; 56   :             Blue += Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _Blue$[ebp]
	mov	DWORD PTR _Blue$[ebp], ecx

; 57   :             ColorCount++;

	mov	edx, DWORD PTR _ColorCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _ColorCount$[ebp], edx

; 58   :             if (GetHighlight)

	cmp	DWORD PTR _GetHighlight$[ebp], 0
	je	SHORT $LN21@RegionMean

; 59   :             {
; 60   :                 double PixLum = GetPixelLuminance(Src[Index + 2], Src[Index + 1], Src[Index + 0]);

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	call	_GetPixelLuminance@12
	fstp	QWORD PTR _PixLum$1[ebp]

; 61   :                 if (PixLum > *BrightestLuminance)

	mov	eax, DWORD PTR _BrightestLuminance$[ebp]
	movsd	xmm0, QWORD PTR _PixLum$1[ebp]
	comisd	xmm0, QWORD PTR [eax]
	jbe	SHORT $LN20@RegionMean

; 62   :                 {
; 63   :                     *BrightestLuminance = PixLum;

	mov	ecx, DWORD PTR _BrightestLuminance$[ebp]
	movsd	xmm0, QWORD PTR _PixLum$1[ebp]
	movsd	QWORD PTR [ecx], xmm0

; 64   :                     *BrightX = Column;

	mov	edx, DWORD PTR _BrightX$[ebp]
	mov	eax, DWORD PTR _Column$4[ebp]
	mov	DWORD PTR [edx], eax

; 65   :                     *BrightY = Row;

	mov	ecx, DWORD PTR _BrightY$[ebp]
	mov	edx, DWORD PTR _Row$3[ebp]
	mov	DWORD PTR [ecx], edx
$LN20@RegionMean:

; 66   :                 }
; 67   :                 if (PixLum < *DarkestLuminance)

	mov	eax, DWORD PTR _DarkestLuminance$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	comisd	xmm0, QWORD PTR _PixLum$1[ebp]
	jbe	SHORT $LN21@RegionMean

; 68   :                 {
; 69   :                     *DarkestLuminance = PixLum;

	mov	ecx, DWORD PTR _DarkestLuminance$[ebp]
	movsd	xmm0, QWORD PTR _PixLum$1[ebp]
	movsd	QWORD PTR [ecx], xmm0

; 70   :                     *DarkX = Column;

	mov	edx, DWORD PTR _DarkX$[ebp]
	mov	eax, DWORD PTR _Column$4[ebp]
	mov	DWORD PTR [edx], eax

; 71   :                     *DarkY = Row;

	mov	ecx, DWORD PTR _DarkY$[ebp]
	mov	edx, DWORD PTR _Row$3[ebp]
	mov	DWORD PTR [ecx], edx
$LN21@RegionMean:

; 72   :                 }
; 73   :             }
; 74   :         }

	jmp	$LN5@RegionMean
$LN6@RegionMean:

; 75   :     }

	jmp	$LN2@RegionMean
$LN3@RegionMean:

; 76   : 
; 77   :     if (ColorCount < 1)

	cmp	DWORD PTR _ColorCount$[ebp], 1
	jge	SHORT $LN22@RegionMean

; 78   :         return NoPixelsSelected;

	mov	eax, 20					; 00000014H
	jmp	SHORT $LN1@RegionMean
$LN22@RegionMean:

; 79   : 
; 80   :     BYTE A = (BYTE)(Alpha / ColorCount);

	mov	eax, DWORD PTR _Alpha$[ebp]
	cdq
	idiv	DWORD PTR _ColorCount$[ebp]
	mov	BYTE PTR _A$[ebp], al

; 81   :     BYTE R = (BYTE)(Red / ColorCount);

	mov	eax, DWORD PTR _Red$[ebp]
	cdq
	idiv	DWORD PTR _ColorCount$[ebp]
	mov	BYTE PTR _R$[ebp], al

; 82   :     BYTE G = (BYTE)(Green / ColorCount);

	mov	eax, DWORD PTR _Green$[ebp]
	cdq
	idiv	DWORD PTR _ColorCount$[ebp]
	mov	BYTE PTR _G$[ebp], al

; 83   :     BYTE B = (BYTE)(Blue / ColorCount);

	mov	eax, DWORD PTR _Blue$[ebp]
	cdq
	idiv	DWORD PTR _ColorCount$[ebp]
	mov	BYTE PTR _B$[ebp], al

; 84   : 
; 85   :     *PackedMeanColor = (A << 24) | (R << 16) | (G << 8) | B;

	movzx	eax, BYTE PTR _A$[ebp]
	shl	eax, 24					; 00000018H
	movzx	ecx, BYTE PTR _R$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	movzx	edx, BYTE PTR _G$[ebp]
	shl	edx, 8
	or	eax, edx
	movzx	ecx, BYTE PTR _B$[ebp]
	or	eax, ecx
	mov	edx, DWORD PTR _PackedMeanColor$[ebp]
	mov	DWORD PTR [edx], eax

; 86   : 
; 87   :     return ErrorStackPushReturn(Success, "RegionMeanColor");

	push	OFFSET $SG110277
	push	0
	call	_ErrorStackPushReturn@8
$LN1@RegionMean:

; 88   : }

	mov	esp, ebp
	pop	ebp
	ret	64					; 00000040H
_RegionMeanColor@64 ENDP
_TEXT	ENDS
END
