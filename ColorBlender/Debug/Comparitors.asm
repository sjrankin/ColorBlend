; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Comparitors.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_ImageDeltaComparisonRegion@40
PUBLIC	_ImageDeltaComparison@24
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\comparitors.cpp
_TEXT	SEGMENT
_Image1$ = 8						; size = 4
_Image2$ = 12						; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_Stride$ = 24						; size = 4
_MismatchIndex$ = 28					; size = 4
_ImageDeltaComparison@24 PROC

; 74   : {

	push	ebp
	mov	ebp, esp

; 75   :     return ImageDeltaComparisonRegion(Image1, Image2, Width, Height, Stride, 0, 0, Width - 1, Height - 1, MismatchIndex);

	mov	eax, DWORD PTR _MismatchIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	sub	edx, 1
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _Stride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Width$[ebp]
	push	edx
	mov	eax, DWORD PTR _Image2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Image1$[ebp]
	push	ecx
	call	_ImageDeltaComparisonRegion@40

; 76   : }

	pop	ebp
	ret	24					; 00000018H
_ImageDeltaComparison@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\comparitors.cpp
_TEXT	SEGMENT
_Img2$ = -24						; size = 4
_Img1$ = -20						; size = 4
_RowOffset$1 = -16					; size = 4
_Index$2 = -12						; size = 4
_Column$3 = -8						; size = 4
_Row$4 = -4						; size = 4
_Image1$ = 8						; size = 4
_Image2$ = 12						; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_Stride$ = 24						; size = 4
_Left$ = 28						; size = 4
_Top$ = 32						; size = 4
_Right$ = 36						; size = 4
_Bottom$ = 40						; size = 4
_MismatchIndex$ = 44					; size = 4
_ImageDeltaComparisonRegion@40 PROC

; 26   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 27   :     if (Image1 == NULL)

	cmp	DWORD PTR _Image1$[ebp], 0
	jne	SHORT $LN8@ImageDelta

; 28   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageDelta
$LN8@ImageDelta:

; 29   :     if (Image2 == NULL)

	cmp	DWORD PTR _Image2$[ebp], 0
	jne	SHORT $LN9@ImageDelta

; 30   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageDelta
$LN9@ImageDelta:

; 31   :     if (MismatchIndex == NULL)

	cmp	DWORD PTR _MismatchIndex$[ebp], 0
	jne	SHORT $LN10@ImageDelta

; 32   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageDelta
$LN10@ImageDelta:

; 33   :     if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN11@ImageDelta

; 34   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ImageDelta
$LN11@ImageDelta:

; 35   :     if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN12@ImageDelta

; 36   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ImageDelta
$LN12@ImageDelta:

; 37   :     if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN13@ImageDelta

; 38   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ImageDelta
$LN13@ImageDelta:

; 39   :     if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN14@ImageDelta

; 40   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ImageDelta
$LN14@ImageDelta:

; 41   : 
; 42   :     *MismatchIndex = UINT32_MAX;

	mov	edx, DWORD PTR _MismatchIndex$[ebp]
	mov	DWORD PTR [edx], -1

; 43   :     BYTE *Img1 = (BYTE *)Image1;

	mov	eax, DWORD PTR _Image1$[ebp]
	mov	DWORD PTR _Img1$[ebp], eax

; 44   :     BYTE *Img2 = (BYTE *)Image2;

	mov	ecx, DWORD PTR _Image2$[ebp]
	mov	DWORD PTR _Img2$[ebp], ecx

; 45   : 
; 46   :     for (int Row = Top; Row <= Bottom; Row++)

	mov	edx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$4[ebp], edx
	jmp	SHORT $LN4@ImageDelta
$LN2@ImageDelta:
	mov	eax, DWORD PTR _Row$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$4[ebp], eax
$LN4@ImageDelta:
	mov	ecx, DWORD PTR _Row$4[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN3@ImageDelta

; 47   :     {
; 48   :         int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$4[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 49   :         for (int Column = Left; Column <= Right; Column++)

	mov	eax, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$3[ebp], eax
	jmp	SHORT $LN7@ImageDelta
$LN5@ImageDelta:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@ImageDelta:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	SHORT $LN6@ImageDelta

; 50   :         {
; 51   :             int Index = RowOffset + Column;

	mov	eax, DWORD PTR _RowOffset$1[ebp]
	add	eax, DWORD PTR _Column$3[ebp]
	mov	DWORD PTR _Index$2[ebp], eax

; 52   :             if (Img1[Index] != Img2[Index])

	mov	ecx, DWORD PTR _Img1$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _Img2$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	je	SHORT $LN15@ImageDelta

; 53   :             {
; 54   :                 *MismatchIndex = Index;

	mov	edx, DWORD PTR _MismatchIndex$[ebp]
	mov	eax, DWORD PTR _Index$2[ebp]
	mov	DWORD PTR [edx], eax

; 55   :                 return ImageMismatch;

	mov	eax, 15					; 0000000fH
	jmp	SHORT $LN1@ImageDelta
$LN15@ImageDelta:

; 56   :             }
; 57   :         }

	jmp	SHORT $LN5@ImageDelta
$LN6@ImageDelta:

; 58   :     }

	jmp	SHORT $LN2@ImageDelta
$LN3@ImageDelta:

; 59   : 
; 60   :     return ImagesMatch;

	mov	eax, 16					; 00000010H
$LN1@ImageDelta:

; 61   : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_ImageDeltaComparisonRegion@40 ENDP
_TEXT	ENDS
END
