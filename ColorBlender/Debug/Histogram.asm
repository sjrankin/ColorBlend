; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Histogram.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_CreateHistogramRegion@72
PUBLIC	_CreateHistogram@56
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4070000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__fltused:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@4070000000000000
CONST	SEGMENT
__real@4070000000000000 DQ 04070000000000000r	; 256
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\histogram.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_BinCount$ = 24						; size = 4
_RawRed$ = 28						; size = 4
_PercentRed$ = 32					; size = 4
_RedCount$ = 36						; size = 4
_RawGreen$ = 40						; size = 4
_PercentGreen$ = 44					; size = 4
_GreenCount$ = 48					; size = 4
_RawBlue$ = 52						; size = 4
_PercentBlue$ = 56					; size = 4
_BlueCount$ = 60					; size = 4
_CreateHistogram@56 PROC

; 148  : {

	push	ebp
	mov	ebp, esp

; 149  :     return CreateHistogramRegion(Source,  SourceWidth, SourceHeight, SourceStride, BinCount,

	mov	eax, DWORD PTR _SourceHeight$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _SourceWidth$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _BlueCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _PercentBlue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RawBlue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _GreenCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _PercentGreen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RawGreen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _RedCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _PercentRed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _RawRed$[ebp]
	push	ecx
	mov	edx, DWORD PTR _BinCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _SourceStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SourceHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_CreateHistogramRegion@72

; 150  :         RawRed, PercentRed, RedCount,
; 151  :         RawGreen, PercentGreen, GreenCount,
; 152  :         RawBlue, PercentBlue, BlueCount,
; 153  :         0, 0, SourceWidth - 1, SourceHeight - 1);
; 154  : }

	pop	ebp
	ret	56					; 00000038H
_CreateHistogram@56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\histogram.cpp
_TEXT	SEGMENT
tv249 = -144						; size = 8
tv240 = -136						; size = 8
tv231 = -128						; size = 8
_BinDivisor$ = -120					; size = 8
_RowOffset$1 = -112					; size = 4
_PixelSize$ = -108					; size = 4
_BluePercent$ = -104					; size = 4
tv373 = -100						; size = 4
tv368 = -96						; size = 4
_GreenPercent$ = -92					; size = 4
tv357 = -88						; size = 4
tv352 = -84						; size = 4
_RedPercent$ = -80					; size = 4
tv341 = -76						; size = 4
tv336 = -72						; size = 4
_BIndex$2 = -68						; size = 4
_GIndex$3 = -64						; size = 4
_RIndex$4 = -60						; size = 4
_Index$5 = -56						; size = 4
_Buffer$ = -52						; size = 4
_Column$6 = -48						; size = 4
_Row$7 = -44						; size = 4
_TotalBlue$ = -40					; size = 4
_TotalGreen$ = -36					; size = 4
_TotalRed$ = -32					; size = 4
_Blues$ = -28						; size = 4
_Greens$ = -24						; size = 4
_Reds$ = -20						; size = 4
_i$8 = -16						; size = 4
_B$9 = -11						; size = 1
_G$10 = -10						; size = 1
_R$11 = -9						; size = 1
_i$12 = -8						; size = 4
_i$13 = -4						; size = 4
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_BinCount$ = 24						; size = 4
_RawRed$ = 28						; size = 4
_PercentRed$ = 32					; size = 4
_RedCount$ = 36						; size = 4
_RawGreen$ = 40						; size = 4
_PercentGreen$ = 44					; size = 4
_GreenCount$ = 48					; size = 4
_RawBlue$ = 52						; size = 4
_PercentBlue$ = 56					; size = 4
_BlueCount$ = 60					; size = 4
_Left$ = 64						; size = 4
_Top$ = 68						; size = 4
_Right$ = 72						; size = 4
_Bottom$ = 76						; size = 4
_CreateHistogramRegion@72 PROC

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H

; 38   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN17@CreateHist

; 39   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CreateHist
$LN17@CreateHist:

; 40   :     if ((RawRed == NULL) || (PercentRed == NULL))

	cmp	DWORD PTR _RawRed$[ebp], 0
	je	SHORT $LN19@CreateHist
	cmp	DWORD PTR _PercentRed$[ebp], 0
	jne	SHORT $LN18@CreateHist
$LN19@CreateHist:

; 41   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CreateHist
$LN18@CreateHist:

; 42   :     if ((RawGreen == NULL) || (PercentGreen == NULL))

	cmp	DWORD PTR _RawGreen$[ebp], 0
	je	SHORT $LN21@CreateHist
	cmp	DWORD PTR _PercentGreen$[ebp], 0
	jne	SHORT $LN20@CreateHist
$LN21@CreateHist:

; 43   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CreateHist
$LN20@CreateHist:

; 44   :     if ((RawBlue == NULL) || (PercentBlue == NULL))

	cmp	DWORD PTR _RawBlue$[ebp], 0
	je	SHORT $LN23@CreateHist
	cmp	DWORD PTR _PercentBlue$[ebp], 0
	jne	SHORT $LN22@CreateHist
$LN23@CreateHist:

; 45   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CreateHist
$LN22@CreateHist:

; 46   :     if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN24@CreateHist

; 47   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CreateHist
$LN24@CreateHist:

; 48   :     if (Right >= SourceWidth)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jl	SHORT $LN25@CreateHist

; 49   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CreateHist
$LN25@CreateHist:

; 50   :     if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN26@CreateHist

; 51   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CreateHist
$LN26@CreateHist:

; 52   :     if (Bottom >= SourceHeight)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _SourceHeight$[ebp]
	jl	SHORT $LN27@CreateHist

; 53   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@CreateHist
$LN27@CreateHist:

; 54   : 
; 55   :     //Clamp the bin count.
; 56   :     if (BinCount < 8)

	cmp	DWORD PTR _BinCount$[ebp], 8
	jge	SHORT $LN28@CreateHist

; 57   :         BinCount = 8;

	mov	DWORD PTR _BinCount$[ebp], 8
$LN28@CreateHist:

; 58   :     if (BinCount > 256)

	cmp	DWORD PTR _BinCount$[ebp], 256		; 00000100H
	jle	SHORT $LN29@CreateHist

; 59   :         BinCount = 256;

	mov	DWORD PTR _BinCount$[ebp], 256		; 00000100H
$LN29@CreateHist:

; 60   : 
; 61   :     BYTE *Buffer = (BYTE *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Buffer$[ebp], edx

; 62   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 63   :     UINT32 *Reds = (UINT32 *)RawRed;

	mov	eax, DWORD PTR _RawRed$[ebp]
	mov	DWORD PTR _Reds$[ebp], eax

; 64   :     double *RedPercent = (double *)PercentRed;

	mov	ecx, DWORD PTR _PercentRed$[ebp]
	mov	DWORD PTR _RedPercent$[ebp], ecx

; 65   :     UINT32 *Greens = (UINT32 *)RawGreen;

	mov	edx, DWORD PTR _RawGreen$[ebp]
	mov	DWORD PTR _Greens$[ebp], edx

; 66   :     double *GreenPercent = (double *)PercentGreen;

	mov	eax, DWORD PTR _PercentGreen$[ebp]
	mov	DWORD PTR _GreenPercent$[ebp], eax

; 67   :     UINT32 *Blues = (UINT32 *)RawBlue;

	mov	ecx, DWORD PTR _RawBlue$[ebp]
	mov	DWORD PTR _Blues$[ebp], ecx

; 68   :     double *BluePercent = (double *)PercentBlue;

	mov	edx, DWORD PTR _PercentBlue$[ebp]
	mov	DWORD PTR _BluePercent$[ebp], edx

; 69   :     UINT32 TotalRed = 0;

	mov	DWORD PTR _TotalRed$[ebp], 0

; 70   :     UINT32 TotalGreen = 0;

	mov	DWORD PTR _TotalGreen$[ebp], 0

; 71   :     UINT32 TotalBlue = 0;

	mov	DWORD PTR _TotalBlue$[ebp], 0

; 72   : 
; 73   :     for (int i = 0; i < BinCount; i++)

	mov	DWORD PTR _i$13[ebp], 0
	jmp	SHORT $LN4@CreateHist
$LN2@CreateHist:
	mov	eax, DWORD PTR _i$13[ebp]
	add	eax, 1
	mov	DWORD PTR _i$13[ebp], eax
$LN4@CreateHist:
	mov	ecx, DWORD PTR _i$13[ebp]
	cmp	ecx, DWORD PTR _BinCount$[ebp]
	jge	SHORT $LN3@CreateHist

; 74   :     {
; 75   :         Reds[i] = Greens[i] = Blues[i] = 0;

	mov	edx, DWORD PTR _i$13[ebp]
	mov	eax, DWORD PTR _Blues$[ebp]
	mov	DWORD PTR [eax+edx*4], 0
	mov	ecx, DWORD PTR _i$13[ebp]
	mov	edx, DWORD PTR _Greens$[ebp]
	mov	DWORD PTR [edx+ecx*4], 0
	mov	eax, DWORD PTR _i$13[ebp]
	mov	ecx, DWORD PTR _Reds$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 76   :         RedPercent[i] = GreenPercent[i] = BluePercent[i] = 0.0;

	mov	edx, DWORD PTR _i$13[ebp]
	mov	eax, DWORD PTR _BluePercent$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [eax+edx*8], xmm0
	mov	ecx, DWORD PTR _i$13[ebp]
	mov	edx, DWORD PTR _GreenPercent$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [edx+ecx*8], xmm0
	mov	eax, DWORD PTR _i$13[ebp]
	mov	ecx, DWORD PTR _RedPercent$[ebp]
	xorps	xmm0, xmm0
	movsd	QWORD PTR [ecx+eax*8], xmm0

; 77   :     }

	jmp	SHORT $LN2@CreateHist
$LN3@CreateHist:

; 78   : 
; 79   :     //double IndexDivisor = BinCount;//(double)MaxBinCount / (double)BinCount;
; 80   :     double BinDivisor = 1.0 / ((double)BinCount / (double)MaxBinCount);

	cvtsi2sd xmm0, DWORD PTR _BinCount$[ebp]
	divsd	xmm0, QWORD PTR __real@4070000000000000
	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	divsd	xmm1, xmm0
	movsd	QWORD PTR _BinDivisor$[ebp], xmm1

; 81   : 
; 82   :     for (int Row = Top; Row <= Bottom; Row++)

	mov	edx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$7[ebp], edx
	jmp	SHORT $LN7@CreateHist
$LN5@CreateHist:
	mov	eax, DWORD PTR _Row$7[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$7[ebp], eax
$LN7@CreateHist:
	mov	ecx, DWORD PTR _Row$7[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	$LN6@CreateHist

; 83   :     {
; 84   :         int RowOffset = Row * SourceStride;

	mov	edx, DWORD PTR _Row$7[ebp]
	imul	edx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 85   :         for (int Column = Left; Column <= Right; Column++)

	mov	eax, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$6[ebp], eax
	jmp	SHORT $LN10@CreateHist
$LN8@CreateHist:
	mov	ecx, DWORD PTR _Column$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$6[ebp], ecx
$LN10@CreateHist:
	mov	edx, DWORD PTR _Column$6[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	$LN9@CreateHist

; 86   :         {
; 87   :             int Index = RowOffset + (Column * PixelSize);

	mov	eax, DWORD PTR _Column$6[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$5[ebp], eax

; 88   :             BYTE R = Buffer[Index + 2];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$11[ebp], dl

; 89   :             BYTE G = Buffer[Index + 1];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$10[ebp], cl

; 90   :             BYTE B = Buffer[Index + 0];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$9[ebp], al

; 91   :             //Get the bin indices.
; 92   :             int RIndex = (int)(R / BinDivisor);

	movzx	ecx, BYTE PTR _R$11[ebp]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR _BinDivisor$[ebp]
	cvttsd2si edx, xmm0
	mov	DWORD PTR _RIndex$4[ebp], edx

; 93   :             int GIndex = (int)(G / BinDivisor);

	movzx	eax, BYTE PTR _G$10[ebp]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR _BinDivisor$[ebp]
	cvttsd2si ecx, xmm0
	mov	DWORD PTR _GIndex$3[ebp], ecx

; 94   :             int BIndex = (int)(B / BinDivisor);

	movzx	edx, BYTE PTR _B$9[ebp]
	cvtsi2sd xmm0, edx
	divsd	xmm0, QWORD PTR _BinDivisor$[ebp]
	cvttsd2si eax, xmm0
	mov	DWORD PTR _BIndex$2[ebp], eax

; 95   :             //Accumulate pixel counts.
; 96   :             Reds[RIndex]++;

	mov	ecx, DWORD PTR _RIndex$4[ebp]
	mov	edx, DWORD PTR _Reds$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	add	eax, 1
	mov	ecx, DWORD PTR _RIndex$4[ebp]
	mov	edx, DWORD PTR _Reds$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 97   :             Greens[GIndex]++;

	mov	eax, DWORD PTR _GIndex$3[ebp]
	mov	ecx, DWORD PTR _Greens$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	add	edx, 1
	mov	eax, DWORD PTR _GIndex$3[ebp]
	mov	ecx, DWORD PTR _Greens$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 98   :             Blues[BIndex]++;

	mov	edx, DWORD PTR _BIndex$2[ebp]
	mov	eax, DWORD PTR _Blues$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, 1
	mov	edx, DWORD PTR _BIndex$2[ebp]
	mov	eax, DWORD PTR _Blues$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 99   :         }

	jmp	$LN8@CreateHist
$LN9@CreateHist:

; 100  :     }

	jmp	$LN5@CreateHist
$LN6@CreateHist:

; 101  : 
; 102  :     //Create non-0 pixel counts.
; 103  :     for (int i = 0; i < BinCount; i++)

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN13@CreateHist
$LN11@CreateHist:
	mov	ecx, DWORD PTR _i$8[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$8[ebp], ecx
$LN13@CreateHist:
	mov	edx, DWORD PTR _i$8[ebp]
	cmp	edx, DWORD PTR _BinCount$[ebp]
	jge	SHORT $LN12@CreateHist

; 104  :     {
; 105  :         TotalRed += Reds[i];

	mov	eax, DWORD PTR _i$8[ebp]
	mov	ecx, DWORD PTR _Reds$[ebp]
	mov	edx, DWORD PTR _TotalRed$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _TotalRed$[ebp], edx

; 106  :         TotalGreen += Greens[i];

	mov	eax, DWORD PTR _i$8[ebp]
	mov	ecx, DWORD PTR _Greens$[ebp]
	mov	edx, DWORD PTR _TotalGreen$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _TotalGreen$[ebp], edx

; 107  :         TotalBlue += Blues[i];

	mov	eax, DWORD PTR _i$8[ebp]
	mov	ecx, DWORD PTR _Blues$[ebp]
	mov	edx, DWORD PTR _TotalBlue$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _TotalBlue$[ebp], edx

; 108  :     }

	jmp	SHORT $LN11@CreateHist
$LN12@CreateHist:

; 109  : 
; 110  :     //Generate percents per pixel.
; 111  :     for (int i = 0; i < BinCount; i++)

	mov	DWORD PTR _i$12[ebp], 0
	jmp	SHORT $LN16@CreateHist
$LN14@CreateHist:
	mov	eax, DWORD PTR _i$12[ebp]
	add	eax, 1
	mov	DWORD PTR _i$12[ebp], eax
$LN16@CreateHist:
	mov	ecx, DWORD PTR _i$12[ebp]
	cmp	ecx, DWORD PTR _BinCount$[ebp]
	jge	$LN15@CreateHist

; 112  :     {
; 113  :         RedPercent[i] = TotalRed == 0 ? 0.0 : (double)Reds[i] / (double)TotalRed;

	cmp	DWORD PTR _TotalRed$[ebp], 0
	jne	SHORT $LN31@CreateHist
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv231[ebp], xmm0
	jmp	SHORT $LN32@CreateHist
$LN31@CreateHist:
	mov	edx, DWORD PTR _i$12[ebp]
	mov	eax, DWORD PTR _Reds$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv336[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv336[ebp]
	mov	edx, DWORD PTR tv336[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	mov	eax, DWORD PTR _TotalRed$[ebp]
	mov	DWORD PTR tv341[ebp], eax
	cvtsi2sd xmm1, DWORD PTR tv341[ebp]
	mov	ecx, DWORD PTR tv341[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	divsd	xmm0, xmm1
	movsd	QWORD PTR tv231[ebp], xmm0
$LN32@CreateHist:
	mov	edx, DWORD PTR _i$12[ebp]
	mov	eax, DWORD PTR _RedPercent$[ebp]
	movsd	xmm0, QWORD PTR tv231[ebp]
	movsd	QWORD PTR [eax+edx*8], xmm0

; 114  :         GreenPercent[i] = TotalGreen == 0 ? 0.0 : (double)Greens[i] / (double)TotalGreen;

	cmp	DWORD PTR _TotalGreen$[ebp], 0
	jne	SHORT $LN33@CreateHist
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv240[ebp], xmm0
	jmp	SHORT $LN34@CreateHist
$LN33@CreateHist:
	mov	ecx, DWORD PTR _i$12[ebp]
	mov	edx, DWORD PTR _Greens$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR tv352[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv352[ebp]
	mov	ecx, DWORD PTR tv352[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	mov	edx, DWORD PTR _TotalGreen$[ebp]
	mov	DWORD PTR tv357[ebp], edx
	cvtsi2sd xmm1, DWORD PTR tv357[ebp]
	mov	eax, DWORD PTR tv357[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	divsd	xmm0, xmm1
	movsd	QWORD PTR tv240[ebp], xmm0
$LN34@CreateHist:
	mov	ecx, DWORD PTR _i$12[ebp]
	mov	edx, DWORD PTR _GreenPercent$[ebp]
	movsd	xmm0, QWORD PTR tv240[ebp]
	movsd	QWORD PTR [edx+ecx*8], xmm0

; 115  :         BluePercent[i] = TotalBlue == 0 ? 0.0 : (double)Blues[i] / (double)TotalBlue;

	cmp	DWORD PTR _TotalBlue$[ebp], 0
	jne	SHORT $LN35@CreateHist
	xorps	xmm0, xmm0
	movsd	QWORD PTR tv249[ebp], xmm0
	jmp	SHORT $LN36@CreateHist
$LN35@CreateHist:
	mov	eax, DWORD PTR _i$12[ebp]
	mov	ecx, DWORD PTR _Blues$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv368[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv368[ebp]
	mov	eax, DWORD PTR tv368[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	mov	ecx, DWORD PTR _TotalBlue$[ebp]
	mov	DWORD PTR tv373[ebp], ecx
	cvtsi2sd xmm1, DWORD PTR tv373[ebp]
	mov	edx, DWORD PTR tv373[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	divsd	xmm0, xmm1
	movsd	QWORD PTR tv249[ebp], xmm0
$LN36@CreateHist:
	mov	eax, DWORD PTR _i$12[ebp]
	mov	ecx, DWORD PTR _BluePercent$[ebp]
	movsd	xmm0, QWORD PTR tv249[ebp]
	movsd	QWORD PTR [ecx+eax*8], xmm0

; 116  :     }

	jmp	$LN14@CreateHist
$LN15@CreateHist:

; 117  : 
; 118  :     RedCount = TotalRed;

	mov	edx, DWORD PTR _RedCount$[ebp]
	mov	eax, DWORD PTR _TotalRed$[ebp]
	mov	DWORD PTR [edx], eax

; 119  :     GreenCount = TotalGreen;

	mov	ecx, DWORD PTR _GreenCount$[ebp]
	mov	edx, DWORD PTR _TotalGreen$[ebp]
	mov	DWORD PTR [ecx], edx

; 120  :     BlueCount = TotalBlue;

	mov	eax, DWORD PTR _BlueCount$[ebp]
	mov	ecx, DWORD PTR _TotalBlue$[ebp]
	mov	DWORD PTR [eax], ecx

; 121  : 
; 122  :     return Success;

	xor	eax, eax
$LN1@CreateHist:

; 123  : }

	mov	esp, ebp
	pop	ebp
	ret	72					; 00000048H
_CreateHistogramRegion@72 ENDP
_TEXT	ENDS
END
