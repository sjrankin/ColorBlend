; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Rotations.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_RotateBufferRight@32
PUBLIC	_ImageRotateRightBy@28
PUBLIC	_ImageRotateRight90@24
PUBLIC	_ImageRotateRight180@24
PUBLIC	_ImageRotateRight270@24
PUBLIC	_CardinalImageRotate@36
PUBLIC	_ImageRotate@44
PUBLIC	_ImageRotate90@24
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3ff921fb54524550
PUBLIC	__real@4000000000000000
PUBLIC	__real@4056800000000000
PUBLIC	__real@c056800000000000
EXTRN	__imp__roundf:PROC
EXTRN	_ClearBuffer2@20:PROC
EXTRN	__libm_sse2_cos_precise:PROC
EXTRN	__libm_sse2_sin_precise:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@c056800000000000
CONST	SEGMENT
__real@c056800000000000 DQ 0c056800000000000r	; -90
CONST	ENDS
;	COMDAT __real@4056800000000000
CONST	SEGMENT
__real@4056800000000000 DQ 04056800000000000r	; 90
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff921fb54524550
CONST	SEGMENT
__real@3ff921fb54524550 DQ 03ff921fb54524550r	; 1.5708
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\rotations.cpp
_TEXT	SEGMENT
_RowSin90$1 = -104					; size = 8
_RowCos90$2 = -96					; size = 8
_HalfHeight$ = -88					; size = 8
_HalfWidth$ = -80					; size = 8
_Radians90$ = -72					; size = 8
_Cos90$ = -64						; size = 8
_Sin90$ = -56						; size = 8
_NewX$3 = -48						; size = 8
_NewY$4 = -40						; size = 8
_Src$ = -32						; size = 4
_SourceIndex$5 = -28					; size = 4
_Dest$ = -24						; size = 4
_DestIndex$6 = -20					; size = 4
tv188 = -16						; size = 4
tv183 = -12						; size = 4
_OldColumn$7 = -8					; size = 4
_OldRow$8 = -4						; size = 4
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_Destination$ = 20					; size = 4
_DestinationWidth$ = 24					; size = 4
_DestinationHeight$ = 28				; size = 4
_ImageRotate90@24 PROC

; 281  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	esi

; 282  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ImageRotat

; 283  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageRotat
$LN8@ImageRotat:

; 284  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ImageRotat

; 285  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageRotat
$LN9@ImageRotat:

; 286  : 
; 287  : 	//Make sure the source image's width is the same as the destination image's height.
; 288  : 	if (SourceWidth != DestinationHeight)

	mov	eax, DWORD PTR _SourceWidth$[ebp]
	cmp	eax, DWORD PTR _DestinationHeight$[ebp]
	je	SHORT $LN10@ImageRotat

; 289  : 		return InvalidRegion;

	mov	eax, 21					; 00000015H
	jmp	$LN1@ImageRotat
$LN10@ImageRotat:

; 290  : 	//Make sure the source image's height is the same as the destination image's width.
; 291  : 	if (SourceHeight != DestinationWidth)

	mov	ecx, DWORD PTR _SourceHeight$[ebp]
	cmp	ecx, DWORD PTR _DestinationWidth$[ebp]
	je	SHORT $LN11@ImageRotat

; 292  : 		return InvalidRegion;

	mov	eax, 21					; 00000015H
	jmp	$LN1@ImageRotat
$LN11@ImageRotat:

; 293  : 
; 294  : 	UINT32 *Src = (UINT32 *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], edx

; 295  : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 296  : 
; 297  : //	double Radians90 = (90 * 3.1415) / 180.0;
; 298  : 	double Radians90 = 1.570796327;

	movsd	xmm0, QWORD PTR __real@3ff921fb54524550
	movsd	QWORD PTR _Radians90$[ebp], xmm0

; 299  : 	double Cos90 = cos(Radians90);

	movsd	xmm0, QWORD PTR _Radians90$[ebp]
	call	__libm_sse2_cos_precise
	movsd	QWORD PTR _Cos90$[ebp], xmm0

; 300  : 	double Sin90 = sin(Radians90);

	movsd	xmm0, QWORD PTR _Radians90$[ebp]
	call	__libm_sse2_sin_precise
	movsd	QWORD PTR _Sin90$[ebp], xmm0

; 301  : 	double HalfWidth = (double)(int)(SourceWidth / 2.0);

	cvtsi2sd xmm0, DWORD PTR _SourceWidth$[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si ecx, xmm0
	cvtsi2sd xmm0, ecx
	movsd	QWORD PTR _HalfWidth$[ebp], xmm0

; 302  : 	double HalfHeight = (double)(int)(SourceHeight / 2.0);

	cvtsi2sd xmm0, DWORD PTR _SourceHeight$[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si edx, xmm0
	cvtsi2sd xmm0, edx
	movsd	QWORD PTR _HalfHeight$[ebp], xmm0

; 303  : 
; 304  : 	for (int OldRow = 0; OldRow < SourceHeight; OldRow++)

	mov	DWORD PTR _OldRow$8[ebp], 0
	jmp	SHORT $LN4@ImageRotat
$LN2@ImageRotat:
	mov	eax, DWORD PTR _OldRow$8[ebp]
	add	eax, 1
	mov	DWORD PTR _OldRow$8[ebp], eax
$LN4@ImageRotat:
	mov	ecx, DWORD PTR _OldRow$8[ebp]
	cmp	ecx, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@ImageRotat

; 305  : 	{
; 306  : 		double RowCos90 = OldRow * Cos90;

	cvtsi2sd xmm0, DWORD PTR _OldRow$8[ebp]
	mulsd	xmm0, QWORD PTR _Cos90$[ebp]
	movsd	QWORD PTR _RowCos90$2[ebp], xmm0

; 307  : 		double RowSin90 = OldRow * Sin90;

	cvtsi2sd xmm0, DWORD PTR _OldRow$8[ebp]
	mulsd	xmm0, QWORD PTR _Sin90$[ebp]
	movsd	QWORD PTR _RowSin90$1[ebp], xmm0

; 308  : 		for (int OldColumn = 0; OldColumn < SourceWidth; OldColumn++)

	mov	DWORD PTR _OldColumn$7[ebp], 0
	jmp	SHORT $LN7@ImageRotat
$LN5@ImageRotat:
	mov	edx, DWORD PTR _OldColumn$7[ebp]
	add	edx, 1
	mov	DWORD PTR _OldColumn$7[ebp], edx
$LN7@ImageRotat:
	mov	eax, DWORD PTR _OldColumn$7[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@ImageRotat

; 309  : 		{
; 310  : 			int SourceIndex = OldColumn + (OldRow * SourceWidth);

	mov	ecx, DWORD PTR _OldRow$8[ebp]
	imul	ecx, DWORD PTR _SourceWidth$[ebp]
	add	ecx, DWORD PTR _OldColumn$7[ebp]
	mov	DWORD PTR _SourceIndex$5[ebp], ecx

; 311  : #if 0
; 312  : 			double NewX = (OldColumn * Cos90) - RowSin90;
; 313  : 			NewX = NewX + HalfWidth;
; 314  : 			NewX--;
; 315  : 			double NewY = (OldColumn * Sin90) + RowCos90;
; 316  : 			NewY = NewY + HalfHeight;
; 317  : 			NewY--;
; 318  : 			int DestIndex = ((int)NewY * DestinationWidth) + (int)NewX;
; 319  : #else
; 320  : 			double NewX = (OldColumn * Cos90) - (OldRow * Sin90);

	cvtsi2sd xmm0, DWORD PTR _OldColumn$7[ebp]
	mulsd	xmm0, QWORD PTR _Cos90$[ebp]
	cvtsi2sd xmm1, DWORD PTR _OldRow$8[ebp]
	mulsd	xmm1, QWORD PTR _Sin90$[ebp]
	subsd	xmm0, xmm1
	movsd	QWORD PTR _NewX$3[ebp], xmm0

; 321  : 			double NewY = (OldColumn * Sin90) + (OldRow * Cos90);

	cvtsi2sd xmm0, DWORD PTR _OldColumn$7[ebp]
	mulsd	xmm0, QWORD PTR _Sin90$[ebp]
	cvtsi2sd xmm1, DWORD PTR _OldRow$8[ebp]
	mulsd	xmm1, QWORD PTR _Cos90$[ebp]
	addsd	xmm0, xmm1
	movsd	QWORD PTR _NewY$4[ebp], xmm0

; 322  : 			NewX += HalfWidth;

	movsd	xmm0, QWORD PTR _NewX$3[ebp]
	addsd	xmm0, QWORD PTR _HalfWidth$[ebp]
	movsd	QWORD PTR _NewX$3[ebp], xmm0

; 323  : 			NewY += HalfHeight;

	movsd	xmm0, QWORD PTR _NewY$4[ebp]
	addsd	xmm0, QWORD PTR _HalfHeight$[ebp]
	movsd	QWORD PTR _NewY$4[ebp], xmm0

; 324  : 			NewX--;

	movsd	xmm0, QWORD PTR _NewX$3[ebp]
	subsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _NewX$3[ebp], xmm0

; 325  : 			NewY--;

	movsd	xmm0, QWORD PTR _NewY$4[ebp]
	subsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _NewY$4[ebp], xmm0

; 326  : 			NewX = (int)(roundf(NewX));

	cvtsd2ss xmm0, QWORD PTR _NewX$3[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR __imp__roundf
	add	esp, 4
	fstp	DWORD PTR tv183[ebp]
	movss	xmm0, DWORD PTR tv183[ebp]
	cvttss2si edx, xmm0
	cvtsi2sd xmm0, edx
	movsd	QWORD PTR _NewX$3[ebp], xmm0

; 327  : 			NewY = (int)(roundf(NewY));

	cvtsd2ss xmm0, QWORD PTR _NewY$4[ebp]
	push	ecx
	movss	DWORD PTR [esp], xmm0
	call	DWORD PTR __imp__roundf
	add	esp, 4
	fstp	DWORD PTR tv188[ebp]
	movss	xmm0, DWORD PTR tv188[ebp]
	cvttss2si eax, xmm0
	cvtsi2sd xmm0, eax
	movsd	QWORD PTR _NewY$4[ebp], xmm0

; 328  : 			UINT32 DestIndex = ((int)NewY * DestinationWidth) + (int)NewX;

	cvttsd2si ecx, QWORD PTR _NewY$4[ebp]
	imul	ecx, DWORD PTR _DestinationWidth$[ebp]
	cvttsd2si edx, QWORD PTR _NewX$3[ebp]
	add	ecx, edx
	mov	DWORD PTR _DestIndex$6[ebp], ecx

; 329  : #endif
; 330  : 			Dest[DestIndex] = Src[SourceIndex];

	mov	eax, DWORD PTR _DestIndex$6[ebp]
	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	edx, DWORD PTR _SourceIndex$5[ebp]
	mov	esi, DWORD PTR _Src$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 331  : 		}

	jmp	$LN5@ImageRotat
$LN6@ImageRotat:

; 332  : 	}

	jmp	$LN2@ImageRotat
$LN3@ImageRotat:

; 333  : 
; 334  : 	return Success;

	xor	eax, eax
$LN1@ImageRotat:

; 335  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_ImageRotate90@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\rotations.cpp
_TEXT	SEGMENT
_Src$ = -32						; size = 4
_SourceIndex$1 = -28					; size = 4
_DestIndex$2 = -24					; size = 4
_Dest$ = -20						; size = 4
_NewRow$ = -16						; size = 4
_OldColumn$3 = -12					; size = 4
_OldRow$4 = -8						; size = 4
_NewColumn$ = -4					; size = 4
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Destination$ = 24					; size = 4
_DestinationWidth$ = 28					; size = 4
_DestinationHeight$ = 32				; size = 4
_DestinationStride$ = 36				; size = 4
_Rotation$ = 40						; size = 8
_FillColor$ = 48					; size = 4
_ImageRotate@44 PROC

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 232  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ImageRotat

; 233  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageRotat
$LN8@ImageRotat:

; 234  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ImageRotat

; 235  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageRotat
$LN9@ImageRotat:

; 236  : 
; 237  : 	UINT32 *Src = (UINT32 *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 238  : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 239  : 
; 240  : 	ClearBuffer2(Dest, DestinationWidth, DestinationHeight, DestinationStride, FillColor);

	mov	edx, DWORD PTR _FillColor$[ebp]
	push	edx
	mov	eax, DWORD PTR _DestinationStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _DestinationHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DestinationWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Dest$[ebp]
	push	eax
	call	_ClearBuffer2@20

; 241  : 
; 242  : 	int NewRow = DestinationHeight - 1;

	mov	ecx, DWORD PTR _DestinationHeight$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _NewRow$[ebp], ecx

; 243  : 	int NewColumn = DestinationWidth - 1;

	mov	edx, DWORD PTR _DestinationWidth$[ebp]
	sub	edx, 1
	mov	DWORD PTR _NewColumn$[ebp], edx

; 244  : 	for (int OldRow = 0; OldRow < SourceHeight; OldRow++)

	mov	DWORD PTR _OldRow$4[ebp], 0
	jmp	SHORT $LN4@ImageRotat
$LN2@ImageRotat:
	mov	eax, DWORD PTR _OldRow$4[ebp]
	add	eax, 1
	mov	DWORD PTR _OldRow$4[ebp], eax
$LN4@ImageRotat:
	mov	ecx, DWORD PTR _OldRow$4[ebp]
	cmp	ecx, DWORD PTR _SourceHeight$[ebp]
	jge	SHORT $LN3@ImageRotat

; 245  : 	{
; 246  : 		for (int OldColumn = 0; OldColumn < SourceWidth; OldColumn++)

	mov	DWORD PTR _OldColumn$3[ebp], 0
	jmp	SHORT $LN7@ImageRotat
$LN5@ImageRotat:
	mov	edx, DWORD PTR _OldColumn$3[ebp]
	add	edx, 1
	mov	DWORD PTR _OldColumn$3[ebp], edx
$LN7@ImageRotat:
	mov	eax, DWORD PTR _OldColumn$3[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	SHORT $LN6@ImageRotat

; 247  : 		{
; 248  : 			int SourceIndex = OldColumn + (OldRow * SourceWidth);

	mov	ecx, DWORD PTR _OldRow$4[ebp]
	imul	ecx, DWORD PTR _SourceWidth$[ebp]
	add	ecx, DWORD PTR _OldColumn$3[ebp]
	mov	DWORD PTR _SourceIndex$1[ebp], ecx

; 249  : 			int DestIndex = NewColumn + (NewRow * DestinationWidth);

	mov	edx, DWORD PTR _NewRow$[ebp]
	imul	edx, DWORD PTR _DestinationWidth$[ebp]
	add	edx, DWORD PTR _NewColumn$[ebp]
	mov	DWORD PTR _DestIndex$2[ebp], edx

; 250  : 			Dest[DestIndex] = Src[SourceIndex];

	mov	eax, DWORD PTR _DestIndex$2[ebp]
	mov	ecx, DWORD PTR _Dest$[ebp]
	mov	edx, DWORD PTR _SourceIndex$1[ebp]
	mov	esi, DWORD PTR _Src$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4], edx

; 251  : 			NewColumn--;

	mov	eax, DWORD PTR _NewColumn$[ebp]
	sub	eax, 1
	mov	DWORD PTR _NewColumn$[ebp], eax

; 252  : 			if (NewColumn < 0)

	jns	SHORT $LN10@ImageRotat

; 253  : 			{
; 254  : 				NewColumn = DestinationWidth - 1;

	mov	ecx, DWORD PTR _DestinationWidth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _NewColumn$[ebp], ecx

; 255  : 				NewRow--;

	mov	edx, DWORD PTR _NewRow$[ebp]
	sub	edx, 1
	mov	DWORD PTR _NewRow$[ebp], edx

; 256  : 				if (NewRow < 0)

	jns	SHORT $LN10@ImageRotat

; 257  : 					return Success;

	xor	eax, eax
	jmp	SHORT $LN1@ImageRotat
$LN10@ImageRotat:

; 258  : 			}
; 259  : 		}

	jmp	SHORT $LN5@ImageRotat
$LN6@ImageRotat:

; 260  : 	}

	jmp	SHORT $LN2@ImageRotat
$LN3@ImageRotat:

; 261  : 
; 262  : 	return Success;

	xor	eax, eax
$LN1@ImageRotat:

; 263  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_ImageRotate@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\rotations.cpp
_TEXT	SEGMENT
tv67 = -8						; size = 8
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Destination$ = 24					; size = 4
_DestinationWidth$ = 28					; size = 4
_DestinationHeight$ = 32				; size = 4
_DestinationStride$ = 36				; size = 4
_RotateLeft$ = 40					; size = 4
_CardinalImageRotate@36 PROC

; 353  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 354  : 	return ImageRotate(Source, SourceWidth, SourceHeight, SourceStride, Destination, DestinationWidth,

	cmp	DWORD PTR _RotateLeft$[ebp], 0
	je	SHORT $LN3@CardinalIm
	movsd	xmm0, QWORD PTR __real@c056800000000000
	movsd	QWORD PTR tv67[ebp], xmm0
	jmp	SHORT $LN4@CardinalIm
$LN3@CardinalIm:
	movsd	xmm0, QWORD PTR __real@4056800000000000
	movsd	QWORD PTR tv67[ebp], xmm0
$LN4@CardinalIm:
	push	-1
	sub	esp, 8
	movsd	xmm0, QWORD PTR tv67[ebp]
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _DestinationStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _DestinationHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DestinationWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SourceStride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _SourceWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_ImageRotate@44

; 355  : 		DestinationHeight, DestinationStride, RotateLeft ? -90.0 : 90.0, 0xffffffff);
; 356  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_CardinalImageRotate@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\rotations.cpp
_TEXT	SEGMENT
_DestinationColumn$ = -44				; size = 4
_DestinationRow$ = -40					; size = 4
_Pixel$1 = -36						; size = 4
_Dest$ = -32						; size = 4
_DestinationIndex$2 = -28				; size = 4
_NewX$3 = -24						; size = 4
_NewY$4 = -20						; size = 4
_Src$ = -16						; size = 4
_SourceIndex$5 = -12					; size = 4
_SourceColumn$6 = -8					; size = 4
_SourceRow$7 = -4					; size = 4
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_Destination$ = 20					; size = 4
_DestinationWidth$ = 24					; size = 4
_DestinationHeight$ = 28				; size = 4
_ImageRotateRight270@24 PROC

; 126  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 127  : 	/*
; 128  : 	__asm
; 129  : 	{
; 130  : 		int 3
; 131  : 	}
; 132  : 	*/
; 133  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ImageRotat

; 134  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageRotat
$LN8@ImageRotat:

; 135  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ImageRotat

; 136  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageRotat
$LN9@ImageRotat:

; 137  : 
; 138  : 	if (SourceWidth != DestinationHeight)

	mov	eax, DWORD PTR _SourceWidth$[ebp]
	cmp	eax, DWORD PTR _DestinationHeight$[ebp]
	je	SHORT $LN10@ImageRotat

; 139  : 		return DimensionalMismatch;

	mov	eax, 28					; 0000001cH
	jmp	$LN1@ImageRotat
$LN10@ImageRotat:

; 140  : 	if (SourceHeight != DestinationWidth)

	mov	ecx, DWORD PTR _SourceHeight$[ebp]
	cmp	ecx, DWORD PTR _DestinationWidth$[ebp]
	je	SHORT $LN11@ImageRotat

; 141  : 		return DimensionalMismatch;

	mov	eax, 28					; 0000001cH
	jmp	$LN1@ImageRotat
$LN11@ImageRotat:

; 142  : 
; 143  : 	UINT32 *Src = (UINT32 *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], edx

; 144  : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 145  : 
; 146  : 	int DestinationRow = 0;

	mov	DWORD PTR _DestinationRow$[ebp], 0

; 147  : 	int DestinationColumn = DestinationWidth - 1;

	mov	ecx, DWORD PTR _DestinationWidth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _DestinationColumn$[ebp], ecx

; 148  : 
; 149  : 	for (int SourceRow = 0; SourceRow < SourceHeight; SourceRow++)

	mov	DWORD PTR _SourceRow$7[ebp], 0
	jmp	SHORT $LN4@ImageRotat
$LN2@ImageRotat:
	mov	edx, DWORD PTR _SourceRow$7[ebp]
	add	edx, 1
	mov	DWORD PTR _SourceRow$7[ebp], edx
$LN4@ImageRotat:
	mov	eax, DWORD PTR _SourceRow$7[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	SHORT $LN3@ImageRotat

; 150  : 	{
; 151  : 		for (int SourceColumn = 0; SourceColumn < SourceWidth; SourceColumn++)

	mov	DWORD PTR _SourceColumn$6[ebp], 0
	jmp	SHORT $LN7@ImageRotat
$LN5@ImageRotat:
	mov	ecx, DWORD PTR _SourceColumn$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _SourceColumn$6[ebp], ecx
$LN7@ImageRotat:
	mov	edx, DWORD PTR _SourceColumn$6[ebp]
	cmp	edx, DWORD PTR _SourceWidth$[ebp]
	jge	SHORT $LN6@ImageRotat

; 152  : 		{
; 153  : 			UINT32 SourceIndex = (SourceRow * SourceWidth) + SourceColumn;

	mov	eax, DWORD PTR _SourceRow$7[ebp]
	imul	eax, DWORD PTR _SourceWidth$[ebp]
	add	eax, DWORD PTR _SourceColumn$6[ebp]
	mov	DWORD PTR _SourceIndex$5[ebp], eax

; 154  : 			UINT32 Pixel = Src[SourceIndex];

	mov	ecx, DWORD PTR _SourceIndex$5[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _Pixel$1[ebp], eax

; 155  : 			UINT32 NewX = SourceRow;

	mov	ecx, DWORD PTR _SourceRow$7[ebp]
	mov	DWORD PTR _NewX$3[ebp], ecx

; 156  : 			UINT32 NewY = (SourceWidth - 1) - SourceColumn;

	mov	edx, DWORD PTR _SourceWidth$[ebp]
	sub	edx, 1
	sub	edx, DWORD PTR _SourceColumn$6[ebp]
	mov	DWORD PTR _NewY$4[ebp], edx

; 157  : 			UINT32 DestinationIndex = (NewY * DestinationWidth) + NewX;

	mov	eax, DWORD PTR _NewY$4[ebp]
	imul	eax, DWORD PTR _DestinationWidth$[ebp]
	add	eax, DWORD PTR _NewX$3[ebp]
	mov	DWORD PTR _DestinationIndex$2[ebp], eax

; 158  : 			Dest[DestinationIndex] = Pixel;

	mov	ecx, DWORD PTR _DestinationIndex$2[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _Pixel$1[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 159  : 		}

	jmp	SHORT $LN5@ImageRotat
$LN6@ImageRotat:

; 160  : 	}

	jmp	SHORT $LN2@ImageRotat
$LN3@ImageRotat:

; 161  : 
; 162  : 	return Success;

	xor	eax, eax
$LN1@ImageRotat:

; 163  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_ImageRotateRight270@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\rotations.cpp
_TEXT	SEGMENT
_DestinationColumn$ = -44				; size = 4
_DestinationRow$ = -40					; size = 4
_Pixel$1 = -36						; size = 4
_Dest$ = -32						; size = 4
_DestinationIndex$2 = -28				; size = 4
_NewColumn$3 = -24					; size = 4
_NewRow$4 = -20						; size = 4
_Src$ = -16						; size = 4
_SourceIndex$5 = -12					; size = 4
_SourceRow$6 = -8					; size = 4
_SourceColumn$7 = -4					; size = 4
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_Destination$ = 20					; size = 4
_DestinationWidth$ = 24					; size = 4
_DestinationHeight$ = 28				; size = 4
_ImageRotateRight180@24 PROC

; 181  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 182  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ImageRotat

; 183  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageRotat
$LN8@ImageRotat:

; 184  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ImageRotat

; 185  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageRotat
$LN9@ImageRotat:

; 186  : 
; 187  : 	if (SourceWidth != DestinationWidth)

	mov	eax, DWORD PTR _SourceWidth$[ebp]
	cmp	eax, DWORD PTR _DestinationWidth$[ebp]
	je	SHORT $LN10@ImageRotat

; 188  : 		return DimensionalMismatch;

	mov	eax, 28					; 0000001cH
	jmp	$LN1@ImageRotat
$LN10@ImageRotat:

; 189  : 	if (SourceHeight != DestinationHeight)

	mov	ecx, DWORD PTR _SourceHeight$[ebp]
	cmp	ecx, DWORD PTR _DestinationHeight$[ebp]
	je	SHORT $LN11@ImageRotat

; 190  : 		return DimensionalMismatch;

	mov	eax, 28					; 0000001cH
	jmp	$LN1@ImageRotat
$LN11@ImageRotat:

; 191  : 
; 192  : 	UINT32 *Src = (UINT32 *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], edx

; 193  : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 194  : 
; 195  : 	int DestinationRow = 0;

	mov	DWORD PTR _DestinationRow$[ebp], 0

; 196  : 	int DestinationColumn = DestinationWidth - 1;

	mov	ecx, DWORD PTR _DestinationWidth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _DestinationColumn$[ebp], ecx

; 197  : 
; 198  : 	for (int SourceRow = 0; SourceRow < SourceHeight; SourceRow++)

	mov	DWORD PTR _SourceRow$6[ebp], 0
	jmp	SHORT $LN4@ImageRotat
$LN2@ImageRotat:
	mov	edx, DWORD PTR _SourceRow$6[ebp]
	add	edx, 1
	mov	DWORD PTR _SourceRow$6[ebp], edx
$LN4@ImageRotat:
	mov	eax, DWORD PTR _SourceRow$6[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	SHORT $LN3@ImageRotat

; 199  : 	{
; 200  : 		for (int SourceColumn = 0; SourceColumn < SourceWidth; SourceColumn++)

	mov	DWORD PTR _SourceColumn$7[ebp], 0
	jmp	SHORT $LN7@ImageRotat
$LN5@ImageRotat:
	mov	ecx, DWORD PTR _SourceColumn$7[ebp]
	add	ecx, 1
	mov	DWORD PTR _SourceColumn$7[ebp], ecx
$LN7@ImageRotat:
	mov	edx, DWORD PTR _SourceColumn$7[ebp]
	cmp	edx, DWORD PTR _SourceWidth$[ebp]
	jge	SHORT $LN6@ImageRotat

; 201  : 		{
; 202  : 			UINT32 SourceIndex = (SourceRow * SourceWidth) + SourceColumn;

	mov	eax, DWORD PTR _SourceRow$6[ebp]
	imul	eax, DWORD PTR _SourceWidth$[ebp]
	add	eax, DWORD PTR _SourceColumn$7[ebp]
	mov	DWORD PTR _SourceIndex$5[ebp], eax

; 203  : 			UINT32 Pixel = Src[SourceIndex];

	mov	ecx, DWORD PTR _SourceIndex$5[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _Pixel$1[ebp], eax

; 204  : 			UINT32 NewColumn = (SourceWidth - 1) - SourceColumn;

	mov	ecx, DWORD PTR _SourceWidth$[ebp]
	sub	ecx, 1
	sub	ecx, DWORD PTR _SourceColumn$7[ebp]
	mov	DWORD PTR _NewColumn$3[ebp], ecx

; 205  : 			UINT32 NewRow = (SourceHeight - 1) - SourceRow;

	mov	edx, DWORD PTR _SourceHeight$[ebp]
	sub	edx, 1
	sub	edx, DWORD PTR _SourceRow$6[ebp]
	mov	DWORD PTR _NewRow$4[ebp], edx

; 206  : 			UINT32 DestinationIndex = (NewRow * SourceWidth) + NewColumn;

	mov	eax, DWORD PTR _NewRow$4[ebp]
	imul	eax, DWORD PTR _SourceWidth$[ebp]
	add	eax, DWORD PTR _NewColumn$3[ebp]
	mov	DWORD PTR _DestinationIndex$2[ebp], eax

; 207  : 			Dest[DestinationIndex] = Pixel;

	mov	ecx, DWORD PTR _DestinationIndex$2[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _Pixel$1[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 208  : 		}

	jmp	SHORT $LN5@ImageRotat
$LN6@ImageRotat:

; 209  : 	}

	jmp	SHORT $LN2@ImageRotat
$LN3@ImageRotat:

; 210  : 
; 211  : 	return Success;

	xor	eax, eax
$LN1@ImageRotat:

; 212  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_ImageRotateRight180@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\rotations.cpp
_TEXT	SEGMENT
_DestinationColumn$ = -44				; size = 4
_DestinationRow$ = -40					; size = 4
_Pixel$1 = -36						; size = 4
_Dest$ = -32						; size = 4
_DestinationIndex$2 = -28				; size = 4
_NewX$3 = -24						; size = 4
_NewY$4 = -20						; size = 4
_Src$ = -16						; size = 4
_SourceIndex$5 = -12					; size = 4
_SourceColumn$6 = -8					; size = 4
_SourceRow$7 = -4					; size = 4
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_Destination$ = 20					; size = 4
_DestinationWidth$ = 24					; size = 4
_DestinationHeight$ = 28				; size = 4
_ImageRotateRight90@24 PROC

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 72   : 	/*
; 73   : 	__asm
; 74   : 	{
; 75   : 		int 3
; 76   : 	}
; 77   : 	*/
; 78   : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ImageRotat

; 79   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageRotat
$LN8@ImageRotat:

; 80   : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ImageRotat

; 81   : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@ImageRotat
$LN9@ImageRotat:

; 82   : 
; 83   : 	if (SourceWidth != DestinationHeight)

	mov	eax, DWORD PTR _SourceWidth$[ebp]
	cmp	eax, DWORD PTR _DestinationHeight$[ebp]
	je	SHORT $LN10@ImageRotat

; 84   : 		return DimensionalMismatch;

	mov	eax, 28					; 0000001cH
	jmp	$LN1@ImageRotat
$LN10@ImageRotat:

; 85   : 	if (SourceHeight != DestinationWidth)

	mov	ecx, DWORD PTR _SourceHeight$[ebp]
	cmp	ecx, DWORD PTR _DestinationWidth$[ebp]
	je	SHORT $LN11@ImageRotat

; 86   : 		return DimensionalMismatch;

	mov	eax, 28					; 0000001cH
	jmp	$LN1@ImageRotat
$LN11@ImageRotat:

; 87   : 
; 88   : 	UINT32 *Src = (UINT32 *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], edx

; 89   : 	UINT32 *Dest = (UINT32 *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 90   : 
; 91   : 	int DestinationRow = 0;

	mov	DWORD PTR _DestinationRow$[ebp], 0

; 92   : 	int DestinationColumn = DestinationWidth - 1;

	mov	ecx, DWORD PTR _DestinationWidth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _DestinationColumn$[ebp], ecx

; 93   : 
; 94   : 	for (int SourceRow = 0; SourceRow < SourceHeight; SourceRow++)

	mov	DWORD PTR _SourceRow$7[ebp], 0
	jmp	SHORT $LN4@ImageRotat
$LN2@ImageRotat:
	mov	edx, DWORD PTR _SourceRow$7[ebp]
	add	edx, 1
	mov	DWORD PTR _SourceRow$7[ebp], edx
$LN4@ImageRotat:
	mov	eax, DWORD PTR _SourceRow$7[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	SHORT $LN3@ImageRotat

; 95   : 	{
; 96   : 		for (int SourceColumn = 0; SourceColumn < SourceWidth; SourceColumn++)

	mov	DWORD PTR _SourceColumn$6[ebp], 0
	jmp	SHORT $LN7@ImageRotat
$LN5@ImageRotat:
	mov	ecx, DWORD PTR _SourceColumn$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _SourceColumn$6[ebp], ecx
$LN7@ImageRotat:
	mov	edx, DWORD PTR _SourceColumn$6[ebp]
	cmp	edx, DWORD PTR _SourceWidth$[ebp]
	jge	SHORT $LN6@ImageRotat

; 97   : 		{
; 98   : 			UINT32 SourceIndex = (SourceRow * SourceWidth) + SourceColumn;

	mov	eax, DWORD PTR _SourceRow$7[ebp]
	imul	eax, DWORD PTR _SourceWidth$[ebp]
	add	eax, DWORD PTR _SourceColumn$6[ebp]
	mov	DWORD PTR _SourceIndex$5[ebp], eax

; 99   : 			UINT32 Pixel = Src[SourceIndex];

	mov	ecx, DWORD PTR _SourceIndex$5[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _Pixel$1[ebp], eax

; 100  : 			UINT32 NewX = (SourceHeight - 1) - SourceRow;

	mov	ecx, DWORD PTR _SourceHeight$[ebp]
	sub	ecx, 1
	sub	ecx, DWORD PTR _SourceRow$7[ebp]
	mov	DWORD PTR _NewX$3[ebp], ecx

; 101  : 			UINT32 NewY = SourceColumn;

	mov	edx, DWORD PTR _SourceColumn$6[ebp]
	mov	DWORD PTR _NewY$4[ebp], edx

; 102  : 			UINT32 DestinationIndex = (NewY * DestinationWidth) + NewX;

	mov	eax, DWORD PTR _NewY$4[ebp]
	imul	eax, DWORD PTR _DestinationWidth$[ebp]
	add	eax, DWORD PTR _NewX$3[ebp]
	mov	DWORD PTR _DestinationIndex$2[ebp], eax

; 103  : 			Dest[DestinationIndex] = Pixel;

	mov	ecx, DWORD PTR _DestinationIndex$2[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	mov	eax, DWORD PTR _Pixel$1[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 104  : 		}

	jmp	SHORT $LN5@ImageRotat
$LN6@ImageRotat:

; 105  : 	}

	jmp	SHORT $LN2@ImageRotat
$LN3@ImageRotat:

; 106  : 
; 107  : 	return Success;

	xor	eax, eax
$LN1@ImageRotat:

; 108  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_ImageRotateRight90@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\rotations.cpp
_TEXT	SEGMENT
tv64 = -4						; size = 4
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_Destination$ = 20					; size = 4
_DestinationWidth$ = 24					; size = 4
_DestinationHeight$ = 28				; size = 4
_RotateHow$ = 32					; size = 4
_ImageRotateRightBy@28 PROC

; 38   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 39   : 	switch (RotateHow)

	mov	eax, DWORD PTR _RotateHow$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 90			; 0000005aH
	je	SHORT $LN4@ImageRotat
	cmp	DWORD PTR tv64[ebp], 180		; 000000b4H
	je	SHORT $LN5@ImageRotat
	cmp	DWORD PTR tv64[ebp], 270		; 0000010eH
	je	SHORT $LN6@ImageRotat
	jmp	SHORT $LN7@ImageRotat
$LN4@ImageRotat:

; 40   : 	{
; 41   : 	case Rotate90CW:
; 42   : 		return ImageRotateRight90(Source, SourceWidth, SourceHeight, Destination, DestinationWidth, DestinationHeight);

	mov	ecx, DWORD PTR _DestinationHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DestinationWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SourceHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_ImageRotateRight90@24
	jmp	SHORT $LN1@ImageRotat
$LN5@ImageRotat:

; 43   : 
; 44   : 	case Rotate180CW:
; 45   : 		return ImageRotateRight180(Source, SourceWidth, SourceHeight, Destination, DestinationWidth, DestinationHeight);

	mov	ecx, DWORD PTR _DestinationHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DestinationWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SourceHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_ImageRotateRight180@24
	jmp	SHORT $LN1@ImageRotat
$LN6@ImageRotat:

; 46   : 
; 47   : 	case Rotate270CW:
; 48   : 		return ImageRotateRight270(Source, SourceWidth, SourceHeight, Destination, DestinationWidth, DestinationHeight);

	mov	ecx, DWORD PTR _DestinationHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DestinationWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _SourceHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _SourceWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Source$[ebp]
	push	eax
	call	_ImageRotateRight270@24
	jmp	SHORT $LN1@ImageRotat
$LN7@ImageRotat:

; 49   : 
; 50   : 	default:
; 51   : 		return BadRotation;

	mov	eax, 29					; 0000001dH
$LN1@ImageRotat:

; 52   : 	}
; 53   : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_ImageRotateRightBy@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\rotations.cpp
_TEXT	SEGMENT
_RowOffset$1 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_DestRow$ = -32						; size = 4
_Index$2 = -28						; size = 4
_SrcBuffer$ = -24					; size = 4
_DestIndex$3 = -20					; size = 4
_DestBuffer$ = -16					; size = 4
_Column$4 = -12						; size = 4
_Row$5 = -8						; size = 4
_DestColumn$ = -4					; size = 4
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Destination$ = 24					; size = 4
_DestinationWidth$ = 28					; size = 4
_DestinationHeight$ = 32				; size = 4
_DestinationStride$ = 36				; size = 4
_RotateBufferRight@32 PROC

; 372  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 373  : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@RotateBuff

; 374  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RotateBuff
$LN8@RotateBuff:

; 375  : 	if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@RotateBuff

; 376  : 		return NullPointer;

	mov	eax, 3
	jmp	$LN1@RotateBuff
$LN9@RotateBuff:

; 377  : 
; 378  : 	BYTE *SrcBuffer = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _SrcBuffer$[ebp], eax

; 379  : 	BYTE *DestBuffer = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _DestBuffer$[ebp], ecx

; 380  : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 381  : 	int DestRow = 0;

	mov	DWORD PTR _DestRow$[ebp], 0

; 382  : 	int DestColumn = 0;

	mov	DWORD PTR _DestColumn$[ebp], 0

; 383  : 
; 384  : 	for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN4@RotateBuff
$LN2@RotateBuff:
	mov	edx, DWORD PTR _Row$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$5[ebp], edx
$LN4@RotateBuff:
	mov	eax, DWORD PTR _Row$5[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@RotateBuff

; 385  : 	{
; 386  : 		int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$5[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 387  : 		for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$4[ebp], 0
	jmp	SHORT $LN7@RotateBuff
$LN5@RotateBuff:
	mov	edx, DWORD PTR _Column$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$4[ebp], edx
$LN7@RotateBuff:
	mov	eax, DWORD PTR _Column$4[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@RotateBuff

; 388  : 		{
; 389  : 			int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$4[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], ecx

; 390  : 			int DestIndex = (DestColumn * PixelSize) + (DestRow * DestinationStride);

	mov	edx, DWORD PTR _DestColumn$[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	mov	eax, DWORD PTR _DestRow$[ebp]
	imul	eax, DWORD PTR _DestinationStride$[ebp]
	add	edx, eax
	mov	DWORD PTR _DestIndex$3[ebp], edx

; 391  : 			DestBuffer[DestIndex + 0] = SrcBuffer[Index + 0];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _DestIndex$3[ebp]
	mov	edx, DWORD PTR _SrcBuffer$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 392  : 			DestBuffer[DestIndex + 1] = SrcBuffer[Index + 1];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _DestIndex$3[ebp]
	mov	edx, DWORD PTR _SrcBuffer$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 393  : 			DestBuffer[DestIndex + 2] = SrcBuffer[Index + 2];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _DestIndex$3[ebp]
	mov	edx, DWORD PTR _SrcBuffer$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 394  : 			DestBuffer[DestIndex + 3] = SrcBuffer[Index + 3];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _DestIndex$3[ebp]
	mov	edx, DWORD PTR _SrcBuffer$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 395  : 			DestColumn++;

	mov	ecx, DWORD PTR _DestColumn$[ebp]
	add	ecx, 1
	mov	DWORD PTR _DestColumn$[ebp], ecx

; 396  : 			if (DestColumn >= DestinationWidth)

	mov	edx, DWORD PTR _DestColumn$[ebp]
	cmp	edx, DWORD PTR _DestinationWidth$[ebp]
	jl	SHORT $LN10@RotateBuff

; 397  : 			{
; 398  : 				DestColumn = 0;

	mov	DWORD PTR _DestColumn$[ebp], 0

; 399  : 				DestRow++;

	mov	eax, DWORD PTR _DestRow$[ebp]
	add	eax, 1
	mov	DWORD PTR _DestRow$[ebp], eax
$LN10@RotateBuff:

; 400  : 			}
; 401  : 		}

	jmp	$LN5@RotateBuff
$LN6@RotateBuff:

; 402  : 	}

	jmp	$LN2@RotateBuff
$LN3@RotateBuff:

; 403  : 	return Success;

	xor	eax, eax
$LN1@RotateBuff:

; 404  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_RotateBufferRight@32 ENDP
_TEXT	ENDS
END
