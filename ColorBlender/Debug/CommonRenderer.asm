; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\CommonRenderer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?memchr@@YAPAXPAXHI@Z				; memchr
PUBLIC	_RenderDisplayList@24
PUBLIC	?RenderColorBlobEx@@YGHPAUColorBlobParameters@@PAUCommonObject@@@Z ; RenderColorBlobEx
PUBLIC	?RenderColorBlock@@YGHPAUColorBlockParameters@@PAUCommonObject@@@Z ; RenderColorBlock
PUBLIC	?RenderLinePlot@@YGHPAULinePlotParameters@@PAUCommonObject@@@Z ; RenderLinePlot
PUBLIC	?CommonObjectRenderer@@YGHPAEHHHPAUCommonObject@@H@Z ; CommonObjectRenderer
PUBLIC	?UpdateBufferAlpha@@YGHPAEHHHPAUMassAlphaParameters@@@Z ; UpdateBufferAlpha
PUBLIC	?InvertRenderBuffer@@YGHPAEHHHPAUInversionParameters@@@Z ; InvertRenderBuffer
PUBLIC	?ClearRenderBuffer@@YGHPAEHHHPAUBufferClearParameters@@@Z ; ClearRenderBuffer
PUBLIC	?MakeObjectList@@YGPAUCommonObject@@H@Z		; MakeObjectList
PUBLIC	?DeleteObjectList@@YGXPAUCommonObject@@H@Z	; DeleteObjectList
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@406fe00000000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_memchr:PROC
EXTRN	?Distance@@YGNHHHH@Z:PROC			; Distance
EXTRN	?PixelLuminance@@YGNEEE@Z:PROC			; PixelLuminance
EXTRN	__fltused:DWORD
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\commonrenderer.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_i$3 = -4						; size = 4
_ObjectList$ = 8					; size = 4
_EntryCount$ = 12					; size = 4
?DeleteObjectList@@YGXPAUCommonObject@@H@Z PROC		; DeleteObjectList

; 443  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 444  :     if (ObjectList == NULL)

	cmp	DWORD PTR _ObjectList$[ebp], 0
	jne	SHORT $LN5@DeleteObje

; 445  :         return;

	jmp	SHORT $LN1@DeleteObje
$LN5@DeleteObje:

; 446  :     if (EntryCount < 1)

	cmp	DWORD PTR _EntryCount$[ebp], 1
	jge	SHORT $LN6@DeleteObje

; 447  :         return;

	jmp	SHORT $LN1@DeleteObje
$LN6@DeleteObje:

; 448  :     for (int i = 0; i < EntryCount; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@DeleteObje
$LN2@DeleteObje:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@DeleteObje:
	mov	ecx, DWORD PTR _i$3[ebp]
	cmp	ecx, DWORD PTR _EntryCount$[ebp]
	jge	SHORT $LN3@DeleteObje

; 449  :     {
; 450  :         if (ObjectList[i].ObjectBuffer != NULL)

	imul	edx, DWORD PTR _i$3[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	cmp	DWORD PTR [eax+edx+4], 0
	je	SHORT $LN7@DeleteObje

; 451  :             delete[] ObjectList[i].ObjectBuffer;

	imul	ecx, DWORD PTR _i$3[ebp], 36
	mov	edx, DWORD PTR _ObjectList$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@DeleteObje:

; 452  :     }

	jmp	SHORT $LN2@DeleteObje
$LN3@DeleteObje:

; 453  :     delete[] ObjectList;

	mov	edx, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	mov	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN1@DeleteObje:

; 454  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DeleteObjectList@@YGXPAUCommonObject@@H@Z ENDP		; DeleteObjectList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\commonrenderer.cpp
_TEXT	SEGMENT
_ObjectList$ = -8					; size = 4
$T1 = -4						; size = 4
_EntryCount$ = 8					; size = 4
?MakeObjectList@@YGPAUCommonObject@@H@Z PROC		; MakeObjectList

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 432  :     CommonObject* ObjectList;
; 433  :     ObjectList = new CommonObject[EntryCount];

	xor	ecx, ecx
	mov	eax, DWORD PTR _EntryCount$[ebp]
	mov	edx, 36					; 00000024H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	mov	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR _ObjectList$[ebp], eax

; 434  :     return ObjectList;

	mov	eax, DWORD PTR _ObjectList$[ebp]

; 435  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?MakeObjectList@@YGPAUCommonObject@@H@Z ENDP		; MakeObjectList
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\commonrenderer.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_Column$2 = -24						; size = 4
_Row$3 = -20						; size = 4
_Index$4 = -16						; size = 4
_grB$ = -9						; size = 1
_bgA$ = -8						; size = 1
_bgR$ = -7						; size = 1
_bgG$ = -6						; size = 1
_grA$ = -5						; size = 1
_grR$ = -4						; size = 1
_grG$ = -3						; size = 1
_PixelSize$ = -2					; size = 1
_bgB$ = -1						; size = 1
_Buffer$ = 8						; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_Parameters$ = 24					; size = 4
?ClearRenderBuffer@@YGHPAEHHHPAUBufferClearParameters@@@Z PROC ; ClearRenderBuffer

; 376  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 377  :     if (Buffer == NULL)

	cmp	DWORD PTR _Buffer$[ebp], 0
	jne	SHORT $LN8@ClearRende

; 378  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ClearRende
$LN8@ClearRende:

; 379  :     if (Parameters == NULL)

	cmp	DWORD PTR _Parameters$[ebp], 0
	jne	SHORT $LN9@ClearRende

; 380  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ClearRende
$LN9@ClearRende:

; 381  : 
; 382  :     BYTE bgB = (BYTE) ((Parameters->BGColor & 0xff000000) >> 24);

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _bgB$[ebp], cl

; 383  :     BYTE bgG = (BYTE) ((Parameters->BGColor & 0x00ff0000) >> 16);

	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _bgG$[ebp], al

; 384  :     BYTE bgR = (BYTE) ((Parameters->BGColor & 0x0000ff00) >> 8);

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _bgR$[ebp], dl

; 385  :     BYTE bgA = (BYTE) ((Parameters->BGColor & 0x000000ff) >> 0);

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _bgA$[ebp], cl

; 386  :     BYTE grB = (BYTE) ((Parameters->GridColor & 0xff000000) >> 24);

	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	BYTE PTR _grB$[ebp], al

; 387  :     BYTE grG = (BYTE) ((Parameters->GridColor & 0x00ff0000) >> 16);

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _grG$[ebp], dl

; 388  :     BYTE grR = (BYTE) ((Parameters->GridColor & 0x0000ff00) >> 8);

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _grR$[ebp], cl

; 389  :     BYTE grA = (BYTE) ((Parameters->GridColor & 0x000000ff) >> 0);

	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _grA$[ebp], al

; 390  : 
; 391  :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 392  :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ClearRende
$LN2@ClearRende:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@ClearRende:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _BufferHeight$[ebp]
	jge	$LN3@ClearRende

; 393  :     {
; 394  :         int RowOffset = Row * BufferStride;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 395  :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ClearRende
$LN5@ClearRende:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@ClearRende:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _BufferWidth$[ebp]
	jge	$LN6@ClearRende

; 396  :         {
; 397  :             int Index = RowOffset + (Column * PixelSize);

	movzx	eax, BYTE PTR _PixelSize$[ebp]
	imul	eax, DWORD PTR _Column$2[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 398  :             if (Parameters->DrawGrid)

	mov	ecx, DWORD PTR _Parameters$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN10@ClearRende

; 399  :             {
; 400  :                 if (
; 401  :                     (Row % Parameters->VerticalFrequency == 0) ||

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR _Row$3[ebp]
	cdq
	idiv	DWORD PTR [ecx+16]
	test	edx, edx
	je	SHORT $LN13@ClearRende
	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR _Column$2[ebp]
	cdq
	idiv	DWORD PTR [ecx+12]
	test	edx, edx
	jne	SHORT $LN12@ClearRende
$LN13@ClearRende:

; 402  :                     (Column % Parameters->HorizontalFrequency == 0)
; 403  :                     )
; 404  :                 {
; 405  :                     Buffer[Index + 0] = bgB;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _bgB$[ebp]
	mov	BYTE PTR [edx], al

; 406  :                     Buffer[Index + 1] = grG;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _grG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 407  :                     Buffer[Index + 2] = grR;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _grR$[ebp]
	mov	BYTE PTR [eax+2], cl

; 408  :                     Buffer[Index + 3] = grA;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _grA$[ebp]
	mov	BYTE PTR [edx+3], al

; 409  :                     continue;

	jmp	SHORT $LN5@ClearRende
$LN12@ClearRende:

; 410  :                 }
; 411  :             }
; 412  :             else

	jmp	SHORT $LN11@ClearRende
$LN10@ClearRende:

; 413  :             {
; 414  :                 Buffer[Index + 0] = bgB;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _bgB$[ebp]
	mov	BYTE PTR [ecx], dl

; 415  :                 Buffer[Index + 1] = bgG;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _bgG$[ebp]
	mov	BYTE PTR [eax+1], cl

; 416  :                 Buffer[Index + 2] = bgR;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _bgR$[ebp]
	mov	BYTE PTR [edx+2], al

; 417  :                 Buffer[Index + 3] = bgA;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _bgA$[ebp]
	mov	BYTE PTR [ecx+3], dl
$LN11@ClearRende:

; 418  :             }
; 419  :         }

	jmp	$LN5@ClearRende
$LN6@ClearRende:

; 420  :     }

	jmp	$LN2@ClearRende
$LN3@ClearRende:

; 421  : 
; 422  :     return Success;

	xor	eax, eax
$LN1@ClearRende:

; 423  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?ClearRenderBuffer@@YGHPAEHHHPAUBufferClearParameters@@@Z ENDP ; ClearRenderBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\commonrenderer.cpp
_TEXT	SEGMENT
_Luminance$1 = -72					; size = 8
_InvertBlue$ = -64					; size = 4
_InvertGreen$ = -60					; size = 4
_InvertRed$ = -56					; size = 4
_RowOffset$2 = -52					; size = 4
tv94 = -48						; size = 4
tv89 = -44						; size = 4
tv84 = -40						; size = 4
tv79 = -36						; size = 4
tv73 = -32						; size = 4
_InvertAlpha$ = -28					; size = 4
tv148 = -24						; size = 4
_Column$3 = -20						; size = 4
_Row$4 = -16						; size = 4
_Index$5 = -12						; size = 4
_FinalLuminance$ = -6					; size = 1
_PixelSize$ = -5					; size = 1
_A$6 = -4						; size = 1
_B$7 = -3						; size = 1
_R$8 = -2						; size = 1
_G$9 = -1						; size = 1
_Buffer$ = 8						; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_Parameters$ = 24					; size = 4
?InvertRenderBuffer@@YGHPAEHHHPAUInversionParameters@@@Z PROC ; InvertRenderBuffer

; 304  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 305  :     if (Buffer == NULL)

	cmp	DWORD PTR _Buffer$[ebp], 0
	jne	SHORT $LN10@InvertRend

; 306  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@InvertRend
$LN10@InvertRend:

; 307  :     if (Parameters == NULL)

	cmp	DWORD PTR _Parameters$[ebp], 0
	jne	SHORT $LN11@InvertRend

; 308  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@InvertRend
$LN11@InvertRend:

; 309  : 
; 310  :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 311  :     BYTE FinalLuminance = Parameters->InvertThreshold ? 255 - Parameters->LuminanceThreshold : Parameters->LuminanceThreshold;

	mov	eax, DWORD PTR _Parameters$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN24@InvertRend
	mov	ecx, DWORD PTR _Parameters$[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN25@InvertRend
$LN24@InvertRend:
	mov	ecx, DWORD PTR _Parameters$[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	mov	DWORD PTR tv73[ebp], edx
$LN25@InvertRend:
	mov	al, BYTE PTR tv73[ebp]
	mov	BYTE PTR _FinalLuminance$[ebp], al

; 312  :     BOOL InvertAlpha = (Parameters->InversionChannels & AlphaChannel) > 0 ? TRUE : FALSE;

	mov	ecx, DWORD PTR _Parameters$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	and	edx, 1
	jle	SHORT $LN26@InvertRend
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN27@InvertRend
$LN26@InvertRend:
	mov	DWORD PTR tv79[ebp], 0
$LN27@InvertRend:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR _InvertAlpha$[ebp], eax

; 313  :     BOOL InvertRed = (Parameters->InversionChannels & RedChannel) > 0 ? TRUE : FALSE;

	mov	ecx, DWORD PTR _Parameters$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	and	edx, 2
	jle	SHORT $LN28@InvertRend
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN29@InvertRend
$LN28@InvertRend:
	mov	DWORD PTR tv84[ebp], 0
$LN29@InvertRend:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR _InvertRed$[ebp], eax

; 314  :     BOOL InvertGreen = (Parameters->InversionChannels & GreenChannel) > 0 ? TRUE : FALSE;

	mov	ecx, DWORD PTR _Parameters$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	and	edx, 4
	jle	SHORT $LN30@InvertRend
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN31@InvertRend
$LN30@InvertRend:
	mov	DWORD PTR tv89[ebp], 0
$LN31@InvertRend:
	mov	eax, DWORD PTR tv89[ebp]
	mov	DWORD PTR _InvertGreen$[ebp], eax

; 315  :     BOOL InvertBlue = (Parameters->InversionChannels & BlueChannel) > 0 ? TRUE : FALSE;

	mov	ecx, DWORD PTR _Parameters$[ebp]
	movzx	edx, BYTE PTR [ecx+16]
	and	edx, 8
	jle	SHORT $LN32@InvertRend
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN33@InvertRend
$LN32@InvertRend:
	mov	DWORD PTR tv94[ebp], 0
$LN33@InvertRend:
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR _InvertBlue$[ebp], eax

; 316  : 
; 317  :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@InvertRend
$LN2@InvertRend:
	mov	ecx, DWORD PTR _Row$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$4[ebp], ecx
$LN4@InvertRend:
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _BufferHeight$[ebp]
	jge	$LN3@InvertRend

; 318  :     {
; 319  :         int RowOffset = Row * BufferStride;

	mov	eax, DWORD PTR _Row$4[ebp]
	imul	eax, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], eax

; 320  :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@InvertRend
$LN5@InvertRend:
	mov	ecx, DWORD PTR _Column$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$3[ebp], ecx
$LN7@InvertRend:
	mov	edx, DWORD PTR _Column$3[ebp]
	cmp	edx, DWORD PTR _BufferWidth$[ebp]
	jge	$LN6@InvertRend

; 321  :         {
; 322  :             int Index = RowOffset + (Column * PixelSize);

	movzx	eax, BYTE PTR _PixelSize$[ebp]
	imul	eax, DWORD PTR _Column$3[ebp]
	add	eax, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], eax

; 323  :             BYTE A = Buffer[Index + 3];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR _A$6[ebp], dl

; 324  :             BYTE R = Buffer[Index + 2];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _R$8[ebp], cl

; 325  :             BYTE G = Buffer[Index + 1];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _G$9[ebp], al

; 326  :             BYTE B = Buffer[Index + 0];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _B$7[ebp], dl

; 327  :             double Luminance = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Luminance$1[ebp], xmm0

; 328  :             switch (Parameters->Operation)

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv148[ebp], ecx
	cmp	DWORD PTR tv148[ebp], 0
	je	SHORT $LN12@InvertRend
	cmp	DWORD PTR tv148[ebp], 1
	je	$LN19@InvertRend
	cmp	DWORD PTR tv148[ebp], 2
	je	SHORT $LN14@InvertRend
	jmp	$LN22@InvertRend
$LN12@InvertRend:

; 329  :             {
; 330  :                 case SimpleInvertOperation:
; 331  :                     R = 255 - R;

	movzx	edx, BYTE PTR _R$8[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _R$8[ebp], al

; 332  :                     G = 255 - G;

	movzx	ecx, BYTE PTR _G$9[ebp]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	BYTE PTR _G$9[ebp], dl

; 333  :                     B = 255 - G;

	movzx	eax, BYTE PTR _G$9[ebp]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	BYTE PTR _B$7[ebp], cl

; 334  :                     if (InvertAlpha)

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN13@InvertRend

; 335  :                         A = 255 - A;

	movzx	edx, BYTE PTR _A$6[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _A$6[ebp], al
$LN13@InvertRend:

; 336  :                     break;

	jmp	$LN8@InvertRend
$LN14@InvertRend:

; 337  : 
; 338  :                 case ChannelInversionOperation:
; 339  :                     if ((InvertAlpha) && (Parameters->AllowInvertAlpha))

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN15@InvertRend
	mov	ecx, DWORD PTR _Parameters$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN15@InvertRend

; 340  :                         A = 255 - A;

	movzx	edx, BYTE PTR _A$6[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _A$6[ebp], al
$LN15@InvertRend:

; 341  :                     if (InvertRed)

	cmp	DWORD PTR _InvertRed$[ebp], 0
	je	SHORT $LN16@InvertRend

; 342  :                         R = 255 - R;

	movzx	ecx, BYTE PTR _R$8[ebp]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	BYTE PTR _R$8[ebp], dl
$LN16@InvertRend:

; 343  :                     if (InvertGreen)

	cmp	DWORD PTR _InvertGreen$[ebp], 0
	je	SHORT $LN17@InvertRend

; 344  :                         G = 255 - G;

	movzx	eax, BYTE PTR _G$9[ebp]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	BYTE PTR _G$9[ebp], cl
$LN17@InvertRend:

; 345  :                     if (InvertBlue)

	cmp	DWORD PTR _InvertBlue$[ebp], 0
	je	SHORT $LN18@InvertRend

; 346  :                         B = 255 - B;

	movzx	edx, BYTE PTR _B$7[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _B$7[ebp], al
$LN18@InvertRend:

; 347  :                     break;

	jmp	SHORT $LN8@InvertRend
$LN19@InvertRend:

; 348  : 
; 349  :                 case VariableInvertOperation:
; 350  :                     Luminance = PixelLuminance (R, G, B);

	movzx	ecx, BYTE PTR _B$7[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$9[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$8[ebp]
	push	eax
	call	?PixelLuminance@@YGNEEE@Z		; PixelLuminance
	fstp	QWORD PTR _Luminance$1[ebp]

; 351  :                     if (Luminance > FinalLuminance)

	movzx	ecx, BYTE PTR _FinalLuminance$[ebp]
	cvtsi2sd xmm0, ecx
	movsd	xmm1, QWORD PTR _Luminance$1[ebp]
	comisd	xmm1, xmm0
	jbe	SHORT $LN21@InvertRend

; 352  :                     {
; 353  :                         R = 255 - R;

	movzx	edx, BYTE PTR _R$8[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _R$8[ebp], al

; 354  :                         G = 255 - G;

	movzx	ecx, BYTE PTR _G$9[ebp]
	mov	edx, 255				; 000000ffH
	sub	edx, ecx
	mov	BYTE PTR _G$9[ebp], dl

; 355  :                         B = 255 - B;

	movzx	eax, BYTE PTR _B$7[ebp]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	BYTE PTR _B$7[ebp], cl

; 356  :                         if (InvertAlpha)

	cmp	DWORD PTR _InvertAlpha$[ebp], 0
	je	SHORT $LN21@InvertRend

; 357  :                             A = 255 - A;

	movzx	edx, BYTE PTR _A$6[ebp]
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	BYTE PTR _A$6[ebp], al
$LN21@InvertRend:

; 358  :                     }
; 359  :                     break;

	jmp	SHORT $LN8@InvertRend
$LN22@InvertRend:

; 360  : 
; 361  :                 default:
; 362  :                     return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@InvertRend
$LN8@InvertRend:

; 363  :             }
; 364  :             Buffer[Index + 0] = B;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR [ecx], dl

; 365  :             Buffer[Index + 1] = G;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR [eax+1], cl

; 366  :             Buffer[Index + 2] = R;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _R$8[ebp]
	mov	BYTE PTR [edx+2], al

; 367  :             Buffer[Index + 3] = A;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _A$6[ebp]
	mov	BYTE PTR [ecx+3], dl

; 368  :         }

	jmp	$LN5@InvertRend
$LN6@InvertRend:

; 369  :     }

	jmp	$LN2@InvertRend
$LN3@InvertRend:

; 370  : 
; 371  :     return Success;

	xor	eax, eax
$LN1@InvertRend:

; 372  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?InvertRenderBuffer@@YGHPAEHHHPAUInversionParameters@@@Z ENDP ; InvertRenderBuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\commonrenderer.cpp
_TEXT	SEGMENT
_Luminance$ = -44					; size = 8
_Ratio$ = -36						; size = 8
_RowOffset$1 = -28					; size = 4
tv75 = -24						; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Index$4 = -12						; size = 4
_R$ = -5						; size = 1
_G$ = -4						; size = 1
_B$ = -3						; size = 1
_PixelSize$ = -2					; size = 1
_A$ = -1						; size = 1
_Buffer$ = 8						; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_Parameters$ = 24					; size = 4
?UpdateBufferAlpha@@YGHPAEHHHPAUMassAlphaParameters@@@Z PROC ; UpdateBufferAlpha

; 254  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 255  :     if (Buffer == NULL)

	cmp	DWORD PTR _Buffer$[ebp], 0
	jne	SHORT $LN10@UpdateBuff

; 256  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@UpdateBuff
$LN10@UpdateBuff:

; 257  :     if (Parameters == NULL)

	cmp	DWORD PTR _Parameters$[ebp], 0
	jne	SHORT $LN11@UpdateBuff

; 258  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@UpdateBuff
$LN11@UpdateBuff:

; 259  : 
; 260  :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 261  :     BYTE A, R, G, B;
; 262  :     double Luminance = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Luminance$[ebp], xmm0

; 263  :     double Ratio = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Ratio$[ebp], xmm0

; 264  : 
; 265  :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@UpdateBuff
$LN2@UpdateBuff:
	mov	eax, DWORD PTR _Row$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$3[ebp], eax
$LN4@UpdateBuff:
	mov	ecx, DWORD PTR _Row$3[ebp]
	cmp	ecx, DWORD PTR _BufferHeight$[ebp]
	jge	$LN3@UpdateBuff

; 266  :     {
; 267  :         int RowOffset = Row * BufferStride;

	mov	edx, DWORD PTR _Row$3[ebp]
	imul	edx, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], edx

; 268  :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@UpdateBuff
$LN5@UpdateBuff:
	mov	eax, DWORD PTR _Column$2[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$2[ebp], eax
$LN7@UpdateBuff:
	mov	ecx, DWORD PTR _Column$2[ebp]
	cmp	ecx, DWORD PTR _BufferWidth$[ebp]
	jge	$LN6@UpdateBuff

; 269  :         {
; 270  :             int Index = (Column * PixelSize + RowOffset);

	movzx	edx, BYTE PTR _PixelSize$[ebp]
	imul	edx, DWORD PTR _Column$2[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], edx

; 271  :             switch (Parameters->AlphaOperation)

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv75[ebp], ecx
	cmp	DWORD PTR tv75[ebp], 0
	je	SHORT $LN12@UpdateBuff
	cmp	DWORD PTR tv75[ebp], 1
	je	SHORT $LN13@UpdateBuff
	jmp	$LN17@UpdateBuff
$LN12@UpdateBuff:

; 272  :             {
; 273  :                 case UnitaryAlphaApplication:
; 274  :                     Buffer[Index + 3] = Parameters->UniformAlpha;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR [edx+3], cl

; 275  :                     break;

	jmp	$LN8@UpdateBuff
$LN13@UpdateBuff:

; 276  : 
; 277  :                 case VariableAlphaApplication:
; 278  :                     B = Buffer[Index + 0];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$[ebp], al

; 279  :                     G = Buffer[Index + 1];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$[ebp], dl

; 280  :                     R = Buffer[Index + 2];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _R$[ebp], cl

; 281  :                     A = Buffer[Index + 3];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$[ebp], al

; 282  :                     Luminance = PixelLuminance (R, G, B);

	movzx	ecx, BYTE PTR _B$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$[ebp]
	push	eax
	call	?PixelLuminance@@YGNEEE@Z		; PixelLuminance
	fstp	QWORD PTR _Luminance$[ebp]

; 283  :                     Ratio = Luminance / 255.0;

	movsd	xmm0, QWORD PTR _Luminance$[ebp]
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _Ratio$[ebp], xmm0

; 284  :                     if (Parameters->InverseAlpha)

	mov	ecx, DWORD PTR _Parameters$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN14@UpdateBuff

; 285  :                         Ratio = 1.0 - Ratio;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _Ratio$[ebp]
	movsd	QWORD PTR _Ratio$[ebp], xmm0
$LN14@UpdateBuff:

; 286  :                     if (Parameters->UseExistingAlpha)

	mov	edx, DWORD PTR _Parameters$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN15@UpdateBuff

; 287  :                         A = (BYTE) ((double) A * Ratio);

	movzx	eax, BYTE PTR _A$[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _Ratio$[ebp]
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _A$[ebp], cl

; 288  :                     else

	jmp	SHORT $LN16@UpdateBuff
$LN15@UpdateBuff:

; 289  :                         A = (BYTE) (255.0 * Ratio);

	movsd	xmm0, QWORD PTR __real@406fe00000000000
	mulsd	xmm0, QWORD PTR _Ratio$[ebp]
	cvttsd2si edx, xmm0
	mov	BYTE PTR _A$[ebp], dl
$LN16@UpdateBuff:

; 290  :                     Buffer[Index + 3] = A;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [eax+3], cl

; 291  :                     break;

	jmp	SHORT $LN8@UpdateBuff
$LN17@UpdateBuff:

; 292  : 
; 293  :                 default:
; 294  :                     return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@UpdateBuff
$LN8@UpdateBuff:

; 295  :             }
; 296  :         }

	jmp	$LN5@UpdateBuff
$LN6@UpdateBuff:

; 297  :     }

	jmp	$LN2@UpdateBuff
$LN3@UpdateBuff:

; 298  : 
; 299  :     return Success;

	xor	eax, eax
$LN1@UpdateBuff:

; 300  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?UpdateBufferAlpha@@YGHPAEHHHPAUMassAlphaParameters@@@Z ENDP ; UpdateBufferAlpha
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\commonrenderer.cpp
_TEXT	SEGMENT
_Final$1 = -80						; size = 32
_a$2 = -48						; size = 4
_b$3 = -44						; size = 4
_RowOffset$4 = -40					; size = 4
_Index$5 = -36						; size = 4
_ObjectIndex$6 = -32					; size = 4
_OverlapCount$7 = -28					; size = 4
_Column$8 = -24						; size = 4
_Row$9 = -20						; size = 4
_i$10 = -16						; size = 4
_OIndex$11 = -12					; size = 4
_FinalA$12 = -5						; size = 1
_FinalR$13 = -4						; size = 1
_FinalG$14 = -3						; size = 1
_FinalB$15 = -2						; size = 1
_PixelSize$ = -1					; size = 1
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_ObjectList$ = 24					; size = 4
_ObjectCount$ = 28					; size = 4
?CommonObjectRenderer@@YGHPAEHHHPAUCommonObject@@H@Z PROC ; CommonObjectRenderer

; 184  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 185  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN14@CommonObje

; 186  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CommonObje
$LN14@CommonObje:

; 187  :     if (ObjectList == NULL)

	cmp	DWORD PTR _ObjectList$[ebp], 0
	jne	SHORT $LN15@CommonObje

; 188  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@CommonObje
$LN15@CommonObje:

; 189  :     if (ObjectCount < 1)

	cmp	DWORD PTR _ObjectCount$[ebp], 1
	jge	SHORT $LN16@CommonObje

; 190  :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@CommonObje
$LN16@CommonObje:

; 191  : 
; 192  :     for (int i = 0; i < ObjectCount; i++)

	mov	DWORD PTR _i$10[ebp], 0
	jmp	SHORT $LN4@CommonObje
$LN2@CommonObje:
	mov	eax, DWORD PTR _i$10[ebp]
	add	eax, 1
	mov	DWORD PTR _i$10[ebp], eax
$LN4@CommonObje:
	mov	ecx, DWORD PTR _i$10[ebp]
	cmp	ecx, DWORD PTR _ObjectCount$[ebp]
	jge	SHORT $LN3@CommonObje

; 193  :     {
; 194  :         ObjectList[i].Right = ObjectList[i].Left + ObjectList[i].ObjectWidth;

	imul	edx, DWORD PTR _i$10[ebp], 36
	imul	eax, DWORD PTR _i$10[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR [ecx+edx+20]
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	add	edx, DWORD PTR [ecx+eax+8]
	imul	eax, DWORD PTR _i$10[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR [ecx+eax+28], edx

; 195  :         ObjectList[i].Bottom = ObjectList[i].Top + ObjectList[i].ObjectHeight;

	imul	edx, DWORD PTR _i$10[ebp], 36
	imul	eax, DWORD PTR _i$10[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR [ecx+edx+24]
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	add	edx, DWORD PTR [ecx+eax+12]
	imul	eax, DWORD PTR _i$10[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR [ecx+eax+32], edx

; 196  :     }

	jmp	SHORT $LN2@CommonObje
$LN3@CommonObje:

; 197  : 
; 198  :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 199  : 
; 200  :     for (int Row = 0; Row < TargetHeight; Row++)

	mov	DWORD PTR _Row$9[ebp], 0
	jmp	SHORT $LN7@CommonObje
$LN5@CommonObje:
	mov	edx, DWORD PTR _Row$9[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$9[ebp], edx
$LN7@CommonObje:
	mov	eax, DWORD PTR _Row$9[ebp]
	cmp	eax, DWORD PTR _TargetHeight$[ebp]
	jge	$LN6@CommonObje

; 201  :     {
; 202  :         int RowOffset = Row * TargetStride;

	mov	ecx, DWORD PTR _Row$9[ebp]
	imul	ecx, DWORD PTR _TargetStride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 203  :         for (int Column = 0; Column < TargetWidth; Column++)

	mov	DWORD PTR _Column$8[ebp], 0
	jmp	SHORT $LN10@CommonObje
$LN8@CommonObje:
	mov	edx, DWORD PTR _Column$8[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$8[ebp], edx
$LN10@CommonObje:
	mov	eax, DWORD PTR _Column$8[ebp]
	cmp	eax, DWORD PTR _TargetWidth$[ebp]
	jge	$LN9@CommonObje

; 204  :         {
; 205  :             int Index = (Column * PixelSize) + RowOffset;

	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _Column$8[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 206  :             //BGRA
; 207  :             double Final[] = { 0.0, 0.0, 0.0, 0.0 };

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp+8], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp+16], xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR _Final$1[ebp+24], xmm0

; 208  :             int OverlapCount = 0;

	mov	DWORD PTR _OverlapCount$7[ebp], 0

; 209  :             for (int OIndex = 0; OIndex < ObjectCount; OIndex++)

	mov	DWORD PTR _OIndex$11[ebp], 0
	jmp	SHORT $LN13@CommonObje
$LN11@CommonObje:
	mov	edx, DWORD PTR _OIndex$11[ebp]
	add	edx, 1
	mov	DWORD PTR _OIndex$11[ebp], edx
$LN13@CommonObje:
	mov	eax, DWORD PTR _OIndex$11[ebp]
	cmp	eax, DWORD PTR _ObjectCount$[ebp]
	jge	$LN12@CommonObje

; 210  :             {
; 211  :                 if (ObjectList[OIndex].ObjectAction == IgnoreObject)

	imul	ecx, DWORD PTR _OIndex$11[ebp], 36
	mov	edx, DWORD PTR _ObjectList$[ebp]
	cmp	DWORD PTR [edx+ecx], 2
	jne	SHORT $LN17@CommonObje

; 212  :                     continue;

	jmp	SHORT $LN11@CommonObje
$LN17@CommonObje:

; 213  :                 if (Row < ObjectList[OIndex].Top)

	imul	eax, DWORD PTR _OIndex$11[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _Row$9[ebp]
	cmp	edx, DWORD PTR [ecx+eax+24]
	jge	SHORT $LN18@CommonObje

; 214  :                     continue;

	jmp	SHORT $LN11@CommonObje
$LN18@CommonObje:

; 215  :                 if (Row > ObjectList[OIndex].Bottom)

	imul	eax, DWORD PTR _OIndex$11[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _Row$9[ebp]
	cmp	edx, DWORD PTR [ecx+eax+32]
	jle	SHORT $LN19@CommonObje

; 216  :                     continue;

	jmp	SHORT $LN11@CommonObje
$LN19@CommonObje:

; 217  :                 if (Column < ObjectList[OIndex].Left)

	imul	eax, DWORD PTR _OIndex$11[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _Column$8[ebp]
	cmp	edx, DWORD PTR [ecx+eax+20]
	jge	SHORT $LN20@CommonObje

; 218  :                     continue;

	jmp	SHORT $LN11@CommonObje
$LN20@CommonObje:

; 219  :                 if (Column > ObjectList[OIndex].Right)

	imul	eax, DWORD PTR _OIndex$11[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _Column$8[ebp]
	cmp	edx, DWORD PTR [ecx+eax+28]
	jle	SHORT $LN21@CommonObje

; 220  :                     continue;

	jmp	SHORT $LN11@CommonObje
$LN21@CommonObje:

; 221  :                 //BGRA
; 222  :                 int a = Row - ObjectList[OIndex].Left;

	imul	eax, DWORD PTR _OIndex$11[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _Row$9[ebp]
	sub	edx, DWORD PTR [ecx+eax+20]
	mov	DWORD PTR _a$2[ebp], edx

; 223  :                 int b = Column - ObjectList[OIndex].Top;

	imul	eax, DWORD PTR _OIndex$11[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _Column$8[ebp]
	sub	edx, DWORD PTR [ecx+eax+24]
	mov	DWORD PTR _b$3[ebp], edx

; 224  :                 int ObjectIndex = (b * ObjectList[OIndex].ObjectStride) + (a * PixelSize);

	imul	eax, DWORD PTR _OIndex$11[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _b$3[ebp]
	imul	edx, DWORD PTR [ecx+eax+16]
	movzx	eax, BYTE PTR _PixelSize$[ebp]
	imul	eax, DWORD PTR _a$2[ebp]
	add	edx, eax
	mov	DWORD PTR _ObjectIndex$6[ebp], edx

; 225  :                 Final[0] += (double) ((double) ObjectList[OIndex].ObjectBuffer[ObjectIndex + 0] / 255.0);

	mov	ecx, 8
	imul	edx, ecx, 0
	imul	eax, DWORD PTR _OIndex$11[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	eax, DWORD PTR [ecx+eax+4]
	mov	ecx, DWORD PTR _ObjectIndex$6[ebp]
	movzx	eax, BYTE PTR [eax+ecx]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	addsd	xmm0, QWORD PTR _Final$1[ebp+edx]
	mov	ecx, 8
	imul	edx, ecx, 0
	movsd	QWORD PTR _Final$1[ebp+edx], xmm0

; 226  :                 Final[1] += (double) ((double) ObjectList[OIndex].ObjectBuffer[ObjectIndex + 1] / 255.0);

	mov	eax, 8
	shl	eax, 0
	imul	ecx, DWORD PTR _OIndex$11[ebp], 36
	mov	edx, DWORD PTR _ObjectList$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	edx, DWORD PTR _ObjectIndex$6[ebp]
	movzx	ecx, BYTE PTR [ecx+edx+1]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	addsd	xmm0, QWORD PTR _Final$1[ebp+eax]
	mov	edx, 8
	shl	edx, 0
	movsd	QWORD PTR _Final$1[ebp+edx], xmm0

; 227  :                 Final[2] += (double) ((double) ObjectList[OIndex].ObjectBuffer[ObjectIndex + 2] / 255.0);

	mov	eax, 8
	shl	eax, 1
	imul	ecx, DWORD PTR _OIndex$11[ebp], 36
	mov	edx, DWORD PTR _ObjectList$[ebp]
	mov	ecx, DWORD PTR [edx+ecx+4]
	mov	edx, DWORD PTR _ObjectIndex$6[ebp]
	movzx	ecx, BYTE PTR [ecx+edx+2]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	addsd	xmm0, QWORD PTR _Final$1[ebp+eax]
	mov	edx, 8
	shl	edx, 1
	movsd	QWORD PTR _Final$1[ebp+edx], xmm0

; 228  :                 Final[3] += (double) ((double) ObjectList[OIndex].ObjectBuffer[ObjectIndex + 3] / 255.0);

	mov	eax, 8
	imul	ecx, eax, 3
	imul	edx, DWORD PTR _OIndex$11[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR [eax+edx+4]
	mov	eax, DWORD PTR _ObjectIndex$6[ebp]
	movzx	edx, BYTE PTR [edx+eax+3]
	cvtsi2sd xmm0, edx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	addsd	xmm0, QWORD PTR _Final$1[ebp+ecx]
	mov	eax, 8
	imul	ecx, eax, 3
	movsd	QWORD PTR _Final$1[ebp+ecx], xmm0

; 229  :             }

	jmp	$LN11@CommonObje
$LN12@CommonObje:

; 230  :             if (OverlapCount > 0)

	cmp	DWORD PTR _OverlapCount$7[ebp], 0
	jle	$LN22@CommonObje

; 231  :             {
; 232  :                 //Merge/blend the pixels.
; 233  :                 Final[0] /= OverlapCount;

	mov	edx, 8
	imul	eax, edx, 0
	cvtsi2sd xmm0, DWORD PTR _OverlapCount$7[ebp]
	movsd	xmm1, QWORD PTR _Final$1[ebp+eax]
	divsd	xmm1, xmm0
	mov	ecx, 8
	imul	edx, ecx, 0
	movsd	QWORD PTR _Final$1[ebp+edx], xmm1

; 234  :                 Final[1] /= OverlapCount;

	mov	eax, 8
	shl	eax, 0
	cvtsi2sd xmm0, DWORD PTR _OverlapCount$7[ebp]
	movsd	xmm1, QWORD PTR _Final$1[ebp+eax]
	divsd	xmm1, xmm0
	mov	ecx, 8
	shl	ecx, 0
	movsd	QWORD PTR _Final$1[ebp+ecx], xmm1

; 235  :                 Final[2] /= OverlapCount;

	mov	edx, 8
	shl	edx, 1
	cvtsi2sd xmm0, DWORD PTR _OverlapCount$7[ebp]
	movsd	xmm1, QWORD PTR _Final$1[ebp+edx]
	divsd	xmm1, xmm0
	mov	eax, 8
	shl	eax, 1
	movsd	QWORD PTR _Final$1[ebp+eax], xmm1

; 236  :                 Final[3] /= OverlapCount;

	mov	ecx, 8
	imul	edx, ecx, 3
	cvtsi2sd xmm0, DWORD PTR _OverlapCount$7[ebp]
	movsd	xmm1, QWORD PTR _Final$1[ebp+edx]
	divsd	xmm1, xmm0
	mov	eax, 8
	imul	ecx, eax, 3
	movsd	QWORD PTR _Final$1[ebp+ecx], xmm1

; 237  :                 BYTE FinalB = (Final[0] * 255.0);

	mov	edx, 8
	imul	eax, edx, 0
	movsd	xmm0, QWORD PTR _Final$1[ebp+eax]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _FinalB$15[ebp], cl

; 238  :                 BYTE FinalG = (Final[1] * 255.0);

	mov	edx, 8
	shl	edx, 0
	movsd	xmm0, QWORD PTR _Final$1[ebp+edx]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si eax, xmm0
	mov	BYTE PTR _FinalG$14[ebp], al

; 239  :                 BYTE FinalR = (Final[2] * 255.0);

	mov	ecx, 8
	shl	ecx, 1
	movsd	xmm0, QWORD PTR _Final$1[ebp+ecx]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si edx, xmm0
	mov	BYTE PTR _FinalR$13[ebp], dl

; 240  :                 BYTE FinalA = (Final[3] * 255.0);

	mov	eax, 8
	imul	ecx, eax, 3
	movsd	xmm0, QWORD PTR _Final$1[ebp+ecx]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si edx, xmm0
	mov	BYTE PTR _FinalA$12[ebp], dl

; 241  :                 Target[Index + 0] = FinalB;

	mov	eax, DWORD PTR _Target$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _FinalB$15[ebp]
	mov	BYTE PTR [eax], cl

; 242  :                 Target[Index + 1] = FinalG;

	mov	edx, DWORD PTR _Target$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR _FinalG$14[ebp]
	mov	BYTE PTR [edx+1], al

; 243  :                 Target[Index + 2] = FinalR;

	mov	ecx, DWORD PTR _Target$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR _FinalR$13[ebp]
	mov	BYTE PTR [ecx+2], dl

; 244  :                 Target[Index + 3] = FinalA;

	mov	eax, DWORD PTR _Target$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR _FinalA$12[ebp]
	mov	BYTE PTR [eax+3], cl
$LN22@CommonObje:

; 245  :             }
; 246  :         }

	jmp	$LN8@CommonObje
$LN9@CommonObje:

; 247  :     }

	jmp	$LN5@CommonObje
$LN6@CommonObje:

; 248  : 
; 249  :     return Success;

	xor	eax, eax
$LN1@CommonObje:

; 250  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?CommonObjectRenderer@@YGHPAEHHHPAUCommonObject@@H@Z ENDP ; CommonObjectRenderer
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\commonrenderer.cpp
_TEXT	SEGMENT
_YPlot$1 = -36						; size = 4
_temp$2 = -32						; size = 4
$T3 = -28						; size = 4
_DeltaY$ = -24						; size = 4
_Index$4 = -20						; size = 4
_DeltaX$ = -16						; size = 4
_XPlot$5 = -12						; size = 4
_A$ = -5						; size = 1
_R$ = -4						; size = 1
_G$ = -3						; size = 1
_B$ = -2						; size = 1
_PixelSize$ = -1					; size = 1
_Parameters$ = 8					; size = 4
_RenderTo$ = 12						; size = 4
?RenderLinePlot@@YGHPAULinePlotParameters@@PAUCommonObject@@@Z PROC ; RenderLinePlot

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 128  :     if (Parameters == NULL)

	cmp	DWORD PTR _Parameters$[ebp], 0
	jne	SHORT $LN5@RenderLine

; 129  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderLine
$LN5@RenderLine:

; 130  :     if (RenderTo == NULL)

	cmp	DWORD PTR _RenderTo$[ebp], 0
	jne	SHORT $LN6@RenderLine

; 131  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderLine
$LN6@RenderLine:

; 132  : 
; 133  :     RenderTo->Left = Parameters->X1;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+20], edx

; 134  :     RenderTo->Top = Parameters->Y1;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+24], edx

; 135  :     RenderTo->Right = Parameters->X2;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+28], edx

; 136  :     RenderTo->Bottom = Parameters->Y2;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+32], edx

; 137  :     BYTE B = (BYTE) ((Parameters->LineColor & 0xff000000) >> 24);

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _B$[ebp], cl

; 138  :     BYTE G = (BYTE) ((Parameters->LineColor & 0x00ff0000) >> 16);

	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [edx+16]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _G$[ebp], al

; 139  :     BYTE R = (BYTE) ((Parameters->LineColor & 0x0000ff00) >> 8);

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _R$[ebp], dl

; 140  :     BYTE A = (BYTE) ((Parameters->LineColor & 0x000000ff) >> 0);

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _A$[ebp], cl

; 141  :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 142  : 
; 143  :     __int32 DeltaX = Parameters->X2 - Parameters->X1;

	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR _DeltaX$[ebp], ecx

; 144  :     __int32 DeltaY = Parameters->Y2 - Parameters->Y1;

	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _DeltaY$[ebp], ecx

; 145  :     RenderTo->ObjectBuffer = new byte[DeltaX * DeltaY * 4];

	mov	edx, DWORD PTR _DeltaX$[ebp]
	imul	edx, DWORD PTR _DeltaY$[ebp]
	shl	edx, 2
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	DWORD PTR [eax+4], ecx

; 146  :     RenderTo->ObjectHeight = DeltaY;

	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	eax, DWORD PTR _DeltaY$[ebp]
	mov	DWORD PTR [edx+12], eax

; 147  :     RenderTo->ObjectWidth = DeltaX;

	mov	ecx, DWORD PTR _RenderTo$[ebp]
	mov	edx, DWORD PTR _DeltaX$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 148  :     RenderTo->ObjectStride = RenderTo->ObjectWidth * PixelSize;

	movzx	eax, BYTE PTR _PixelSize$[ebp]
	mov	ecx, DWORD PTR _RenderTo$[ebp]
	imul	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	DWORD PTR [edx+16], eax

; 149  :     if (Parameters->X1 > Parameters->X2)

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+8]
	jle	SHORT $LN7@RenderLine

; 150  :     {
; 151  :         __int32 temp = Parameters->X2;

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _temp$2[ebp], ecx

; 152  :         Parameters->X2 = Parameters->X1;

	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], ecx

; 153  :         Parameters->X1 = temp;

	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR _temp$2[ebp]
	mov	DWORD PTR [edx], eax
$LN7@RenderLine:

; 154  :     }
; 155  : 
; 156  :     for (int XPlot = 0; XPlot < DeltaX; XPlot++)

	mov	DWORD PTR _XPlot$5[ebp], 0
	jmp	SHORT $LN4@RenderLine
$LN2@RenderLine:
	mov	ecx, DWORD PTR _XPlot$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _XPlot$5[ebp], ecx
$LN4@RenderLine:
	mov	edx, DWORD PTR _XPlot$5[ebp]
	cmp	edx, DWORD PTR _DeltaX$[ebp]
	jge	SHORT $LN3@RenderLine

; 157  :     {
; 158  :         int YPlot = DeltaY * (XPlot / DeltaX);

	mov	eax, DWORD PTR _XPlot$5[ebp]
	cdq
	idiv	DWORD PTR _DeltaX$[ebp]
	imul	eax, DWORD PTR _DeltaY$[ebp]
	mov	DWORD PTR _YPlot$1[ebp], eax

; 159  :         int Index = (YPlot - 1) * RenderTo->ObjectStride;

	mov	eax, DWORD PTR _YPlot$1[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _RenderTo$[ebp]
	imul	eax, DWORD PTR [ecx+16]
	mov	DWORD PTR _Index$4[ebp], eax

; 160  :         RenderTo->ObjectBuffer[Index + 0] = B;

	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 161  :         RenderTo->ObjectBuffer[Index + 1] = G;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _G$[ebp]
	mov	BYTE PTR [ecx+edx+1], al

; 162  :         RenderTo->ObjectBuffer[Index + 2] = R;

	mov	ecx, DWORD PTR _RenderTo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _R$[ebp]
	mov	BYTE PTR [edx+eax+2], cl

; 163  :         RenderTo->ObjectBuffer[Index + 3] = A;

	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [eax+ecx+3], dl

; 164  :     }

	jmp	SHORT $LN2@RenderLine
$LN3@RenderLine:

; 165  : 
; 166  :     return Success;

	xor	eax, eax
$LN1@RenderLine:

; 167  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RenderLinePlot@@YGHPAULinePlotParameters@@PAUCommonObject@@@Z ENDP ; RenderLinePlot
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\commonrenderer.cpp
_TEXT	SEGMENT
_RowOffset$1 = -24					; size = 4
$T2 = -20						; size = 4
_Index$3 = -16						; size = 4
_Column$4 = -12						; size = 4
_Row$5 = -8						; size = 4
_A$ = -4						; size = 1
_R$ = -3						; size = 1
_G$ = -2						; size = 1
_B$ = -1						; size = 1
_Parameters$ = 8					; size = 4
_RenderTo$ = 12						; size = 4
?RenderColorBlock@@YGHPAUColorBlockParameters@@PAUCommonObject@@@Z PROC ; RenderColorBlock

; 93   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 94   :     if (Parameters == NULL)

	cmp	DWORD PTR _Parameters$[ebp], 0
	jne	SHORT $LN8@RenderColo

; 95   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderColo
$LN8@RenderColo:

; 96   :     if (RenderTo == NULL)

	cmp	DWORD PTR _RenderTo$[ebp], 0
	jne	SHORT $LN9@RenderColo

; 97   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderColo
$LN9@RenderColo:

; 98   : 
; 99   :     RenderTo->Left = Parameters->X1;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+20], edx

; 100  :     RenderTo->Top = Parameters->Y1;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+24], edx

; 101  :     RenderTo->Right = RenderTo->Left + RenderTo->ObjectWidth;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _RenderTo$[ebp]
	add	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 102  :     RenderTo->Bottom = RenderTo->Top + RenderTo->ObjectHeight;

	mov	ecx, DWORD PTR _RenderTo$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _RenderTo$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _RenderTo$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 103  :     BYTE B = (BYTE) ((Parameters->BGColor & 0xff000000) >> 24);

	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [edx+20]
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	BYTE PTR _B$[ebp], al

; 104  :     BYTE G = (BYTE) ((Parameters->BGColor & 0x00ff0000) >> 16);

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	BYTE PTR _G$[ebp], dl

; 105  :     BYTE R = (BYTE) ((Parameters->BGColor & 0x0000ff00) >> 8);

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _R$[ebp], cl

; 106  :     BYTE A = (BYTE) ((Parameters->BGColor & 0x000000ff) >> 0);

	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [edx+20]
	and	eax, 255				; 000000ffH
	mov	BYTE PTR _A$[ebp], al

; 107  : 
; 108  :     RenderTo->ObjectBuffer = new byte[Parameters->Width * Parameters->Height * 4];

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	imul	eax, DWORD PTR [edx+12]
	shl	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR _RenderTo$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+4], edx

; 109  : 
; 110  :     for (int Row = 0; Row < Parameters->Height; Row++)

	mov	DWORD PTR _Row$5[ebp], 0
	jmp	SHORT $LN4@RenderColo
$LN2@RenderColo:
	mov	eax, DWORD PTR _Row$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$5[ebp], eax
$LN4@RenderColo:
	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR _Row$5[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jge	SHORT $LN3@RenderColo

; 111  :     {
; 112  :         int RowOffset = Row * (Parameters->Width * 4);

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 2
	imul	ecx, DWORD PTR _Row$5[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 113  :         for (int Column = 0; Column < Parameters->Width; Column++)

	mov	DWORD PTR _Column$4[ebp], 0
	jmp	SHORT $LN7@RenderColo
$LN5@RenderColo:
	mov	edx, DWORD PTR _Column$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$4[ebp], edx
$LN7@RenderColo:
	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR _Column$4[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jge	SHORT $LN6@RenderColo

; 114  :         {
; 115  :             int Index = RowOffset + (Column * 4);

	mov	edx, DWORD PTR _Column$4[ebp]
	mov	eax, DWORD PTR _RowOffset$1[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _Index$3[ebp], ecx

; 116  :             RenderTo->ObjectBuffer[Index + 0] = B;

	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _Index$3[ebp]
	mov	dl, BYTE PTR _B$[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 117  :             RenderTo->ObjectBuffer[Index + 1] = G;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _Index$3[ebp]
	mov	al, BYTE PTR _G$[ebp]
	mov	BYTE PTR [ecx+edx+1], al

; 118  :             RenderTo->ObjectBuffer[Index + 2] = R;

	mov	ecx, DWORD PTR _RenderTo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _Index$3[ebp]
	mov	cl, BYTE PTR _R$[ebp]
	mov	BYTE PTR [edx+eax+2], cl

; 119  :             RenderTo->ObjectBuffer[Index + 3] = A;

	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _Index$3[ebp]
	mov	dl, BYTE PTR _A$[ebp]
	mov	BYTE PTR [eax+ecx+3], dl

; 120  :         }

	jmp	SHORT $LN5@RenderColo
$LN6@RenderColo:

; 121  :     }

	jmp	$LN2@RenderColo
$LN3@RenderColo:

; 122  : 
; 123  :     return Success;

	xor	eax, eax
$LN1@RenderColo:

; 124  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RenderColorBlock@@YGHPAUColorBlockParameters@@PAUCommonObject@@@Z ENDP ; RenderColorBlock
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\commonrenderer.cpp
_TEXT	SEGMENT
_Dist$1 = -64						; size = 8
_Percent$2 = -56					; size = 8
_AlphaDelta$ = -48					; size = 4
_CenterX$ = -44						; size = 4
_CenterY$ = -40						; size = 4
_RowOffset$3 = -36					; size = 4
$T4 = -32						; size = 4
_Radius$ = -28						; size = 4
_Column$5 = -24						; size = 4
_Row$6 = -20						; size = 4
_Index$7 = -16						; size = 4
_iR$ = -9						; size = 1
_iG$ = -8						; size = 1
_iB$ = -7						; size = 1
_CenterAlpha$ = -6					; size = 1
_CenterBlue$ = -5					; size = 1
_CenterGreen$ = -4					; size = 1
_CenterRed$ = -3					; size = 1
_iA$8 = -2						; size = 1
_PixelSize$ = -1					; size = 1
_Parameters$ = 8					; size = 4
_RenderTo$ = 12						; size = 4
?RenderColorBlobEx@@YGHPAUColorBlobParameters@@PAUCommonObject@@@Z PROC ; RenderColorBlobEx

; 10   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 11   :     if (Parameters == NULL)

	cmp	DWORD PTR _Parameters$[ebp], 0
	jne	SHORT $LN8@RenderColo

; 12   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderColo
$LN8@RenderColo:

; 13   :     if (RenderTo == NULL)

	cmp	DWORD PTR _RenderTo$[ebp], 0
	jne	SHORT $LN9@RenderColo

; 14   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderColo
$LN9@RenderColo:

; 15   : 
; 16   :     BYTE CenterBlue = (BYTE) ((Parameters->BlobColor & 0xff000000) >> 24);

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _CenterBlue$[ebp], cl

; 17   :     BYTE CenterGreen = (BYTE) ((Parameters->BlobColor & 0x00ff0000) >> 16);

	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [edx+16]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _CenterGreen$[ebp], al

; 18   :     BYTE CenterRed = (BYTE) ((Parameters->BlobColor & 0x0000ff00) >> 8);

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	BYTE PTR _CenterRed$[ebp], dl

; 19   :     BYTE CenterAlpha = (BYTE) ((Parameters->BlobColor & 0x000000ff) >> 0);

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _CenterAlpha$[ebp], cl

; 20   :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 21   :     RenderTo->Left = Parameters->X1;

	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+20], ecx

; 22   :     RenderTo->Top = Parameters->Y1;

	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+24], ecx

; 23   :     RenderTo->Right = RenderTo->Left + Parameters->Width;

	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _Parameters$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	DWORD PTR [edx+28], eax

; 24   :     RenderTo->Bottom = RenderTo->Top + Parameters->Height;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR _Parameters$[ebp]
	add	ecx, DWORD PTR [edx+12]
	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 25   :     RenderTo->ObjectBuffer = new byte[Parameters->Width * Parameters->Height * PixelSize];

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	imul	eax, DWORD PTR [edx+12]
	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR [edx+4], eax

; 26   :     memchr(RenderTo->ObjectBuffer, 0xff, Parameters->Width * Parameters->Height * PixelSize);

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	imul	eax, DWORD PTR [edx+12]
	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	eax, ecx
	push	eax
	push	255					; 000000ffH
	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?memchr@@YAPAXPAXHI@Z			; memchr
	add	esp, 12					; 0000000cH

; 27   :     int Radius = Parameters->Width / 2;

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _Radius$[ebp], eax

; 28   :     int AlphaDelta = (abs (Parameters->CenterAlpha - Parameters->EdgeAlpha));

	mov	edx, DWORD PTR _Parameters$[ebp]
	movzx	eax, BYTE PTR [edx+20]
	mov	ecx, DWORD PTR _Parameters$[ebp]
	movzx	edx, BYTE PTR [ecx+21]
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _AlphaDelta$[ebp], eax

; 29   :     int CenterX = Parameters->Width / 2;

	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [eax+8]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _CenterX$[ebp], eax

; 30   :     int CenterY = Parameters->Height / 2;

	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _CenterY$[ebp], eax

; 31   : 
; 32   :     BYTE iR = CenterRed;

	mov	dl, BYTE PTR _CenterRed$[ebp]
	mov	BYTE PTR _iR$[ebp], dl

; 33   :     BYTE iG = CenterGreen;

	mov	al, BYTE PTR _CenterGreen$[ebp]
	mov	BYTE PTR _iG$[ebp], al

; 34   :     BYTE iB = CenterBlue;

	mov	cl, BYTE PTR _CenterBlue$[ebp]
	mov	BYTE PTR _iB$[ebp], cl

; 35   : 
; 36   :     for (int Row = 0; Row < Parameters->Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@RenderColo
$LN2@RenderColo:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@RenderColo:
	mov	eax, DWORD PTR _Parameters$[ebp]
	mov	ecx, DWORD PTR _Row$6[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	$LN3@RenderColo

; 37   :     {
; 38   :         int RowOffset = Row * (Parameters->Width * PixelSize);

	movzx	edx, BYTE PTR _PixelSize$[ebp]
	mov	eax, DWORD PTR _Parameters$[ebp]
	imul	edx, DWORD PTR [eax+8]
	imul	edx, DWORD PTR _Row$6[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], edx

; 39   :         for (int Column = 0; Column < Parameters->Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@RenderColo
$LN5@RenderColo:
	mov	ecx, DWORD PTR _Column$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$5[ebp], ecx
$LN7@RenderColo:
	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	$LN6@RenderColo

; 40   :         {
; 41   :             int Index = RowOffset + (Column * PixelSize);

	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _Column$5[ebp]
	add	ecx, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 42   :             if ((Row == 0) || (Row == Parameters->Height - 1))

	cmp	DWORD PTR _Row$6[ebp], 0
	je	SHORT $LN11@RenderColo
	mov	edx, DWORD PTR _Parameters$[ebp]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 1
	cmp	DWORD PTR _Row$6[ebp], eax
	jne	SHORT $LN10@RenderColo
$LN11@RenderColo:

; 43   :             {
; 44   :                 RenderTo->ObjectBuffer[Index + 0] = 0x0;

	mov	ecx, DWORD PTR _RenderTo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [edx+eax], 0

; 45   :                 RenderTo->ObjectBuffer[Index + 1] = 0x0;

	mov	ecx, DWORD PTR _RenderTo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [edx+eax+1], 0

; 46   :                 RenderTo->ObjectBuffer[Index + 2] = 0x0;

	mov	ecx, DWORD PTR _RenderTo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [edx+eax+2], 0

; 47   :                 RenderTo->ObjectBuffer[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _RenderTo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [edx+eax+3], 255		; 000000ffH

; 48   :                 continue;

	jmp	SHORT $LN5@RenderColo
$LN10@RenderColo:

; 49   :             }
; 50   :             if ((Column == 0) || (Column == Parameters->Width - 1))

	cmp	DWORD PTR _Column$5[ebp], 0
	je	SHORT $LN13@RenderColo
	mov	ecx, DWORD PTR _Parameters$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 1
	cmp	DWORD PTR _Column$5[ebp], edx
	jne	SHORT $LN12@RenderColo
$LN13@RenderColo:

; 51   :             {
; 52   :                 RenderTo->ObjectBuffer[Index + 0] = 0x0;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [ecx+edx], 0

; 53   :                 RenderTo->ObjectBuffer[Index + 1] = 0x0;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [ecx+edx+1], 0

; 54   :                 RenderTo->ObjectBuffer[Index + 2] = 0x0;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [ecx+edx+2], 0

; 55   :                 RenderTo->ObjectBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _Index$7[ebp]
	mov	BYTE PTR [ecx+edx+3], 255		; 000000ffH

; 56   :                 continue;

	jmp	$LN5@RenderColo
$LN12@RenderColo:

; 57   :             }
; 58   : 
; 59   :             BYTE iA = 0x0;

	mov	BYTE PTR _iA$8[ebp], 0

; 60   : 
; 61   :             double Dist = Distance (Column, Row, CenterX, CenterY);

	mov	eax, DWORD PTR _CenterY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CenterX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Row$6[ebp]
	push	edx
	mov	eax, DWORD PTR _Column$5[ebp]
	push	eax
	call	?Distance@@YGNHHHH@Z			; Distance
	fstp	QWORD PTR _Dist$1[ebp]

; 62   :             if (Dist > Radius)

	cvtsi2sd xmm0, DWORD PTR _Radius$[ebp]
	movsd	xmm1, QWORD PTR _Dist$1[ebp]
	comisd	xmm1, xmm0
	jbe	SHORT $LN14@RenderColo

; 63   :             {
; 64   :                 //RenderTo->ObjectBuffer[Index + 0] = 0x0;
; 65   :                 //RenderTo->ObjectBuffer[Index + 1] = 0x0;
; 66   :                 //RenderTo->ObjectBuffer[Index + 2] = 0x0;
; 67   :                 //RenderTo->ObjectBuffer[Index + 3] = 0x0;
; 68   :                 continue;

	jmp	$LN5@RenderColo
$LN14@RenderColo:

; 69   :             }
; 70   : //                continue;
; 71   :             if (Dist == 0)

	movsd	xmm0, QWORD PTR _Dist$1[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN15@RenderColo

; 72   :                 iA = CenterAlpha;

	mov	cl, BYTE PTR _CenterAlpha$[ebp]
	mov	BYTE PTR _iA$8[ebp], cl

; 73   :             else

	jmp	SHORT $LN16@RenderColo
$LN15@RenderColo:

; 74   :             {
; 75   :                 double Percent = Dist / Radius;

	cvtsi2sd xmm0, DWORD PTR _Radius$[ebp]
	movsd	xmm1, QWORD PTR _Dist$1[ebp]
	divsd	xmm1, xmm0
	movsd	QWORD PTR _Percent$2[ebp], xmm1

; 76   :                 Percent = 1.0 - Percent;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	subsd	xmm0, QWORD PTR _Percent$2[ebp]
	movsd	QWORD PTR _Percent$2[ebp], xmm0

; 77   :                 if (Percent < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _Percent$2[ebp]
	jbe	SHORT $LN17@RenderColo

; 78   :                     Percent = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Percent$2[ebp], xmm0
$LN17@RenderColo:

; 79   :                 iA = (BYTE) (Percent * (double) AlphaDelta);

	cvtsi2sd xmm0, DWORD PTR _AlphaDelta$[ebp]
	mulsd	xmm0, QWORD PTR _Percent$2[ebp]
	cvttsd2si edx, xmm0
	mov	BYTE PTR _iA$8[ebp], dl
$LN16@RenderColo:

; 80   :             }
; 81   : 
; 82   :             RenderTo->ObjectBuffer[Index + 0] = iB;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _iB$[ebp]
	mov	BYTE PTR [ecx+edx], al

; 83   :             RenderTo->ObjectBuffer[Index + 1] = iG;

	mov	ecx, DWORD PTR _RenderTo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _iG$[ebp]
	mov	BYTE PTR [edx+eax+1], cl

; 84   :             RenderTo->ObjectBuffer[Index + 2] = iR;

	mov	edx, DWORD PTR _RenderTo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _iR$[ebp]
	mov	BYTE PTR [eax+ecx+2], dl

; 85   :             RenderTo->ObjectBuffer[Index + 3] = iA;

	mov	eax, DWORD PTR _RenderTo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _iA$8[ebp]
	mov	BYTE PTR [ecx+edx+3], al

; 86   :         }

	jmp	$LN5@RenderColo
$LN6@RenderColo:

; 87   :     }

	jmp	$LN2@RenderColo
$LN3@RenderColo:

; 88   : 
; 89   :     return Success;

	xor	eax, eax
$LN1@RenderColo:

; 90   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?RenderColorBlobEx@@YGHPAUColorBlobParameters@@PAUCommonObject@@@Z ENDP ; RenderColorBlobEx
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\commonrenderer.cpp
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
_IP$ = -40						; size = 4
_MAP$ = -36						; size = 4
_BCP$ = -32						; size = 4
tv80 = -28						; size = 4
_Buffer$ = -24						; size = 4
_LPP$ = -20						; size = 4
_CBP$ = -16						; size = 4
_CBBP$ = -12						; size = 4
_ObjectList$ = -8					; size = 4
_i$4 = -4						; size = 4
_Target$ = 8						; size = 4
_TargetWidth$ = 12					; size = 4
_TargetHeight$ = 16					; size = 4
_TargetStride$ = 20					; size = 4
_DisplayList$ = 24					; size = 4
_DisplayListCount$ = 28					; size = 4
_RenderDisplayList@24 PROC

; 468  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi

; 469  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN7@RenderDisp

; 470  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderDisp
$LN7@RenderDisp:

; 471  :     if (DisplayList == NULL)

	cmp	DWORD PTR _DisplayList$[ebp], 0
	jne	SHORT $LN8@RenderDisp

; 472  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RenderDisp
$LN8@RenderDisp:

; 473  :     if (DisplayListCount < 1)

	cmp	DWORD PTR _DisplayListCount$[ebp], 1
	jge	SHORT $LN9@RenderDisp

; 474  :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@RenderDisp
$LN9@RenderDisp:

; 475  : 
; 476  :     BYTE* Buffer = (BYTE *) Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 477  :     CommonObject *ObjectList = MakeObjectList (DisplayListCount);

	mov	ecx, DWORD PTR _DisplayListCount$[ebp]
	push	ecx
	call	?MakeObjectList@@YGPAUCommonObject@@H@Z	; MakeObjectList
	mov	DWORD PTR _ObjectList$[ebp], eax

; 478  : 
; 479  :     ColorBlobParameters *CBBP = NULL;

	mov	DWORD PTR _CBBP$[ebp], 0

; 480  :     ColorBlockParameters *CBP = NULL;

	mov	DWORD PTR _CBP$[ebp], 0

; 481  :     LinePlotParameters *LPP = NULL;

	mov	DWORD PTR _LPP$[ebp], 0

; 482  :     BufferClearParameters *BCP = NULL;

	mov	DWORD PTR _BCP$[ebp], 0

; 483  :     MassAlphaParameters *MAP = NULL;

	mov	DWORD PTR _MAP$[ebp], 0

; 484  :     InversionParameters *IP = NULL;

	mov	DWORD PTR _IP$[ebp], 0

; 485  : 
; 486  :     for (int i = 0; i < DisplayListCount; i++)

	mov	DWORD PTR _i$4[ebp], 0
	jmp	SHORT $LN4@RenderDisp
$LN2@RenderDisp:
	mov	edx, DWORD PTR _i$4[ebp]
	add	edx, 1
	mov	DWORD PTR _i$4[ebp], edx
$LN4@RenderDisp:
	mov	eax, DWORD PTR _i$4[ebp]
	cmp	eax, DWORD PTR _DisplayListCount$[ebp]
	jge	$LN3@RenderDisp

; 487  :     {
; 488  :         ObjectList[i].ObjectAction = DisplayList[i].Operand;

	mov	ecx, DWORD PTR _i$4[ebp]
	shl	ecx, 4
	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	mov	esi, DWORD PTR _DisplayList$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx], ecx

; 489  :         switch (ObjectList[i].ObjectAction)

	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR tv80[ebp], ecx
	cmp	DWORD PTR tv80[ebp], 9
	ja	$LN20@RenderDisp
	mov	edx, DWORD PTR tv80[ebp]
	jmp	DWORD PTR $LN22@RenderDisp[edx*4]
$LN10@RenderDisp:

; 490  :         {
; 491  :             case NOP:
; 492  :                 break;

	jmp	$LN5@RenderDisp
$LN11@RenderDisp:

; 493  : 
; 494  :             case DrawColorBlob:
; 495  :                 CBBP = (ColorBlobParameters *) DisplayList[i].Parameters;

	mov	eax, DWORD PTR _i$4[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _DisplayList$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _CBBP$[ebp], edx

; 496  :                 ObjectList[i].Left = CBBP->X1;

	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _CBBP$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax+20], edx

; 497  :                 ObjectList[i].Top = CBBP->Y1;

	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _CBBP$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+eax+24], edx

; 498  :                 ObjectList[i].Right = CBBP->X1 + CBBP->Width;

	mov	eax, DWORD PTR _CBBP$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _CBBP$[ebp]
	add	ecx, DWORD PTR [edx+8]
	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	edx, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR [edx+eax+28], ecx

; 499  :                 ObjectList[i].Bottom = CBBP->Y1 + CBBP->Height;

	mov	eax, DWORD PTR _CBBP$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _CBBP$[ebp]
	add	ecx, DWORD PTR [edx+12]
	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	edx, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR [edx+eax+32], ecx

; 500  :                 ObjectList[i].ObjectHeight = CBBP->Height;

	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _CBBP$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+eax+12], edx

; 501  :                 ObjectList[i].ObjectWidth = CBBP->Width;

	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _CBBP$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+eax+8], edx

; 502  :                 ObjectList[i].ObjectStride = CBBP->Width * 4;

	mov	eax, DWORD PTR _CBBP$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 2
	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR [eax+edx+16], ecx

; 503  :                 ObjectList[i].ObjectBuffer = new byte[CBBP->Height * (CBBP->Width * 4)];

	mov	ecx, DWORD PTR _CBBP$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 2
	mov	eax, DWORD PTR _CBBP$[ebp]
	imul	edx, DWORD PTR [eax+12]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	imul	ecx, DWORD PTR _i$4[ebp], 36
	mov	edx, DWORD PTR _ObjectList$[ebp]
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [edx+ecx+4], eax

; 504  :                 RenderColorBlobEx (CBBP, &ObjectList[i]);

	imul	ecx, DWORD PTR _i$4[ebp], 36
	add	ecx, DWORD PTR _ObjectList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CBBP$[ebp]
	push	edx
	call	?RenderColorBlobEx@@YGHPAUColorBlobParameters@@PAUCommonObject@@@Z ; RenderColorBlobEx

; 505  :                 break;

	jmp	$LN5@RenderDisp
$LN12@RenderDisp:

; 506  : 
; 507  :             case DrawColorBlock:
; 508  :                 CBP = (ColorBlockParameters *) DisplayList[i].Parameters;

	mov	eax, DWORD PTR _i$4[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _DisplayList$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _CBP$[ebp], edx

; 509  :                 ObjectList[i].Left = CBP->X1;

	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _CBP$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax+20], edx

; 510  :                 ObjectList[i].Top = CBP->Y1;

	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _CBP$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+eax+24], edx

; 511  :                 ObjectList[i].ObjectHeight = CBP->Height;

	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _CBP$[ebp]
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+eax+12], edx

; 512  :                 ObjectList[i].ObjectWidth = CBP->Width;

	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _CBP$[ebp]
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+eax+8], edx

; 513  :                 ObjectList[i].Right = CBP->X1 + CBP->Width;

	mov	eax, DWORD PTR _CBP$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _CBP$[ebp]
	add	ecx, DWORD PTR [edx+8]
	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	edx, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR [edx+eax+28], ecx

; 514  :                 ObjectList[i].Bottom = CBP->Y1 + CBP->Height;

	mov	eax, DWORD PTR _CBP$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _CBP$[ebp]
	add	ecx, DWORD PTR [edx+12]
	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	edx, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR [edx+eax+32], ecx

; 515  :                 ObjectList[i].ObjectBuffer = new byte[(CBP->Height * CBP->Width * 4)];

	mov	eax, DWORD PTR _CBP$[ebp]
	mov	ecx, DWORD PTR _CBP$[ebp]
	mov	edx, DWORD PTR [eax+12]
	imul	edx, DWORD PTR [ecx+8]
	shl	edx, 2
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR [ecx+eax+4], edx

; 516  :                 ObjectList[i].ObjectStride = CBP->Width * 4;

	mov	eax, DWORD PTR _CBP$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 2
	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR [eax+edx+16], ecx

; 517  :                 RenderColorBlock (CBP, &ObjectList[i]);

	imul	ecx, DWORD PTR _i$4[ebp], 36
	add	ecx, DWORD PTR _ObjectList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _CBP$[ebp]
	push	edx
	call	?RenderColorBlock@@YGHPAUColorBlockParameters@@PAUCommonObject@@@Z ; RenderColorBlock

; 518  :                 break;

	jmp	$LN5@RenderDisp
$LN13@RenderDisp:

; 519  : 
; 520  :             case PlotLine:
; 521  :                 LPP = (LinePlotParameters *) DisplayList[i].Parameters;

	mov	eax, DWORD PTR _i$4[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _DisplayList$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _LPP$[ebp], edx

; 522  :                 ObjectList[i].Left = LPP->X1;

	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _LPP$[ebp]
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+eax+20], edx

; 523  :                 ObjectList[i].Top = LPP->Y1;

	imul	eax, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	edx, DWORD PTR _LPP$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+eax+24], edx

; 524  :                 ObjectList[i].ObjectHeight = abs (LPP->Y1 - LPP->Y2 + 1);

	mov	eax, DWORD PTR _LPP$[ebp]
	mov	ecx, DWORD PTR _LPP$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+12]
	add	eax, 1
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR [ecx+edx+12], eax

; 525  :                 ObjectList[i].ObjectWidth = abs (LPP->X1 - LPP->X2 + 1);

	mov	edx, DWORD PTR _LPP$[ebp]
	mov	eax, DWORD PTR _LPP$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	ecx, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR [ecx+edx+8], eax

; 526  :                 ObjectList[i].ObjectStride = ObjectList[i].ObjectWidth * 4;

	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	shl	ecx, 2
	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	mov	DWORD PTR [eax+edx+16], ecx

; 527  :                 ObjectList[i].ObjectBuffer = new byte[ObjectList[i].ObjectWidth * ObjectList[i].ObjectStride];

	imul	ecx, DWORD PTR _i$4[ebp], 36
	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	mov	esi, DWORD PTR _ObjectList$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+8]
	imul	ecx, DWORD PTR [esi+edx+16]
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [eax+edx+4], ecx

; 528  :                 ObjectList[i].Right = LPP->X2;

	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	mov	ecx, DWORD PTR _LPP$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+edx+28], ecx

; 529  :                 ObjectList[i].Bottom = LPP->Y2;

	imul	edx, DWORD PTR _i$4[ebp], 36
	mov	eax, DWORD PTR _ObjectList$[ebp]
	mov	ecx, DWORD PTR _LPP$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+edx+32], ecx

; 530  :                 RenderLinePlot (LPP, &ObjectList[i]);

	imul	edx, DWORD PTR _i$4[ebp], 36
	add	edx, DWORD PTR _ObjectList$[ebp]
	push	edx
	mov	eax, DWORD PTR _LPP$[ebp]
	push	eax
	call	?RenderLinePlot@@YGHPAULinePlotParameters@@PAUCommonObject@@@Z ; RenderLinePlot

; 531  :                 break;

	jmp	$LN5@RenderDisp
$LN14@RenderDisp:

; 532  : 
; 533  :             case DrawBackground:
; 534  :                 BCP = (BufferClearParameters *) DisplayList[i].Parameters;

	mov	ecx, DWORD PTR _i$4[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _DisplayList$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _BCP$[ebp], eax

; 535  :                 ClearRenderBuffer (Buffer, TargetWidth, TargetHeight, TargetStride, BCP);

	mov	ecx, DWORD PTR _BCP$[ebp]
	push	ecx
	mov	edx, DWORD PTR _TargetStride$[ebp]
	push	edx
	mov	eax, DWORD PTR _TargetHeight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _TargetWidth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Buffer$[ebp]
	push	edx
	call	?ClearRenderBuffer@@YGHPAEHHHPAUBufferClearParameters@@@Z ; ClearRenderBuffer

; 536  :                 break;

	jmp	SHORT $LN5@RenderDisp
$LN15@RenderDisp:

; 537  : 
; 538  :             case Debug:
; 539  :                 break;

	jmp	SHORT $LN5@RenderDisp
$LN16@RenderDisp:

; 540  : 
; 541  :             case ResizeBuffer:
; 542  :                 break;

	jmp	SHORT $LN5@RenderDisp
$LN17@RenderDisp:

; 543  : 
; 544  :             case CopyBuffer:
; 545  :                 break;

	jmp	SHORT $LN5@RenderDisp
$LN18@RenderDisp:

; 546  : 
; 547  :             case MassAlpha:
; 548  :                 MAP = (MassAlphaParameters *) DisplayList[i].Parameters;

	mov	eax, DWORD PTR _i$4[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _DisplayList$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _MAP$[ebp], edx

; 549  :                 UpdateBufferAlpha (Buffer, TargetWidth, TargetHeight, TargetStride, MAP);

	mov	eax, DWORD PTR _MAP$[ebp]
	push	eax
	mov	ecx, DWORD PTR _TargetStride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _TargetHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _TargetWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	call	?UpdateBufferAlpha@@YGHPAEHHHPAUMassAlphaParameters@@@Z ; UpdateBufferAlpha

; 550  :                 break;

	jmp	SHORT $LN5@RenderDisp
$LN19@RenderDisp:

; 551  : 
; 552  :             case InvertBuffer:
; 553  :                 IP = (InversionParameters*) DisplayList[i].Parameters;

	mov	edx, DWORD PTR _i$4[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _DisplayList$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _IP$[ebp], ecx

; 554  :                 InvertRenderBuffer (Buffer, TargetWidth, TargetHeight, TargetStride, IP);

	mov	edx, DWORD PTR _IP$[ebp]
	push	edx
	mov	eax, DWORD PTR _TargetStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _TargetHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _TargetWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Buffer$[ebp]
	push	eax
	call	?InvertRenderBuffer@@YGHPAEHHHPAUInversionParameters@@@Z ; InvertRenderBuffer

; 555  :                 break;

	jmp	SHORT $LN5@RenderDisp
$LN20@RenderDisp:

; 556  : 
; 557  :             default:
; 558  :                 return UnknownDisplayListOperand;

	mov	eax, 10					; 0000000aH
	jmp	SHORT $LN1@RenderDisp
$LN5@RenderDisp:

; 559  :         }
; 560  :     }

	jmp	$LN2@RenderDisp
$LN3@RenderDisp:

; 561  : 
; 562  :     CommonObjectRenderer (Buffer, TargetWidth, TargetHeight, TargetStride, ObjectList, DisplayListCount);

	mov	ecx, DWORD PTR _DisplayListCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ObjectList$[ebp]
	push	edx
	mov	eax, DWORD PTR _TargetStride$[ebp]
	push	eax
	mov	ecx, DWORD PTR _TargetHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _TargetWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _Buffer$[ebp]
	push	eax
	call	?CommonObjectRenderer@@YGHPAEHHHPAUCommonObject@@H@Z ; CommonObjectRenderer

; 563  : 
; 564  :     DeleteObjectList (ObjectList, DisplayListCount);

	mov	ecx, DWORD PTR _DisplayListCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ObjectList$[ebp]
	push	edx
	call	?DeleteObjectList@@YGXPAUCommonObject@@H@Z ; DeleteObjectList

; 565  : 
; 566  :     return Success;

	xor	eax, eax
$LN1@RenderDisp:

; 567  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	3
$LN22@RenderDisp:
	DD	$LN10@RenderDisp
	DD	$LN11@RenderDisp
	DD	$LN12@RenderDisp
	DD	$LN13@RenderDisp
	DD	$LN14@RenderDisp
	DD	$LN15@RenderDisp
	DD	$LN16@RenderDisp
	DD	$LN17@RenderDisp
	DD	$LN18@RenderDisp
	DD	$LN19@RenderDisp
_RenderDisplayList@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memory.h
;	COMDAT ?memchr@@YAPAXPAXHI@Z
_TEXT	SEGMENT
__Pvc$ = -4						; size = 4
__Pv$ = 8						; size = 4
__C$ = 12						; size = 4
__N$ = 16						; size = 4
?memchr@@YAPAXPAXHI@Z PROC				; memchr, COMDAT

; 105  :     {

	push	ebp
	mov	ebp, esp
	push	ecx

; 106  :         void const* const _Pvc = _Pv;

	mov	eax, DWORD PTR __Pv$[ebp]
	mov	DWORD PTR __Pvc$[ebp], eax

; 107  :         return const_cast<void*>(memchr(_Pvc, _C, _N));

	mov	ecx, DWORD PTR __N$[ebp]
	push	ecx
	mov	edx, DWORD PTR __C$[ebp]
	push	edx
	mov	eax, DWORD PTR __Pvc$[ebp]
	push	eax
	call	_memchr
	add	esp, 12					; 0000000cH

; 108  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
?memchr@@YAPAXPAXHI@Z ENDP				; memchr
_TEXT	ENDS
END
