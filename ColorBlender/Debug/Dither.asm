; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Dither.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_DoDither@28
PUBLIC	?FloydSteinbergDither@@YGHPAXHHH0PAEH@Z		; FloydSteinbergDither
PUBLIC	?FalseFloydSteinbergDither@@YGHPAXHHH0PAEH@Z	; FalseFloydSteinbergDither
PUBLIC	?AtkinsonDither@@YGHPAXHHH0PAEH@Z		; AtkinsonDither
PUBLIC	__real@3fb0000000000000
PUBLIC	__real@3fc0000000000000
PUBLIC	__real@3fc8000000000000
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@3fd4000000000000
PUBLIC	__real@3fd8000000000000
PUBLIC	__real@3fdc000000000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__fltused:DWORD
;	COMDAT __real@3fdc000000000000
CONST	SEGMENT
__real@3fdc000000000000 DQ 03fdc000000000000r	; 0.4375
CONST	ENDS
;	COMDAT __real@3fd8000000000000
CONST	SEGMENT
__real@3fd8000000000000 DQ 03fd8000000000000r	; 0.375
CONST	ENDS
;	COMDAT __real@3fd4000000000000
CONST	SEGMENT
__real@3fd4000000000000 DQ 03fd4000000000000r	; 0.3125
CONST	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@3fc8000000000000
CONST	SEGMENT
__real@3fc8000000000000 DQ 03fc8000000000000r	; 0.1875
CONST	ENDS
;	COMDAT __real@3fc0000000000000
CONST	SEGMENT
__real@3fc0000000000000 DQ 03fc0000000000000r	; 0.125
CONST	ENDS
;	COMDAT __real@3fb0000000000000
CONST	SEGMENT
__real@3fb0000000000000 DQ 03fb0000000000000r	; 0.0625
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\dither.cpp
_TEXT	SEGMENT
_Multiplier$ = -72					; size = 8
_Src$ = -64						; size = 4
_Dest$ = -60						; size = 4
_PixelSize$ = -56					; size = 4
_RowOffset$1 = -52					; size = 4
_Index5$2 = -48						; size = 4
_Index4$3 = -44						; size = 4
_Index3$4 = -40						; size = 4
_Index2$5 = -36						; size = 4
_Index1$6 = -32						; size = 4
_Index0$7 = -28						; size = 4
_Index$8 = -24						; size = 4
_GrayscalePixelSize$ = -20				; size = 4
_Row$9 = -16						; size = 4
_Column$10 = -12					; size = 4
_V5$11 = -6						; size = 1
_V4$12 = -5						; size = 1
_V3$13 = -4						; size = 1
_V2$14 = -3						; size = 1
_V1$15 = -2						; size = 1
_V0$16 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Scratch$ = 28						; size = 4
_AsGrayscale$ = 32					; size = 4
?AtkinsonDither@@YGHPAXHHH0PAEH@Z PROC			; AtkinsonDither

; 157  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 158  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@AtkinsonDi

; 159  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AtkinsonDi
$LN8@AtkinsonDi:

; 160  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@AtkinsonDi

; 161  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AtkinsonDi
$LN9@AtkinsonDi:

; 162  : 
; 163  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 164  :     int GrayscalePixelSize = 1;

	mov	DWORD PTR _GrayscalePixelSize$[ebp], 1

; 165  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 166  :     BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 167  :     const double Multiplier = 1.0 / 8.0;

	movsd	xmm0, QWORD PTR __real@3fc0000000000000
	movsd	QWORD PTR _Multiplier$[ebp], xmm0

; 168  : 
; 169  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$9[ebp], 0
	jmp	SHORT $LN4@AtkinsonDi
$LN2@AtkinsonDi:
	mov	edx, DWORD PTR _Row$9[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$9[ebp], edx
$LN4@AtkinsonDi:
	mov	eax, DWORD PTR _Row$9[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@AtkinsonDi

; 170  :     {
; 171  :         int RowOffset = Row * Width;

	mov	ecx, DWORD PTR _Row$9[ebp]
	imul	ecx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 172  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$10[ebp], 0
	jmp	SHORT $LN7@AtkinsonDi
$LN5@AtkinsonDi:
	mov	edx, DWORD PTR _Column$10[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$10[ebp], edx
$LN7@AtkinsonDi:
	mov	eax, DWORD PTR _Column$10[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@AtkinsonDi

; 173  :         {
; 174  :             int Index = (Column * GrayscalePixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$10[ebp]
	imul	ecx, DWORD PTR _GrayscalePixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$8[ebp], ecx

; 175  :             //
; 176  :             //          X      index0 index1
; 177  :             //   index2 index3 index4
; 178  :             //          index5
; 179  :             int Index0 = -1;

	mov	DWORD PTR _Index0$7[ebp], -1

; 180  :             int Index1 = -1;

	mov	DWORD PTR _Index1$6[ebp], -1

; 181  :             int Index2 = -1;

	mov	DWORD PTR _Index2$5[ebp], -1

; 182  :             int Index3 = -1;

	mov	DWORD PTR _Index3$4[ebp], -1

; 183  :             int Index4 = -1;

	mov	DWORD PTR _Index4$3[ebp], -1

; 184  :             int Index5 = -1;

	mov	DWORD PTR _Index5$2[ebp], -1

; 185  :             if (Column < Width - 1)

	mov	edx, DWORD PTR _Width$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _Column$10[ebp], edx
	jge	SHORT $LN10@AtkinsonDi

; 186  :             {
; 187  :                 Index0 = ((Column + 1) * GrayscalePixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$10[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _GrayscalePixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index0$7[ebp], eax
$LN10@AtkinsonDi:

; 188  : 
; 189  :             }
; 190  :             if (Column < Width - 2)

	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 2
	cmp	DWORD PTR _Column$10[ebp], ecx
	jge	SHORT $LN11@AtkinsonDi

; 191  :             {
; 192  :                 Index1 = ((Column + 2) * GrayscalePixelSize) + ((Row + 1) * Width);

	mov	edx, DWORD PTR _Column$10[ebp]
	add	edx, 2
	imul	edx, DWORD PTR _GrayscalePixelSize$[ebp]
	mov	eax, DWORD PTR _Row$9[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _Width$[ebp]
	add	edx, eax
	mov	DWORD PTR _Index1$6[ebp], edx
$LN11@AtkinsonDi:

; 193  :             }
; 194  :             if (Column > 0)

	cmp	DWORD PTR _Column$10[ebp], 0
	jle	SHORT $LN13@AtkinsonDi

; 195  :             {
; 196  :                 if (Row < Height - 1)

	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Row$9[ebp], ecx
	jge	SHORT $LN13@AtkinsonDi

; 197  :                     Index2 = ((Column - 1) * GrayscalePixelSize) + ((Row + 1) * Width);

	mov	edx, DWORD PTR _Column$10[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _GrayscalePixelSize$[ebp]
	mov	eax, DWORD PTR _Row$9[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _Width$[ebp]
	add	edx, eax
	mov	DWORD PTR _Index2$5[ebp], edx
$LN13@AtkinsonDi:

; 198  :             }
; 199  :             if (Row < Height - 1)

	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Row$9[ebp], ecx
	jge	SHORT $LN14@AtkinsonDi

; 200  :             {
; 201  :                 Index3 = ((Column + 0) * GrayscalePixelSize) + ((Row + 1) * Width);

	mov	edx, DWORD PTR _Column$10[ebp]
	imul	edx, DWORD PTR _GrayscalePixelSize$[ebp]
	mov	eax, DWORD PTR _Row$9[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _Width$[ebp]
	add	edx, eax
	mov	DWORD PTR _Index3$4[ebp], edx
$LN14@AtkinsonDi:

; 202  :             }
; 203  :             if (Column < Width - 1)

	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Column$10[ebp], ecx
	jge	SHORT $LN16@AtkinsonDi

; 204  :             {
; 205  :                 if (Row < Height - 1)

	mov	edx, DWORD PTR _Height$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _Row$9[ebp], edx
	jge	SHORT $LN16@AtkinsonDi

; 206  :                     Index4 = ((Column + 1)*GrayscalePixelSize) + ((Row + 1) * Width);

	mov	eax, DWORD PTR _Column$10[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _GrayscalePixelSize$[ebp]
	mov	ecx, DWORD PTR _Row$9[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _Width$[ebp]
	add	eax, ecx
	mov	DWORD PTR _Index4$3[ebp], eax
$LN16@AtkinsonDi:

; 207  :             }
; 208  :             if (Row < Height - 2)

	mov	edx, DWORD PTR _Height$[ebp]
	sub	edx, 2
	cmp	DWORD PTR _Row$9[ebp], edx
	jge	SHORT $LN17@AtkinsonDi

; 209  :             {
; 210  :                 Index5 = ((Column + 0) * GrayscalePixelSize) + ((Row + 2) * Width);

	mov	eax, DWORD PTR _Column$10[ebp]
	imul	eax, DWORD PTR _GrayscalePixelSize$[ebp]
	mov	ecx, DWORD PTR _Row$9[ebp]
	add	ecx, 2
	imul	ecx, DWORD PTR _Width$[ebp]
	add	eax, ecx
	mov	DWORD PTR _Index5$2[ebp], eax
$LN17@AtkinsonDi:

; 211  :             }
; 212  : 
; 213  :             if (Index0 > -1)

	cmp	DWORD PTR _Index0$7[ebp], -1
	jle	SHORT $LN18@AtkinsonDi

; 214  :             {
; 215  :                 BYTE V0 = (BYTE)((double)Scratch[Index] * Multiplier);

	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3fc0000000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _V0$16[ebp], cl

; 216  :                 Scratch[Index0] = (BYTE)((Scratch[Index0] + V0) & 0xff);

	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index0$7[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _V0$16[ebp]
	add	eax, ecx
	and	eax, 255				; 000000ffH
	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index0$7[ebp]
	mov	BYTE PTR [edx], al
$LN18@AtkinsonDi:

; 217  :             }
; 218  :             if (Index1 > -1)

	cmp	DWORD PTR _Index1$6[ebp], -1
	jle	SHORT $LN19@AtkinsonDi

; 219  :             {
; 220  :                 BYTE V1 = (BYTE)((double)Scratch[Index] * Multiplier);

	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR __real@3fc0000000000000
	cvttsd2si edx, xmm0
	mov	BYTE PTR _V1$15[ebp], dl

; 221  :                 Scratch[Index1] = (BYTE)((Scratch[Index1] + V1) & 0xff);

	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index1$6[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _V1$15[ebp]
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index1$6[ebp]
	mov	BYTE PTR [eax], cl
$LN19@AtkinsonDi:

; 222  :             }
; 223  :             if (Index2 > -1)

	cmp	DWORD PTR _Index2$5[ebp], -1
	jle	SHORT $LN20@AtkinsonDi

; 224  :             {
; 225  :                 BYTE V2 = (BYTE)((double)Scratch[Index] * Multiplier);

	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	movzx	edx, BYTE PTR [ecx]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR __real@3fc0000000000000
	cvttsd2si eax, xmm0
	mov	BYTE PTR _V2$14[ebp], al

; 226  :                 Scratch[Index2] = (BYTE)((Scratch[Index2] + V2) & 0xff);

	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index2$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _V2$14[ebp]
	add	edx, eax
	and	edx, 255				; 000000ffH
	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index2$5[ebp]
	mov	BYTE PTR [ecx], dl
$LN20@AtkinsonDi:

; 227  :             }
; 228  :             if (Index3 > -1)

	cmp	DWORD PTR _Index3$4[ebp], -1
	jle	SHORT $LN21@AtkinsonDi

; 229  :             {
; 230  :                 BYTE V3 = (BYTE)((double)Scratch[Index] * Multiplier);

	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3fc0000000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _V3$13[ebp], cl

; 231  :                 Scratch[Index3] = (BYTE)((Scratch[Index3] + V3) & 0xff);

	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index3$4[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _V3$13[ebp]
	add	eax, ecx
	and	eax, 255				; 000000ffH
	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index3$4[ebp]
	mov	BYTE PTR [edx], al
$LN21@AtkinsonDi:

; 232  :             }
; 233  :             if (Index4 > -1)

	cmp	DWORD PTR _Index4$3[ebp], -1
	jle	SHORT $LN22@AtkinsonDi

; 234  :             {
; 235  :                 BYTE V4 = (BYTE)((double)Scratch[Index] * Multiplier);

	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR __real@3fc0000000000000
	cvttsd2si edx, xmm0
	mov	BYTE PTR _V4$12[ebp], dl

; 236  :                 Scratch[Index4] = (BYTE)((Scratch[Index4] + V4) & 0xff);

	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index4$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _V4$12[ebp]
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index4$3[ebp]
	mov	BYTE PTR [eax], cl
$LN22@AtkinsonDi:

; 237  :             }
; 238  :             if (Index5 > -1)

	cmp	DWORD PTR _Index5$2[ebp], -1
	jle	SHORT $LN23@AtkinsonDi

; 239  :             {
; 240  :                 BYTE V5 = (BYTE)((double)Scratch[Index] * Multiplier);

	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	movzx	edx, BYTE PTR [ecx]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR __real@3fc0000000000000
	cvttsd2si eax, xmm0
	mov	BYTE PTR _V5$11[ebp], al

; 241  :                 Scratch[Index5] = (BYTE)((Scratch[Index5] + V5) & 0xff);

	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index5$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _V5$11[ebp]
	add	edx, eax
	and	edx, 255				; 000000ffH
	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index5$2[ebp]
	mov	BYTE PTR [ecx], dl
$LN23@AtkinsonDi:

; 242  :             }
; 243  :         }

	jmp	$LN5@AtkinsonDi
$LN6@AtkinsonDi:

; 244  :     }

	jmp	$LN2@AtkinsonDi
$LN3@AtkinsonDi:

; 245  : 
; 246  :     return Success;

	xor	eax, eax
$LN1@AtkinsonDi:

; 247  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?AtkinsonDither@@YGHPAXHHH0PAEH@Z ENDP			; AtkinsonDither
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\dither.cpp
_TEXT	SEGMENT
_Index2Mul$ = -72					; size = 8
_Index1Mul$ = -64					; size = 8
_Index0Mul$ = -56					; size = 8
_Src$ = -48						; size = 4
_Dest$ = -44						; size = 4
_PixelSize$ = -40					; size = 4
_RowOffset$1 = -36					; size = 4
_Index$2 = -32						; size = 4
_Index2$3 = -28						; size = 4
_Index1$4 = -24						; size = 4
_Index0$5 = -20						; size = 4
_GrayscalePixelSize$ = -16				; size = 4
_Row$6 = -12						; size = 4
_Column$7 = -8						; size = 4
_V2$8 = -3						; size = 1
_V1$9 = -2						; size = 1
_V0$10 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Scratch$ = 28						; size = 4
_AsGrayscale$ = 32					; size = 4
?FalseFloydSteinbergDither@@YGHPAXHHH0PAEH@Z PROC	; FalseFloydSteinbergDither

; 96   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 97   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@FalseFloyd

; 98   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@FalseFloyd
$LN8@FalseFloyd:

; 99   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@FalseFloyd

; 100  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@FalseFloyd
$LN9@FalseFloyd:

; 101  : 
; 102  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 103  :     int GrayscalePixelSize = 1;

	mov	DWORD PTR _GrayscalePixelSize$[ebp], 1

; 104  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 105  :     BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 106  :     const double Index0Mul = 3.0 / 8.0;

	movsd	xmm0, QWORD PTR __real@3fd8000000000000
	movsd	QWORD PTR _Index0Mul$[ebp], xmm0

; 107  :     const double Index1Mul = 2.0 / 8.0;

	movsd	xmm0, QWORD PTR __real@3fd0000000000000
	movsd	QWORD PTR _Index1Mul$[ebp], xmm0

; 108  :     const double Index2Mul = 3.0 / 8.0;

	movsd	xmm0, QWORD PTR __real@3fd8000000000000
	movsd	QWORD PTR _Index2Mul$[ebp], xmm0

; 109  : 
; 110  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@FalseFloyd
$LN2@FalseFloyd:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@FalseFloyd:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@FalseFloyd

; 111  :     {
; 112  :         int RowOffset = Row * Width;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 113  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$7[ebp], 0
	jmp	SHORT $LN7@FalseFloyd
$LN5@FalseFloyd:
	mov	edx, DWORD PTR _Column$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$7[ebp], edx
$LN7@FalseFloyd:
	mov	eax, DWORD PTR _Column$7[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@FalseFloyd

; 114  :         {
; 115  :             int Index = (Column * GrayscalePixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$7[ebp]
	imul	ecx, DWORD PTR _GrayscalePixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$2[ebp], ecx

; 116  :             //
; 117  :             //          X      index0
; 118  :             //          index2 index1
; 119  :             int Index0 = -1;

	mov	DWORD PTR _Index0$5[ebp], -1

; 120  :             int Index1 = -1;

	mov	DWORD PTR _Index1$4[ebp], -1

; 121  :             int Index2 = -1;

	mov	DWORD PTR _Index2$3[ebp], -1

; 122  :             if (Column < Width - 1)

	mov	edx, DWORD PTR _Width$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _Column$7[ebp], edx
	jge	SHORT $LN11@FalseFloyd

; 123  :             {
; 124  :                 Index0 = ((Column + 1) * GrayscalePixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$7[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _GrayscalePixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index0$5[ebp], eax

; 125  :                 if (Row < Height - 1)

	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Row$6[ebp], ecx
	jge	SHORT $LN11@FalseFloyd

; 126  :                     Index1 = ((Column + 1) * GrayscalePixelSize) + ((Row + 1) * Width);

	mov	edx, DWORD PTR _Column$7[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _GrayscalePixelSize$[ebp]
	mov	eax, DWORD PTR _Row$6[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _Width$[ebp]
	add	edx, eax
	mov	DWORD PTR _Index1$4[ebp], edx
$LN11@FalseFloyd:

; 127  :             }
; 128  :             if (Column > 0)

	cmp	DWORD PTR _Column$7[ebp], 0
	jle	SHORT $LN13@FalseFloyd

; 129  :             {
; 130  :                 if (Row < Height - 1)

	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Row$6[ebp], ecx
	jge	SHORT $LN13@FalseFloyd

; 131  :                     Index2 = ((Column + 0) * GrayscalePixelSize) + ((Row + 1) * Width);

	mov	edx, DWORD PTR _Column$7[ebp]
	imul	edx, DWORD PTR _GrayscalePixelSize$[ebp]
	mov	eax, DWORD PTR _Row$6[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _Width$[ebp]
	add	edx, eax
	mov	DWORD PTR _Index2$3[ebp], edx
$LN13@FalseFloyd:

; 132  :             }
; 133  : 
; 134  :             if (Index0 > -1)

	cmp	DWORD PTR _Index0$5[ebp], -1
	jle	SHORT $LN14@FalseFloyd

; 135  :             {
; 136  :                 BYTE V0 = (BYTE)((double)Scratch[Index] * Index0Mul);

	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index$2[ebp]
	movzx	edx, BYTE PTR [ecx]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR __real@3fd8000000000000
	cvttsd2si eax, xmm0
	mov	BYTE PTR _V0$10[ebp], al

; 137  :                 Scratch[Index0] = (BYTE)((Scratch[Index0] + V0) & 0xff);

	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index0$5[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _V0$10[ebp]
	add	edx, eax
	and	edx, 255				; 000000ffH
	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index0$5[ebp]
	mov	BYTE PTR [ecx], dl
$LN14@FalseFloyd:

; 138  :             }
; 139  :             if (Index1 > -1)

	cmp	DWORD PTR _Index1$4[ebp], -1
	jle	SHORT $LN15@FalseFloyd

; 140  :             {
; 141  :                 BYTE V1 = (BYTE)((double)Scratch[Index] * Index1Mul);

	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index$2[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3fd0000000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _V1$9[ebp], cl

; 142  :                 Scratch[Index1] = (BYTE)((Scratch[Index1] + V1) & 0xff);

	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index1$4[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _V1$9[ebp]
	add	eax, ecx
	and	eax, 255				; 000000ffH
	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index1$4[ebp]
	mov	BYTE PTR [edx], al
$LN15@FalseFloyd:

; 143  :             }
; 144  :             if (Index2 > -1)

	cmp	DWORD PTR _Index2$3[ebp], -1
	jle	SHORT $LN16@FalseFloyd

; 145  :             {
; 146  :                 BYTE V2 = (BYTE)((double)Scratch[Index] * Index2Mul);

	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index$2[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR __real@3fd8000000000000
	cvttsd2si edx, xmm0
	mov	BYTE PTR _V2$8[ebp], dl

; 147  :                 Scratch[Index2] = (BYTE)((Scratch[Index2] + V2) & 0xff);

	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index2$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _V2$8[ebp]
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index2$3[ebp]
	mov	BYTE PTR [eax], cl
$LN16@FalseFloyd:

; 148  :             }
; 149  :         }

	jmp	$LN5@FalseFloyd
$LN6@FalseFloyd:

; 150  :     }

	jmp	$LN2@FalseFloyd
$LN3@FalseFloyd:

; 151  : 
; 152  :     return Success;

	xor	eax, eax
$LN1@FalseFloyd:

; 153  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?FalseFloydSteinbergDither@@YGHPAXHHH0PAEH@Z ENDP	; FalseFloydSteinbergDither
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\dither.cpp
_TEXT	SEGMENT
_Index3Mul$ = -84					; size = 8
_Index2Mul$ = -76					; size = 8
_Index1Mul$ = -68					; size = 8
_Index0Mul$ = -60					; size = 8
_Src$ = -52						; size = 4
_Dest$ = -48						; size = 4
_PixelSize$ = -44					; size = 4
_RowOffset$1 = -40					; size = 4
_Index3$2 = -36						; size = 4
_Index$3 = -32						; size = 4
_Index2$4 = -28						; size = 4
_Index1$5 = -24						; size = 4
_Index0$6 = -20						; size = 4
_GrayscalePixelSize$ = -16				; size = 4
_Column$7 = -12						; size = 4
_Row$8 = -8						; size = 4
_V3$9 = -4						; size = 1
_V2$10 = -3						; size = 1
_V1$11 = -2						; size = 1
_V0$12 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Scratch$ = 28						; size = 4
_AsGrayscale$ = 32					; size = 4
?FloydSteinbergDither@@YGHPAXHHH0PAEH@Z PROC		; FloydSteinbergDither

; 23   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 24   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@FloydStein

; 25   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@FloydStein
$LN8@FloydStein:

; 26   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@FloydStein

; 27   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@FloydStein
$LN9@FloydStein:

; 28   : 
; 29   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 30   :     int GrayscalePixelSize = 1;

	mov	DWORD PTR _GrayscalePixelSize$[ebp], 1

; 31   :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 32   :     BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 33   :     const double Index0Mul = 7.0 / 16.0;

	movsd	xmm0, QWORD PTR __real@3fdc000000000000
	movsd	QWORD PTR _Index0Mul$[ebp], xmm0

; 34   :     const double Index1Mul = 1.0 / 16.0;

	movsd	xmm0, QWORD PTR __real@3fb0000000000000
	movsd	QWORD PTR _Index1Mul$[ebp], xmm0

; 35   :     const double Index2Mul = 3.0 / 16.0;

	movsd	xmm0, QWORD PTR __real@3fc8000000000000
	movsd	QWORD PTR _Index2Mul$[ebp], xmm0

; 36   :     const double Index3Mul = 5.0 / 16.0;

	movsd	xmm0, QWORD PTR __real@3fd4000000000000
	movsd	QWORD PTR _Index3Mul$[ebp], xmm0

; 37   : 
; 38   :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$8[ebp], 0
	jmp	SHORT $LN4@FloydStein
$LN2@FloydStein:
	mov	edx, DWORD PTR _Row$8[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$8[ebp], edx
$LN4@FloydStein:
	mov	eax, DWORD PTR _Row$8[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@FloydStein

; 39   :     {
; 40   :         int RowOffset = Row * Width;

	mov	ecx, DWORD PTR _Row$8[ebp]
	imul	ecx, DWORD PTR _Width$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 41   :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$7[ebp], 0
	jmp	SHORT $LN7@FloydStein
$LN5@FloydStein:
	mov	edx, DWORD PTR _Column$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$7[ebp], edx
$LN7@FloydStein:
	mov	eax, DWORD PTR _Column$7[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@FloydStein

; 42   :         {
; 43   :             int Index = (Column * GrayscalePixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$7[ebp]
	imul	ecx, DWORD PTR _GrayscalePixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$3[ebp], ecx

; 44   :             //
; 45   :             //          X      index0
; 46   :             //   index2 index3 index1
; 47   :             int Index0 = -1;

	mov	DWORD PTR _Index0$6[ebp], -1

; 48   :             int Index1 = -1;

	mov	DWORD PTR _Index1$5[ebp], -1

; 49   :             int Index2 = -1;

	mov	DWORD PTR _Index2$4[ebp], -1

; 50   :             int Index3 = -1;

	mov	DWORD PTR _Index3$2[ebp], -1

; 51   :             if (Column < Width - 1)

	mov	edx, DWORD PTR _Width$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _Column$7[ebp], edx
	jge	SHORT $LN11@FloydStein

; 52   :             {
; 53   :                 Index0 = ((Column + 1) * GrayscalePixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$7[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _GrayscalePixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index0$6[ebp], eax

; 54   :                 if (Row < Height - 1)

	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Row$8[ebp], ecx
	jge	SHORT $LN11@FloydStein

; 55   :                     Index1 = ((Column + 1) * GrayscalePixelSize) + ((Row + 1) * Width);

	mov	edx, DWORD PTR _Column$7[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _GrayscalePixelSize$[ebp]
	mov	eax, DWORD PTR _Row$8[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _Width$[ebp]
	add	edx, eax
	mov	DWORD PTR _Index1$5[ebp], edx
$LN11@FloydStein:

; 56   :             }
; 57   :             if (Column > 0)

	cmp	DWORD PTR _Column$7[ebp], 0
	jle	SHORT $LN13@FloydStein

; 58   :             {
; 59   :                 if (Row < Height - 1)

	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Row$8[ebp], ecx
	jge	SHORT $LN13@FloydStein

; 60   :                     Index2 = ((Column - 1) * GrayscalePixelSize) + ((Row + 1) * Width);

	mov	edx, DWORD PTR _Column$7[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _GrayscalePixelSize$[ebp]
	mov	eax, DWORD PTR _Row$8[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _Width$[ebp]
	add	edx, eax
	mov	DWORD PTR _Index2$4[ebp], edx
$LN13@FloydStein:

; 61   :             }
; 62   :             if (Row < Height - 1)

	mov	ecx, DWORD PTR _Height$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _Row$8[ebp], ecx
	jge	SHORT $LN15@FloydStein

; 63   :             {
; 64   :                 if (Row < Height - 1)

	mov	edx, DWORD PTR _Height$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _Row$8[ebp], edx
	jge	SHORT $LN15@FloydStein

; 65   :                     Index3 = ((Column + 0) * GrayscalePixelSize) + ((Row + 1) * Width);

	mov	eax, DWORD PTR _Column$7[ebp]
	imul	eax, DWORD PTR _GrayscalePixelSize$[ebp]
	mov	ecx, DWORD PTR _Row$8[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _Width$[ebp]
	add	eax, ecx
	mov	DWORD PTR _Index3$2[ebp], eax
$LN15@FloydStein:

; 66   :             }
; 67   : 
; 68   :             if (Index0 > -1)

	cmp	DWORD PTR _Index0$6[ebp], -1
	jle	SHORT $LN16@FloydStein

; 69   :             {
; 70   :                 BYTE V0 = (BYTE)((double)Scratch[Index] * Index0Mul);

	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index$3[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3fdc000000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _V0$12[ebp], cl

; 71   :                 Scratch[Index0] = (BYTE)((Scratch[Index0] + V0) & 0xff);

	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index0$6[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _V0$12[ebp]
	add	eax, ecx
	and	eax, 255				; 000000ffH
	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index0$6[ebp]
	mov	BYTE PTR [edx], al
$LN16@FloydStein:

; 72   :             }
; 73   :             if (Index1 > -1)

	cmp	DWORD PTR _Index1$5[ebp], -1
	jle	SHORT $LN17@FloydStein

; 74   :             {
; 75   :                 BYTE V1 = (BYTE)((double)Scratch[Index] * Index1Mul);

	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index$3[ebp]
	movzx	ecx, BYTE PTR [eax]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR __real@3fb0000000000000
	cvttsd2si edx, xmm0
	mov	BYTE PTR _V1$11[ebp], dl

; 76   :                 Scratch[Index1] = (BYTE)((Scratch[Index1] + V1) & 0xff);

	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index1$5[ebp]
	movzx	ecx, BYTE PTR [eax]
	movzx	edx, BYTE PTR _V1$11[ebp]
	add	ecx, edx
	and	ecx, 255				; 000000ffH
	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _Index1$5[ebp]
	mov	BYTE PTR [eax], cl
$LN17@FloydStein:

; 77   :             }
; 78   :             if (Index2 > -1)

	cmp	DWORD PTR _Index2$4[ebp], -1
	jle	SHORT $LN18@FloydStein

; 79   :             {
; 80   :                 BYTE V2 = (BYTE)((double)Scratch[Index] * Index2Mul);

	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index$3[ebp]
	movzx	edx, BYTE PTR [ecx]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR __real@3fc8000000000000
	cvttsd2si eax, xmm0
	mov	BYTE PTR _V2$10[ebp], al

; 81   :                 Scratch[Index2] = (BYTE)((Scratch[Index2] + V2) & 0xff);

	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index2$4[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _V2$10[ebp]
	add	edx, eax
	and	edx, 255				; 000000ffH
	mov	ecx, DWORD PTR _Scratch$[ebp]
	add	ecx, DWORD PTR _Index2$4[ebp]
	mov	BYTE PTR [ecx], dl
$LN18@FloydStein:

; 82   :             }
; 83   :             if (Index3 > -1)

	cmp	DWORD PTR _Index3$2[ebp], -1
	jle	SHORT $LN19@FloydStein

; 84   :             {
; 85   :                 BYTE V3 = (BYTE)((double)Scratch[Index] * Index3Mul);

	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index$3[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3fd4000000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _V3$9[ebp], cl

; 86   :                 Scratch[Index3] = (BYTE)((Scratch[Index3] + V3) & 0xff);

	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index3$2[ebp]
	movzx	eax, BYTE PTR [edx]
	movzx	ecx, BYTE PTR _V3$9[ebp]
	add	eax, ecx
	and	eax, 255				; 000000ffH
	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _Index3$2[ebp]
	mov	BYTE PTR [edx], al
$LN19@FloydStein:

; 87   :             }
; 88   :         }

	jmp	$LN5@FloydStein
$LN6@FloydStein:

; 89   :     }

	jmp	$LN2@FloydStein
$LN3@FloydStein:

; 90   : 
; 91   :     return Success;

	xor	eax, eax
$LN1@FloydStein:

; 92   : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?FloydSteinbergDither@@YGHPAXHHH0PAEH@Z ENDP		; FloydSteinbergDither
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\dither.cpp
_TEXT	SEGMENT
$T1 = -76						; size = 4
_RowOffset$2 = -72					; size = 4
_RowOffset$3 = -68					; size = 4
$T4 = -64						; size = 4
tv172 = -60						; size = 4
_PixelSize$ = -56					; size = 4
tv130 = -52						; size = 4
_Index$5 = -48						; size = 4
_Src$ = -44						; size = 4
_Index$6 = -40						; size = 4
_Dest$ = -36						; size = 4
_Column$7 = -32						; size = 4
_Row$8 = -28						; size = 4
_Column$9 = -24						; size = 4
_Row$10 = -20						; size = 4
_DitherResult$ = -16					; size = 4
_Scratch$ = -12						; size = 4
_ScratchIndex$ = -8					; size = 4
_FinalValue$11 = -1					; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_DitherType$ = 28					; size = 4
_AsGrayscale$ = 32					; size = 4
_DoDither@28 PROC

; 250  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 251  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN16@DoDither

; 252  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@DoDither
$LN16@DoDither:

; 253  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN17@DoDither

; 254  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@DoDither
$LN17@DoDither:

; 255  : 
; 256  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 257  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 258  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 259  : 
; 260  :     BYTE *Scratch = new BYTE[Height * Width];

	mov	edx, DWORD PTR _Height$[ebp]
	imul	edx, DWORD PTR _Width$[ebp]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	eax, DWORD PTR $T4[ebp]
	mov	DWORD PTR _Scratch$[ebp], eax

; 261  :     int ScratchIndex = 0;

	mov	DWORD PTR _ScratchIndex$[ebp], 0

; 262  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$10[ebp], 0
	jmp	SHORT $LN4@DoDither
$LN2@DoDither:
	mov	ecx, DWORD PTR _Row$10[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$10[ebp], ecx
$LN4@DoDither:
	mov	edx, DWORD PTR _Row$10[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@DoDither

; 263  :     {
; 264  :         int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$10[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], eax

; 265  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$9[ebp], 0
	jmp	SHORT $LN7@DoDither
$LN5@DoDither:
	mov	ecx, DWORD PTR _Column$9[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$9[ebp], ecx
$LN7@DoDither:
	mov	edx, DWORD PTR _Column$9[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@DoDither

; 266  :         {
; 267  :             int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$9[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$5[ebp], eax

; 268  :             Scratch[ScratchIndex++] = (BYTE)((Src[Index + 2] + Src[Index + 1] + Src[Index + 0]) / 3);

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [ecx+2]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [edx+1]
	add	eax, ecx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [edx]
	add	eax, ecx
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	edx, DWORD PTR _Scratch$[ebp]
	add	edx, DWORD PTR _ScratchIndex$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _ScratchIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _ScratchIndex$[ebp], eax

; 269  :         }

	jmp	SHORT $LN5@DoDither
$LN6@DoDither:

; 270  :     }

	jmp	SHORT $LN2@DoDither
$LN3@DoDither:

; 271  : 
; 272  :     int DitherResult = NoAction;

	mov	DWORD PTR _DitherResult$[ebp], 0

; 273  :     switch (DitherType)

	mov	ecx, DWORD PTR _DitherType$[ebp]
	mov	DWORD PTR tv130[ebp], ecx
	cmp	DWORD PTR tv130[ebp], 0
	je	SHORT $LN18@DoDither
	cmp	DWORD PTR tv130[ebp], 1
	je	SHORT $LN19@DoDither
	cmp	DWORD PTR tv130[ebp], 2
	je	SHORT $LN20@DoDither
	jmp	SHORT $LN21@DoDither
$LN18@DoDither:

; 274  :     {
; 275  :     case Dither_FloydSteinberg:
; 276  :         DitherResult = FloydSteinbergDither(Source, Width, Height, Stride, Destination, Scratch, TRUE);

	push	1
	mov	edx, DWORD PTR _Scratch$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	?FloydSteinbergDither@@YGHPAXHHH0PAEH@Z	; FloydSteinbergDither
	mov	DWORD PTR _DitherResult$[ebp], eax

; 277  :         break;

	jmp	SHORT $LN8@DoDither
$LN19@DoDither:

; 278  : 
; 279  :     case Dither_FalseFloydSteinberg:
; 280  :         DitherResult = FalseFloydSteinbergDither(Source, Width, Height, Stride, Destination, Scratch, TRUE);

	push	1
	mov	edx, DWORD PTR _Scratch$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	?FalseFloydSteinbergDither@@YGHPAXHHH0PAEH@Z ; FalseFloydSteinbergDither
	mov	DWORD PTR _DitherResult$[ebp], eax

; 281  :         break;

	jmp	SHORT $LN8@DoDither
$LN20@DoDither:

; 282  : 
; 283  :     case Dither_Atkinson:
; 284  :         DitherResult = AtkinsonDither(Source, Width, Height, Stride, Destination, Scratch, TRUE);

	push	1
	mov	edx, DWORD PTR _Scratch$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	?AtkinsonDither@@YGHPAXHHH0PAEH@Z	; AtkinsonDither
	mov	DWORD PTR _DitherResult$[ebp], eax

; 285  :         break;

	jmp	SHORT $LN8@DoDither
$LN21@DoDither:

; 286  : 
; 287  :     default:
; 288  :         DitherResult = InvalidOperation;

	mov	DWORD PTR _DitherResult$[ebp], 11	; 0000000bH
$LN8@DoDither:

; 289  :         break;
; 290  :     }
; 291  : 
; 292  :     ScratchIndex = 0;

	mov	DWORD PTR _ScratchIndex$[ebp], 0

; 293  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$8[ebp], 0
	jmp	SHORT $LN12@DoDither
$LN10@DoDither:
	mov	edx, DWORD PTR _Row$8[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$8[ebp], edx
$LN12@DoDither:
	mov	eax, DWORD PTR _Row$8[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN11@DoDither

; 294  :     {
; 295  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$8[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 296  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$7[ebp], 0
	jmp	SHORT $LN15@DoDither
$LN13@DoDither:
	mov	edx, DWORD PTR _Column$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$7[ebp], edx
$LN15@DoDither:
	mov	eax, DWORD PTR _Column$7[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN14@DoDither

; 297  :         {
; 298  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$7[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$6[ebp], ecx

; 299  :             Dest[Index + 3] = 0xff;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH

; 300  :             BYTE FinalValue = Scratch[ScratchIndex] < 0x7f ? 0xff : 0x0;

	mov	eax, DWORD PTR _Scratch$[ebp]
	add	eax, DWORD PTR _ScratchIndex$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	jge	SHORT $LN23@DoDither
	mov	DWORD PTR tv172[ebp], 255		; 000000ffH
	jmp	SHORT $LN24@DoDither
$LN23@DoDither:
	mov	DWORD PTR tv172[ebp], 0
$LN24@DoDither:
	mov	dl, BYTE PTR tv172[ebp]
	mov	BYTE PTR _FinalValue$11[ebp], dl

; 301  :             Dest[Index + 2] = FinalValue;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _FinalValue$11[ebp]
	mov	BYTE PTR [eax+2], cl

; 302  :             Dest[Index + 1] = FinalValue;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _FinalValue$11[ebp]
	mov	BYTE PTR [edx+1], al

; 303  :             Dest[Index + 0] = FinalValue;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _FinalValue$11[ebp]
	mov	BYTE PTR [ecx], dl

; 304  :             ScratchIndex++;

	mov	eax, DWORD PTR _ScratchIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _ScratchIndex$[ebp], eax

; 305  :         }

	jmp	SHORT $LN13@DoDither
$LN14@DoDither:

; 306  :     }

	jmp	$LN10@DoDither
$LN11@DoDither:

; 307  : 
; 308  :     delete[] Scratch;

	mov	ecx, DWORD PTR _Scratch$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 309  : 
; 310  :     return DitherResult;

	mov	eax, DWORD PTR _DitherResult$[ebp]
$LN1@DoDither:

; 311  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_DoDither@28 ENDP
_TEXT	ENDS
END
