; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\FullBufferFunctions.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_AccumulateDoubleBlock@20
PUBLIC	_ConvertBlockToDouble@20
PUBLIC	_ByteBlockOperationByChannel@44
PUBLIC	_ByteBlocksOperation@32
PUBLIC	_MassImageArithmetic@32
PUBLIC	_ByteBlockOperation@32
PUBLIC	_DoubleBlockOperation@32
PUBLIC	_ChannelShiftBits@32
PUBLIC	_ChannelRollBits@32
PUBLIC	_PixelSum@8
PUBLIC	_PixelSumDouble@24
PUBLIC	_MeanPixel@8
PUBLIC	_MedianPixel@8
PUBLIC	_BrightestPixel@8
PUBLIC	_DarkestPixel@8
PUBLIC	_ClosestPixelLuminance@16
PUBLIC	_LeastClosestPixelLuminance@16
PUBLIC	_SmallestAlphaPixel@8
PUBLIC	_GreatestAlphaPixel@8
PUBLIC	_ClosestAlphaPixel@12
PUBLIC	_FarthestAlphaPixel@12
PUBLIC	?MakeMasqk@@YGHHH@Z				; MakeMasqk
PUBLIC	?MakeMask@@YGEEE@Z				; MakeMask
PUBLIC	?RotateRight@@YGEEH@Z				; RotateRight
PUBLIC	?PixelLogicalOperation@@YGIPAIHH@Z		; PixelLogicalOperation
PUBLIC	__real@0000000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@7fefffffffffffff
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_ColorLuminance@12:PROC
EXTRN	?ColorLuminance3@@YGNIH@Z:PROC			; ColorLuminance3
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	__fltused:DWORD
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@7fefffffffffffff
CONST	SEGMENT
__real@7fefffffffffffff DQ 07fefffffffffffffr	; 1.79769e+308
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
tv84 = -16						; size = 4
_i$1 = -12						; size = 4
_lBlue$2 = -6						; size = 1
_lGreen$3 = -5						; size = 1
_lRed$4 = -4						; size = 1
_Blue$ = -3						; size = 1
_Green$ = -2						; size = 1
_Red$ = -1						; size = 1
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_Operation$ = 16					; size = 4
?PixelLogicalOperation@@YGIPAIHH@Z PROC			; PixelLogicalOperation

; 1646 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1647 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN7@PixelLogic

; 1648 :         return 0;

	xor	eax, eax
	jmp	$LN1@PixelLogic
$LN7@PixelLogic:

; 1649 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN8@PixelLogic

; 1650 :         return 0;

	xor	eax, eax
	jmp	$LN1@PixelLogic
$LN8@PixelLogic:

; 1651 :     if ((Operation != ArithmeticAnd) && (Operation != ArithmeticOr) && (Operation != ArithmeticXor))

	cmp	DWORD PTR _Operation$[ebp], 13		; 0000000dH
	je	SHORT $LN9@PixelLogic
	cmp	DWORD PTR _Operation$[ebp], 14		; 0000000eH
	je	SHORT $LN9@PixelLogic
	cmp	DWORD PTR _Operation$[ebp], 15		; 0000000fH
	je	SHORT $LN9@PixelLogic

; 1652 :         return 0;

	xor	eax, eax
	jmp	$LN1@PixelLogic
$LN9@PixelLogic:

; 1653 : 
; 1654 :     BYTE Red = 0;

	mov	BYTE PTR _Red$[ebp], 0

; 1655 :     BYTE Green = 0;

	mov	BYTE PTR _Green$[ebp], 0

; 1656 :     BYTE Blue = 0;

	mov	BYTE PTR _Blue$[ebp], 0

; 1657 : 
; 1658 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@PixelLogic
$LN2@PixelLogic:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@PixelLogic:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _PixelCount$[ebp]
	jge	$LN3@PixelLogic

; 1659 :     {
; 1660 :         BYTE lRed = (PackedPixels[i] & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	mov	BYTE PTR _lRed$4[ebp], cl

; 1661 :         BYTE lGreen = (PackedPixels[i] & 0x0000ff00) >> 0;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, 65280				; 0000ff00H
	mov	BYTE PTR _lGreen$3[ebp], cl

; 1662 :         BYTE lBlue = (PackedPixels[i] & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, 255				; 000000ffH
	mov	BYTE PTR _lBlue$2[ebp], cl

; 1663 :         switch (Operation)

	mov	edx, DWORD PTR _Operation$[ebp]
	mov	DWORD PTR tv84[ebp], edx
	cmp	DWORD PTR tv84[ebp], 13			; 0000000dH
	je	SHORT $LN10@PixelLogic
	cmp	DWORD PTR tv84[ebp], 14			; 0000000eH
	je	SHORT $LN11@PixelLogic
	cmp	DWORD PTR tv84[ebp], 15			; 0000000fH
	je	SHORT $LN12@PixelLogic
	jmp	SHORT $LN5@PixelLogic
$LN10@PixelLogic:

; 1664 :         {
; 1665 :         case ArithmeticAnd:
; 1666 :             Red &= lRed;

	movzx	eax, BYTE PTR _lRed$4[ebp]
	movzx	ecx, BYTE PTR _Red$[ebp]
	and	ecx, eax
	mov	BYTE PTR _Red$[ebp], cl

; 1667 :             Green &= lGreen;

	movzx	edx, BYTE PTR _lGreen$3[ebp]
	movzx	eax, BYTE PTR _Green$[ebp]
	and	eax, edx
	mov	BYTE PTR _Green$[ebp], al

; 1668 :             Blue &= lBlue;

	movzx	ecx, BYTE PTR _lBlue$2[ebp]
	movzx	edx, BYTE PTR _Blue$[ebp]
	and	edx, ecx
	mov	BYTE PTR _Blue$[ebp], dl

; 1669 :             break;

	jmp	SHORT $LN5@PixelLogic
$LN11@PixelLogic:

; 1670 : 
; 1671 :         case ArithmeticOr:
; 1672 :             Red |= lRed;

	movzx	eax, BYTE PTR _lRed$4[ebp]
	movzx	ecx, BYTE PTR _Red$[ebp]
	or	ecx, eax
	mov	BYTE PTR _Red$[ebp], cl

; 1673 :             Green |= lGreen;

	movzx	edx, BYTE PTR _lGreen$3[ebp]
	movzx	eax, BYTE PTR _Green$[ebp]
	or	eax, edx
	mov	BYTE PTR _Green$[ebp], al

; 1674 :             Blue |= lBlue;

	movzx	ecx, BYTE PTR _lBlue$2[ebp]
	movzx	edx, BYTE PTR _Blue$[ebp]
	or	edx, ecx
	mov	BYTE PTR _Blue$[ebp], dl

; 1675 :             break;

	jmp	SHORT $LN5@PixelLogic
$LN12@PixelLogic:

; 1676 : 
; 1677 :         case ArithmeticXor:
; 1678 :             Red ^= lRed;

	movzx	eax, BYTE PTR _lRed$4[ebp]
	movzx	ecx, BYTE PTR _Red$[ebp]
	xor	ecx, eax
	mov	BYTE PTR _Red$[ebp], cl

; 1679 :             Green ^= lGreen;

	movzx	edx, BYTE PTR _lGreen$3[ebp]
	movzx	eax, BYTE PTR _Green$[ebp]
	xor	eax, edx
	mov	BYTE PTR _Green$[ebp], al

; 1680 :             Blue ^= lBlue;

	movzx	ecx, BYTE PTR _lBlue$2[ebp]
	movzx	edx, BYTE PTR _Blue$[ebp]
	xor	edx, ecx
	mov	BYTE PTR _Blue$[ebp], dl
$LN5@PixelLogic:

; 1681 :             break;
; 1682 :         }
; 1683 :     }

	jmp	$LN2@PixelLogic
$LN3@PixelLogic:

; 1684 : 
; 1685 :     return 0xff000000 | (Red << 16) | (Green << 8) | (Blue << 0);

	movzx	eax, BYTE PTR _Red$[ebp]
	shl	eax, 16					; 00000010H
	or	eax, -16777216				; ff000000H
	movzx	ecx, BYTE PTR _Green$[ebp]
	shl	ecx, 8
	or	eax, ecx
	movzx	edx, BYTE PTR _Blue$[ebp]
	or	eax, edx
$LN1@PixelLogic:

; 1686 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?PixelLogicalOperation@@YGIPAIHH@Z ENDP			; PixelLogicalOperation
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_Value$ = 8						; size = 1
_Count$ = 12						; size = 4
?RotateRight@@YGEEH@Z PROC				; RotateRight

; 1211 : {

	push	ebp
	mov	ebp, esp

; 1212 :     if (Count == 0)

	cmp	DWORD PTR _Count$[ebp], 0
	jne	SHORT $LN2@RotateRigh

; 1213 :         return Value;

	mov	al, BYTE PTR _Value$[ebp]
	jmp	SHORT $LN1@RotateRigh
$LN2@RotateRigh:

; 1214 :     return 0;

	xor	al, al
$LN1@RotateRigh:

; 1215 : }

	pop	ebp
	ret	8
?RotateRight@@YGEEH@Z ENDP				; RotateRight
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_v$ = -1						; size = 1
_Value$ = 8						; size = 1
_Location$ = 12						; size = 1
?MakeMask@@YGEEE@Z PROC					; MakeMask

; 1204 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1205 :     BYTE v = (BYTE)pow((double)Value, (double)2.0);

	movzx	eax, BYTE PTR _Value$[ebp]
	cvtsi2sd xmm0, eax
	movsd	xmm1, QWORD PTR __real@4000000000000000
	call	__libm_sse2_pow_precise
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _v$[ebp], cl

; 1206 :     v = (v << 8) - Location;

	movzx	edx, BYTE PTR _v$[ebp]
	shl	edx, 8
	movzx	eax, BYTE PTR _Location$[ebp]
	sub	edx, eax
	mov	BYTE PTR _v$[ebp], dl

; 1207 :     return v;

	mov	al, BYTE PTR _v$[ebp]

; 1208 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MakeMask@@YGEEE@Z ENDP					; MakeMask
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_c$ = -8						; size = 4
_mask$ = -4						; size = 4
_bitstorotate$ = 8					; size = 4
_RotateRight$ = 12					; size = 4
?MakeMasqk@@YGHHH@Z PROC				; MakeMasqk

; 1183 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1184 :     int mask = 0;

	mov	DWORD PTR _mask$[ebp], 0

; 1185 :     int c;
; 1186 : 
; 1187 :     if (bitstorotate == 0)

	cmp	DWORD PTR _bitstorotate$[ebp], 0
	jne	SHORT $LN2@MakeMasqk

; 1188 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@MakeMasqk
$LN2@MakeMasqk:

; 1189 : 
; 1190 :     c = 0x80000000;

	mov	DWORD PTR _c$[ebp], -2147483648		; 80000000H

; 1191 :     mask = (c >> bitstorotate);

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _bitstorotate$[ebp]
	sar	eax, cl
	mov	DWORD PTR _mask$[ebp], eax

; 1192 :     if (RotateRight)

	cmp	DWORD PTR _RotateRight$[ebp], 0
	je	SHORT $LN3@MakeMasqk

; 1193 :     {
; 1194 :         mask = (c >> (32 - bitstorotate));

	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR _bitstorotate$[ebp]
	mov	edx, DWORD PTR _c$[ebp]
	sar	edx, cl
	mov	DWORD PTR _mask$[ebp], edx

; 1195 :         mask = ~mask;

	mov	eax, DWORD PTR _mask$[ebp]
	not	eax
	mov	DWORD PTR _mask$[ebp], eax

; 1196 :     }
; 1197 :     else

	jmp	SHORT $LN4@MakeMasqk
$LN3@MakeMasqk:

; 1198 :         mask = (c >> bitstorotate);

	mov	edx, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _bitstorotate$[ebp]
	sar	edx, cl
	mov	DWORD PTR _mask$[ebp], edx
$LN4@MakeMasqk:

; 1199 : 
; 1200 :     return mask;

	mov	eax, DWORD PTR _mask$[ebp]
$LN1@MakeMasqk:

; 1201 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MakeMasqk@@YGHHH@Z ENDP				; MakeMasqk
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_FarthestPixel$ = -12					; size = 4
_i$1 = -8						; size = 4
_Farthest$ = -2						; size = 1
_AlphaValue$2 = -1					; size = 1
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_FarthestFrom$ = 16					; size = 1
_FarthestAlphaPixel@12 PROC

; 1618 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1619 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN5@FarthestAl

; 1620 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FarthestAl
$LN5@FarthestAl:

; 1621 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN6@FarthestAl

; 1622 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@FarthestAl
$LN6@FarthestAl:

; 1623 : 
; 1624 :     BYTE Farthest = 0x0;

	mov	BYTE PTR _Farthest$[ebp], 0

; 1625 :     UINT32 FarthestPixel = 0x0;

	mov	DWORD PTR _FarthestPixel$[ebp], 0

; 1626 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@FarthestAl
$LN2@FarthestAl:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@FarthestAl:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _PixelCount$[ebp]
	jge	SHORT $LN3@FarthestAl

; 1627 :     {
; 1628 :         BYTE AlphaValue = (PackedPixels[i] & 0xff000000) >> 24;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _AlphaValue$2[ebp], cl

; 1629 :         if (abs(AlphaValue - FarthestFrom) > Farthest)

	movzx	eax, BYTE PTR _AlphaValue$2[ebp]
	movzx	edx, BYTE PTR _FarthestFrom$[ebp]
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	movzx	ecx, BYTE PTR _Farthest$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN7@FarthestAl

; 1630 :         {
; 1631 :             Farthest = abs(AlphaValue - FarthestFrom);

	movzx	eax, BYTE PTR _AlphaValue$2[ebp]
	movzx	edx, BYTE PTR _FarthestFrom$[ebp]
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	BYTE PTR _Farthest$[ebp], al

; 1632 :             FarthestPixel = PackedPixels[i];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _PackedPixels$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _FarthestPixel$[ebp], edx
$LN7@FarthestAl:

; 1633 :         }
; 1634 :     }

	jmp	SHORT $LN2@FarthestAl
$LN3@FarthestAl:

; 1635 :     return FarthestPixel;

	mov	eax, DWORD PTR _FarthestPixel$[ebp]
$LN1@FarthestAl:

; 1636 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_FarthestAlphaPixel@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_ClosestPixel$ = -12					; size = 4
_i$1 = -8						; size = 4
_Closest$ = -2						; size = 1
_AlphaValue$2 = -1					; size = 1
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_ClosestTo$ = 16					; size = 1
_ClosestAlphaPixel@12 PROC

; 1588 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1589 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN5@ClosestAlp

; 1590 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ClosestAlp
$LN5@ClosestAlp:

; 1591 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN6@ClosestAlp

; 1592 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@ClosestAlp
$LN6@ClosestAlp:

; 1593 : 
; 1594 :     BYTE Closest = 0xff;

	mov	BYTE PTR _Closest$[ebp], 255		; 000000ffH

; 1595 :     UINT32 ClosestPixel = 0x0;

	mov	DWORD PTR _ClosestPixel$[ebp], 0

; 1596 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@ClosestAlp
$LN2@ClosestAlp:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@ClosestAlp:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _PixelCount$[ebp]
	jge	SHORT $LN3@ClosestAlp

; 1597 :     {
; 1598 :         BYTE AlphaValue = (PackedPixels[i] & 0xff000000) >> 24;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _AlphaValue$2[ebp], cl

; 1599 :         if (abs(AlphaValue - ClosestTo) < Closest)

	movzx	eax, BYTE PTR _AlphaValue$2[ebp]
	movzx	edx, BYTE PTR _ClosestTo$[ebp]
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	movzx	ecx, BYTE PTR _Closest$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN7@ClosestAlp

; 1600 :         {
; 1601 :             Closest = abs(AlphaValue - ClosestTo);

	movzx	eax, BYTE PTR _AlphaValue$2[ebp]
	movzx	edx, BYTE PTR _ClosestTo$[ebp]
	sub	eax, edx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	BYTE PTR _Closest$[ebp], al

; 1602 :             ClosestPixel = PackedPixels[i];

	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _PackedPixels$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _ClosestPixel$[ebp], edx
$LN7@ClosestAlp:

; 1603 :         }
; 1604 :     }

	jmp	SHORT $LN2@ClosestAlp
$LN3@ClosestAlp:

; 1605 :     return ClosestPixel;

	mov	eax, DWORD PTR _ClosestPixel$[ebp]
$LN1@ClosestAlp:

; 1606 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_ClosestAlphaPixel@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_BiggestAlphaPix$ = -12					; size = 4
_i$1 = -8						; size = 4
_Biggest$ = -2						; size = 1
_AlphaValue$2 = -1					; size = 1
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_GreatestAlphaPixel@8 PROC

; 1558 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1559 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN5@GreatestAl

; 1560 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GreatestAl
$LN5@GreatestAl:

; 1561 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN6@GreatestAl

; 1562 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GreatestAl
$LN6@GreatestAl:

; 1563 : 
; 1564 :     BYTE Biggest = 0x0;

	mov	BYTE PTR _Biggest$[ebp], 0

; 1565 :     UINT32 BiggestAlphaPix = 0x0;

	mov	DWORD PTR _BiggestAlphaPix$[ebp], 0

; 1566 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@GreatestAl
$LN2@GreatestAl:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@GreatestAl:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _PixelCount$[ebp]
	jge	SHORT $LN3@GreatestAl

; 1567 :     {
; 1568 :         BYTE AlphaValue = (PackedPixels[i] & 0xff000000) >> 24;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _AlphaValue$2[ebp], cl

; 1569 :         if (AlphaValue > Biggest)

	movzx	edx, BYTE PTR _AlphaValue$2[ebp]
	movzx	eax, BYTE PTR _Biggest$[ebp]
	cmp	edx, eax
	jle	SHORT $LN7@GreatestAl

; 1570 :         {
; 1571 :             Biggest = AlphaValue;

	mov	cl, BYTE PTR _AlphaValue$2[ebp]
	mov	BYTE PTR _Biggest$[ebp], cl

; 1572 :             BiggestAlphaPix = PackedPixels[i];

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _BiggestAlphaPix$[ebp], ecx
$LN7@GreatestAl:

; 1573 :         }
; 1574 :     }

	jmp	SHORT $LN2@GreatestAl
$LN3@GreatestAl:

; 1575 :     return BiggestAlphaPix;

	mov	eax, DWORD PTR _BiggestAlphaPix$[ebp]
$LN1@GreatestAl:

; 1576 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_GreatestAlphaPixel@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_SmallestAlphaPix$ = -12				; size = 4
_i$1 = -8						; size = 4
_Smallest$ = -2						; size = 1
_AlphaValue$2 = -1					; size = 1
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_SmallestAlphaPixel@8 PROC

; 1531 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1532 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN5@SmallestAl

; 1533 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SmallestAl
$LN5@SmallestAl:

; 1534 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN6@SmallestAl

; 1535 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@SmallestAl
$LN6@SmallestAl:

; 1536 : 
; 1537 :     BYTE Smallest = 0xff;

	mov	BYTE PTR _Smallest$[ebp], 255		; 000000ffH

; 1538 :     UINT32 SmallestAlphaPix = 0x0;

	mov	DWORD PTR _SmallestAlphaPix$[ebp], 0

; 1539 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@SmallestAl
$LN2@SmallestAl:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@SmallestAl:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _PixelCount$[ebp]
	jge	SHORT $LN3@SmallestAl

; 1540 :     {
; 1541 :         BYTE AlphaValue = (PackedPixels[i] & 0xff000000) >> 24;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR _AlphaValue$2[ebp], cl

; 1542 :         if (AlphaValue < Smallest)

	movzx	edx, BYTE PTR _AlphaValue$2[ebp]
	movzx	eax, BYTE PTR _Smallest$[ebp]
	cmp	edx, eax
	jge	SHORT $LN7@SmallestAl

; 1543 :         {
; 1544 :             Smallest = AlphaValue;

	mov	cl, BYTE PTR _AlphaValue$2[ebp]
	mov	BYTE PTR _Smallest$[ebp], cl

; 1545 :             SmallestAlphaPix = PackedPixels[i];

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _SmallestAlphaPix$[ebp], ecx
$LN7@SmallestAl:

; 1546 :         }
; 1547 :     }

	jmp	SHORT $LN2@SmallestAl
$LN3@SmallestAl:

; 1548 :     return SmallestAlphaPix;

	mov	eax, DWORD PTR _SmallestAlphaPix$[ebp]
$LN1@SmallestAl:

; 1549 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SmallestAlphaPixel@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_BiggestDeltaLuminance$ = -24				; size = 8
_Lum$1 = -16						; size = 8
_BigDelta$ = -8						; size = 4
_i$2 = -4						; size = 4
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_LuminanceTarget$ = 16					; size = 8
_LeastClosestPixelLuminance@16 PROC

; 1504 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1505 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN5@LeastClose

; 1506 :         return 0;

	xor	eax, eax
	jmp	$LN1@LeastClose
$LN5@LeastClose:

; 1507 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN6@LeastClose

; 1508 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@LeastClose
$LN6@LeastClose:

; 1509 : 
; 1510 :     UINT32 BigDelta = 0x0;

	mov	DWORD PTR _BigDelta$[ebp], 0

; 1511 :     double BiggestDeltaLuminance = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _BiggestDeltaLuminance$[ebp], xmm0

; 1512 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@LeastClose
$LN2@LeastClose:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@LeastClose:
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR _PixelCount$[ebp]
	jge	SHORT $LN3@LeastClose

; 1513 :     {
; 1514 :         double Lum = ColorLuminance3(PackedPixels[i], FALSE);

	push	0
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	?ColorLuminance3@@YGNIH@Z		; ColorLuminance3
	fstp	QWORD PTR _Lum$1[ebp]

; 1515 :         if (fabs(Lum - LuminanceTarget) > BiggestDeltaLuminance)

	movsd	xmm0, QWORD PTR _Lum$1[ebp]
	subsd	xmm0, QWORD PTR _LuminanceTarget$[ebp]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	comisd	xmm0, QWORD PTR _BiggestDeltaLuminance$[ebp]
	jbe	SHORT $LN7@LeastClose

; 1516 :         {
; 1517 :             BiggestDeltaLuminance = fabs(Lum - LuminanceTarget);

	movsd	xmm0, QWORD PTR _Lum$1[ebp]
	subsd	xmm0, QWORD PTR _LuminanceTarget$[ebp]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movsd	QWORD PTR _BiggestDeltaLuminance$[ebp], xmm0

; 1518 :             BigDelta = PackedPixels[i];

	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _BigDelta$[ebp], ecx
$LN7@LeastClose:

; 1519 :         }
; 1520 :     }

	jmp	SHORT $LN2@LeastClose
$LN3@LeastClose:

; 1521 :     return BigDelta;

	mov	eax, DWORD PTR _BigDelta$[ebp]
$LN1@LeastClose:

; 1522 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_LeastClosestPixelLuminance@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_ClosestLuminance$ = -24				; size = 8
_Lum$1 = -16						; size = 8
_Closest$ = -8						; size = 4
_i$2 = -4						; size = 4
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_LuminanceTarget$ = 16					; size = 8
_ClosestPixelLuminance@16 PROC

; 1476 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1477 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN5@ClosestPix

; 1478 :         return 0;

	xor	eax, eax
	jmp	$LN1@ClosestPix
$LN5@ClosestPix:

; 1479 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN6@ClosestPix

; 1480 :         return 0;

	xor	eax, eax
	jmp	$LN1@ClosestPix
$LN6@ClosestPix:

; 1481 : 
; 1482 :     UINT32 Closest = 0x0;

	mov	DWORD PTR _Closest$[ebp], 0

; 1483 :     double ClosestLuminance = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _ClosestLuminance$[ebp], xmm0

; 1484 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@ClosestPix
$LN2@ClosestPix:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@ClosestPix:
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR _PixelCount$[ebp]
	jge	SHORT $LN3@ClosestPix

; 1485 :     {
; 1486 :         double Lum = ColorLuminance3(PackedPixels[i], FALSE);

	push	0
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	?ColorLuminance3@@YGNIH@Z		; ColorLuminance3
	fstp	QWORD PTR _Lum$1[ebp]

; 1487 :         if (fabs(Lum - LuminanceTarget) < ClosestLuminance)

	movsd	xmm0, QWORD PTR _Lum$1[ebp]
	subsd	xmm0, QWORD PTR _LuminanceTarget$[ebp]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movsd	xmm1, QWORD PTR _ClosestLuminance$[ebp]
	comisd	xmm1, xmm0
	jbe	SHORT $LN7@ClosestPix

; 1488 :         {
; 1489 :             ClosestLuminance = fabs(Lum - LuminanceTarget);

	movsd	xmm0, QWORD PTR _Lum$1[ebp]
	subsd	xmm0, QWORD PTR _LuminanceTarget$[ebp]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movsd	QWORD PTR _ClosestLuminance$[ebp], xmm0

; 1490 :             Closest = PackedPixels[i];

	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _Closest$[ebp], ecx
$LN7@ClosestPix:

; 1491 :         }
; 1492 :     }

	jmp	SHORT $LN2@ClosestPix
$LN3@ClosestPix:

; 1493 :     return Closest;

	mov	eax, DWORD PTR _Closest$[ebp]
$LN1@ClosestPix:

; 1494 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_ClosestPixelLuminance@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_DarkestLuminance$ = -24				; size = 8
_Lum$1 = -16						; size = 8
_Darkest$ = -8						; size = 4
_i$2 = -4						; size = 4
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_DarkestPixel@8 PROC

; 1379 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1380 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN5@DarkestPix

; 1381 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@DarkestPix
$LN5@DarkestPix:

; 1382 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN6@DarkestPix

; 1383 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@DarkestPix
$LN6@DarkestPix:

; 1384 : 
; 1385 :     UINT32 Darkest = 0xffffffff;

	mov	DWORD PTR _Darkest$[ebp], -1

; 1386 :     double DarkestLuminance = DBL_MAX;

	movsd	xmm0, QWORD PTR __real@7fefffffffffffff
	movsd	QWORD PTR _DarkestLuminance$[ebp], xmm0

; 1387 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@DarkestPix
$LN2@DarkestPix:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@DarkestPix:
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR _PixelCount$[ebp]
	jge	SHORT $LN3@DarkestPix

; 1388 :     {
; 1389 :         double Lum = ColorLuminance3(PackedPixels[i], FALSE);

	push	0
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	?ColorLuminance3@@YGNIH@Z		; ColorLuminance3
	fstp	QWORD PTR _Lum$1[ebp]

; 1390 :         if (Lum < DarkestLuminance)

	movsd	xmm0, QWORD PTR _DarkestLuminance$[ebp]
	comisd	xmm0, QWORD PTR _Lum$1[ebp]
	jbe	SHORT $LN7@DarkestPix

; 1391 :         {
; 1392 :             DarkestLuminance = Lum;

	movsd	xmm0, QWORD PTR _Lum$1[ebp]
	movsd	QWORD PTR _DarkestLuminance$[ebp], xmm0

; 1393 :             Darkest = PackedPixels[i];

	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _Darkest$[ebp], ecx
$LN7@DarkestPix:

; 1394 :         }
; 1395 :     }

	jmp	SHORT $LN2@DarkestPix
$LN3@DarkestPix:

; 1396 :     return Darkest;

	mov	eax, DWORD PTR _Darkest$[ebp]
$LN1@DarkestPix:

; 1397 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_DarkestPixel@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_BrightestLuminance$ = -24				; size = 8
_Lum$1 = -16						; size = 8
_Brightest$ = -8					; size = 4
_i$2 = -4						; size = 4
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_BrightestPixel@8 PROC

; 1352 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1353 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN5@BrightestP

; 1354 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@BrightestP
$LN5@BrightestP:

; 1355 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN6@BrightestP

; 1356 :         return 0;

	xor	eax, eax
	jmp	SHORT $LN1@BrightestP
$LN6@BrightestP:

; 1357 : 
; 1358 :     UINT32 Brightest = 0x0;

	mov	DWORD PTR _Brightest$[ebp], 0

; 1359 :     double BrightestLuminance = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _BrightestLuminance$[ebp], xmm0

; 1360 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@BrightestP
$LN2@BrightestP:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@BrightestP:
	mov	ecx, DWORD PTR _i$2[ebp]
	cmp	ecx, DWORD PTR _PixelCount$[ebp]
	jge	SHORT $LN3@BrightestP

; 1361 :     {
; 1362 :         double Lum = ColorLuminance3(PackedPixels[i], FALSE);

	push	0
	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	?ColorLuminance3@@YGNIH@Z		; ColorLuminance3
	fstp	QWORD PTR _Lum$1[ebp]

; 1363 :         if (Lum > BrightestLuminance)

	movsd	xmm0, QWORD PTR _Lum$1[ebp]
	comisd	xmm0, QWORD PTR _BrightestLuminance$[ebp]
	jbe	SHORT $LN7@BrightestP

; 1364 :         {
; 1365 :             BrightestLuminance = Lum;

	movsd	xmm0, QWORD PTR _Lum$1[ebp]
	movsd	QWORD PTR _BrightestLuminance$[ebp], xmm0

; 1366 :             Brightest = PackedPixels[i];

	mov	edx, DWORD PTR _i$2[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _Brightest$[ebp], ecx
$LN7@BrightestP:

; 1367 :         }
; 1368 :     }

	jmp	SHORT $LN2@BrightestP
$LN3@BrightestP:

; 1369 :     return Brightest;

	mov	eax, DWORD PTR _Brightest$[ebp]
$LN1@BrightestP:

; 1370 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_BrightestPixel@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_temp$1 = -52						; size = 16
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_Swapped$ = -28						; size = 4
_P1$4 = -24						; size = 4
_P0$5 = -20						; size = 4
_i$6 = -16						; size = 4
_FinalPixel$ = -12					; size = 4
_i$7 = -8						; size = 4
_Pixels$ = -4						; size = 4
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_MedianPixel@8 PROC

; 1296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi

; 1297 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN11@MedianPixe

; 1298 :         return 0;

	xor	eax, eax
	jmp	$LN1@MedianPixe
$LN11@MedianPixe:

; 1299 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN12@MedianPixe

; 1300 :         return 0;

	xor	eax, eax
	jmp	$LN1@MedianPixe
$LN12@MedianPixe:

; 1301 :     LumPixel* Pixels = new LumPixel[PixelCount];

	xor	ecx, ecx
	mov	eax, DWORD PTR _PixelCount$[ebp]
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _Pixels$[ebp], eax

; 1302 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN4@MedianPixe
$LN2@MedianPixe:
	mov	ecx, DWORD PTR _i$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$6[ebp], ecx
$LN4@MedianPixe:
	mov	edx, DWORD PTR _i$6[ebp]
	cmp	edx, DWORD PTR _PixelCount$[ebp]
	jge	SHORT $LN3@MedianPixe

; 1303 :     {
; 1304 :         Pixels[i].PixelData = PackedPixels[i];

	mov	eax, DWORD PTR _i$6[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _Pixels$[ebp]
	mov	edx, DWORD PTR _i$6[ebp]
	mov	esi, DWORD PTR _PackedPixels$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax], edx

; 1305 :         Pixels[i].Luminance = ColorLuminance3(Pixels[i].PixelData, FALSE);

	push	0
	mov	eax, DWORD PTR _i$6[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _Pixels$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	?ColorLuminance3@@YGNIH@Z		; ColorLuminance3
	mov	eax, DWORD PTR _i$6[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _Pixels$[ebp]
	fstp	QWORD PTR [ecx+eax+8]

; 1306 :     }

	jmp	SHORT $LN2@MedianPixe
$LN3@MedianPixe:

; 1307 :     //Use a stupid bubble sort to sort the pixels by luminance. Don't need anything more sophisticated.
; 1308 :     BOOL Swapped = FALSE;

	mov	DWORD PTR _Swapped$[ebp], 0
$LN7@MedianPixe:

; 1309 :     do
; 1310 :     {
; 1311 :         for (int i = 1; i < PixelCount - 1; i++)

	mov	DWORD PTR _i$7[ebp], 1
	jmp	SHORT $LN10@MedianPixe
$LN8@MedianPixe:
	mov	edx, DWORD PTR _i$7[ebp]
	add	edx, 1
	mov	DWORD PTR _i$7[ebp], edx
$LN10@MedianPixe:
	mov	eax, DWORD PTR _PixelCount$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$7[ebp], eax
	jge	$LN9@MedianPixe

; 1312 :         {
; 1313 :             if (Pixels[i - 1].Luminance>Pixels[i].Luminance)

	mov	ecx, DWORD PTR _i$7[ebp]
	sub	ecx, 1
	shl	ecx, 4
	mov	edx, DWORD PTR _i$7[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _Pixels$[ebp]
	mov	esi, DWORD PTR _Pixels$[ebp]
	movsd	xmm0, QWORD PTR [eax+ecx+8]
	comisd	xmm0, QWORD PTR [esi+edx+8]
	jbe	$LN13@MedianPixe

; 1314 :             {
; 1315 :                 LumPixel temp;
; 1316 :                 temp.Luminance = Pixels[i - 1].Luminance;

	mov	ecx, DWORD PTR _i$7[ebp]
	sub	ecx, 1
	shl	ecx, 4
	mov	edx, DWORD PTR _Pixels$[ebp]
	movsd	xmm0, QWORD PTR [edx+ecx+8]
	movsd	QWORD PTR _temp$1[ebp+8], xmm0

; 1317 :                 temp.PixelData = Pixels[i - 1].PixelData;

	mov	eax, DWORD PTR _i$7[ebp]
	sub	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _Pixels$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _temp$1[ebp], edx

; 1318 :                 Pixels[i - 1].Luminance = Pixels[i].Luminance;

	mov	eax, DWORD PTR _i$7[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _i$7[ebp]
	sub	ecx, 1
	shl	ecx, 4
	mov	edx, DWORD PTR _Pixels$[ebp]
	mov	esi, DWORD PTR _Pixels$[ebp]
	movsd	xmm0, QWORD PTR [esi+eax+8]
	movsd	QWORD PTR [edx+ecx+8], xmm0

; 1319 :                 Pixels[i - 1].PixelData = Pixels[i].PixelData;

	mov	eax, DWORD PTR _i$7[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _i$7[ebp]
	sub	ecx, 1
	shl	ecx, 4
	mov	edx, DWORD PTR _Pixels$[ebp]
	mov	esi, DWORD PTR _Pixels$[ebp]
	mov	eax, DWORD PTR [esi+eax]
	mov	DWORD PTR [edx+ecx], eax

; 1320 :                 Pixels[i].Luminance = temp.Luminance;

	mov	ecx, DWORD PTR _i$7[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _Pixels$[ebp]
	movsd	xmm0, QWORD PTR _temp$1[ebp+8]
	movsd	QWORD PTR [edx+ecx+8], xmm0

; 1321 :                 Pixels[i].PixelData = temp.PixelData;

	mov	eax, DWORD PTR _i$7[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _Pixels$[ebp]
	mov	edx, DWORD PTR _temp$1[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 1322 :                 Swapped = TRUE;

	mov	DWORD PTR _Swapped$[ebp], 1
$LN13@MedianPixe:

; 1323 :             }
; 1324 :         }

	jmp	$LN8@MedianPixe
$LN9@MedianPixe:

; 1325 :     } while (!Swapped);

	cmp	DWORD PTR _Swapped$[ebp], 0
	je	$LN7@MedianPixe

; 1326 : 
; 1327 :     UINT32 FinalPixel = 0x0;

	mov	DWORD PTR _FinalPixel$[ebp], 0

; 1328 :     if (PixelCount % 2 == 1)

	mov	eax, DWORD PTR _PixelCount$[ebp]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN17@MedianPixe
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN17@MedianPixe:
	cmp	eax, 1
	jne	SHORT $LN14@MedianPixe

; 1329 :         FinalPixel = Pixels[(PixelCount / 2) + 1].PixelData;

	mov	eax, DWORD PTR _PixelCount$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _Pixels$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _FinalPixel$[ebp], edx

; 1330 :     else

	jmp	$LN15@MedianPixe
$LN14@MedianPixe:

; 1331 :     {
; 1332 :         UINT32 P0 = Pixels[(PixelCount / 2)].PixelData;

	mov	eax, DWORD PTR _PixelCount$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _Pixels$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _P0$5[ebp], edx

; 1333 :         UINT32 P1 = Pixels[(PixelCount / 2) + 1].PixelData;

	mov	eax, DWORD PTR _PixelCount$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _Pixels$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _P1$4[ebp], edx

; 1334 :         FinalPixel = 0xff000000;

	mov	DWORD PTR _FinalPixel$[ebp], -16777216	; ff000000H

; 1335 :         FinalPixel |= (((P0 & 0x00ff0000 >> 16) + (P1 & 0x00ff0000 >> 16) / 2) << 16);

	mov	eax, DWORD PTR _P0$5[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _P1$4[ebp]
	and	ecx, 255				; 000000ffH
	shr	ecx, 1
	add	eax, ecx
	shl	eax, 16					; 00000010H
	or	eax, DWORD PTR _FinalPixel$[ebp]
	mov	DWORD PTR _FinalPixel$[ebp], eax

; 1336 :         FinalPixel |= (((P0 & 0x0000ff00 >> 8) + (P1 & 0x0000ff00 >> 8) / 2) << 8);

	mov	edx, DWORD PTR _P0$5[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _P1$4[ebp]
	and	eax, 255				; 000000ffH
	shr	eax, 1
	add	edx, eax
	shl	edx, 8
	or	edx, DWORD PTR _FinalPixel$[ebp]
	mov	DWORD PTR _FinalPixel$[ebp], edx

; 1337 :         FinalPixel |= (((P0 & 0x000000ff >> 0) + (P1 & 0x000000ff >> 0) / 2) << 0);

	mov	ecx, DWORD PTR _P0$5[ebp]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _P1$4[ebp]
	and	edx, 255				; 000000ffH
	shr	edx, 1
	add	ecx, edx
	or	ecx, DWORD PTR _FinalPixel$[ebp]
	mov	DWORD PTR _FinalPixel$[ebp], ecx
$LN15@MedianPixe:

; 1338 :     }
; 1339 : 
; 1340 :     delete[] Pixels;

	mov	eax, DWORD PTR _Pixels$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 1341 : 
; 1342 :     return FinalPixel;

	mov	eax, DWORD PTR _FinalPixel$[ebp]
$LN1@MedianPixe:

; 1343 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_MedianPixel@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_Blue$ = -20						; size = 4
_Green$ = -16						; size = 4
_Red$ = -12						; size = 4
_Alpha$ = -8						; size = 4
_i$1 = -4						; size = 4
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_MeanPixel@8 PROC

; 1260 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1261 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN5@MeanPixel

; 1262 :         return 0;

	xor	eax, eax
	jmp	$LN1@MeanPixel
$LN5@MeanPixel:

; 1263 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN6@MeanPixel

; 1264 :         return 0;

	xor	eax, eax
	jmp	$LN1@MeanPixel
$LN6@MeanPixel:

; 1265 :     UINT32 Alpha = 0;

	mov	DWORD PTR _Alpha$[ebp], 0

; 1266 :     UINT32 Red = 0;

	mov	DWORD PTR _Red$[ebp], 0

; 1267 :     UINT32 Green = 0;

	mov	DWORD PTR _Green$[ebp], 0

; 1268 :     UINT32 Blue = 0;

	mov	DWORD PTR _Blue$[ebp], 0

; 1269 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@MeanPixel
$LN2@MeanPixel:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@MeanPixel:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _PixelCount$[ebp]
	jge	SHORT $LN3@MeanPixel

; 1270 :     {
; 1271 :         Alpha += (PackedPixels[i] & 0xff000000) >> 24;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	add	ecx, DWORD PTR _Alpha$[ebp]
	mov	DWORD PTR _Alpha$[ebp], ecx

; 1272 :         Red += (PackedPixels[i] & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _Red$[ebp]
	mov	DWORD PTR _Red$[ebp], ecx

; 1273 :         Green += (PackedPixels[i] & 0x0000ff00) >> 8;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	add	ecx, DWORD PTR _Green$[ebp]
	mov	DWORD PTR _Green$[ebp], ecx

; 1274 :         Blue += (PackedPixels[i] & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, 255				; 000000ffH
	add	ecx, DWORD PTR _Blue$[ebp]
	mov	DWORD PTR _Blue$[ebp], ecx

; 1275 :     }

	jmp	SHORT $LN2@MeanPixel
$LN3@MeanPixel:

; 1276 :     Alpha = Alpha / PixelCount;

	mov	eax, DWORD PTR _Alpha$[ebp]
	xor	edx, edx
	div	DWORD PTR _PixelCount$[ebp]
	mov	DWORD PTR _Alpha$[ebp], eax

; 1277 :     Red = Red / PixelCount;

	mov	eax, DWORD PTR _Red$[ebp]
	xor	edx, edx
	div	DWORD PTR _PixelCount$[ebp]
	mov	DWORD PTR _Red$[ebp], eax

; 1278 :     Green = Green / PixelCount;

	mov	eax, DWORD PTR _Green$[ebp]
	xor	edx, edx
	div	DWORD PTR _PixelCount$[ebp]
	mov	DWORD PTR _Green$[ebp], eax

; 1279 :     Blue = Blue / PixelCount;

	mov	eax, DWORD PTR _Blue$[ebp]
	xor	edx, edx
	div	DWORD PTR _PixelCount$[ebp]
	mov	DWORD PTR _Blue$[ebp], eax

; 1280 :     return Alpha << 24 | Red << 16 | Green << 8 | Blue;

	mov	eax, DWORD PTR _Alpha$[ebp]
	shl	eax, 24					; 00000018H
	mov	edx, DWORD PTR _Red$[ebp]
	shl	edx, 16					; 00000010H
	or	eax, edx
	mov	ecx, DWORD PTR _Green$[ebp]
	shl	ecx, 8
	or	eax, ecx
	or	eax, DWORD PTR _Blue$[ebp]
$LN1@MeanPixel:

; 1281 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_MeanPixel@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_ChannelIndex$ = -12					; size = 4
_PixelSize$ = -8					; size = 4
_i$1 = -4						; size = 4
_DoublePixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_AlphaSum$ = 16						; size = 4
_RedSum$ = 20						; size = 4
_GreenSum$ = 24						; size = 4
_BlueSum$ = 28						; size = 4
_PixelSumDouble@24 PROC

; 1444 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1445 :     if (DoublePixels == NULL)

	cmp	DWORD PTR _DoublePixels$[ebp], 0
	jne	SHORT $LN5@PixelSumDo

; 1446 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@PixelSumDo
$LN5@PixelSumDo:

; 1447 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN6@PixelSumDo

; 1448 :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@PixelSumDo
$LN6@PixelSumDo:

; 1449 : 
; 1450 :     AlphaSum = 0;

	mov	DWORD PTR _AlphaSum$[ebp], 0

; 1451 :     RedSum = 0;

	mov	DWORD PTR _RedSum$[ebp], 0

; 1452 :     GreenSum = 0;

	mov	DWORD PTR _GreenSum$[ebp], 0

; 1453 :     BlueSum = 0;

	mov	DWORD PTR _BlueSum$[ebp], 0

; 1454 :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1455 : 
; 1456 :     int ChannelIndex = 0;

	mov	DWORD PTR _ChannelIndex$[ebp], 0

; 1457 :     for (int i = 0; i < PixelCount * PixelSize; i += PixelSize)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@PixelSumDo
$LN2@PixelSumDo:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, DWORD PTR _PixelSize$[ebp]
	mov	DWORD PTR _i$1[ebp], eax
$LN4@PixelSumDo:
	mov	ecx, DWORD PTR _PixelCount$[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	cmp	DWORD PTR _i$1[ebp], ecx
	jge	SHORT $LN3@PixelSumDo

; 1458 :     {
; 1459 :         *AlphaSum += DoublePixels[i + 3];

	mov	edx, DWORD PTR _AlphaSum$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _DoublePixels$[ebp]
	movsd	xmm0, QWORD PTR [edx]
	addsd	xmm0, QWORD PTR [ecx+eax*8+24]
	mov	edx, DWORD PTR _AlphaSum$[ebp]
	movsd	QWORD PTR [edx], xmm0

; 1460 :         *RedSum += DoublePixels[i + 2];

	mov	eax, DWORD PTR _RedSum$[ebp]
	mov	ecx, DWORD PTR _i$1[ebp]
	mov	edx, DWORD PTR _DoublePixels$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	addsd	xmm0, QWORD PTR [edx+ecx*8+16]
	mov	eax, DWORD PTR _RedSum$[ebp]
	movsd	QWORD PTR [eax], xmm0

; 1461 :         *GreenSum += DoublePixels[i + 1];

	mov	ecx, DWORD PTR _GreenSum$[ebp]
	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _DoublePixels$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	addsd	xmm0, QWORD PTR [eax+edx*8+8]
	mov	ecx, DWORD PTR _GreenSum$[ebp]
	movsd	QWORD PTR [ecx], xmm0

; 1462 :         *BlueSum += DoublePixels[i + 0];

	mov	edx, DWORD PTR _BlueSum$[ebp]
	mov	eax, DWORD PTR _i$1[ebp]
	mov	ecx, DWORD PTR _DoublePixels$[ebp]
	movsd	xmm0, QWORD PTR [edx]
	addsd	xmm0, QWORD PTR [ecx+eax*8]
	mov	edx, DWORD PTR _BlueSum$[ebp]
	movsd	QWORD PTR [edx], xmm0

; 1463 :     }

	jmp	SHORT $LN2@PixelSumDo
$LN3@PixelSumDo:

; 1464 : 
; 1465 :     return Success;

	xor	eax, eax
$LN1@PixelSumDo:

; 1466 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_PixelSumDouble@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_Blue$ = -20						; size = 4
_Green$ = -16						; size = 4
_Red$ = -12						; size = 4
_Alpha$ = -8						; size = 4
_i$1 = -4						; size = 4
_PackedPixels$ = 8					; size = 4
_PixelCount$ = 12					; size = 4
_PixelSum@8 PROC

; 1406 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1407 :     if (PackedPixels == NULL)

	cmp	DWORD PTR _PackedPixels$[ebp], 0
	jne	SHORT $LN5@PixelSum

; 1408 :         return 0;

	xor	eax, eax
	jmp	$LN1@PixelSum
$LN5@PixelSum:

; 1409 :     if (PixelCount < 1)

	cmp	DWORD PTR _PixelCount$[ebp], 1
	jge	SHORT $LN6@PixelSum

; 1410 :         return 0;

	xor	eax, eax
	jmp	$LN1@PixelSum
$LN6@PixelSum:

; 1411 :     UINT32 Alpha = 0;

	mov	DWORD PTR _Alpha$[ebp], 0

; 1412 :     UINT32 Red = 0;

	mov	DWORD PTR _Red$[ebp], 0

; 1413 :     UINT32 Green = 0;

	mov	DWORD PTR _Green$[ebp], 0

; 1414 :     UINT32 Blue = 0;

	mov	DWORD PTR _Blue$[ebp], 0

; 1415 :     for (int i = 0; i < PixelCount; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@PixelSum
$LN2@PixelSum:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@PixelSum:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _PixelCount$[ebp]
	jge	SHORT $LN3@PixelSum

; 1416 :     {
; 1417 :         Alpha += (PackedPixels[i] & 0xff000000) >> 24;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	add	ecx, DWORD PTR _Alpha$[ebp]
	mov	DWORD PTR _Alpha$[ebp], ecx

; 1418 :         Red += (PackedPixels[i] & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, 16711680				; 00ff0000H
	shr	ecx, 16					; 00000010H
	add	ecx, DWORD PTR _Red$[ebp]
	mov	DWORD PTR _Red$[ebp], ecx

; 1419 :         Green += (PackedPixels[i] & 0x0000ff00) >> 8;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	add	ecx, DWORD PTR _Green$[ebp]
	mov	DWORD PTR _Green$[ebp], ecx

; 1420 :         Blue += (PackedPixels[i] & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _i$1[ebp]
	mov	eax, DWORD PTR _PackedPixels$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	and	ecx, 255				; 000000ffH
	add	ecx, DWORD PTR _Blue$[ebp]
	mov	DWORD PTR _Blue$[ebp], ecx

; 1421 :     }

	jmp	SHORT $LN2@PixelSum
$LN3@PixelSum:

; 1422 :     if (Alpha > 255)

	cmp	DWORD PTR _Alpha$[ebp], 255		; 000000ffH
	jbe	SHORT $LN7@PixelSum

; 1423 :         Alpha = 255;

	mov	DWORD PTR _Alpha$[ebp], 255		; 000000ffH
$LN7@PixelSum:

; 1424 :     if (Red > 255)

	cmp	DWORD PTR _Red$[ebp], 255		; 000000ffH
	jbe	SHORT $LN8@PixelSum

; 1425 :         Red = 255;

	mov	DWORD PTR _Red$[ebp], 255		; 000000ffH
$LN8@PixelSum:

; 1426 :     if (Green > 255)

	cmp	DWORD PTR _Green$[ebp], 255		; 000000ffH
	jbe	SHORT $LN9@PixelSum

; 1427 :         Green = 255;

	mov	DWORD PTR _Green$[ebp], 255		; 000000ffH
$LN9@PixelSum:

; 1428 :     if (Blue > 255)

	cmp	DWORD PTR _Blue$[ebp], 255		; 000000ffH
	jbe	SHORT $LN10@PixelSum

; 1429 :         Blue = 255;

	mov	DWORD PTR _Blue$[ebp], 255		; 000000ffH
$LN10@PixelSum:

; 1430 :     return Alpha << 24 | Red << 16 | Green << 8 | Blue;

	mov	eax, DWORD PTR _Alpha$[ebp]
	shl	eax, 24					; 00000018H
	mov	edx, DWORD PTR _Red$[ebp]
	shl	edx, 16					; 00000010H
	or	eax, edx
	mov	ecx, DWORD PTR _Green$[ebp]
	shl	ecx, 8
	or	eax, ecx
	or	eax, DWORD PTR _Blue$[ebp]
$LN1@PixelSum:

; 1431 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_PixelSum@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Dest$ = -24						; size = 4
_Src$ = -20						; size = 4
_Column$2 = -16						; size = 4
_Row$3 = -12						; size = 4
_Index$4 = -8						; size = 4
_B$5 = -4						; size = 1
_G$6 = -3						; size = 1
_R$7 = -2						; size = 1
_A$8 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_RollRight$ = 28					; size = 4
_RollAmount$ = 32					; size = 4
_IncludeAlpha$ = 36					; size = 4
_ChannelRollBits@32 PROC

; 1219 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1220 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ChannelRol

; 1221 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelRol
$LN8@ChannelRol:

; 1222 :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ChannelRol

; 1223 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelRol
$LN9@ChannelRol:

; 1224 :     if (RollAmount == 0)

	cmp	DWORD PTR _RollAmount$[ebp], 0
	jne	SHORT $LN10@ChannelRol

; 1225 :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@ChannelRol
$LN10@ChannelRol:

; 1226 : 
; 1227 :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1228 :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1229 :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1230 : 
; 1231 :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ChannelRol
$LN2@ChannelRol:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@ChannelRol:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@ChannelRol

; 1232 :     {
; 1233 :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 1234 :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ChannelRol
$LN5@ChannelRol:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@ChannelRol:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@ChannelRol

; 1235 :         {
; 1236 :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 1237 :             BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 1238 :             BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$7[ebp], dl

; 1239 :             BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$6[ebp], cl

; 1240 :             BYTE B = Src[Index + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$5[ebp], al

; 1241 : 
; 1242 : 
; 1243 :             Dest[Index + 3] = A;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 1244 :             Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [eax+2], cl

; 1245 :             Dest[Index + 1] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [edx+1], al

; 1246 :             Dest[Index + 0] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _B$5[ebp]
	mov	BYTE PTR [ecx], dl

; 1247 :         }

	jmp	SHORT $LN5@ChannelRol
$LN6@ChannelRol:

; 1248 :     }

	jmp	$LN2@ChannelRol
$LN3@ChannelRol:

; 1249 : 
; 1250 :     return Success;

	xor	eax, eax
$LN1@ChannelRol:

; 1251 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_ChannelRollBits@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_RowOffset$1 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Dest$ = -24						; size = 4
_Src$ = -20						; size = 4
_Column$2 = -16						; size = 4
_Row$3 = -12						; size = 4
_Index$4 = -8						; size = 4
_B$5 = -4						; size = 1
_G$6 = -3						; size = 1
_R$7 = -2						; size = 1
_A$8 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_ShiftRight$ = 28					; size = 4
_ShiftAmount$ = 32					; size = 4
_IncludeAlpha$ = 36					; size = 4
_ChannelShiftBits@32 PROC

; 1131 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1132 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ChannelShi

; 1133 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelShi
$LN8@ChannelShi:

; 1134 :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ChannelShi

; 1135 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelShi
$LN9@ChannelShi:

; 1136 :     if (ShiftAmount == 0)

	cmp	DWORD PTR _ShiftAmount$[ebp], 0
	jne	SHORT $LN10@ChannelShi

; 1137 :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@ChannelShi
$LN10@ChannelShi:

; 1138 : 
; 1139 :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1140 :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1141 :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1142 : 
; 1143 :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ChannelShi
$LN2@ChannelShi:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@ChannelShi:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@ChannelShi

; 1144 :     {
; 1145 :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 1146 :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ChannelShi
$LN5@ChannelShi:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@ChannelShi:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@ChannelShi

; 1147 :         {
; 1148 :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 1149 :             BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$8[ebp], al

; 1150 :             BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$7[ebp], dl

; 1151 :             BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$6[ebp], cl

; 1152 :             BYTE B = Src[Index + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$5[ebp], al

; 1153 :             if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN11@ChannelShi

; 1154 :             {
; 1155 :                 if (ShiftRight)

	cmp	DWORD PTR _ShiftRight$[ebp], 0
	je	SHORT $LN12@ChannelShi

; 1156 :                     A = A >> ShiftAmount;

	movzx	edx, BYTE PTR _A$8[ebp]
	mov	ecx, DWORD PTR _ShiftAmount$[ebp]
	sar	edx, cl
	mov	BYTE PTR _A$8[ebp], dl

; 1157 :                 else

	jmp	SHORT $LN11@ChannelShi
$LN12@ChannelShi:

; 1158 :                     A = A << ShiftAmount;

	movzx	eax, BYTE PTR _A$8[ebp]
	mov	ecx, DWORD PTR _ShiftAmount$[ebp]
	shl	eax, cl
	mov	BYTE PTR _A$8[ebp], al
$LN11@ChannelShi:

; 1159 :             }
; 1160 :             if (ShiftRight)

	cmp	DWORD PTR _ShiftRight$[ebp], 0
	je	SHORT $LN14@ChannelShi

; 1161 :             {
; 1162 :                 R = R >> ShiftAmount;

	movzx	edx, BYTE PTR _R$7[ebp]
	mov	ecx, DWORD PTR _ShiftAmount$[ebp]
	sar	edx, cl
	mov	BYTE PTR _R$7[ebp], dl

; 1163 :                 G = G >> ShiftAmount;

	movzx	eax, BYTE PTR _G$6[ebp]
	mov	ecx, DWORD PTR _ShiftAmount$[ebp]
	sar	eax, cl
	mov	BYTE PTR _G$6[ebp], al

; 1164 :                 B = B >> ShiftAmount;

	movzx	edx, BYTE PTR _B$5[ebp]
	mov	ecx, DWORD PTR _ShiftAmount$[ebp]
	sar	edx, cl
	mov	BYTE PTR _B$5[ebp], dl

; 1165 :             }
; 1166 :             else

	jmp	SHORT $LN15@ChannelShi
$LN14@ChannelShi:

; 1167 :             {
; 1168 :                 R = R << ShiftAmount;

	movzx	eax, BYTE PTR _R$7[ebp]
	mov	ecx, DWORD PTR _ShiftAmount$[ebp]
	shl	eax, cl
	mov	BYTE PTR _R$7[ebp], al

; 1169 :                 G = G << ShiftAmount;

	movzx	edx, BYTE PTR _G$6[ebp]
	mov	ecx, DWORD PTR _ShiftAmount$[ebp]
	shl	edx, cl
	mov	BYTE PTR _G$6[ebp], dl

; 1170 :                 B = B << ShiftAmount;

	movzx	eax, BYTE PTR _B$5[ebp]
	mov	ecx, DWORD PTR _ShiftAmount$[ebp]
	shl	eax, cl
	mov	BYTE PTR _B$5[ebp], al
$LN15@ChannelShi:

; 1171 :             }
; 1172 :             Dest[Index + 3] = A;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 1173 :             Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [eax+2], cl

; 1174 :             Dest[Index + 1] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [edx+1], al

; 1175 :             Dest[Index + 0] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _B$5[ebp]
	mov	BYTE PTR [ecx], dl

; 1176 :         }

	jmp	$LN5@ChannelShi
$LN6@ChannelShi:

; 1177 :     }

	jmp	$LN2@ChannelShi
$LN3@ChannelShi:

; 1178 : 
; 1179 :     return Success;

	xor	eax, eax
$LN1@ChannelShi:

; 1180 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_ChannelShiftBits@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
tv76 = -24						; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_SourceBuffer$ = -12					; size = 4
_Index$4 = -8						; size = 4
_PixelSize$ = -1					; size = 1
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Operator$ = 24						; size = 4
_Operand$ = 28						; size = 8
_IncludeAlpha$ = 36					; size = 1
_DoubleBlockOperation@32 PROC

; 151  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 152  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN10@DoubleBloc

; 153  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@DoubleBloc
$LN10@DoubleBloc:

; 154  :     if (Operand == 0.0)

	movsd	xmm0, QWORD PTR _Operand$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN12@DoubleBloc

; 155  :     {
; 156  :         if ((Operator == BlockDivide) || (Operator == BlockModulo))

	cmp	DWORD PTR _Operator$[ebp], 3
	je	SHORT $LN13@DoubleBloc
	cmp	DWORD PTR _Operator$[ebp], 4
	jne	SHORT $LN12@DoubleBloc
$LN13@DoubleBloc:

; 157  :         {
; 158  :             return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@DoubleBloc
$LN12@DoubleBloc:

; 159  :         }
; 160  :     }
; 161  : 
; 162  :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 163  :     double* SourceBuffer = (double*)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _SourceBuffer$[ebp], eax

; 164  : 
; 165  :     for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@DoubleBloc
$LN2@DoubleBloc:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@DoubleBloc:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@DoubleBloc

; 166  :     {
; 167  :         int RowOffset = Row * SourceStride;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 168  :         for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@DoubleBloc
$LN5@DoubleBloc:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@DoubleBloc:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@DoubleBloc

; 169  :         {
; 170  :             int Index = RowOffset + (Column * PixelSize);

	movzx	eax, BYTE PTR _PixelSize$[ebp]
	imul	eax, DWORD PTR _Column$2[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 171  :             switch (Operator)

	mov	ecx, DWORD PTR _Operator$[ebp]
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 3
	ja	$LN22@DoubleBloc
	mov	edx, DWORD PTR tv76[ebp]
	jmp	DWORD PTR $LN24@DoubleBloc[edx*4]
$LN14@DoubleBloc:

; 172  :             {
; 173  :             case BlockAdd:
; 174  :                 SourceBuffer[Index + 0] += Operand;

	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [ecx+eax*8]
	addsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [eax+edx*8], xmm0

; 175  :                 SourceBuffer[Index + 1] += Operand;

	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [edx+ecx*8+8]
	addsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [ecx+eax*8+8], xmm0

; 176  :                 SourceBuffer[Index + 2] += Operand;

	mov	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [eax+edx*8+16]
	addsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [edx+ecx*8+16], xmm0

; 177  :                 if (IncludeAlpha)

	movzx	eax, BYTE PTR _IncludeAlpha$[ebp]
	test	eax, eax
	je	SHORT $LN15@DoubleBloc

; 178  :                     SourceBuffer[Index + 3] += Operand;

	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [edx+ecx*8+24]
	addsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [ecx+eax*8+24], xmm0
$LN15@DoubleBloc:

; 179  :                 break;

	jmp	$LN8@DoubleBloc
$LN16@DoubleBloc:

; 180  : 
; 181  :             case BlockSubtract:
; 182  :                 SourceBuffer[Index + 0] -= Operand;

	mov	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [eax+edx*8]
	subsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [edx+ecx*8], xmm0

; 183  :                 SourceBuffer[Index + 1] -= Operand;

	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [ecx+eax*8+8]
	subsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [eax+edx*8+8], xmm0

; 184  :                 SourceBuffer[Index + 2] -= Operand;

	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [edx+ecx*8+16]
	subsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [ecx+eax*8+16], xmm0

; 185  :                 if (IncludeAlpha)

	movzx	edx, BYTE PTR _IncludeAlpha$[ebp]
	test	edx, edx
	je	SHORT $LN17@DoubleBloc

; 186  :                     SourceBuffer[Index + 3] -= Operand;

	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [ecx+eax*8+24]
	subsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [eax+edx*8+24], xmm0
$LN17@DoubleBloc:

; 187  :                 break;

	jmp	$LN8@DoubleBloc
$LN18@DoubleBloc:

; 188  : 
; 189  :             case BlockMultiply:
; 190  :                 SourceBuffer[Index + 0] *= Operand;

	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [edx+ecx*8]
	mulsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [ecx+eax*8], xmm0

; 191  :                 SourceBuffer[Index + 1] *= Operand;

	mov	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [eax+edx*8+8]
	mulsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [edx+ecx*8+8], xmm0

; 192  :                 SourceBuffer[Index + 2] *= Operand;

	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [ecx+eax*8+16]
	mulsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [eax+edx*8+16], xmm0

; 193  :                 if (IncludeAlpha)

	movzx	ecx, BYTE PTR _IncludeAlpha$[ebp]
	test	ecx, ecx
	je	SHORT $LN19@DoubleBloc

; 194  :                     SourceBuffer[Index + 3] *= Operand;

	mov	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [eax+edx*8+24]
	mulsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [edx+ecx*8+24], xmm0
$LN19@DoubleBloc:

; 195  :                 break;

	jmp	$LN8@DoubleBloc
$LN20@DoubleBloc:

; 196  : 
; 197  :             case BlockDivide:
; 198  :                 SourceBuffer[Index + 0] /= Operand;

	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [ecx+eax*8]
	divsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [eax+edx*8], xmm0

; 199  :                 SourceBuffer[Index + 1] /= Operand;

	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [edx+ecx*8+8]
	divsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [ecx+eax*8+8], xmm0

; 200  :                 SourceBuffer[Index + 2] /= Operand;

	mov	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [eax+edx*8+16]
	divsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [edx+ecx*8+16], xmm0

; 201  :                 if (IncludeAlpha)

	movzx	eax, BYTE PTR _IncludeAlpha$[ebp]
	test	eax, eax
	je	SHORT $LN21@DoubleBloc

; 202  :                     SourceBuffer[Index + 3] /= Operand;

	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	movsd	xmm0, QWORD PTR [edx+ecx*8+24]
	divsd	xmm0, QWORD PTR _Operand$[ebp]
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	movsd	QWORD PTR [ecx+eax*8+24], xmm0
$LN21@DoubleBloc:

; 203  :                 break;

	jmp	SHORT $LN8@DoubleBloc
$LN22@DoubleBloc:

; 204  : 
; 205  :             default:
; 206  :                 return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@DoubleBloc
$LN8@DoubleBloc:

; 207  :             }
; 208  :         }

	jmp	$LN5@DoubleBloc
$LN6@DoubleBloc:

; 209  :     }

	jmp	$LN2@DoubleBloc
$LN3@DoubleBloc:

; 210  : 
; 211  :     return Success;

	xor	eax, eax
$LN1@DoubleBloc:

; 212  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	3
$LN24@DoubleBloc:
	DD	$LN14@DoubleBloc
	DD	$LN16@DoubleBloc
	DD	$LN18@DoubleBloc
	DD	$LN20@DoubleBloc
_DoubleBlockOperation@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Operator$ = 28						; size = 4
_Operand$ = 32						; size = 1
_IncludeAlpha$ = 36					; size = 1
_ByteBlockOperation@32 PROC

; 494  : {

	push	ebp
	mov	ebp, esp

; 495  :     return ByteBlockOperationByChannel(Source, Width, Height, Stride, Destination, Operator, Operand, IncludeAlpha, TRUE, TRUE, TRUE);

	push	1
	push	1
	push	1
	movzx	eax, BYTE PTR _IncludeAlpha$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _Operand$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Operator$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_ByteBlockOperationByChannel@44

; 496  :     /*
; 497  :     if (Source == NULL)
; 498  :         return NullPointer;
; 499  :     if (Destination == NULL)
; 500  :         return NullPointer;
; 501  :     if (Operand == 0.0)
; 502  :     {
; 503  :         if ((Operator == BlockDivide) || (Operator == BlockModulo))
; 504  :         {
; 505  :             return InvalidOperation;
; 506  :         }
; 507  :     }
; 508  : 
; 509  :     BYTE PixelSize = 4;
; 510  :     BYTE* Src = (BYTE*)Source;
; 511  :     BYTE *Dest = (BYTE *)Destination;
; 512  : 
; 513  :     for (int Row = 0; Row < Height; Row++)
; 514  :     {
; 515  :         int RowOffset = Row * Stride;
; 516  :         for (int Column = 0; Column < Width; Column++)
; 517  :         {
; 518  :             int Index = RowOffset + (Column * PixelSize);
; 519  :             Dest[Index + 3] = Src[Index + 3];
; 520  :             BYTE A = Src[Index + 3];
; 521  :             BYTE R = Src[Index + 2];
; 522  :             BYTE G = Src[Index + 1];
; 523  :             BYTE B = Src[Index + 0];
; 524  : 
; 525  :             switch (Operator)
; 526  :             {
; 527  :             case BlockAdd:
; 528  :                 Dest[Index + 0] = (BYTE)(B + Operand);
; 529  :                 Dest[Index + 1] = (BYTE)(G + Operand);
; 530  :                 Dest[Index + 2] = (BYTE)(R + Operand);
; 531  :                 if (IncludeAlpha)
; 532  :                     Dest[Index + 3] = (BYTE)(A + Operand);
; 533  :                 break;
; 534  : 
; 535  :             case BlockSubtract:
; 536  :                 Dest[Index + 0] = (BYTE)(B - Operand);
; 537  :                 Dest[Index + 1] = (BYTE)(G - Operand);
; 538  :                 Dest[Index + 2] = (BYTE)(R - Operand);
; 539  :                 if (IncludeAlpha)
; 540  :                     Dest[Index + 3] = (BYTE)(A - Operand);
; 541  :                 break;
; 542  : 
; 543  :             case BlockMultiply:
; 544  :                 Dest[Index + 0] = (BYTE)(B * Operand);
; 545  :                 Dest[Index + 1] = (BYTE)(G * Operand);
; 546  :                 Dest[Index + 2] = (BYTE)(R * Operand);
; 547  :                 if (IncludeAlpha)
; 548  :                     Dest[Index + 3] = (BYTE)(A * Operand);
; 549  :                 break;
; 550  : 
; 551  :             case BlockDivide:
; 552  :                 Dest[Index + 0] = (BYTE)((double)B / (double)Operand);
; 553  :                 Dest[Index + 1] = (BYTE)((double)G / (double)Operand);
; 554  :                 Dest[Index + 2] = (BYTE)((double)R / (double)Operand);
; 555  :                 if (IncludeAlpha)
; 556  :                     Dest[Index + 3] = (BYTE)((double)A / (double)Operand);
; 557  :                 break;
; 558  : 
; 559  :             case BlockModulo:
; 560  :                 Dest[Index + 0] = (BYTE)(B % Operand);
; 561  :                 Dest[Index + 1] = (BYTE)(G % Operand);
; 562  :                 Dest[Index + 2] = (BYTE)(R % Operand);
; 563  :                 if (IncludeAlpha)
; 564  :                     Dest[Index + 3] = (BYTE)(A % Operand);
; 565  :                 break;
; 566  : 
; 567  :             case BlockAnd:
; 568  :                 Dest[Index + 0] = (BYTE)(B & Operand);
; 569  :                 Dest[Index + 1] = (BYTE)(G & Operand);
; 570  :                 Dest[Index + 2] = (BYTE)(R & Operand);
; 571  :                 if (IncludeAlpha)
; 572  :                     Dest[Index + 3] = (BYTE)(A & Operand);
; 573  :                 break;
; 574  : 
; 575  :             case BlockOr:
; 576  :                 Dest[Index + 0] = (BYTE)(B | Operand);
; 577  :                 Dest[Index + 1] = (BYTE)(G | Operand);
; 578  :                 Dest[Index + 2] = (BYTE)(R | Operand);
; 579  :                 if (IncludeAlpha)
; 580  :                     Dest[Index + 3] = (BYTE)(A | Operand);
; 581  :                 break;
; 582  : 
; 583  :             case BlockXor:
; 584  :                 Dest[Index + 0] = (BYTE)(B ^ Operand);
; 585  :                 Dest[Index + 1] = (BYTE)(G ^ Operand);
; 586  :                 Dest[Index + 2] = (BYTE)(R ^ Operand);
; 587  :                 if (IncludeAlpha)
; 588  :                     Dest[Index + 3] = (BYTE)(A ^ Operand);
; 589  :                 break;
; 590  : 
; 591  :             case BlockShl:
; 592  :                 Dest[Index + 0] = (BYTE)(B << Operand);
; 593  :                 Dest[Index + 1] = (BYTE)(G << Operand);
; 594  :                 Dest[Index + 2] = (BYTE)(R << Operand);
; 595  :                 if (IncludeAlpha)
; 596  :                     Dest[Index + 3] = (BYTE)(A << Operand);
; 597  :                 break;
; 598  : 
; 599  :             case BlockShr:
; 600  :                 Dest[Index + 0] = (BYTE)(B >> Operand);
; 601  :                 Dest[Index + 1] = (BYTE)(G >> Operand);
; 602  :                 Dest[Index + 2] = (BYTE)(R >> Operand);
; 603  :                 if (IncludeAlpha)
; 604  :                     Dest[Index + 3] = (BYTE)(A >> Operand);
; 605  :                 break;
; 606  : 
; 607  :             case BlockRol:
; 608  :                 break;
; 609  : 
; 610  :             case BlockRor:
; 611  :                 break;
; 612  : 
; 613  :             default:
; 614  :                 return InvalidOperation;
; 615  :             }
; 616  :         }
; 617  :     }
; 618  : 
; 619  :     return Success;
; 620  :     */
; 621  : }

	pop	ebp
	ret	32					; 00000020H
_ByteBlockOperation@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
$T1 = -60						; size = 4
_Images$ = -56						; size = 4
$T2 = -52						; size = 4
_RowOffset$3 = -48					; size = 4
_PixelSize$ = -44					; size = 4
tv148 = -40						; size = 4
_Dest$ = -36						; size = 4
_Extra$ = -32						; size = 4
_ImageBits$4 = -28					; size = 4
_Column$5 = -24						; size = 4
_Row$6 = -20						; size = 4
_i$7 = -16						; size = 4
_Index$8 = -12						; size = 4
_PixelList$9 = -8					; size = 4
_Final$10 = -4						; size = 4
_Destination$ = 8					; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_ImageSet$ = 24						; size = 4
_ImageCount$ = 28					; size = 4
_Operation$ = 32					; size = 4
_ExtraData$ = 36					; size = 4
_MassImageArithmetic@32 PROC

; 1711 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 1712 :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN13@MassImageA

; 1713 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MassImageA
$LN13@MassImageA:

; 1714 :     if (ImageSet == NULL)

	cmp	DWORD PTR _ImageSet$[ebp], 0
	jne	SHORT $LN14@MassImageA

; 1715 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@MassImageA
$LN14@MassImageA:

; 1716 :     if (ImageCount < 1)

	cmp	DWORD PTR _ImageCount$[ebp], 1
	jge	SHORT $LN15@MassImageA

; 1717 :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@MassImageA
$LN15@MassImageA:

; 1718 :     MassArithmeticExtra *Extra = NULL;

	mov	DWORD PTR _Extra$[ebp], 0

; 1719 :     if ((Operation == ClosestLuminance) || (Operation == FarthestLuminance))

	cmp	DWORD PTR _Operation$[ebp], 5
	je	SHORT $LN17@MassImageA
	cmp	DWORD PTR _Operation$[ebp], 6
	jne	SHORT $LN16@MassImageA
$LN17@MassImageA:

; 1720 :     {
; 1721 :         if (ExtraData == NULL)

	cmp	DWORD PTR _ExtraData$[ebp], 0
	jne	SHORT $LN18@MassImageA

; 1722 :             return NullPointer;

	mov	eax, 3
	jmp	$LN1@MassImageA
$LN18@MassImageA:

; 1723 :         Extra = (MassArithmeticExtra *)ExtraData;

	mov	eax, DWORD PTR _ExtraData$[ebp]
	mov	DWORD PTR _Extra$[ebp], eax
$LN16@MassImageA:

; 1724 :     }
; 1725 : 
; 1726 :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1727 :     GenericImageNode *Images = (GenericImageNode *)ImageSet;

	mov	edx, DWORD PTR _ImageSet$[ebp]
	mov	DWORD PTR _Images$[ebp], edx

; 1728 :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1729 : 
; 1730 :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@MassImageA
$LN2@MassImageA:
	mov	eax, DWORD PTR _Row$6[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$6[ebp], eax
$LN4@MassImageA:
	mov	ecx, DWORD PTR _Row$6[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN3@MassImageA

; 1731 :     {
; 1732 :         int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$6[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], edx

; 1733 :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@MassImageA
$LN5@MassImageA:
	mov	eax, DWORD PTR _Column$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$5[ebp], eax
$LN7@MassImageA:
	mov	ecx, DWORD PTR _Column$5[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	$LN6@MassImageA

; 1734 :         {
; 1735 :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$5[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$8[ebp], edx

; 1736 :             UINT32 *PixelList = new UINT32[ImageCount];

	xor	ecx, ecx
	mov	eax, DWORD PTR _ImageCount$[ebp]
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _PixelList$9[ebp], eax

; 1737 :             for (int i = 0; i < ImageCount; i++)

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN10@MassImageA
$LN8@MassImageA:
	mov	ecx, DWORD PTR _i$7[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$7[ebp], ecx
$LN10@MassImageA:
	mov	edx, DWORD PTR _i$7[ebp]
	cmp	edx, DWORD PTR _ImageCount$[ebp]
	jge	SHORT $LN9@MassImageA

; 1738 :             {
; 1739 :                 BYTE *ImageBits = (BYTE *)Images[i].TheBits;

	mov	eax, DWORD PTR _i$7[ebp]
	mov	ecx, DWORD PTR _Images$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _ImageBits$4[ebp], edx

; 1740 :                 PixelList[i] = (ImageBits[Index + 3] << 24) |

	mov	eax, DWORD PTR _ImageBits$4[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	shl	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _ImageBits$4[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	movzx	eax, BYTE PTR [edx+2]
	shl	eax, 16					; 00000010H
	or	ecx, eax
	mov	edx, DWORD PTR _ImageBits$4[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	movzx	eax, BYTE PTR [edx+1]
	shl	eax, 8
	or	ecx, eax
	mov	edx, DWORD PTR _ImageBits$4[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	movzx	eax, BYTE PTR [edx]
	or	ecx, eax
	mov	edx, DWORD PTR _i$7[ebp]
	mov	eax, DWORD PTR _PixelList$9[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 1741 :                     (ImageBits[Index + 2] << 16) |
; 1742 :                     (ImageBits[Index + 1] << 8) |
; 1743 :                     (ImageBits[Index + 0] << 0);
; 1744 :             }

	jmp	SHORT $LN8@MassImageA
$LN9@MassImageA:

; 1745 :             UINT32 Final = 0xff000000;

	mov	DWORD PTR _Final$10[ebp], -16777216	; ff000000H

; 1746 :             switch (Operation)

	mov	ecx, DWORD PTR _Operation$[ebp]
	mov	DWORD PTR tv148[ebp], ecx
	cmp	DWORD PTR tv148[ebp], 15		; 0000000fH
	ja	$LN30@MassImageA
	mov	edx, DWORD PTR tv148[ebp]
	jmp	DWORD PTR $LN32@MassImageA[edx*4]
$LN19@MassImageA:

; 1747 :             {
; 1748 :             case ArithemticMean:
; 1749 :                 Final = MeanPixel(PixelList, ImageCount);

	mov	eax, DWORD PTR _ImageCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _PixelList$9[ebp]
	push	ecx
	call	_MeanPixel@8
	mov	DWORD PTR _Final$10[ebp], eax

; 1750 :                 break;

	jmp	$LN11@MassImageA
$LN20@MassImageA:

; 1751 : 
; 1752 :             case ArithmeticMedian:
; 1753 :                 Final = MedianPixel(PixelList, ImageCount);

	mov	edx, DWORD PTR _ImageCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _PixelList$9[ebp]
	push	eax
	call	_MedianPixel@8
	mov	DWORD PTR _Final$10[ebp], eax

; 1754 :                 break;

	jmp	$LN11@MassImageA
$LN21@MassImageA:

; 1755 : 
; 1756 :             case ArithmeticBrightest:
; 1757 :                 Final = BrightestPixel(PixelList, ImageCount);

	mov	ecx, DWORD PTR _ImageCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _PixelList$9[ebp]
	push	edx
	call	_BrightestPixel@8
	mov	DWORD PTR _Final$10[ebp], eax

; 1758 :                 break;

	jmp	$LN11@MassImageA
$LN22@MassImageA:

; 1759 : 
; 1760 :             case ArithmeticDarkest:
; 1761 :                 Final = DarkestPixel(PixelList, ImageCount);

	mov	eax, DWORD PTR _ImageCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _PixelList$9[ebp]
	push	ecx
	call	_DarkestPixel@8
	mov	DWORD PTR _Final$10[ebp], eax

; 1762 :                 break;

	jmp	$LN11@MassImageA
$LN23@MassImageA:

; 1763 : 
; 1764 :             case ArithmeticSum:
; 1765 :                 Final = PixelSum(PixelList, ImageCount);

	mov	edx, DWORD PTR _ImageCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _PixelList$9[ebp]
	push	eax
	call	_PixelSum@8
	mov	DWORD PTR _Final$10[ebp], eax

; 1766 :                 break;

	jmp	$LN11@MassImageA
$LN24@MassImageA:

; 1767 : 
; 1768 :             case ClosestLuminance:
; 1769 :                 Final = ClosestPixelLuminance(PixelList, ImageCount, Extra->Luminance);

	mov	ecx, DWORD PTR _Extra$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _ImageCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _PixelList$9[ebp]
	push	eax
	call	_ClosestPixelLuminance@16
	mov	DWORD PTR _Final$10[ebp], eax

; 1770 :                 break;

	jmp	SHORT $LN11@MassImageA
$LN25@MassImageA:

; 1771 : 
; 1772 :             case GreatestAlpha:
; 1773 :                 Final = GreatestAlphaPixel(PixelList, ImageCount);

	mov	ecx, DWORD PTR _ImageCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _PixelList$9[ebp]
	push	edx
	call	_GreatestAlphaPixel@8
	mov	DWORD PTR _Final$10[ebp], eax

; 1774 :                 break;

	jmp	SHORT $LN11@MassImageA
$LN26@MassImageA:

; 1775 : 
; 1776 :             case LeastAlpha:
; 1777 :                 Final = SmallestAlphaPixel(PixelList, ImageCount);

	mov	eax, DWORD PTR _ImageCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _PixelList$9[ebp]
	push	ecx
	call	_SmallestAlphaPixel@8
	mov	DWORD PTR _Final$10[ebp], eax

; 1778 :                 break;

	jmp	SHORT $LN11@MassImageA
$LN27@MassImageA:

; 1779 : 
; 1780 :             case FarthestAlpha:
; 1781 :                 Final = FarthestAlphaPixel(PixelList, ImageCount, Extra->Channel);

	mov	edx, DWORD PTR _Extra$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _ImageCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _PixelList$9[ebp]
	push	edx
	call	_FarthestAlphaPixel@12
	mov	DWORD PTR _Final$10[ebp], eax

; 1782 :                 break;

	jmp	SHORT $LN11@MassImageA
$LN28@MassImageA:

; 1783 : 
; 1784 :             case ClosestAlpha:
; 1785 :                 Final = ClosestAlphaPixel(PixelList, ImageCount, Extra->Channel);

	mov	eax, DWORD PTR _Extra$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _ImageCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _PixelList$9[ebp]
	push	eax
	call	_ClosestAlphaPixel@12
	mov	DWORD PTR _Final$10[ebp], eax

; 1786 :                 break;

	jmp	SHORT $LN11@MassImageA
$LN29@MassImageA:

; 1787 : 
; 1788 :             case ArithmeticAnd:
; 1789 :             case ArithmeticOr:
; 1790 :             case ArithmeticXor:
; 1791 :                 Final = PixelLogicalOperation(PixelList, ImageCount, Operation);

	mov	ecx, DWORD PTR _Operation$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ImageCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _PixelList$9[ebp]
	push	eax
	call	?PixelLogicalOperation@@YGIPAIHH@Z	; PixelLogicalOperation
	mov	DWORD PTR _Final$10[ebp], eax

; 1792 :                 break;

	jmp	SHORT $LN11@MassImageA
$LN30@MassImageA:

; 1793 : 
; 1794 :             default:
; 1795 :                 return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@MassImageA
$LN11@MassImageA:

; 1796 :             }
; 1797 :             delete[] PixelList;

	mov	ecx, DWORD PTR _PixelList$9[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 1798 : 
; 1799 :             Dest[Index + 3] = (Final & 0xff000000) >> 24;

	mov	eax, DWORD PTR _Final$10[ebp]
	and	eax, -16777216				; ff000000H
	shr	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	BYTE PTR [ecx+3], al

; 1800 :             Dest[Index + 2] = (Final & 0x00ff0000) >> 16;

	mov	edx, DWORD PTR _Final$10[ebp]
	and	edx, 16711680				; 00ff0000H
	shr	edx, 16					; 00000010H
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	BYTE PTR [eax+2], dl

; 1801 :             Dest[Index + 1] = (Final & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _Final$10[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	BYTE PTR [edx+1], cl

; 1802 :             Dest[Index + 0] = (Final & 0x000000ff) >> 0;

	mov	eax, DWORD PTR _Final$10[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	BYTE PTR [ecx], al

; 1803 :         }

	jmp	$LN5@MassImageA
$LN6@MassImageA:

; 1804 :     }

	jmp	$LN2@MassImageA
$LN3@MassImageA:

; 1805 : 
; 1806 :     return Success;

	xor	eax, eax
$LN1@MassImageA:

; 1807 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	1
$LN32@MassImageA:
	DD	$LN19@MassImageA
	DD	$LN21@MassImageA
	DD	$LN22@MassImageA
	DD	$LN20@MassImageA
	DD	$LN23@MassImageA
	DD	$LN24@MassImageA
	DD	$LN30@MassImageA
	DD	$LN25@MassImageA
	DD	$LN26@MassImageA
	DD	$LN30@MassImageA
	DD	$LN30@MassImageA
	DD	$LN28@MassImageA
	DD	$LN27@MassImageA
	DD	$LN29@MassImageA
	DD	$LN29@MassImageA
	DD	$LN29@MassImageA
_MassImageArithmetic@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_Lum1$1 = -172						; size = 8
_Lum2$2 = -164						; size = 8
_Lum2$3 = -156						; size = 8
_Lum1$4 = -148						; size = 8
_Lum1$5 = -140						; size = 8
_Lum2$6 = -132						; size = 8
_Lum2$7 = -124						; size = 8
_Lum1$8 = -116						; size = 8
_Lum1$9 = -108						; size = 8
_Lum2$10 = -100						; size = 8
_Lum2$11 = -92						; size = 8
_Lum1$12 = -84						; size = 8
_Lum1$13 = -76						; size = 8
_Lum2$14 = -68						; size = 8
_Lum2$15 = -60						; size = 8
_Lum1$16 = -52						; size = 8
_RowOffset$17 = -44					; size = 4
tv368 = -40						; size = 4
tv278 = -36						; size = 4
tv75 = -32						; size = 4
_Column$18 = -28					; size = 4
_Row$19 = -24						; size = 4
_PixelSize$ = -17					; size = 1
_Buffer1$ = -16						; size = 4
_Buffer2$ = -12						; size = 4
_DestBuffer$ = -8					; size = 4
_Index$20 = -4						; size = 4
_Destination$ = 8					; size = 4
_DestinationWidth$ = 12					; size = 4
_DestinationHeight$ = 16				; size = 4
_DestinationStride$ = 20				; size = 4
_BufferA$ = 24						; size = 4
_BufferB$ = 28						; size = 4
_Operator$ = 32						; size = 4
_IncludeAlpha$ = 36					; size = 4
_ByteBlocksOperation@32 PROC

; 637  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH

; 638  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN10@ByteBlocks

; 639  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ByteBlocks
$LN10@ByteBlocks:

; 640  :     if (BufferA == NULL)

	cmp	DWORD PTR _BufferA$[ebp], 0
	jne	SHORT $LN11@ByteBlocks

; 641  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ByteBlocks
$LN11@ByteBlocks:

; 642  :     if (BufferB == NULL)

	cmp	DWORD PTR _BufferB$[ebp], 0
	jne	SHORT $LN12@ByteBlocks

; 643  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ByteBlocks
$LN12@ByteBlocks:

; 644  : 
; 645  :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 646  :     BYTE* DestBuffer = (BYTE*)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _DestBuffer$[ebp], eax

; 647  :     BYTE* Buffer1 = (BYTE*)BufferA;

	mov	ecx, DWORD PTR _BufferA$[ebp]
	mov	DWORD PTR _Buffer1$[ebp], ecx

; 648  :     BYTE* Buffer2 = (BYTE*)BufferB;

	mov	edx, DWORD PTR _BufferB$[ebp]
	mov	DWORD PTR _Buffer2$[ebp], edx

; 649  : 
; 650  :     for (int Row = 0; Row < DestinationHeight; Row++)

	mov	DWORD PTR _Row$19[ebp], 0
	jmp	SHORT $LN4@ByteBlocks
$LN2@ByteBlocks:
	mov	eax, DWORD PTR _Row$19[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$19[ebp], eax
$LN4@ByteBlocks:
	mov	ecx, DWORD PTR _Row$19[ebp]
	cmp	ecx, DWORD PTR _DestinationHeight$[ebp]
	jge	$LN3@ByteBlocks

; 651  :     {
; 652  :         int RowOffset = Row * DestinationStride;

	mov	edx, DWORD PTR _Row$19[ebp]
	imul	edx, DWORD PTR _DestinationStride$[ebp]
	mov	DWORD PTR _RowOffset$17[ebp], edx

; 653  :         for (int Column = 0; Column < DestinationWidth; Column++)

	mov	DWORD PTR _Column$18[ebp], 0
	jmp	SHORT $LN7@ByteBlocks
$LN5@ByteBlocks:
	mov	eax, DWORD PTR _Column$18[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$18[ebp], eax
$LN7@ByteBlocks:
	mov	ecx, DWORD PTR _Column$18[ebp]
	cmp	ecx, DWORD PTR _DestinationWidth$[ebp]
	jge	$LN6@ByteBlocks

; 654  :         {
; 655  :             int Index = RowOffset + (Column * PixelSize);

	movzx	edx, BYTE PTR _PixelSize$[ebp]
	imul	edx, DWORD PTR _Column$18[ebp]
	add	edx, DWORD PTR _RowOffset$17[ebp]
	mov	DWORD PTR _Index$20[ebp], edx

; 656  :             switch (Operator)

	mov	eax, DWORD PTR _Operator$[ebp]
	mov	DWORD PTR tv75[ebp], eax
	cmp	DWORD PTR tv75[ebp], 21			; 00000015H
	ja	$LN151@ByteBlocks
	mov	ecx, DWORD PTR tv75[ebp]
	jmp	DWORD PTR $LN157@ByteBlocks[ecx*4]
$LN13@ByteBlocks:

; 657  :             {
; 658  :             case BlockAdd:
; 659  :                 DestBuffer[Index + 0] = (BYTE)(Buffer1[Index + 0] + Buffer2[Index + 0]);

	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx]
	add	eax, edx
	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx], al

; 660  :                 DestBuffer[Index + 1] = (BYTE)(Buffer1[Index + 1] + Buffer2[Index + 1]);

	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+1]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	add	eax, edx
	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+1], al

; 661  :                 DestBuffer[Index + 2] = (BYTE)(Buffer1[Index + 2] + Buffer2[Index + 2]);

	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+2]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	add	eax, edx
	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+2], al

; 662  :                 if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN14@ByteBlocks

; 663  :                     DestBuffer[Index + 3] = (BYTE)(Buffer1[Index + 3] + Buffer2[Index + 3]);

	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+3]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	add	eax, edx
	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+3], al

; 664  :                 else

	jmp	SHORT $LN15@ByteBlocks
$LN14@ByteBlocks:

; 665  :                     DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN15@ByteBlocks:

; 666  :                 break;

	jmp	$LN8@ByteBlocks
$LN16@ByteBlocks:

; 667  : 
; 668  :             case BlockSubtract:
; 669  :                 DestBuffer[Index + 0] = (BYTE)(Buffer1[Index + 0] - Buffer2[Index + 0]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx]
	sub	ecx, eax
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx], cl

; 670  :                 DestBuffer[Index + 1] = (BYTE)(Buffer1[Index + 1] - Buffer2[Index + 1]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+1]
	sub	ecx, eax
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+1], cl

; 671  :                 DestBuffer[Index + 2] = (BYTE)(Buffer1[Index + 2] - Buffer2[Index + 2]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+2]
	sub	ecx, eax
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+2], cl

; 672  :                 if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN17@ByteBlocks

; 673  :                     DestBuffer[Index + 3] = (BYTE)(Buffer1[Index + 3] - Buffer2[Index + 3]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+3]
	sub	ecx, eax
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], cl

; 674  :                 else

	jmp	SHORT $LN18@ByteBlocks
$LN17@ByteBlocks:

; 675  :                     DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN18@ByteBlocks:

; 676  :                 break;

	jmp	$LN8@ByteBlocks
$LN19@ByteBlocks:

; 677  : 
; 678  :             case BlockMultiply:
; 679  :                 DestBuffer[Index + 0] = (BYTE)(Buffer1[Index + 0] * Buffer2[Index + 0]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax]
	imul	edx, ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax], dl

; 680  :                 DestBuffer[Index + 1] = (BYTE)(Buffer1[Index + 1] * Buffer2[Index + 1]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	imul	edx, ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+1], dl

; 681  :                 DestBuffer[Index + 2] = (BYTE)(Buffer1[Index + 2] * Buffer2[Index + 2]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	imul	edx, ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+2], dl

; 682  :                 if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN20@ByteBlocks

; 683  :                     DestBuffer[Index + 3] = (BYTE)(Buffer1[Index + 3] * Buffer2[Index + 3]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	imul	edx, ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], dl

; 684  :                 else

	jmp	SHORT $LN21@ByteBlocks
$LN20@ByteBlocks:

; 685  :                     DestBuffer[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH
$LN21@ByteBlocks:

; 686  :                 break;

	jmp	$LN8@ByteBlocks
$LN22@ByteBlocks:

; 687  : 
; 688  :             case BlockDivide:
; 689  :                 if (Buffer2[Index + 0 > 0])

	cmp	DWORD PTR _Index$20[ebp], 0
	jle	SHORT $LN153@ByteBlocks
	mov	DWORD PTR tv278[ebp], 1
	jmp	SHORT $LN154@ByteBlocks
$LN153@ByteBlocks:
	mov	DWORD PTR tv278[ebp], 0
$LN154@ByteBlocks:
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR tv278[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN23@ByteBlocks

; 690  :                     DestBuffer[Index + 0] = (BYTE)(Buffer1[Index + 0] / Buffer2[Index + 0]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [ecx]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [edx]
	cdq
	idiv	ecx
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx], al

; 691  :                 else

	jmp	SHORT $LN24@ByteBlocks
$LN23@ByteBlocks:

; 692  :                     DestBuffer[Index + 0] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH
$LN24@ByteBlocks:

; 693  :                 if (Buffer2[Index + 1] > 0)

	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	test	edx, edx
	jle	SHORT $LN25@ByteBlocks

; 694  :                     DestBuffer[Index + 1] = (BYTE)(Buffer1[Index + 1] + Buffer2[Index + 1]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+1]
	add	ecx, eax
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+1], cl

; 695  :                 else

	jmp	SHORT $LN26@ByteBlocks
$LN25@ByteBlocks:

; 696  :                     DestBuffer[Index + 1] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH
$LN26@ByteBlocks:

; 697  :                 if (Buffer2[Index + 2] > 0)

	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	test	edx, edx
	jle	SHORT $LN27@ByteBlocks

; 698  :                     DestBuffer[Index + 2] = (BYTE)(Buffer1[Index + 2] + Buffer2[Index + 2]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+2]
	add	ecx, eax
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+2], cl

; 699  :                 else

	jmp	SHORT $LN28@ByteBlocks
$LN27@ByteBlocks:

; 700  :                     DestBuffer[Index + 2] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+2], 255			; 000000ffH
$LN28@ByteBlocks:

; 701  :                 if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN29@ByteBlocks

; 702  :                 {
; 703  :                     if (Buffer2[Index + 3] > 0)

	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	test	edx, edx
	jle	SHORT $LN31@ByteBlocks

; 704  :                         DestBuffer[Index + 3] = (BYTE)(Buffer1[Index + 3] + Buffer2[Index + 3]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+3]
	add	ecx, eax
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], cl

; 705  :                     else

	jmp	SHORT $LN32@ByteBlocks
$LN31@ByteBlocks:

; 706  :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN32@ByteBlocks:

; 707  :                 }
; 708  :                 else

	jmp	SHORT $LN30@ByteBlocks
$LN29@ByteBlocks:

; 709  :                     DestBuffer[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH
$LN30@ByteBlocks:

; 710  :                 break;

	jmp	$LN8@ByteBlocks
$LN33@ByteBlocks:

; 711  : 
; 712  :             case BlockModulo:
; 713  :                 if (Buffer2[Index + 0 > 0])

	cmp	DWORD PTR _Index$20[ebp], 0
	jle	SHORT $LN155@ByteBlocks
	mov	DWORD PTR tv368[ebp], 1
	jmp	SHORT $LN156@ByteBlocks
$LN155@ByteBlocks:
	mov	DWORD PTR tv368[ebp], 0
$LN156@ByteBlocks:
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR tv368[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN34@ByteBlocks

; 714  :                     DestBuffer[Index + 0] = (BYTE)(Buffer1[Index + 0] % Buffer2[Index + 0]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [ecx]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [edx]
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax], dl

; 715  :                 else

	jmp	SHORT $LN35@ByteBlocks
$LN34@ByteBlocks:

; 716  :                     DestBuffer[Index + 0] = 0;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx], 0
$LN35@ByteBlocks:

; 717  :                 if (Buffer2[Index + 1] > 0)

	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+1]
	test	eax, eax
	jle	SHORT $LN36@ByteBlocks

; 718  :                     DestBuffer[Index + 1] = (BYTE)(Buffer1[Index + 1] % Buffer2[Index + 1]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [ecx+1]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [edx+1]
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+1], dl

; 719  :                 else

	jmp	SHORT $LN37@ByteBlocks
$LN36@ByteBlocks:

; 720  :                     DestBuffer[Index + 1] = 0;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+1], 0
$LN37@ByteBlocks:

; 721  :                 if (Buffer2[Index + 2] > 0)

	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+2]
	test	eax, eax
	jle	SHORT $LN38@ByteBlocks

; 722  :                     DestBuffer[Index + 2] = (BYTE)(Buffer1[Index + 2] % Buffer2[Index + 2]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [ecx+2]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [edx+2]
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+2], dl

; 723  :                 else

	jmp	SHORT $LN39@ByteBlocks
$LN38@ByteBlocks:

; 724  :                     DestBuffer[Index + 2] = 0;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+2], 0
$LN39@ByteBlocks:

; 725  :                 if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN40@ByteBlocks

; 726  :                 {
; 727  :                     if (Buffer2[Index + 3] > 0)

	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+3]
	test	eax, eax
	jle	SHORT $LN42@ByteBlocks

; 728  :                         DestBuffer[Index + 3] = (BYTE)(Buffer1[Index + 3] % Buffer2[Index + 3]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [ecx+3]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [edx+3]
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], dl

; 729  :                     else

	jmp	SHORT $LN43@ByteBlocks
$LN42@ByteBlocks:

; 730  :                         DestBuffer[Index + 3] = 0;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+3], 0
$LN43@ByteBlocks:

; 731  :                 }
; 732  :                 else

	jmp	SHORT $LN41@ByteBlocks
$LN40@ByteBlocks:

; 733  :                     DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN41@ByteBlocks:

; 734  :                 break;

	jmp	$LN8@ByteBlocks
$LN44@ByteBlocks:

; 735  : 
; 736  :             case BlockAnd:
; 737  :                 DestBuffer[Index + 0] = (BYTE)(Buffer1[Index + 0] & Buffer2[Index + 0]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx]
	and	ecx, eax
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx], cl

; 738  :                 DestBuffer[Index + 1] = (BYTE)(Buffer1[Index + 1] & Buffer2[Index + 1]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+1]
	and	ecx, eax
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+1], cl

; 739  :                 DestBuffer[Index + 2] = (BYTE)(Buffer1[Index + 2] & Buffer2[Index + 2]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+2]
	and	ecx, eax
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+2], cl

; 740  :                 if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN45@ByteBlocks

; 741  :                     DestBuffer[Index + 3] = (BYTE)(Buffer1[Index + 3] & Buffer2[Index + 3]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+3]
	and	ecx, eax
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], cl

; 742  :                 else

	jmp	SHORT $LN46@ByteBlocks
$LN45@ByteBlocks:

; 743  :                     DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN46@ByteBlocks:

; 744  :                 break;

	jmp	$LN8@ByteBlocks
$LN47@ByteBlocks:

; 745  : 
; 746  :             case BlockOr:
; 747  :                 DestBuffer[Index + 0] = (BYTE)(Buffer1[Index + 0] | Buffer2[Index + 0]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	edx, ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax], dl

; 748  :                 DestBuffer[Index + 1] = (BYTE)(Buffer1[Index + 1] | Buffer2[Index + 1]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	or	edx, ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+1], dl

; 749  :                 DestBuffer[Index + 2] = (BYTE)(Buffer1[Index + 2] | Buffer2[Index + 2]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	or	edx, ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+2], dl

; 750  :                 if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN48@ByteBlocks

; 751  :                     DestBuffer[Index + 3] = (BYTE)(Buffer1[Index + 3] | Buffer2[Index + 3]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+3]
	or	edx, ecx
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], dl

; 752  :                 else

	jmp	SHORT $LN49@ByteBlocks
$LN48@ByteBlocks:

; 753  :                     DestBuffer[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH
$LN49@ByteBlocks:

; 754  :                 break;

	jmp	$LN8@ByteBlocks
$LN50@ByteBlocks:

; 755  : 
; 756  :             case BlockXor:
; 757  :                 DestBuffer[Index + 0] = (BYTE)(Buffer1[Index + 0] ^ Buffer2[Index + 0]);

	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx]
	xor	eax, edx
	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx], al

; 758  :                 DestBuffer[Index + 1] = (BYTE)(Buffer1[Index + 1] ^ Buffer2[Index + 1]);

	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+1]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	xor	eax, edx
	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+1], al

; 759  :                 DestBuffer[Index + 2] = (BYTE)(Buffer1[Index + 2] ^ Buffer2[Index + 2]);

	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+2]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	xor	eax, edx
	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+2], al

; 760  :                 if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN51@ByteBlocks

; 761  :                     DestBuffer[Index + 3] = (BYTE)(Buffer1[Index + 3] ^ Buffer2[Index + 3]);

	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+3]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	xor	eax, edx
	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+3], al

; 762  :                 else

	jmp	SHORT $LN52@ByteBlocks
$LN51@ByteBlocks:

; 763  :                     DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN52@ByteBlocks:

; 764  :                 break;

	jmp	$LN8@ByteBlocks
$LN53@ByteBlocks:

; 765  : 
; 766  :             case BlockBrightest:
; 767  :             {
; 768  :                 double Lum1 = ColorLuminance(Buffer1[Index + 2], Buffer1[Index + 1], Buffer1[Index + 0]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum1$16[ebp]

; 769  :                 double Lum2 = ColorLuminance(Buffer2[Index + 2], Buffer2[Index + 1], Buffer2[Index + 0]);

	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum2$15[ebp]

; 770  :                 if (Lum1 >= Lum2)

	movsd	xmm0, QWORD PTR _Lum1$16[ebp]
	comisd	xmm0, QWORD PTR _Lum2$15[ebp]
	jb	SHORT $LN54@ByteBlocks

; 771  :                 {
; 772  :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 773  :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 774  :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 775  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN56@ByteBlocks

; 776  :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 777  :                     else

	jmp	SHORT $LN57@ByteBlocks
$LN56@ByteBlocks:

; 778  :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN57@ByteBlocks:

; 779  :                 }
; 780  :                 else

	jmp	SHORT $LN59@ByteBlocks
$LN54@ByteBlocks:

; 781  :                 {
; 782  :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 783  :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 784  :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 785  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN58@ByteBlocks

; 786  :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 787  :                     else

	jmp	SHORT $LN59@ByteBlocks
$LN58@ByteBlocks:

; 788  :                         DestBuffer[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH
$LN59@ByteBlocks:

; 789  :                 }
; 790  :             }
; 791  :             break;

	jmp	$LN8@ByteBlocks
$LN60@ByteBlocks:

; 792  : 
; 793  :             case BlockDarkest:
; 794  :             {
; 795  :                 double Lum1 = ColorLuminance(Buffer1[Index + 2], Buffer1[Index + 1], Buffer1[Index + 0]);

	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum1$13[ebp]

; 796  :                 double Lum2 = ColorLuminance(Buffer2[Index + 2], Buffer2[Index + 1], Buffer2[Index + 0]);

	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum2$14[ebp]

; 797  :                 if (Lum1 <= Lum2)

	movsd	xmm0, QWORD PTR _Lum2$14[ebp]
	comisd	xmm0, QWORD PTR _Lum1$13[ebp]
	jb	SHORT $LN61@ByteBlocks

; 798  :                 {
; 799  :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 800  :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 801  :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 802  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN63@ByteBlocks

; 803  :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 804  :                     else

	jmp	SHORT $LN64@ByteBlocks
$LN63@ByteBlocks:

; 805  :                         DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN64@ByteBlocks:

; 806  :                 }
; 807  :                 else

	jmp	SHORT $LN66@ByteBlocks
$LN61@ByteBlocks:

; 808  :                 {
; 809  :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 810  :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 811  :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 812  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN65@ByteBlocks

; 813  :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 814  :                     else

	jmp	SHORT $LN66@ByteBlocks
$LN65@ByteBlocks:

; 815  :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN66@ByteBlocks:

; 816  :                 }
; 817  :             }
; 818  :             break;

	jmp	$LN8@ByteBlocks
$LN67@ByteBlocks:

; 819  : 
; 820  :             case BlockBiggestRed:
; 821  :                 if (Buffer1[Index + 2] >= Buffer2[Index + 2])

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cmp	edx, ecx
	jl	SHORT $LN68@ByteBlocks

; 822  :                 {
; 823  :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 824  :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 825  :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 826  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN70@ByteBlocks

; 827  :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 828  :                     else

	jmp	SHORT $LN71@ByteBlocks
$LN70@ByteBlocks:

; 829  :                         DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN71@ByteBlocks:

; 830  :                 }
; 831  :                 else

	jmp	SHORT $LN73@ByteBlocks
$LN68@ByteBlocks:

; 832  :                 {
; 833  :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 834  :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 835  :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 836  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN72@ByteBlocks

; 837  :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 838  :                     else

	jmp	SHORT $LN73@ByteBlocks
$LN72@ByteBlocks:

; 839  :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN73@ByteBlocks:

; 840  :                 }
; 841  :                 break;

	jmp	$LN8@ByteBlocks
$LN74@ByteBlocks:

; 842  : 
; 843  :             case BlockSmallestRed:
; 844  :                 if (Buffer1[Index + 2] <= Buffer2[Index + 2])

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cmp	edx, ecx
	jg	SHORT $LN75@ByteBlocks

; 845  :                 {
; 846  :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 847  :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 848  :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 849  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN77@ByteBlocks

; 850  :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 851  :                     else

	jmp	SHORT $LN78@ByteBlocks
$LN77@ByteBlocks:

; 852  :                         DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN78@ByteBlocks:

; 853  :                 }
; 854  :                 else

	jmp	SHORT $LN80@ByteBlocks
$LN75@ByteBlocks:

; 855  :                 {
; 856  :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 857  :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 858  :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 859  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN79@ByteBlocks

; 860  :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 861  :                     else

	jmp	SHORT $LN80@ByteBlocks
$LN79@ByteBlocks:

; 862  :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN80@ByteBlocks:

; 863  :                 }
; 864  :                 break;

	jmp	$LN8@ByteBlocks
$LN81@ByteBlocks:

; 865  : 
; 866  :             case BlockBiggestGreen:
; 867  :                 if (Buffer1[Index + 1] >= Buffer2[Index + 1])

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	edx, ecx
	jl	SHORT $LN82@ByteBlocks

; 868  :                 {
; 869  :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 870  :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 871  :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 872  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN84@ByteBlocks

; 873  :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 874  :                     else

	jmp	SHORT $LN85@ByteBlocks
$LN84@ByteBlocks:

; 875  :                         DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN85@ByteBlocks:

; 876  :                 }
; 877  :                 else

	jmp	SHORT $LN87@ByteBlocks
$LN82@ByteBlocks:

; 878  :                 {
; 879  :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 880  :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 881  :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 882  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN86@ByteBlocks

; 883  :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 884  :                     else

	jmp	SHORT $LN87@ByteBlocks
$LN86@ByteBlocks:

; 885  :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN87@ByteBlocks:

; 886  :                 }
; 887  :                 break;

	jmp	$LN8@ByteBlocks
$LN88@ByteBlocks:

; 888  : 
; 889  :             case BlockSmallestGreen:
; 890  :                 if (Buffer1[Index + 1] <= Buffer2[Index + 1])

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	edx, ecx
	jg	SHORT $LN89@ByteBlocks

; 891  :                 {
; 892  :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 893  :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 894  :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 895  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN91@ByteBlocks

; 896  :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 897  :                     else

	jmp	SHORT $LN92@ByteBlocks
$LN91@ByteBlocks:

; 898  :                         DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN92@ByteBlocks:

; 899  :                 }
; 900  :                 else

	jmp	SHORT $LN94@ByteBlocks
$LN89@ByteBlocks:

; 901  :                 {
; 902  :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 903  :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 904  :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 905  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN93@ByteBlocks

; 906  :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 907  :                     else

	jmp	SHORT $LN94@ByteBlocks
$LN93@ByteBlocks:

; 908  :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN94@ByteBlocks:

; 909  :                 }
; 910  :                 break;

	jmp	$LN8@ByteBlocks
$LN95@ByteBlocks:

; 911  : 
; 912  :             case BlockBiggestBlue:
; 913  :                 if (Buffer1[Index + 0] <= Buffer2[Index + 0])

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jg	SHORT $LN96@ByteBlocks

; 914  :                 {
; 915  :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 916  :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 917  :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 918  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN98@ByteBlocks

; 919  :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 920  :                     else

	jmp	SHORT $LN99@ByteBlocks
$LN98@ByteBlocks:

; 921  :                         DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN99@ByteBlocks:

; 922  :                 }
; 923  :                 else

	jmp	SHORT $LN101@ByteBlocks
$LN96@ByteBlocks:

; 924  :                 {
; 925  :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 926  :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 927  :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 928  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN100@ByteBlocks

; 929  :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 930  :                     else

	jmp	SHORT $LN101@ByteBlocks
$LN100@ByteBlocks:

; 931  :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN101@ByteBlocks:

; 932  :                 }
; 933  :                 break;

	jmp	$LN8@ByteBlocks
$LN102@ByteBlocks:

; 934  : 
; 935  :             case BlockSmallestBlue:
; 936  :                 if (Buffer1[Index + 0] <= Buffer2[Index + 0])

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jg	SHORT $LN103@ByteBlocks

; 937  :                 {
; 938  :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 939  :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 940  :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 941  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN105@ByteBlocks

; 942  :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 943  :                     else

	jmp	SHORT $LN106@ByteBlocks
$LN105@ByteBlocks:

; 944  :                         DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN106@ByteBlocks:

; 945  :                 }
; 946  :                 else

	jmp	SHORT $LN108@ByteBlocks
$LN103@ByteBlocks:

; 947  :                 {
; 948  :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 949  :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 950  :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 951  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN107@ByteBlocks

; 952  :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 953  :                     else

	jmp	SHORT $LN108@ByteBlocks
$LN107@ByteBlocks:

; 954  :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN108@ByteBlocks:

; 955  :                 }
; 956  :                 break;

	jmp	$LN8@ByteBlocks
$LN109@ByteBlocks:

; 957  : 
; 958  :             case BlockBiggestCyan:
; 959  :             {
; 960  :                 double Lum1 = ColorLuminance(0xff, Buffer1[Index + 1], Buffer1[Index + 0]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	push	ecx
	push	255					; 000000ffH
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum1$12[ebp]

; 961  :                 double Lum2 = ColorLuminance(0xff, Buffer2[Index + 1], Buffer2[Index + 0]);

	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	push	255					; 000000ffH
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum2$11[ebp]

; 962  :                 if (Lum1 >= Lum2)

	movsd	xmm0, QWORD PTR _Lum1$12[ebp]
	comisd	xmm0, QWORD PTR _Lum2$11[ebp]
	jb	SHORT $LN110@ByteBlocks

; 963  :                 {
; 964  :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 965  :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 966  :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 967  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN112@ByteBlocks

; 968  :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 969  :                     else

	jmp	SHORT $LN113@ByteBlocks
$LN112@ByteBlocks:

; 970  :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN113@ByteBlocks:

; 971  :                 }
; 972  :                 else

	jmp	SHORT $LN115@ByteBlocks
$LN110@ByteBlocks:

; 973  :                 {
; 974  :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 975  :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 976  :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 977  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN114@ByteBlocks

; 978  :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 979  :                     else

	jmp	SHORT $LN115@ByteBlocks
$LN114@ByteBlocks:

; 980  :                         DestBuffer[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH
$LN115@ByteBlocks:

; 981  :                 }
; 982  :             }
; 983  :             break;

	jmp	$LN8@ByteBlocks
$LN116@ByteBlocks:

; 984  : 
; 985  :             case BlockSmallestCyan:
; 986  :             {
; 987  :                 double Lum1 = ColorLuminance(0xff, Buffer1[Index + 1], Buffer1[Index + 0]);

	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	push	255					; 000000ffH
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum1$9[ebp]

; 988  :                 double Lum2 = ColorLuminance(0xff, Buffer2[Index + 1], Buffer2[Index + 0]);

	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	push	255					; 000000ffH
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum2$10[ebp]

; 989  :                 if (Lum1 <= Lum2)

	movsd	xmm0, QWORD PTR _Lum2$10[ebp]
	comisd	xmm0, QWORD PTR _Lum1$9[ebp]
	jb	SHORT $LN117@ByteBlocks

; 990  :                 {
; 991  :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 992  :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 993  :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 994  :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN119@ByteBlocks

; 995  :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 996  :                     else

	jmp	SHORT $LN120@ByteBlocks
$LN119@ByteBlocks:

; 997  :                         DestBuffer[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH
$LN120@ByteBlocks:

; 998  :                 }
; 999  :                 else

	jmp	SHORT $LN122@ByteBlocks
$LN117@ByteBlocks:

; 1000 :                 {
; 1001 :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 1002 :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 1003 :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 1004 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN121@ByteBlocks

; 1005 :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1006 :                     else

	jmp	SHORT $LN122@ByteBlocks
$LN121@ByteBlocks:

; 1007 :                         DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN122@ByteBlocks:

; 1008 :                 }
; 1009 :             }
; 1010 :             break;

	jmp	$LN8@ByteBlocks
$LN123@ByteBlocks:

; 1011 : 
; 1012 :             case BlockBiggestMagenta:
; 1013 :             {
; 1014 :                 double Lum1 = ColorLuminance(Buffer1[Index + 2], 0xff, Buffer1[Index + 0]);

	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	push	255					; 000000ffH
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum1$8[ebp]

; 1015 :                 double Lum2 = ColorLuminance(Buffer2[Index + 2], 0xff, Buffer2[Index + 0]);

	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	push	255					; 000000ffH
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum2$7[ebp]

; 1016 :                 if (Lum1 >= Lum2)

	movsd	xmm0, QWORD PTR _Lum1$8[ebp]
	comisd	xmm0, QWORD PTR _Lum2$7[ebp]
	jb	SHORT $LN124@ByteBlocks

; 1017 :                 {
; 1018 :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 1019 :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 1020 :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 1021 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN126@ByteBlocks

; 1022 :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1023 :                     else

	jmp	SHORT $LN127@ByteBlocks
$LN126@ByteBlocks:

; 1024 :                         DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN127@ByteBlocks:

; 1025 :                 }
; 1026 :                 else

	jmp	SHORT $LN129@ByteBlocks
$LN124@ByteBlocks:

; 1027 :                 {
; 1028 :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 1029 :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 1030 :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 1031 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN128@ByteBlocks

; 1032 :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 1033 :                     else

	jmp	SHORT $LN129@ByteBlocks
$LN128@ByteBlocks:

; 1034 :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN129@ByteBlocks:

; 1035 :                 }
; 1036 :             }
; 1037 :             break;

	jmp	$LN8@ByteBlocks
$LN130@ByteBlocks:

; 1038 : 
; 1039 :             case BlockSmallestMagenta:
; 1040 :             {
; 1041 :                 double Lum1 = ColorLuminance(Buffer1[Index + 2], 0xff, Buffer1[Index + 0]);

	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	push	255					; 000000ffH
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum1$5[ebp]

; 1042 :                 double Lum2 = ColorLuminance(Buffer2[Index + 2], 0xff, Buffer2[Index + 0]);

	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	push	255					; 000000ffH
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum2$6[ebp]

; 1043 :                 if (Lum1 <= Lum2)

	movsd	xmm0, QWORD PTR _Lum2$6[ebp]
	comisd	xmm0, QWORD PTR _Lum1$5[ebp]
	jb	SHORT $LN131@ByteBlocks

; 1044 :                 {
; 1045 :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 1046 :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 1047 :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 1048 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN133@ByteBlocks

; 1049 :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 1050 :                     else

	jmp	SHORT $LN134@ByteBlocks
$LN133@ByteBlocks:

; 1051 :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN134@ByteBlocks:

; 1052 :                 }
; 1053 :                 else

	jmp	SHORT $LN136@ByteBlocks
$LN131@ByteBlocks:

; 1054 :                 {
; 1055 :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 1056 :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 1057 :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 1058 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN135@ByteBlocks

; 1059 :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 1060 :                     else

	jmp	SHORT $LN136@ByteBlocks
$LN135@ByteBlocks:

; 1061 :                         DestBuffer[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH
$LN136@ByteBlocks:

; 1062 :                 }
; 1063 :             }
; 1064 :             break;

	jmp	$LN8@ByteBlocks
$LN137@ByteBlocks:

; 1065 : 
; 1066 :             case BlockBiggestYellow:
; 1067 :             {
; 1068 :                 double Lum1 = ColorLuminance(Buffer1[Index + 2], Buffer1[Index + 1], 0xff);

	push	255					; 000000ffH
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+1]
	push	eax
	mov	ecx, DWORD PTR _Buffer1$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+2]
	push	edx
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum1$4[ebp]

; 1069 :                 double Lum2 = ColorLuminance(Buffer2[Index + 2], Buffer2[Index + 1], 0xff);

	push	255					; 000000ffH
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	push	ecx
	mov	edx, DWORD PTR _Buffer2$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum2$3[ebp]

; 1070 :                 if (Lum1 >= Lum2)

	movsd	xmm0, QWORD PTR _Lum1$4[ebp]
	comisd	xmm0, QWORD PTR _Lum2$3[ebp]
	jb	SHORT $LN138@ByteBlocks

; 1071 :                 {
; 1072 :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 1073 :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 1074 :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 1075 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN140@ByteBlocks

; 1076 :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 1077 :                     else

	jmp	SHORT $LN141@ByteBlocks
$LN140@ByteBlocks:

; 1078 :                         DestBuffer[Index + 3] = 0xff;

	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [ecx+3], 255			; 000000ffH
$LN141@ByteBlocks:

; 1079 :                 }
; 1080 :                 else

	jmp	SHORT $LN143@ByteBlocks
$LN138@ByteBlocks:

; 1081 :                 {
; 1082 :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 1083 :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 1084 :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 1085 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN142@ByteBlocks

; 1086 :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1087 :                     else

	jmp	SHORT $LN143@ByteBlocks
$LN142@ByteBlocks:

; 1088 :                         DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN143@ByteBlocks:

; 1089 :                 }
; 1090 :             }
; 1091 :             break;

	jmp	$LN8@ByteBlocks
$LN144@ByteBlocks:

; 1092 : 
; 1093 :             case BlockSmallestYellow:
; 1094 :             {
; 1095 :                 double Lum1 = ColorLuminance(Buffer1[Index + 2], Buffer1[Index + 1], 0xff);

	push	255					; 000000ffH
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	push	ecx
	mov	edx, DWORD PTR _Buffer1$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	movzx	eax, BYTE PTR [edx+2]
	push	eax
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum1$1[ebp]

; 1096 :                 double Lum2 = ColorLuminance(Buffer2[Index + 2], Buffer2[Index + 1], 0xff);

	push	255					; 000000ffH
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	mov	eax, DWORD PTR _Buffer2$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_ColorLuminance@12
	fstp	QWORD PTR _Lum2$2[ebp]

; 1097 :                 if (Lum1 <= Lum2)

	movsd	xmm0, QWORD PTR _Lum2$2[ebp]
	comisd	xmm0, QWORD PTR _Lum1$1[ebp]
	jb	SHORT $LN145@ByteBlocks

; 1098 :                 {
; 1099 :                     DestBuffer[Index + 0] = Buffer1[Index + 0];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 1100 :                     DestBuffer[Index + 1] = Buffer1[Index + 1];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 1101 :                     DestBuffer[Index + 2] = Buffer1[Index + 2];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 1102 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN147@ByteBlocks

; 1103 :                         DestBuffer[Index + 3] = Buffer1[Index + 3];

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	eax, DWORD PTR _Buffer1$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 1104 :                     else

	jmp	SHORT $LN148@ByteBlocks
$LN147@ByteBlocks:

; 1105 :                         DestBuffer[Index + 3] = 0xff;

	mov	edx, DWORD PTR _DestBuffer$[ebp]
	add	edx, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH
$LN148@ByteBlocks:

; 1106 :                 }
; 1107 :                 else

	jmp	SHORT $LN150@ByteBlocks
$LN145@ByteBlocks:

; 1108 :                 {
; 1109 :                     DestBuffer[Index + 0] = Buffer2[Index + 0];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 1110 :                     DestBuffer[Index + 1] = Buffer2[Index + 1];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 1111 :                     DestBuffer[Index + 2] = Buffer2[Index + 2];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 1112 :                     if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN149@ByteBlocks

; 1113 :                         DestBuffer[Index + 3] = Buffer2[Index + 3];

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	ecx, DWORD PTR _Buffer2$[ebp]
	add	ecx, DWORD PTR _Index$20[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 1114 :                     else

	jmp	SHORT $LN150@ByteBlocks
$LN149@ByteBlocks:

; 1115 :                         DestBuffer[Index + 3] = 0xff;

	mov	eax, DWORD PTR _DestBuffer$[ebp]
	add	eax, DWORD PTR _Index$20[ebp]
	mov	BYTE PTR [eax+3], 255			; 000000ffH
$LN150@ByteBlocks:

; 1116 :                 }
; 1117 :             }
; 1118 :             break;

	jmp	SHORT $LN8@ByteBlocks
$LN151@ByteBlocks:

; 1119 : 
; 1120 :             default:
; 1121 :                 return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@ByteBlocks
$LN8@ByteBlocks:

; 1122 :             }
; 1123 :         }

	jmp	$LN5@ByteBlocks
$LN6@ByteBlocks:

; 1124 :     }

	jmp	$LN2@ByteBlocks
$LN3@ByteBlocks:

; 1125 : 
; 1126 :     return Success;

	xor	eax, eax
$LN1@ByteBlocks:

; 1127 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	2
$LN157@ByteBlocks:
	DD	$LN13@ByteBlocks
	DD	$LN16@ByteBlocks
	DD	$LN19@ByteBlocks
	DD	$LN22@ByteBlocks
	DD	$LN33@ByteBlocks
	DD	$LN44@ByteBlocks
	DD	$LN47@ByteBlocks
	DD	$LN50@ByteBlocks
	DD	$LN53@ByteBlocks
	DD	$LN60@ByteBlocks
	DD	$LN67@ByteBlocks
	DD	$LN74@ByteBlocks
	DD	$LN81@ByteBlocks
	DD	$LN88@ByteBlocks
	DD	$LN95@ByteBlocks
	DD	$LN102@ByteBlocks
	DD	$LN109@ByteBlocks
	DD	$LN116@ByteBlocks
	DD	$LN123@ByteBlocks
	DD	$LN130@ByteBlocks
	DD	$LN137@ByteBlocks
	DD	$LN144@ByteBlocks
_ByteBlocksOperation@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_RowOffset$1 = -88					; size = 4
tv151 = -84						; size = 4
_Column$2 = -80						; size = 4
_Row$3 = -76						; size = 4
_PixelSize$ = -69					; size = 1
_Src$ = -68						; size = 4
tv499 = -61						; size = 1
tv491 = -60						; size = 1
tv803 = -59						; size = 1
tv802 = -58						; size = 1
tv796 = -57						; size = 1
tv787 = -56						; size = 1
tv786 = -55						; size = 1
tv780 = -54						; size = 1
tv771 = -53						; size = 1
tv770 = -52						; size = 1
tv764 = -51						; size = 1
tv755 = -50						; size = 1
tv754 = -49						; size = 1
tv748 = -48						; size = 1
tv739 = -47						; size = 1
tv738 = -46						; size = 1
tv732 = -45						; size = 1
tv723 = -44						; size = 1
tv722 = -43						; size = 1
tv716 = -42						; size = 1
tv707 = -41						; size = 1
tv706 = -40						; size = 1
tv700 = -39						; size = 1
tv691 = -38						; size = 1
tv690 = -37						; size = 1
tv684 = -36						; size = 1
tv675 = -35						; size = 1
tv667 = -34						; size = 1
tv659 = -33						; size = 1
tv651 = -32						; size = 1
tv643 = -31						; size = 1
tv635 = -30						; size = 1
tv627 = -29						; size = 1
tv619 = -28						; size = 1
tv611 = -27						; size = 1
tv603 = -26						; size = 1
tv595 = -25						; size = 1
tv587 = -24						; size = 1
tv579 = -23						; size = 1
tv571 = -22						; size = 1
tv563 = -21						; size = 1
tv555 = -20						; size = 1
tv547 = -19						; size = 1
tv539 = -18						; size = 1
tv531 = -17						; size = 1
tv523 = -16						; size = 1
tv515 = -15						; size = 1
tv507 = -14						; size = 1
_A$4 = -13						; size = 1
_Dest$ = -12						; size = 4
_Index$5 = -8						; size = 4
_Operand$ = -4						; size = 1
_R$6 = -3						; size = 1
_B$7 = -2						; size = 1
_G$8 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Operator$ = 28						; size = 4
_OperandValue$ = 32					; size = 4
_DoAlpha$ = 36						; size = 4
_DoRed$ = 40						; size = 4
_DoGreen$ = 44						; size = 4
_DoBlue$ = 48						; size = 4
_ByteBlockOperationByChannel@44 PROC

; 230  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 231  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN10@ByteBlockO

; 232  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ByteBlockO
$LN10@ByteBlockO:

; 233  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN11@ByteBlockO

; 234  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ByteBlockO
$LN11@ByteBlockO:

; 235  :     if (!DoAlpha && !DoRed && !DoGreen && !DoBlue)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	jne	SHORT $LN12@ByteBlockO
	cmp	DWORD PTR _DoRed$[ebp], 0
	jne	SHORT $LN12@ByteBlockO
	cmp	DWORD PTR _DoGreen$[ebp], 0
	jne	SHORT $LN12@ByteBlockO
	cmp	DWORD PTR _DoBlue$[ebp], 0
	jne	SHORT $LN12@ByteBlockO

; 236  :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@ByteBlockO
$LN12@ByteBlockO:

; 237  :     BYTE Operand = (BYTE)OperandValue;

	mov	al, BYTE PTR _OperandValue$[ebp]
	mov	BYTE PTR _Operand$[ebp], al

; 238  :     if (Operand == 0.0)

	movzx	ecx, BYTE PTR _Operand$[ebp]
	cvtsi2sd xmm0, ecx
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN14@ByteBlockO

; 239  :     {
; 240  :         if ((Operator == BlockDivide) || (Operator == BlockModulo))

	cmp	DWORD PTR _Operator$[ebp], 3
	je	SHORT $LN15@ByteBlockO
	cmp	DWORD PTR _Operator$[ebp], 4
	jne	SHORT $LN14@ByteBlockO
$LN15@ByteBlockO:

; 241  :         {
; 242  :             return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ByteBlockO
$LN14@ByteBlockO:

; 243  :         }
; 244  :     }
; 245  : 
; 246  :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 247  :     BYTE* Src = (BYTE*)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], edx

; 248  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 249  : 
; 250  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ByteBlockO
$LN2@ByteBlockO:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@ByteBlockO:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	$LN3@ByteBlockO

; 251  :     {
; 252  :         int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 253  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ByteBlockO
$LN5@ByteBlockO:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@ByteBlockO:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	$LN6@ByteBlockO

; 254  :         {
; 255  :             int Index = RowOffset + (Column * PixelSize);

	movzx	eax, BYTE PTR _PixelSize$[ebp]
	imul	eax, DWORD PTR _Column$2[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$5[ebp], eax

; 256  :             Dest[Index + 3] = Src[Index + 3];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 257  :             Dest[Index + 2] = Src[Index + 2];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 258  :             Dest[Index + 1] = Src[Index + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 259  :             Dest[Index + 0] = Src[Index + 0];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 260  : 
; 261  :             BYTE A = Src[Index + 3];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR _A$4[ebp], dl

; 262  :             BYTE R = Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _R$6[ebp], cl

; 263  :             BYTE G = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _G$8[ebp], al

; 264  :             BYTE B = Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _B$7[ebp], dl

; 265  : 
; 266  :             switch (Operator)

	mov	eax, DWORD PTR _Operator$[ebp]
	mov	DWORD PTR tv151[ebp], eax
	cmp	DWORD PTR tv151[ebp], 33		; 00000021H
	ja	$LN108@ByteBlockO
	mov	ecx, DWORD PTR tv151[ebp]
	movzx	edx, BYTE PTR $LN206@ByteBlockO[ecx]
	jmp	DWORD PTR $LN207@ByteBlockO[edx*4]
$LN16@ByteBlockO:

; 267  :             {
; 268  :             case BlockAdd:
; 269  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN17@ByteBlockO

; 270  :                     Dest[Index + 0] = (BYTE)(B + Operand);

	movzx	eax, BYTE PTR _B$7[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx], al
$LN17@ByteBlockO:

; 271  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN18@ByteBlockO

; 272  :                     Dest[Index + 1] = (BYTE)(G + Operand);

	movzx	eax, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+1], al
$LN18@ByteBlockO:

; 273  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN19@ByteBlockO

; 274  :                     Dest[Index + 2] = (BYTE)(R + Operand);

	movzx	eax, BYTE PTR _R$6[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+2], al
$LN19@ByteBlockO:

; 275  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN20@ByteBlockO

; 276  :                     Dest[Index + 3] = (BYTE)(A + Operand);

	movzx	eax, BYTE PTR _A$4[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+3], al
$LN20@ByteBlockO:

; 277  :                 break;

	jmp	$LN8@ByteBlockO
$LN21@ByteBlockO:

; 278  : 
; 279  :             case BlockSubtract:
; 280  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN22@ByteBlockO

; 281  :                     Dest[Index + 0] = (BYTE)(B - Operand);

	movzx	eax, BYTE PTR _B$7[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	sub	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx], al
$LN22@ByteBlockO:

; 282  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN23@ByteBlockO

; 283  :                     Dest[Index + 1] = (BYTE)(G - Operand);

	movzx	eax, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	sub	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+1], al
$LN23@ByteBlockO:

; 284  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN24@ByteBlockO

; 285  :                     Dest[Index + 2] = (BYTE)(R - Operand);

	movzx	eax, BYTE PTR _R$6[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	sub	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+2], al
$LN24@ByteBlockO:

; 286  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN25@ByteBlockO

; 287  :                     Dest[Index + 3] = (BYTE)(A - Operand);

	movzx	eax, BYTE PTR _A$4[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	sub	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+3], al
$LN25@ByteBlockO:

; 288  :                 break;

	jmp	$LN8@ByteBlockO
$LN26@ByteBlockO:

; 289  : 
; 290  :             case BlockMultiply:
; 291  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN27@ByteBlockO

; 292  :                     Dest[Index + 0] = (BYTE)(B * Operand);

	movzx	eax, BYTE PTR _B$7[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	imul	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx], al
$LN27@ByteBlockO:

; 293  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN28@ByteBlockO

; 294  :                     Dest[Index + 1] = (BYTE)(G * Operand);

	movzx	eax, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	imul	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+1], al
$LN28@ByteBlockO:

; 295  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN29@ByteBlockO

; 296  :                     Dest[Index + 2] = (BYTE)(R * Operand);

	movzx	eax, BYTE PTR _R$6[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	imul	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+2], al
$LN29@ByteBlockO:

; 297  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN30@ByteBlockO

; 298  :                     Dest[Index + 3] = (BYTE)(A * Operand);

	movzx	eax, BYTE PTR _A$4[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	imul	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+3], al
$LN30@ByteBlockO:

; 299  :                 break;

	jmp	$LN8@ByteBlockO
$LN31@ByteBlockO:

; 300  : 
; 301  :             case BlockDivide:
; 302  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN32@ByteBlockO

; 303  :                     Dest[Index + 0] = (BYTE)((double)B / (double)Operand);

	movzx	eax, BYTE PTR _B$7[ebp]
	cvtsi2sd xmm0, eax
	movzx	ecx, BYTE PTR _Operand$[ebp]
	cvtsi2sd xmm1, ecx
	divsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax], dl
$LN32@ByteBlockO:

; 304  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN33@ByteBlockO

; 305  :                     Dest[Index + 1] = (BYTE)((double)G / (double)Operand);

	movzx	ecx, BYTE PTR _G$8[ebp]
	cvtsi2sd xmm0, ecx
	movzx	edx, BYTE PTR _Operand$[ebp]
	cvtsi2sd xmm1, edx
	divsd	xmm0, xmm1
	cvttsd2si eax, xmm0
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [ecx+1], al
$LN33@ByteBlockO:

; 306  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN34@ByteBlockO

; 307  :                     Dest[Index + 2] = (BYTE)((double)R / (double)Operand);

	movzx	edx, BYTE PTR _R$6[ebp]
	cvtsi2sd xmm0, edx
	movzx	eax, BYTE PTR _Operand$[ebp]
	cvtsi2sd xmm1, eax
	divsd	xmm0, xmm1
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+2], cl
$LN34@ByteBlockO:

; 308  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN35@ByteBlockO

; 309  :                     Dest[Index + 3] = (BYTE)((double)A / (double)Operand);

	movzx	eax, BYTE PTR _A$4[ebp]
	cvtsi2sd xmm0, eax
	movzx	ecx, BYTE PTR _Operand$[ebp]
	cvtsi2sd xmm1, ecx
	divsd	xmm0, xmm1
	cvttsd2si edx, xmm0
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+3], dl
$LN35@ByteBlockO:

; 310  :                 break;

	jmp	$LN8@ByteBlockO
$LN36@ByteBlockO:

; 311  : 
; 312  :             case BlockModulo:
; 313  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN37@ByteBlockO

; 314  :                     Dest[Index + 0] = (BYTE)(B % Operand);

	movzx	eax, BYTE PTR _B$7[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax], dl
$LN37@ByteBlockO:

; 315  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN38@ByteBlockO

; 316  :                     Dest[Index + 1] = (BYTE)(G % Operand);

	movzx	eax, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+1], dl
$LN38@ByteBlockO:

; 317  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN39@ByteBlockO

; 318  :                     Dest[Index + 2] = (BYTE)(R % Operand);

	movzx	eax, BYTE PTR _R$6[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+2], dl
$LN39@ByteBlockO:

; 319  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN40@ByteBlockO

; 320  :                     Dest[Index + 3] = (BYTE)(A % Operand);

	movzx	eax, BYTE PTR _A$4[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	cdq
	idiv	ecx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+3], dl
$LN40@ByteBlockO:

; 321  :                 break;

	jmp	$LN8@ByteBlockO
$LN41@ByteBlockO:

; 322  : 
; 323  :             case BlockAnd:
; 324  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN42@ByteBlockO

; 325  :                     Dest[Index + 0] = (BYTE)(B & Operand);

	movzx	ecx, BYTE PTR _B$7[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	and	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax], cl
$LN42@ByteBlockO:

; 326  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN43@ByteBlockO

; 327  :                     Dest[Index + 1] = (BYTE)(G & Operand);

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	and	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+1], cl
$LN43@ByteBlockO:

; 328  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN44@ByteBlockO

; 329  :                     Dest[Index + 2] = (BYTE)(R & Operand);

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	and	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+2], cl
$LN44@ByteBlockO:

; 330  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN45@ByteBlockO

; 331  :                     Dest[Index + 3] = (BYTE)(A & Operand);

	movzx	ecx, BYTE PTR _A$4[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	and	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+3], cl
$LN45@ByteBlockO:

; 332  :                 break;

	jmp	$LN8@ByteBlockO
$LN46@ByteBlockO:

; 333  : 
; 334  :             case BlockOr:
; 335  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN47@ByteBlockO

; 336  :                     Dest[Index + 0] = (BYTE)(B | Operand);

	movzx	ecx, BYTE PTR _B$7[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	or	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax], cl
$LN47@ByteBlockO:

; 337  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN48@ByteBlockO

; 338  :                     Dest[Index + 1] = (BYTE)(G | Operand);

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	or	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+1], cl
$LN48@ByteBlockO:

; 339  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN49@ByteBlockO

; 340  :                     Dest[Index + 2] = (BYTE)(R | Operand);

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	or	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+2], cl
$LN49@ByteBlockO:

; 341  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN50@ByteBlockO

; 342  :                     Dest[Index + 3] = (BYTE)(A | Operand);

	movzx	ecx, BYTE PTR _A$4[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	or	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+3], cl
$LN50@ByteBlockO:

; 343  :                 break;

	jmp	$LN8@ByteBlockO
$LN51@ByteBlockO:

; 344  : 
; 345  :             case BlockXor:
; 346  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN52@ByteBlockO

; 347  :                     Dest[Index + 0] = (BYTE)(B ^ Operand);

	movzx	ecx, BYTE PTR _B$7[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax], cl
$LN52@ByteBlockO:

; 348  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN53@ByteBlockO

; 349  :                     Dest[Index + 1] = (BYTE)(G ^ Operand);

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+1], cl
$LN53@ByteBlockO:

; 350  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN54@ByteBlockO

; 351  :                     Dest[Index + 2] = (BYTE)(R ^ Operand);

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+2], cl
$LN54@ByteBlockO:

; 352  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN55@ByteBlockO

; 353  :                     Dest[Index + 3] = (BYTE)(A ^ Operand);

	movzx	ecx, BYTE PTR _A$4[ebp]
	movzx	edx, BYTE PTR _Operand$[ebp]
	xor	ecx, edx
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+3], cl
$LN55@ByteBlockO:

; 354  :                 break;

	jmp	$LN8@ByteBlockO
$LN56@ByteBlockO:

; 355  : 
; 356  :             case BlockShl:
; 357  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN57@ByteBlockO

; 358  :                     Dest[Index + 0] = (BYTE)(B << Operand);

	movzx	edx, BYTE PTR _B$7[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax], dl
$LN57@ByteBlockO:

; 359  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN58@ByteBlockO

; 360  :                     Dest[Index + 1] = (BYTE)(G << Operand);

	movzx	edx, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+1], dl
$LN58@ByteBlockO:

; 361  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN59@ByteBlockO

; 362  :                     Dest[Index + 2] = (BYTE)(R << Operand);

	movzx	edx, BYTE PTR _R$6[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+2], dl
$LN59@ByteBlockO:

; 363  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN60@ByteBlockO

; 364  :                     Dest[Index + 3] = (BYTE)(A << Operand);

	movzx	edx, BYTE PTR _A$4[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+3], dl
$LN60@ByteBlockO:

; 365  :                 break;

	jmp	$LN8@ByteBlockO
$LN61@ByteBlockO:

; 366  : 
; 367  :             case BlockShr:
; 368  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN62@ByteBlockO

; 369  :                     Dest[Index + 0] = (BYTE)(B >> Operand);

	movzx	edx, BYTE PTR _B$7[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax], dl
$LN62@ByteBlockO:

; 370  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN63@ByteBlockO

; 371  :                     Dest[Index + 1] = (BYTE)(G >> Operand);

	movzx	edx, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+1], dl
$LN63@ByteBlockO:

; 372  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN64@ByteBlockO

; 373  :                     Dest[Index + 2] = (BYTE)(R >> Operand);

	movzx	edx, BYTE PTR _R$6[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+2], dl
$LN64@ByteBlockO:

; 374  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN65@ByteBlockO

; 375  :                     Dest[Index + 3] = (BYTE)(A >> Operand);

	movzx	edx, BYTE PTR _A$4[ebp]
	movzx	ecx, BYTE PTR _Operand$[ebp]
	sar	edx, cl
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [eax+3], dl
$LN65@ByteBlockO:

; 376  :                 break;

	jmp	$LN8@ByteBlockO
$LN66@ByteBlockO:

; 377  : 
; 378  :             case BlockRol:
; 379  :                 break;

	jmp	$LN8@ByteBlockO
$LN67@ByteBlockO:

; 380  : 
; 381  :             case BlockRor:
; 382  :                 break;

	jmp	$LN8@ByteBlockO
$LN68@ByteBlockO:

; 383  : 
; 384  :             case BlockMaxRG:
; 385  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN69@ByteBlockO

; 386  :                     Dest[Index + 0] = (BYTE)(max(R,G));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _G$8[ebp]
	cmp	ecx, edx
	jle	SHORT $LN110@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv491[ebp], al
	jmp	SHORT $LN111@ByteBlockO
$LN110@ByteBlockO:
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv491[ebp], cl
$LN111@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv491[ebp]
	mov	BYTE PTR [edx], al
$LN69@ByteBlockO:

; 387  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN70@ByteBlockO

; 388  :                     Dest[Index + 1] = (BYTE)(max(R, G));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _G$8[ebp]
	cmp	ecx, edx
	jle	SHORT $LN112@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv499[ebp], al
	jmp	SHORT $LN113@ByteBlockO
$LN112@ByteBlockO:
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv499[ebp], cl
$LN113@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv499[ebp]
	mov	BYTE PTR [edx+1], al
$LN70@ByteBlockO:

; 389  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN71@ByteBlockO

; 390  :                     Dest[Index + 2] = (BYTE)(max(R, G));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _G$8[ebp]
	cmp	ecx, edx
	jle	SHORT $LN114@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv507[ebp], al
	jmp	SHORT $LN115@ByteBlockO
$LN114@ByteBlockO:
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv507[ebp], cl
$LN115@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv507[ebp]
	mov	BYTE PTR [edx+2], al
$LN71@ByteBlockO:

; 391  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN72@ByteBlockO

; 392  :                     Dest[Index + 3] = (BYTE)(max(R, G));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _G$8[ebp]
	cmp	ecx, edx
	jle	SHORT $LN116@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv515[ebp], al
	jmp	SHORT $LN117@ByteBlockO
$LN116@ByteBlockO:
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv515[ebp], cl
$LN117@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv515[ebp]
	mov	BYTE PTR [edx+3], al
$LN72@ByteBlockO:

; 393  :                 break;

	jmp	$LN8@ByteBlockO
$LN73@ByteBlockO:

; 394  : 
; 395  :             case BlockMaxRB:
; 396  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN74@ByteBlockO

; 397  :                     Dest[Index + 0] = (BYTE)(max(R, B));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jle	SHORT $LN118@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv523[ebp], al
	jmp	SHORT $LN119@ByteBlockO
$LN118@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv523[ebp], cl
$LN119@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv523[ebp]
	mov	BYTE PTR [edx], al
$LN74@ByteBlockO:

; 398  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN75@ByteBlockO

; 399  :                     Dest[Index + 1] = (BYTE)(max(R, B));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jle	SHORT $LN120@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv531[ebp], al
	jmp	SHORT $LN121@ByteBlockO
$LN120@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv531[ebp], cl
$LN121@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv531[ebp]
	mov	BYTE PTR [edx+1], al
$LN75@ByteBlockO:

; 400  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN76@ByteBlockO

; 401  :                     Dest[Index + 2] = (BYTE)(max(R, B));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jle	SHORT $LN122@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv539[ebp], al
	jmp	SHORT $LN123@ByteBlockO
$LN122@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv539[ebp], cl
$LN123@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv539[ebp]
	mov	BYTE PTR [edx+2], al
$LN76@ByteBlockO:

; 402  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN77@ByteBlockO

; 403  :                     Dest[Index + 3] = (BYTE)(max(R, B));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jle	SHORT $LN124@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv547[ebp], al
	jmp	SHORT $LN125@ByteBlockO
$LN124@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv547[ebp], cl
$LN125@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv547[ebp]
	mov	BYTE PTR [edx+3], al
$LN77@ByteBlockO:

; 404  :                 break;

	jmp	$LN8@ByteBlockO
$LN78@ByteBlockO:

; 405  : 
; 406  :             case BlockMaxGB:
; 407  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN79@ByteBlockO

; 408  :                     Dest[Index + 0] = (BYTE)(max(G, B));

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jle	SHORT $LN126@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv555[ebp], al
	jmp	SHORT $LN127@ByteBlockO
$LN126@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv555[ebp], cl
$LN127@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv555[ebp]
	mov	BYTE PTR [edx], al
$LN79@ByteBlockO:

; 409  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN80@ByteBlockO

; 410  :                     Dest[Index + 1] = (BYTE)(max(G, B));

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jle	SHORT $LN128@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv563[ebp], al
	jmp	SHORT $LN129@ByteBlockO
$LN128@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv563[ebp], cl
$LN129@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv563[ebp]
	mov	BYTE PTR [edx+1], al
$LN80@ByteBlockO:

; 411  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN81@ByteBlockO

; 412  :                     Dest[Index + 2] = (BYTE)(max(G, B));

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jle	SHORT $LN130@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv571[ebp], al
	jmp	SHORT $LN131@ByteBlockO
$LN130@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv571[ebp], cl
$LN131@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv571[ebp]
	mov	BYTE PTR [edx+2], al
$LN81@ByteBlockO:

; 413  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN82@ByteBlockO

; 414  :                     Dest[Index + 3] = (BYTE)(max(G, B));

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jle	SHORT $LN132@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv579[ebp], al
	jmp	SHORT $LN133@ByteBlockO
$LN132@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv579[ebp], cl
$LN133@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv579[ebp]
	mov	BYTE PTR [edx+3], al
$LN82@ByteBlockO:

; 415  :                 break;

	jmp	$LN8@ByteBlockO
$LN83@ByteBlockO:

; 416  : 
; 417  :             case BlockMinRG:
; 418  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN84@ByteBlockO

; 419  :                     Dest[Index + 0] = (BYTE)(min(R, G));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _G$8[ebp]
	cmp	ecx, edx
	jge	SHORT $LN134@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv587[ebp], al
	jmp	SHORT $LN135@ByteBlockO
$LN134@ByteBlockO:
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv587[ebp], cl
$LN135@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv587[ebp]
	mov	BYTE PTR [edx], al
$LN84@ByteBlockO:

; 420  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN85@ByteBlockO

; 421  :                     Dest[Index + 1] = (BYTE)(min(R, G));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _G$8[ebp]
	cmp	ecx, edx
	jge	SHORT $LN136@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv595[ebp], al
	jmp	SHORT $LN137@ByteBlockO
$LN136@ByteBlockO:
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv595[ebp], cl
$LN137@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv595[ebp]
	mov	BYTE PTR [edx+1], al
$LN85@ByteBlockO:

; 422  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN86@ByteBlockO

; 423  :                     Dest[Index + 2] = (BYTE)(min(R, G));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _G$8[ebp]
	cmp	ecx, edx
	jge	SHORT $LN138@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv603[ebp], al
	jmp	SHORT $LN139@ByteBlockO
$LN138@ByteBlockO:
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv603[ebp], cl
$LN139@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv603[ebp]
	mov	BYTE PTR [edx+2], al
$LN86@ByteBlockO:

; 424  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN87@ByteBlockO

; 425  :                     Dest[Index + 3] = (BYTE)(min(R, G));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _G$8[ebp]
	cmp	ecx, edx
	jge	SHORT $LN140@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv611[ebp], al
	jmp	SHORT $LN141@ByteBlockO
$LN140@ByteBlockO:
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv611[ebp], cl
$LN141@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv611[ebp]
	mov	BYTE PTR [edx+3], al
$LN87@ByteBlockO:

; 426  :                 break;

	jmp	$LN8@ByteBlockO
$LN88@ByteBlockO:

; 427  : 
; 428  :             case BlockMinRB:
; 429  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN89@ByteBlockO

; 430  :                     Dest[Index + 0] = (BYTE)(min(R, B));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jge	SHORT $LN142@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv619[ebp], al
	jmp	SHORT $LN143@ByteBlockO
$LN142@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv619[ebp], cl
$LN143@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv619[ebp]
	mov	BYTE PTR [edx], al
$LN89@ByteBlockO:

; 431  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN90@ByteBlockO

; 432  :                     Dest[Index + 1] = (BYTE)(min(R, B));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jge	SHORT $LN144@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv627[ebp], al
	jmp	SHORT $LN145@ByteBlockO
$LN144@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv627[ebp], cl
$LN145@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv627[ebp]
	mov	BYTE PTR [edx+1], al
$LN90@ByteBlockO:

; 433  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN91@ByteBlockO

; 434  :                     Dest[Index + 2] = (BYTE)(min(R, B));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jge	SHORT $LN146@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv635[ebp], al
	jmp	SHORT $LN147@ByteBlockO
$LN146@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv635[ebp], cl
$LN147@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv635[ebp]
	mov	BYTE PTR [edx+2], al
$LN91@ByteBlockO:

; 435  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN92@ByteBlockO

; 436  :                     Dest[Index + 3] = (BYTE)(min(R, B));

	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jge	SHORT $LN148@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv643[ebp], al
	jmp	SHORT $LN149@ByteBlockO
$LN148@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv643[ebp], cl
$LN149@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv643[ebp]
	mov	BYTE PTR [edx+3], al
$LN92@ByteBlockO:

; 437  :                 break;

	jmp	$LN8@ByteBlockO
$LN93@ByteBlockO:

; 438  : 
; 439  :             case BlockMinGB:
; 440  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN94@ByteBlockO

; 441  :                     Dest[Index + 0] = (BYTE)(min(G, B));

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jge	SHORT $LN150@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv651[ebp], al
	jmp	SHORT $LN151@ByteBlockO
$LN150@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv651[ebp], cl
$LN151@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv651[ebp]
	mov	BYTE PTR [edx], al
$LN94@ByteBlockO:

; 442  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN95@ByteBlockO

; 443  :                     Dest[Index + 1] = (BYTE)(min(G, B));

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jge	SHORT $LN152@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv659[ebp], al
	jmp	SHORT $LN153@ByteBlockO
$LN152@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv659[ebp], cl
$LN153@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv659[ebp]
	mov	BYTE PTR [edx+1], al
$LN95@ByteBlockO:

; 444  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN96@ByteBlockO

; 445  :                     Dest[Index + 2] = (BYTE)(min(G, B));

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jge	SHORT $LN154@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv667[ebp], al
	jmp	SHORT $LN155@ByteBlockO
$LN154@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv667[ebp], cl
$LN155@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv667[ebp]
	mov	BYTE PTR [edx+2], al
$LN96@ByteBlockO:

; 446  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN97@ByteBlockO

; 447  :                     Dest[Index + 3] = (BYTE)(min(G, B));

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jge	SHORT $LN156@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv675[ebp], al
	jmp	SHORT $LN157@ByteBlockO
$LN156@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv675[ebp], cl
$LN157@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv675[ebp]
	mov	BYTE PTR [edx+3], al
$LN97@ByteBlockO:

; 448  :                 break;

	jmp	$LN8@ByteBlockO
$LN98@ByteBlockO:

; 449  : 
; 450  :             case BlockBiggest:
; 451  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN99@ByteBlockO

; 452  :                     Dest[Index + 0] = (BYTE)(max(R,max(G, B)));

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jle	SHORT $LN158@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv684[ebp], al
	jmp	SHORT $LN159@ByteBlockO
$LN158@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv684[ebp], cl
$LN159@ByteBlockO:
	movzx	edx, BYTE PTR _R$6[ebp]
	movzx	eax, BYTE PTR tv684[ebp]
	cmp	edx, eax
	jle	SHORT $LN162@ByteBlockO
	mov	cl, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv691[ebp], cl
	jmp	SHORT $LN163@ByteBlockO
$LN162@ByteBlockO:
	movzx	edx, BYTE PTR _G$8[ebp]
	movzx	eax, BYTE PTR _B$7[ebp]
	cmp	edx, eax
	jle	SHORT $LN160@ByteBlockO
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv690[ebp], cl
	jmp	SHORT $LN161@ByteBlockO
$LN160@ByteBlockO:
	mov	dl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv690[ebp], dl
$LN161@ByteBlockO:
	mov	al, BYTE PTR tv690[ebp]
	mov	BYTE PTR tv691[ebp], al
$LN163@ByteBlockO:
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR tv691[ebp]
	mov	BYTE PTR [ecx], dl
$LN99@ByteBlockO:

; 453  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN100@ByteBlockO

; 454  :                     Dest[Index + 1] = (BYTE)(max(R, max(G, B)));

	movzx	eax, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _B$7[ebp]
	cmp	eax, ecx
	jle	SHORT $LN164@ByteBlockO
	mov	dl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv700[ebp], dl
	jmp	SHORT $LN165@ByteBlockO
$LN164@ByteBlockO:
	mov	al, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv700[ebp], al
$LN165@ByteBlockO:
	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR tv700[ebp]
	cmp	ecx, edx
	jle	SHORT $LN168@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv707[ebp], al
	jmp	SHORT $LN169@ByteBlockO
$LN168@ByteBlockO:
	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jle	SHORT $LN166@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv706[ebp], al
	jmp	SHORT $LN167@ByteBlockO
$LN166@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv706[ebp], cl
$LN167@ByteBlockO:
	mov	dl, BYTE PTR tv706[ebp]
	mov	BYTE PTR tv707[ebp], dl
$LN169@ByteBlockO:
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR tv707[ebp]
	mov	BYTE PTR [eax+1], cl
$LN100@ByteBlockO:

; 455  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN101@ByteBlockO

; 456  :                     Dest[Index + 2] = (BYTE)(max(R, max(G, B)));

	movzx	edx, BYTE PTR _G$8[ebp]
	movzx	eax, BYTE PTR _B$7[ebp]
	cmp	edx, eax
	jle	SHORT $LN170@ByteBlockO
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv716[ebp], cl
	jmp	SHORT $LN171@ByteBlockO
$LN170@ByteBlockO:
	mov	dl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv716[ebp], dl
$LN171@ByteBlockO:
	movzx	eax, BYTE PTR _R$6[ebp]
	movzx	ecx, BYTE PTR tv716[ebp]
	cmp	eax, ecx
	jle	SHORT $LN174@ByteBlockO
	mov	dl, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv723[ebp], dl
	jmp	SHORT $LN175@ByteBlockO
$LN174@ByteBlockO:
	movzx	eax, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _B$7[ebp]
	cmp	eax, ecx
	jle	SHORT $LN172@ByteBlockO
	mov	dl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv722[ebp], dl
	jmp	SHORT $LN173@ByteBlockO
$LN172@ByteBlockO:
	mov	al, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv722[ebp], al
$LN173@ByteBlockO:
	mov	cl, BYTE PTR tv722[ebp]
	mov	BYTE PTR tv723[ebp], cl
$LN175@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv723[ebp]
	mov	BYTE PTR [edx+2], al
$LN101@ByteBlockO:

; 457  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN102@ByteBlockO

; 458  :                     Dest[Index + 3] = (BYTE)(max(R, max(G, B)));

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jle	SHORT $LN176@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv732[ebp], al
	jmp	SHORT $LN177@ByteBlockO
$LN176@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv732[ebp], cl
$LN177@ByteBlockO:
	movzx	edx, BYTE PTR _R$6[ebp]
	movzx	eax, BYTE PTR tv732[ebp]
	cmp	edx, eax
	jle	SHORT $LN180@ByteBlockO
	mov	cl, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv739[ebp], cl
	jmp	SHORT $LN181@ByteBlockO
$LN180@ByteBlockO:
	movzx	edx, BYTE PTR _G$8[ebp]
	movzx	eax, BYTE PTR _B$7[ebp]
	cmp	edx, eax
	jle	SHORT $LN178@ByteBlockO
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv738[ebp], cl
	jmp	SHORT $LN179@ByteBlockO
$LN178@ByteBlockO:
	mov	dl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv738[ebp], dl
$LN179@ByteBlockO:
	mov	al, BYTE PTR tv738[ebp]
	mov	BYTE PTR tv739[ebp], al
$LN181@ByteBlockO:
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR tv739[ebp]
	mov	BYTE PTR [ecx+3], dl
$LN102@ByteBlockO:

; 459  :                 break;

	jmp	$LN8@ByteBlockO
$LN103@ByteBlockO:

; 460  : 
; 461  :             case BlockSmallest:
; 462  :                 if (DoBlue)

	cmp	DWORD PTR _DoBlue$[ebp], 0
	je	SHORT $LN104@ByteBlockO

; 463  :                     Dest[Index + 0] = (BYTE)(min(R, min(G, B)));

	movzx	eax, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _B$7[ebp]
	cmp	eax, ecx
	jge	SHORT $LN182@ByteBlockO
	mov	dl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv748[ebp], dl
	jmp	SHORT $LN183@ByteBlockO
$LN182@ByteBlockO:
	mov	al, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv748[ebp], al
$LN183@ByteBlockO:
	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR tv748[ebp]
	cmp	ecx, edx
	jge	SHORT $LN186@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv755[ebp], al
	jmp	SHORT $LN187@ByteBlockO
$LN186@ByteBlockO:
	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jge	SHORT $LN184@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv754[ebp], al
	jmp	SHORT $LN185@ByteBlockO
$LN184@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv754[ebp], cl
$LN185@ByteBlockO:
	mov	dl, BYTE PTR tv754[ebp]
	mov	BYTE PTR tv755[ebp], dl
$LN187@ByteBlockO:
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR tv755[ebp]
	mov	BYTE PTR [eax], cl
$LN104@ByteBlockO:

; 464  :                 if (DoGreen)

	cmp	DWORD PTR _DoGreen$[ebp], 0
	je	SHORT $LN105@ByteBlockO

; 465  :                     Dest[Index + 1] = (BYTE)(min(R, min(G, B)));

	movzx	edx, BYTE PTR _G$8[ebp]
	movzx	eax, BYTE PTR _B$7[ebp]
	cmp	edx, eax
	jge	SHORT $LN188@ByteBlockO
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv764[ebp], cl
	jmp	SHORT $LN189@ByteBlockO
$LN188@ByteBlockO:
	mov	dl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv764[ebp], dl
$LN189@ByteBlockO:
	movzx	eax, BYTE PTR _R$6[ebp]
	movzx	ecx, BYTE PTR tv764[ebp]
	cmp	eax, ecx
	jge	SHORT $LN192@ByteBlockO
	mov	dl, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv771[ebp], dl
	jmp	SHORT $LN193@ByteBlockO
$LN192@ByteBlockO:
	movzx	eax, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _B$7[ebp]
	cmp	eax, ecx
	jge	SHORT $LN190@ByteBlockO
	mov	dl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv770[ebp], dl
	jmp	SHORT $LN191@ByteBlockO
$LN190@ByteBlockO:
	mov	al, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv770[ebp], al
$LN191@ByteBlockO:
	mov	cl, BYTE PTR tv770[ebp]
	mov	BYTE PTR tv771[ebp], cl
$LN193@ByteBlockO:
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	al, BYTE PTR tv771[ebp]
	mov	BYTE PTR [edx+1], al
$LN105@ByteBlockO:

; 466  :                 if (DoRed)

	cmp	DWORD PTR _DoRed$[ebp], 0
	je	SHORT $LN106@ByteBlockO

; 467  :                     Dest[Index + 2] = (BYTE)(min(R, min(G, B)));

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jge	SHORT $LN194@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv780[ebp], al
	jmp	SHORT $LN195@ByteBlockO
$LN194@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv780[ebp], cl
$LN195@ByteBlockO:
	movzx	edx, BYTE PTR _R$6[ebp]
	movzx	eax, BYTE PTR tv780[ebp]
	cmp	edx, eax
	jge	SHORT $LN198@ByteBlockO
	mov	cl, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv787[ebp], cl
	jmp	SHORT $LN199@ByteBlockO
$LN198@ByteBlockO:
	movzx	edx, BYTE PTR _G$8[ebp]
	movzx	eax, BYTE PTR _B$7[ebp]
	cmp	edx, eax
	jge	SHORT $LN196@ByteBlockO
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv786[ebp], cl
	jmp	SHORT $LN197@ByteBlockO
$LN196@ByteBlockO:
	mov	dl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv786[ebp], dl
$LN197@ByteBlockO:
	mov	al, BYTE PTR tv786[ebp]
	mov	BYTE PTR tv787[ebp], al
$LN199@ByteBlockO:
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	dl, BYTE PTR tv787[ebp]
	mov	BYTE PTR [ecx+2], dl
$LN106@ByteBlockO:

; 468  :                 if (DoAlpha)

	cmp	DWORD PTR _DoAlpha$[ebp], 0
	je	SHORT $LN107@ByteBlockO

; 469  :                     Dest[Index + 3] = (BYTE)(min(R, min(G, B)));

	movzx	eax, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _B$7[ebp]
	cmp	eax, ecx
	jge	SHORT $LN200@ByteBlockO
	mov	dl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv796[ebp], dl
	jmp	SHORT $LN201@ByteBlockO
$LN200@ByteBlockO:
	mov	al, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv796[ebp], al
$LN201@ByteBlockO:
	movzx	ecx, BYTE PTR _R$6[ebp]
	movzx	edx, BYTE PTR tv796[ebp]
	cmp	ecx, edx
	jge	SHORT $LN204@ByteBlockO
	mov	al, BYTE PTR _R$6[ebp]
	mov	BYTE PTR tv803[ebp], al
	jmp	SHORT $LN205@ByteBlockO
$LN204@ByteBlockO:
	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$7[ebp]
	cmp	ecx, edx
	jge	SHORT $LN202@ByteBlockO
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv802[ebp], al
	jmp	SHORT $LN203@ByteBlockO
$LN202@ByteBlockO:
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR tv802[ebp], cl
$LN203@ByteBlockO:
	mov	dl, BYTE PTR tv802[ebp]
	mov	BYTE PTR tv803[ebp], dl
$LN205@ByteBlockO:
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	mov	cl, BYTE PTR tv803[ebp]
	mov	BYTE PTR [eax+3], cl
$LN107@ByteBlockO:

; 470  :                 break;

	jmp	SHORT $LN8@ByteBlockO
$LN108@ByteBlockO:

; 471  : 
; 472  :             default:
; 473  :                 return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@ByteBlockO
$LN8@ByteBlockO:

; 474  :             }
; 475  :         }

	jmp	$LN5@ByteBlockO
$LN6@ByteBlockO:

; 476  :     }

	jmp	$LN2@ByteBlockO
$LN3@ByteBlockO:

; 477  : 
; 478  :     return Success;

	xor	eax, eax
$LN1@ByteBlockO:

; 479  : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
$LN207@ByteBlockO:
	DD	$LN16@ByteBlockO
	DD	$LN21@ByteBlockO
	DD	$LN26@ByteBlockO
	DD	$LN31@ByteBlockO
	DD	$LN36@ByteBlockO
	DD	$LN41@ByteBlockO
	DD	$LN46@ByteBlockO
	DD	$LN51@ByteBlockO
	DD	$LN61@ByteBlockO
	DD	$LN56@ByteBlockO
	DD	$LN66@ByteBlockO
	DD	$LN67@ByteBlockO
	DD	$LN68@ByteBlockO
	DD	$LN73@ByteBlockO
	DD	$LN78@ByteBlockO
	DD	$LN83@ByteBlockO
	DD	$LN88@ByteBlockO
	DD	$LN93@ByteBlockO
	DD	$LN98@ByteBlockO
	DD	$LN103@ByteBlockO
	DD	$LN108@ByteBlockO
$LN206@ByteBlockO:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	20					; 00000014H
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
_ByteBlockOperationByChannel@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_DestBuffer$ = -24					; size = 4
_SourceBuffer$ = -20					; size = 4
_Column$2 = -16						; size = 4
_Row$3 = -12						; size = 4
_Index$4 = -8						; size = 4
_PixelSize$ = -1					; size = 1
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Destination$ = 24					; size = 4
_ConvertBlockToDouble@20 PROC

; 40   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 41   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ConvertBlo

; 42   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ConvertBlo
$LN8@ConvertBlo:

; 43   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@ConvertBlo

; 44   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ConvertBlo
$LN9@ConvertBlo:

; 45   : 
; 46   :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 47   :     BYTE* SourceBuffer = (BYTE*)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _SourceBuffer$[ebp], eax

; 48   :     double* DestBuffer = (double*)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _DestBuffer$[ebp], ecx

; 49   : 
; 50   :     for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ConvertBlo
$LN2@ConvertBlo:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@ConvertBlo:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@ConvertBlo

; 51   :     {
; 52   :         int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 53   :         for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ConvertBlo
$LN5@ConvertBlo:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@ConvertBlo:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@ConvertBlo

; 54   :         {
; 55   :             int Index = RowOffset + (Column * PixelSize);

	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 56   :             DestBuffer[Index + 3] = ((double)SourceBuffer[Index + 3] / 255.0);

	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+3]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	movsd	QWORD PTR [edx+ecx*8+24], xmm0

; 57   :             DestBuffer[Index + 2] = ((double)SourceBuffer[Index + 2] / 255.0);

	mov	eax, DWORD PTR _SourceBuffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	mov	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _DestBuffer$[ebp]
	movsd	QWORD PTR [eax+edx*8+16], xmm0

; 58   :             DestBuffer[Index + 1] = ((double)SourceBuffer[Index + 1] / 255.0);

	mov	ecx, DWORD PTR _SourceBuffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cvtsi2sd xmm0, edx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _DestBuffer$[ebp]
	movsd	QWORD PTR [ecx+eax*8+8], xmm0

; 59   :             DestBuffer[Index + 0] = ((double)SourceBuffer[Index + 0] / 255.0);

	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2sd xmm0, eax
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _DestBuffer$[ebp]
	movsd	QWORD PTR [edx+ecx*8], xmm0

; 60   :         }

	jmp	$LN5@ConvertBlo
$LN6@ConvertBlo:

; 61   :     }

	jmp	$LN2@ConvertBlo
$LN3@ConvertBlo:

; 62   : 
; 63   :     return Success;

	xor	eax, eax
$LN1@ConvertBlo:

; 64   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_ConvertBlockToDouble@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\fullbufferfunctions.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_SourceBuffer$ = -24					; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Acc$ = -12						; size = 4
_Index$4 = -8						; size = 4
_PixelSize$ = -1					; size = 1
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_Accumulator$ = 24					; size = 4
_AccumulateDoubleBlock@20 PROC

; 77   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 78   :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@Accumulate

; 79   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@Accumulate
$LN8@Accumulate:

; 80   :     if (Accumulator == NULL)

	cmp	DWORD PTR _Accumulator$[ebp], 0
	jne	SHORT $LN9@Accumulate

; 81   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@Accumulate
$LN9@Accumulate:

; 82   : 
; 83   :     BYTE PixelSize = 4;

	mov	BYTE PTR _PixelSize$[ebp], 4

; 84   :     BYTE* SourceBuffer = (BYTE*)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _SourceBuffer$[ebp], eax

; 85   :     double* Acc = (double*)Accumulator;

	mov	ecx, DWORD PTR _Accumulator$[ebp]
	mov	DWORD PTR _Acc$[ebp], ecx

; 86   : 
; 87   :     for (int Row = 0; Row < SourceHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@Accumulate
$LN2@Accumulate:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@Accumulate:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _SourceHeight$[ebp]
	jge	$LN3@Accumulate

; 88   :     {
; 89   :         int RowOffset = Row * SourceStride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 90   :         for (int Column = 0; Column < SourceWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@Accumulate
$LN5@Accumulate:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@Accumulate:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _SourceWidth$[ebp]
	jge	$LN6@Accumulate

; 91   :         {
; 92   :             int Index = RowOffset + (Column * PixelSize);

	movzx	ecx, BYTE PTR _PixelSize$[ebp]
	imul	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 93   :             Acc[Index + 3] += SourceBuffer[Index + 3];

	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+3]
	cvtsi2sd xmm0, eax
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Acc$[ebp]
	addsd	xmm0, QWORD PTR [edx+ecx*8+24]
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Acc$[ebp]
	movsd	QWORD PTR [ecx+eax*8+24], xmm0

; 94   :             Acc[Index + 2] += SourceBuffer[Index + 2];

	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+2]
	cvtsi2sd xmm0, eax
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Acc$[ebp]
	addsd	xmm0, QWORD PTR [edx+ecx*8+16]
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Acc$[ebp]
	movsd	QWORD PTR [ecx+eax*8+16], xmm0

; 95   :             Acc[Index + 1] += SourceBuffer[Index + 1];

	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cvtsi2sd xmm0, eax
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Acc$[ebp]
	addsd	xmm0, QWORD PTR [edx+ecx*8+8]
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Acc$[ebp]
	movsd	QWORD PTR [ecx+eax*8+8], xmm0

; 96   :             Acc[Index + 0] += SourceBuffer[Index + 0];

	mov	edx, DWORD PTR _SourceBuffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2sd xmm0, eax
	mov	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Acc$[ebp]
	addsd	xmm0, QWORD PTR [edx+ecx*8]
	mov	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Acc$[ebp]
	movsd	QWORD PTR [ecx+eax*8], xmm0

; 97   :         }

	jmp	$LN5@Accumulate
$LN6@Accumulate:

; 98   :     }

	jmp	$LN2@Accumulate
$LN3@Accumulate:

; 99   : 
; 100  :     return Success;

	xor	eax, eax
$LN1@Accumulate:

; 101  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_AccumulateDoubleBlock@20 ENDP
_TEXT	ENDS
END
