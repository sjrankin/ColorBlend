; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Channels.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_ChannelShift@20
PUBLIC	_ChannelSwap@28
PUBLIC	_ChannelSwap3@24
PUBLIC	_ChannelSwap4@36
PUBLIC	_ChannelMigrate@36
PUBLIC	_RandomChannelSwap@24
PUBLIC	_PixelMigrate@24
PUBLIC	_ChannelSwap2@28
PUBLIC	_SelectRGBChannels@36
PUBLIC	_SelectHSLChannels@40
PUBLIC	_RGBCombine@32
PUBLIC	_ApplyBrightnessMap@24
PUBLIC	_GammaCorrection@32
PUBLIC	_AdjustSaturation@28
PUBLIC	_HighlightImageColor@44
PUBLIC	_AdjustImageHSL@44
PUBLIC	?BMask@@YGEH@Z					; BMask
PUBLIC	?shuffle@@YGXPAEI@Z				; shuffle
PUBLIC	?Random3@@YGXPAE00@Z				; Random3
PUBLIC	?Random4@@YGXPAE000@Z				; Random4
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@403e000000000000
PUBLIC	__real@406fe00000000000
PUBLIC	__real@4076800000000000
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp__srand:PROC
EXTRN	__imp__rand:PROC
EXTRN	_ColorLuminance@12:PROC
EXTRN	?PixelLuminance@@YGNEEE@Z:PROC			; PixelLuminance
EXTRN	_RGBtoHSL2@24:PROC
EXTRN	_HSLtoRGB2@36:PROC
EXTRN	_SetPixelLuminance@20:PROC
EXTRN	_RGBtoHue2@12:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	__fltused:DWORD
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@403e000000000000
CONST	SEGMENT
__real@403e000000000000 DQ 0403e000000000000r	; 30
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_Ar$ = -4						; size = 4
_Alpha$ = 8						; size = 4
_Red$ = 12						; size = 4
_Green$ = 16						; size = 4
_Blue$ = 20						; size = 4
?Random4@@YGXPAE000@Z PROC				; Random4

; 567  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 568  :     BYTE* Ar = new BYTE[4];

	push	4
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _Ar$[ebp], eax

; 569  :     Ar[0] = *Alpha;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _Ar$[ebp]
	mov	ecx, DWORD PTR _Alpha$[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+edx], cl

; 570  :     Ar[1] = *Red;

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _Ar$[ebp]
	mov	ecx, DWORD PTR _Red$[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+edx], cl

; 571  :     Ar[2] = *Green;

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _Ar$[ebp]
	mov	ecx, DWORD PTR _Green$[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+edx], cl

; 572  :     Ar[3] = *Blue;

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _Ar$[ebp]
	mov	edx, DWORD PTR _Blue$[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [ecx+eax], dl

; 573  :     shuffle(Ar, 4);

	push	4
	mov	eax, DWORD PTR _Ar$[ebp]
	push	eax
	call	?shuffle@@YGXPAEI@Z			; shuffle

; 574  :     *Alpha = Ar[0];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _Alpha$[ebp]
	mov	ecx, DWORD PTR _Ar$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl

; 575  :     *Red = Ar[1];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _Red$[ebp]
	mov	edx, DWORD PTR _Ar$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al

; 576  :     *Green = Ar[2];

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _Green$[ebp]
	mov	eax, DWORD PTR _Ar$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl

; 577  :     *Blue = Ar[3];

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _Blue$[ebp]
	mov	edx, DWORD PTR _Ar$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al

; 578  :     delete[] Ar;

	mov	ecx, DWORD PTR _Ar$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 579  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Random4@@YGXPAE000@Z ENDP				; Random4
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_Ar$ = -4						; size = 4
_Red$ = 8						; size = 4
_Green$ = 12						; size = 4
_Blue$ = 16						; size = 4
?Random3@@YGXPAE00@Z PROC				; Random3

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 548  :     BYTE* Ar = new BYTE[3];

	push	3
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _Ar$[ebp], eax

; 549  :     Ar[0] = *Red;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _Ar$[ebp]
	mov	ecx, DWORD PTR _Red$[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+edx], cl

; 550  :     Ar[1] = *Green;

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _Ar$[ebp]
	mov	ecx, DWORD PTR _Green$[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+edx], cl

; 551  :     Ar[2] = *Blue;

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _Ar$[ebp]
	mov	ecx, DWORD PTR _Blue$[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+edx], cl

; 552  :     shuffle(Ar, 3);

	push	3
	mov	edx, DWORD PTR _Ar$[ebp]
	push	edx
	call	?shuffle@@YGXPAEI@Z			; shuffle

; 553  :     *Red = Ar[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _Red$[ebp]
	mov	eax, DWORD PTR _Ar$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl

; 554  :     *Green = Ar[1];

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _Green$[ebp]
	mov	ecx, DWORD PTR _Ar$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl

; 555  :     *Blue = Ar[2];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _Blue$[ebp]
	mov	edx, DWORD PTR _Ar$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx], al

; 556  :     delete[] Ar;

	mov	ecx, DWORD PTR _Ar$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 557  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Random3@@YGXPAE00@Z ENDP				; Random3
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_j$1 = -12						; size = 4
_i$2 = -8						; size = 4
_t$3 = -1						; size = 1
_array$ = 8						; size = 4
_n$ = 12						; size = 4
?shuffle@@YGXPAEI@Z PROC				; shuffle

; 526  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 527  :     if (n > 1)

	cmp	DWORD PTR _n$[ebp], 1
	jbe	SHORT $LN1@shuffle

; 528  :     {
; 529  :         size_t i;
; 530  :         for (i = 0; i < n - 1; i++)

	mov	DWORD PTR _i$2[ebp], 0
	jmp	SHORT $LN4@shuffle
$LN2@shuffle:
	mov	eax, DWORD PTR _i$2[ebp]
	add	eax, 1
	mov	DWORD PTR _i$2[ebp], eax
$LN4@shuffle:
	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, 1
	cmp	DWORD PTR _i$2[ebp], ecx
	jae	SHORT $LN1@shuffle

; 531  :         {
; 532  :             size_t j = i + rand() / (RAND_MAX / (n - i) + 1);

	call	DWORD PTR __imp__rand
	mov	ecx, eax
	mov	esi, DWORD PTR _n$[ebp]
	sub	esi, DWORD PTR _i$2[ebp]
	mov	eax, 32767				; 00007fffH
	xor	edx, edx
	div	esi
	mov	esi, eax
	add	esi, 1
	mov	eax, ecx
	xor	edx, edx
	div	esi
	add	eax, DWORD PTR _i$2[ebp]
	mov	DWORD PTR _j$1[ebp], eax

; 533  :             BYTE t = array[j];

	mov	edx, DWORD PTR _array$[ebp]
	add	edx, DWORD PTR _j$1[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _t$3[ebp], al

; 534  :             array[j] = array[i];

	mov	ecx, DWORD PTR _array$[ebp]
	add	ecx, DWORD PTR _j$1[ebp]
	mov	edx, DWORD PTR _array$[ebp]
	add	edx, DWORD PTR _i$2[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 535  :             array[i] = t;

	mov	ecx, DWORD PTR _array$[ebp]
	add	ecx, DWORD PTR _i$2[ebp]
	mov	dl, BYTE PTR _t$3[ebp]
	mov	BYTE PTR [ecx], dl

; 536  :         }

	jmp	SHORT $LN2@shuffle
$LN1@shuffle:

; 537  :     }
; 538  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?shuffle@@YGXPAEI@Z ENDP				; shuffle
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
;	COMDAT ?BMask@@YGEH@Z
_TEXT	SEGMENT
_Value$ = 8						; size = 4
?BMask@@YGEH@Z PROC					; BMask, COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp

; 47   :     return (BYTE)pow(2.0, Value) - 1;

	movsd	xmm0, QWORD PTR __real@4000000000000000
	cvtsi2sd xmm1, DWORD PTR _Value$[ebp]
	call	__libm_sse2_pow_precise
	cvttsd2si eax, xmm0
	movzx	eax, al
	sub	eax, 1

; 48   : }

	pop	ebp
	ret	4
?BMask@@YGEH@Z ENDP					; BMask
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_SourceLuminance$1 = -80				; size = 8
_SourceSaturation$2 = -72				; size = 8
_FinalHue$3 = -64					; size = 8
_SourceHue$4 = -56					; size = 8
_FinalSaturation$5 = -48				; size = 8
_FinalLuminance$6 = -40					; size = 8
_RowOffset$7 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Dest$ = -24						; size = 4
_Src$ = -20						; size = 4
_Column$8 = -16						; size = 4
_Row$9 = -12						; size = 4
_Index$10 = -8						; size = 4
_A$11 = -4						; size = 1
_B$12 = -3						; size = 1
_G$13 = -2						; size = 1
_R$14 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_HueAdjustment$ = 28					; size = 8
_SaturationAdjustment$ = 36				; size = 8
_LuminanceAdjustment$ = 44				; size = 8
_AdjustImageHSL@44 PROC

; 1058 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 1059 :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@AdjustImag

; 1060 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AdjustImag
$LN8@AdjustImag:

; 1061 :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@AdjustImag

; 1062 :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AdjustImag
$LN9@AdjustImag:

; 1063 : 
; 1064 :     if (HueAdjustment == 0.0 && SaturationAdjustment == 0.0 && LuminanceAdjustment == 0.0)

	movsd	xmm0, QWORD PTR _HueAdjustment$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@AdjustImag
	movsd	xmm0, QWORD PTR _SaturationAdjustment$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@AdjustImag
	movsd	xmm0, QWORD PTR _LuminanceAdjustment$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@AdjustImag

; 1065 :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@AdjustImag
$LN10@AdjustImag:

; 1066 : 
; 1067 :     //Normalize hue.
; 1068 :     HueAdjustment = (HueAdjustment + 1.0) / 2.0;

	movsd	xmm0, QWORD PTR _HueAdjustment$[ebp]
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	divsd	xmm0, QWORD PTR __real@4000000000000000
	movsd	QWORD PTR _HueAdjustment$[ebp], xmm0

; 1069 : 
; 1070 :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 1071 :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 1072 :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 1073 : 
; 1074 :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$9[ebp], 0
	jmp	SHORT $LN4@AdjustImag
$LN2@AdjustImag:
	mov	edx, DWORD PTR _Row$9[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$9[ebp], edx
$LN4@AdjustImag:
	mov	eax, DWORD PTR _Row$9[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@AdjustImag

; 1075 :     {
; 1076 :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$9[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$7[ebp], ecx

; 1077 :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$8[ebp], 0
	jmp	SHORT $LN7@AdjustImag
$LN5@AdjustImag:
	mov	edx, DWORD PTR _Column$8[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$8[ebp], edx
$LN7@AdjustImag:
	mov	eax, DWORD PTR _Column$8[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@AdjustImag

; 1078 :         {
; 1079 :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$8[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$7[ebp]
	mov	DWORD PTR _Index$10[ebp], ecx

; 1080 :             BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$10[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$11[ebp], al

; 1081 :             BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$14[ebp], dl

; 1082 :             BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$10[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$13[ebp], cl

; 1083 :             BYTE B = Src[Index + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$10[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$12[ebp], al

; 1084 :             double SourceHue = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _SourceHue$4[ebp], xmm0

; 1085 :             double SourceSaturation = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _SourceSaturation$2[ebp], xmm0

; 1086 :             double SourceLuminance = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _SourceLuminance$1[ebp], xmm0

; 1087 :             RGBtoHSL2(R, G, B, &SourceHue, &SourceSaturation, &SourceLuminance);

	lea	ecx, DWORD PTR _SourceLuminance$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _SourceSaturation$2[ebp]
	push	edx
	lea	eax, DWORD PTR _SourceHue$4[ebp]
	push	eax
	movzx	ecx, BYTE PTR _B$12[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$13[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$14[ebp]
	push	eax
	call	_RGBtoHSL2@24

; 1088 :             double FinalHue = SourceHue;

	movsd	xmm0, QWORD PTR _SourceHue$4[ebp]
	movsd	QWORD PTR _FinalHue$3[ebp], xmm0

; 1089 :             double FinalSaturation = SourceSaturation;

	movsd	xmm0, QWORD PTR _SourceSaturation$2[ebp]
	movsd	QWORD PTR _FinalSaturation$5[ebp], xmm0

; 1090 :             double FinalLuminance = SourceLuminance;

	movsd	xmm0, QWORD PTR _SourceLuminance$1[ebp]
	movsd	QWORD PTR _FinalLuminance$6[ebp], xmm0

; 1091 : 
; 1092 :             if (HueAdjustment != 0.0)

	movsd	xmm0, QWORD PTR _HueAdjustment$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@AdjustImag

; 1093 :             {
; 1094 :                 FinalHue = (SourceHue + (360.0 * HueAdjustment));

	movsd	xmm0, QWORD PTR __real@4076800000000000
	mulsd	xmm0, QWORD PTR _HueAdjustment$[ebp]
	addsd	xmm0, QWORD PTR _SourceHue$4[ebp]
	movsd	QWORD PTR _FinalHue$3[ebp], xmm0

; 1095 :                 if (FinalHue > 360.0)

	movsd	xmm0, QWORD PTR _FinalHue$3[ebp]
	comisd	xmm0, QWORD PTR __real@4076800000000000
	jbe	SHORT $LN12@AdjustImag

; 1096 :                     FinalHue -= 360.0;

	movsd	xmm0, QWORD PTR _FinalHue$3[ebp]
	subsd	xmm0, QWORD PTR __real@4076800000000000
	movsd	QWORD PTR _FinalHue$3[ebp], xmm0
$LN12@AdjustImag:

; 1097 :             }
; 1098 :             if (SaturationAdjustment != 0.0)

	movsd	xmm0, QWORD PTR _SaturationAdjustment$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN15@AdjustImag

; 1099 :             {
; 1100 :                 FinalSaturation = SourceHue + SaturationAdjustment;

	movsd	xmm0, QWORD PTR _SourceHue$4[ebp]
	addsd	xmm0, QWORD PTR _SaturationAdjustment$[ebp]
	movsd	QWORD PTR _FinalSaturation$5[ebp], xmm0

; 1101 :                 if (FinalSaturation < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _FinalSaturation$5[ebp]
	jbe	SHORT $LN14@AdjustImag

; 1102 :                     FinalSaturation = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _FinalSaturation$5[ebp], xmm0
$LN14@AdjustImag:

; 1103 :                 if (FinalSaturation > 1.0)

	movsd	xmm0, QWORD PTR _FinalSaturation$5[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN15@AdjustImag

; 1104 :                     FinalSaturation = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _FinalSaturation$5[ebp], xmm0
$LN15@AdjustImag:

; 1105 :             }
; 1106 :             if (LuminanceAdjustment != 0.0)

	movsd	xmm0, QWORD PTR _LuminanceAdjustment$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN18@AdjustImag

; 1107 :             {
; 1108 :                 FinalLuminance = SourceHue + LuminanceAdjustment;

	movsd	xmm0, QWORD PTR _SourceHue$4[ebp]
	addsd	xmm0, QWORD PTR _LuminanceAdjustment$[ebp]
	movsd	QWORD PTR _FinalLuminance$6[ebp], xmm0

; 1109 :                 if (FinalLuminance < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _FinalLuminance$6[ebp]
	jbe	SHORT $LN17@AdjustImag

; 1110 :                     FinalLuminance = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _FinalLuminance$6[ebp], xmm0
$LN17@AdjustImag:

; 1111 :                 if (FinalLuminance > 1.0)

	movsd	xmm0, QWORD PTR _FinalLuminance$6[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN18@AdjustImag

; 1112 :                     FinalLuminance = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _FinalLuminance$6[ebp], xmm0
$LN18@AdjustImag:

; 1113 :             }
; 1114 : 
; 1115 :             HSLtoRGB2(FinalHue, FinalSaturation, FinalLuminance, &R, &G, &B);

	lea	ecx, DWORD PTR _B$12[ebp]
	push	ecx
	lea	edx, DWORD PTR _G$13[ebp]
	push	edx
	lea	eax, DWORD PTR _R$14[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _FinalLuminance$6[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _FinalSaturation$5[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _FinalHue$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB2@36

; 1116 : 
; 1117 :             Dest[Index + 3] = A;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	dl, BYTE PTR _A$11[ebp]
	mov	BYTE PTR [ecx+3], dl

; 1118 :             Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$10[ebp]
	mov	cl, BYTE PTR _R$14[ebp]
	mov	BYTE PTR [eax+2], cl

; 1119 :             Dest[Index + 1] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$10[ebp]
	mov	al, BYTE PTR _G$13[ebp]
	mov	BYTE PTR [edx+1], al

; 1120 :             Dest[Index + 0] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	dl, BYTE PTR _B$12[ebp]
	mov	BYTE PTR [ecx], dl

; 1121 :         }

	jmp	$LN5@AdjustImag
$LN6@AdjustImag:

; 1122 :     }

	jmp	$LN2@AdjustImag
$LN3@AdjustImag:

; 1123 : 
; 1124 :     return Success;

	xor	eax, eax
$LN1@AdjustImag:

; 1125 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_AdjustImageHSL@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_Hue$1 = -68						; size = 8
_HDelta$2 = -60						; size = 8
_RowOffset$3 = -52					; size = 4
_PixelSize$ = -48					; size = 4
_ALPHA$4 = -44						; size = 4
_Dest$ = -40						; size = 4
_Index$5 = -36						; size = 4
_Column$6 = -32						; size = 4
_Row$7 = -28						; size = 4
_BLUE$8 = -24						; size = 4
_GREEN$9 = -20						; size = 4
_RED$10 = -16						; size = 4
_Src$ = -12						; size = 4
_A$ = -5						; size = 1
_Mean$11 = -4						; size = 1
_B$ = -3						; size = 1
_G$ = -2						; size = 1
_R$ = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_TargetHue$ = 28					; size = 8
_NonHighlightAction$ = 36				; size = 4
_HighlightLuminance$ = 40				; size = 8
_HueDelta$ = 48						; size = 4
_HighlightImageColor@44 PROC

; 990  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 991  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@HighlightI

; 992  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@HighlightI
$LN8@HighlightI:

; 993  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@HighlightI

; 994  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@HighlightI
$LN9@HighlightI:

; 995  : 
; 996  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 997  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 998  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 999  :     BYTE A, R, G, B;
; 1000 : 
; 1001 :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$7[ebp], 0
	jmp	SHORT $LN4@HighlightI
$LN2@HighlightI:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN4@HighlightI:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@HighlightI

; 1002 :     {
; 1003 :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$3[ebp], ecx

; 1004 :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$6[ebp], 0
	jmp	SHORT $LN7@HighlightI
$LN5@HighlightI:
	mov	edx, DWORD PTR _Column$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$6[ebp], edx
$LN7@HighlightI:
	mov	eax, DWORD PTR _Column$6[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@HighlightI

; 1005 :         {
; 1006 :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$6[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$3[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 1007 :             int ALPHA = Index + 3;

	mov	edx, DWORD PTR _Index$5[ebp]
	add	edx, 3
	mov	DWORD PTR _ALPHA$4[ebp], edx

; 1008 :             int RED = Index + 2;

	mov	eax, DWORD PTR _Index$5[ebp]
	add	eax, 2
	mov	DWORD PTR _RED$10[ebp], eax

; 1009 :             int GREEN = Index + 1;

	mov	ecx, DWORD PTR _Index$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _GREEN$9[ebp], ecx

; 1010 :             int BLUE = Index + 0;

	mov	edx, DWORD PTR _Index$5[ebp]
	mov	DWORD PTR _BLUE$8[ebp], edx

; 1011 : 
; 1012 :             double Hue = RGBtoHue2(Src[RED], Src[GREEN], Src[BLUE]);

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _BLUE$8[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _GREEN$9[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _RED$10[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	_RGBtoHue2@12
	fstp	QWORD PTR _Hue$1[ebp]

; 1013 :             BYTE Mean = (Src[RED] + Src[GREEN] + Src[BLUE]) / 3;

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _RED$10[ebp]
	movzx	eax, BYTE PTR [eax]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _GREEN$9[ebp]
	movzx	edx, BYTE PTR [ecx]
	add	eax, edx
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _BLUE$8[ebp]
	movzx	edx, BYTE PTR [ecx]
	add	eax, edx
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	BYTE PTR _Mean$11[ebp], al

; 1014 :             A = Src[ALPHA];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _ALPHA$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _A$[ebp], al

; 1015 :             R = Mean;

	mov	cl, BYTE PTR _Mean$11[ebp]
	mov	BYTE PTR _R$[ebp], cl

; 1016 :             G = Mean;

	mov	dl, BYTE PTR _Mean$11[ebp]
	mov	BYTE PTR _G$[ebp], dl

; 1017 :             B = Mean;

	mov	al, BYTE PTR _Mean$11[ebp]
	mov	BYTE PTR _B$[ebp], al

; 1018 : 
; 1019 :             double HDelta = fabs(TargetHue - Hue);

	movsd	xmm0, QWORD PTR _TargetHue$[ebp]
	subsd	xmm0, QWORD PTR _Hue$1[ebp]
	andps	xmm0, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
	movsd	QWORD PTR _HDelta$2[ebp], xmm0

; 1020 :             HueDelta = HDelta;

	mov	ecx, DWORD PTR _HueDelta$[ebp]
	movsd	xmm0, QWORD PTR _HDelta$2[ebp]
	movsd	QWORD PTR [ecx], xmm0

; 1021 :             if (HDelta <= 30.0)

	movsd	xmm0, QWORD PTR __real@403e000000000000
	comisd	xmm0, QWORD PTR _HDelta$2[ebp]
	jb	SHORT $LN10@HighlightI

; 1022 :             {
; 1023 :                 R = Src[RED];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _RED$10[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _R$[ebp], al

; 1024 :                 G = Src[GREEN];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _GREEN$9[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _G$[ebp], dl

; 1025 :                 B = Src[BLUE];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _BLUE$8[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$[ebp], cl

; 1026 :                 if (HighlightLuminance != 1.0)

	movsd	xmm0, QWORD PTR _HighlightLuminance$[ebp]
	ucomisd	xmm0, QWORD PTR __real@3ff0000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN12@HighlightI

; 1027 :                 {
; 1028 :                     SetPixelLuminance(&R, &G, &B, HighlightLuminance);

	sub	esp, 8
	movsd	xmm0, QWORD PTR _HighlightLuminance$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _B$[ebp]
	push	edx
	lea	eax, DWORD PTR _G$[ebp]
	push	eax
	lea	ecx, DWORD PTR _R$[ebp]
	push	ecx
	call	_SetPixelLuminance@20
$LN12@HighlightI:

; 1029 :                 }
; 1030 :             }
; 1031 :             else

	jmp	SHORT $LN15@HighlightI
$LN10@HighlightI:

; 1032 :             {
; 1033 :                 if (NonHighlightAction == NonHighlightTransparent)

	cmp	DWORD PTR _NonHighlightAction$[ebp], 1
	jne	SHORT $LN13@HighlightI

; 1034 :                 {
; 1035 :                     A = 0;

	mov	BYTE PTR _A$[ebp], 0

; 1036 :                 }
; 1037 :                 else

	jmp	SHORT $LN15@HighlightI
$LN13@HighlightI:

; 1038 :                     if (NonHighlightAction == NonHighlightInverse)

	cmp	DWORD PTR _NonHighlightAction$[ebp], 2
	jne	SHORT $LN15@HighlightI

; 1039 :                     {
; 1040 :                         R = 0xff - Src[RED];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _RED$10[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	BYTE PTR _R$[ebp], cl

; 1041 :                         G = 0xff - Src[GREEN];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _GREEN$9[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	BYTE PTR _G$[ebp], cl

; 1042 :                         B = 0xff - Src[BLUE];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _BLUE$8[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	mov	BYTE PTR _B$[ebp], cl
$LN15@HighlightI:

; 1043 :                     }
; 1044 :             }
; 1045 : 
; 1046 :             Dest[ALPHA] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _ALPHA$4[ebp]
	mov	al, BYTE PTR _A$[ebp]
	mov	BYTE PTR [edx], al

; 1047 :             Dest[RED] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _RED$10[ebp]
	mov	dl, BYTE PTR _R$[ebp]
	mov	BYTE PTR [ecx], dl

; 1048 :             Dest[GREEN] = G;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _GREEN$9[ebp]
	mov	cl, BYTE PTR _G$[ebp]
	mov	BYTE PTR [eax], cl

; 1049 :             Dest[BLUE] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _BLUE$8[ebp]
	mov	al, BYTE PTR _B$[ebp]
	mov	BYTE PTR [edx], al

; 1050 :         }

	jmp	$LN5@HighlightI
$LN6@HighlightI:

; 1051 :     }

	jmp	$LN2@HighlightI
$LN3@HighlightI:

; 1052 : 
; 1053 :     return Success;

	xor	eax, eax
$LN1@HighlightI:

; 1054 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
_HighlightImageColor@44 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_H$1 = -56						; size = 8
_S$2 = -48						; size = 8
_L$3 = -40						; size = 8
_RowOffset$4 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Dest$ = -24						; size = 4
_Src$ = -20						; size = 4
_Column$5 = -16						; size = 4
_Row$6 = -12						; size = 4
_Index$7 = -8						; size = 4
_B$8 = -3						; size = 1
_G$9 = -2						; size = 1
_R$10 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SaturationValue$ = 28					; size = 8
_AdjustSaturation@28 PROC

; 937  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 938  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@AdjustSatu

; 939  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AdjustSatu
$LN8@AdjustSatu:

; 940  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@AdjustSatu

; 941  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@AdjustSatu
$LN9@AdjustSatu:

; 942  : 
; 943  :     if (SaturationValue < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _SaturationValue$[ebp]
	jbe	SHORT $LN10@AdjustSatu

; 944  :         SaturationValue = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _SaturationValue$[ebp], xmm0
$LN10@AdjustSatu:

; 945  :     if (SaturationValue > 1.0)

	movsd	xmm0, QWORD PTR _SaturationValue$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN11@AdjustSatu

; 946  :         SaturationValue = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _SaturationValue$[ebp], xmm0
$LN11@AdjustSatu:

; 947  : 
; 948  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 949  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 950  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 951  : 
; 952  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@AdjustSatu
$LN2@AdjustSatu:
	mov	edx, DWORD PTR _Row$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$6[ebp], edx
$LN4@AdjustSatu:
	mov	eax, DWORD PTR _Row$6[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@AdjustSatu

; 953  :     {
; 954  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$6[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 955  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@AdjustSatu
$LN5@AdjustSatu:
	mov	edx, DWORD PTR _Column$5[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$5[ebp], edx
$LN7@AdjustSatu:
	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@AdjustSatu

; 956  :         {
; 957  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$5[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$7[ebp], ecx

; 958  :             Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 959  :             double H = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _H$1[ebp], xmm0

; 960  :             double S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$2[ebp], xmm0

; 961  :             double L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$3[ebp], xmm0

; 962  :             RGBtoHSL2(Src[Index + 2], Src[Index + 1], Src[Index + 0], &H, &S, &L);

	lea	edx, DWORD PTR _L$3[ebp]
	push	edx
	lea	eax, DWORD PTR _S$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _H$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	push	edx
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	_RGBtoHSL2@24

; 963  :             L = L * SaturationValue;

	movsd	xmm0, QWORD PTR _L$3[ebp]
	mulsd	xmm0, QWORD PTR _SaturationValue$[ebp]
	movsd	QWORD PTR _L$3[ebp], xmm0

; 964  :             BYTE R = 0;

	mov	BYTE PTR _R$10[ebp], 0

; 965  :             BYTE G = 0;

	mov	BYTE PTR _G$9[ebp], 0

; 966  :             BYTE B = 0;

	mov	BYTE PTR _B$8[ebp], 0

; 967  :             HSLtoRGB2(H, S, L, &R, &G, &B);

	lea	edx, DWORD PTR _B$8[ebp]
	push	edx
	lea	eax, DWORD PTR _G$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _R$10[ebp]
	push	ecx
	sub	esp, 8
	movsd	xmm0, QWORD PTR _L$3[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _S$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR _H$1[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_HSLtoRGB2@36

; 968  :             Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _R$10[ebp]
	mov	BYTE PTR [edx+2], al

; 969  :             Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _G$9[ebp]
	mov	BYTE PTR [ecx+1], dl

; 970  :             Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _B$8[ebp]
	mov	BYTE PTR [eax], cl

; 971  :         }

	jmp	$LN5@AdjustSatu
$LN6@AdjustSatu:

; 972  :     }

	jmp	$LN2@AdjustSatu
$LN3@AdjustSatu:

; 973  : 
; 974  :     return Success;

	xor	eax, eax
$LN1@AdjustSatu:

; 975  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_AdjustSaturation@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Dest$ = -12						; size = 4
_Src$ = -8						; size = 4
_Index$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_Gamma$ = 28						; size = 8
_IncludeAlpha$ = 36					; size = 4
_GammaCorrection@32 PROC

; 902  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 903  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@GammaCorre

; 904  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@GammaCorre
$LN8@GammaCorre:

; 905  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN9@GammaCorre

; 906  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@GammaCorre
$LN9@GammaCorre:

; 907  : 
; 908  :     if (Gamma < 0.0)

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _Gamma$[ebp]
	jbe	SHORT $LN10@GammaCorre

; 909  :         Gamma = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _Gamma$[ebp], xmm0
$LN10@GammaCorre:

; 910  :     if (Gamma > 1.0)

	movsd	xmm0, QWORD PTR _Gamma$[ebp]
	comisd	xmm0, QWORD PTR __real@3ff0000000000000
	jbe	SHORT $LN11@GammaCorre

; 911  :         Gamma = 1.0;

	movsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _Gamma$[ebp], xmm0
$LN11@GammaCorre:

; 912  : 
; 913  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 914  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 915  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 916  : 
; 917  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@GammaCorre
$LN2@GammaCorre:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@GammaCorre:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@GammaCorre

; 918  :     {
; 919  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 920  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@GammaCorre
$LN5@GammaCorre:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@GammaCorre:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@GammaCorre

; 921  :         {
; 922  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 923  :             if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN12@GammaCorre

; 924  :                 Dest[Index + 3] = (BYTE)(pow((double)Src[Index + 3], Gamma));

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx+3]
	cvtsi2sd xmm0, eax
	movsd	xmm1, QWORD PTR _Gamma$[ebp]
	call	__libm_sse2_pow_precise
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx+3], cl

; 925  :             else

	jmp	SHORT $LN13@GammaCorre
$LN12@GammaCorre:

; 926  :                 Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl
$LN13@GammaCorre:

; 927  :             Dest[Index + 2] = (BYTE)(pow((double)Src[Index + 2], Gamma));

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2sd xmm0, ecx
	movsd	xmm1, QWORD PTR _Gamma$[ebp]
	call	__libm_sse2_pow_precise
	cvttsd2si edx, xmm0
	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [eax+2], dl

; 928  :             Dest[Index + 1] = (BYTE)(pow((double)Src[Index + 1], Gamma));

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cvtsi2sd xmm0, edx
	movsd	xmm1, QWORD PTR _Gamma$[ebp]
	call	__libm_sse2_pow_precise
	cvttsd2si eax, xmm0
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx+1], al

; 929  :             Dest[Index + 0] = (BYTE)(pow((double)Src[Index + 0], Gamma));

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2sd xmm0, eax
	movsd	xmm1, QWORD PTR _Gamma$[ebp]
	call	__libm_sse2_pow_precise
	cvttsd2si ecx, xmm0
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx], cl

; 930  :         }

	jmp	$LN5@GammaCorre
$LN6@GammaCorre:

; 931  :     }

	jmp	$LN2@GammaCorre
$LN3@GammaCorre:

; 932  : 
; 933  :     return Success;

	xor	eax, eax
$LN1@GammaCorre:

; 934  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_GammaCorrection@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_MapPercent$1 = -40					; size = 8
_Map$ = -32						; size = 4
_RowOffset$2 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Dest$ = -20						; size = 4
_Src$ = -16						; size = 4
_Column$3 = -12						; size = 4
_Row$4 = -8						; size = 4
_Index$5 = -4						; size = 4
_Source$ = 8						; size = 4
_IlluminationMap$ = 12					; size = 4
_Width$ = 16						; size = 4
_Height$ = 20						; size = 4
_Stride$ = 24						; size = 4
_Destination$ = 28					; size = 4
_ApplyBrightnessMap@24 PROC

; 861  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 862  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@ApplyBrigh

; 863  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ApplyBrigh
$LN8@ApplyBrigh:

; 864  :     if (IlluminationMap == NULL)

	cmp	DWORD PTR _IlluminationMap$[ebp], 0
	jne	SHORT $LN9@ApplyBrigh

; 865  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ApplyBrigh
$LN9@ApplyBrigh:

; 866  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN10@ApplyBrigh

; 867  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ApplyBrigh
$LN10@ApplyBrigh:

; 868  : 
; 869  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 870  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 871  :     BYTE *Map = (BYTE *)IlluminationMap;

	mov	ecx, DWORD PTR _IlluminationMap$[ebp]
	mov	DWORD PTR _Map$[ebp], ecx

; 872  :     BYTE *Dest = (BYTE *)Destination;

	mov	edx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], edx

; 873  : 
; 874  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@ApplyBrigh
$LN2@ApplyBrigh:
	mov	eax, DWORD PTR _Row$4[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$4[ebp], eax
$LN4@ApplyBrigh:
	mov	ecx, DWORD PTR _Row$4[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jge	$LN3@ApplyBrigh

; 875  :     {
; 876  :         int RowOffset = Row * Stride;

	mov	edx, DWORD PTR _Row$4[ebp]
	imul	edx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], edx

; 877  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@ApplyBrigh
$LN5@ApplyBrigh:
	mov	eax, DWORD PTR _Column$3[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$3[ebp], eax
$LN7@ApplyBrigh:
	mov	ecx, DWORD PTR _Column$3[ebp]
	cmp	ecx, DWORD PTR _Width$[ebp]
	jge	$LN6@ApplyBrigh

; 878  :         {
; 879  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$3[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$5[ebp], edx

; 880  :             double MapPercent = (double)Map[Index + 2] / 255.0;

	mov	eax, DWORD PTR _Map$[ebp]
	add	eax, DWORD PTR _Index$5[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@406fe00000000000
	movsd	QWORD PTR _MapPercent$1[ebp], xmm0

; 881  :             Dest[Index + 2] = 255 - (BYTE)((double)Src[Index + 2] * MapPercent);

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx+2]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _MapPercent$1[ebp]
	cvttsd2si ecx, xmm0
	movzx	edx, cl
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [ecx+2], al

; 882  :             Dest[Index + 1] = 255 - (BYTE)((double)Src[Index + 1] * MapPercent);

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _MapPercent$1[ebp]
	cvttsd2si ecx, xmm0
	movzx	edx, cl
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [ecx+1], al

; 883  :             Dest[Index + 0] = 255 - (BYTE)((double)Src[Index + 0] * MapPercent);

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	movzx	eax, BYTE PTR [edx]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR _MapPercent$1[ebp]
	cvttsd2si ecx, xmm0
	movzx	edx, cl
	mov	eax, 255				; 000000ffH
	sub	eax, edx
	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [ecx], al

; 884  :         }

	jmp	$LN5@ApplyBrigh
$LN6@ApplyBrigh:

; 885  :     }

	jmp	$LN2@ApplyBrigh
$LN3@ApplyBrigh:

; 886  : 
; 887  :     return Success;

	xor	eax, eax
$LN1@ApplyBrigh:

; 888  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_ApplyBrightnessMap@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_Blue$ = -36						; size = 4
_Green$ = -32						; size = 4
_Red$ = -28						; size = 4
_RowOffset$1 = -24					; size = 4
_PixelSize$ = -20					; size = 4
_Dest$ = -16						; size = 4
_Column$2 = -12						; size = 4
_Row$3 = -8						; size = 4
_Index$4 = -4						; size = 4
_RedSource$ = 8						; size = 4
_GreenSource$ = 12					; size = 4
_BlueSource$ = 16					; size = 4
_Width$ = 20						; size = 4
_Height$ = 24						; size = 4
_Stride$ = 28						; size = 4
_Destination$ = 32					; size = 4
_AlphaValue$ = 36					; size = 1
_RGBCombine@32 PROC

; 815  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 816  :     if (RedSource == NULL)

	cmp	DWORD PTR _RedSource$[ebp], 0
	jne	SHORT $LN8@RGBCombine

; 817  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBCombine
$LN8@RGBCombine:

; 818  :     if (GreenSource == NULL)

	cmp	DWORD PTR _GreenSource$[ebp], 0
	jne	SHORT $LN9@RGBCombine

; 819  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBCombine
$LN9@RGBCombine:

; 820  :     if (BlueSource == NULL)

	cmp	DWORD PTR _BlueSource$[ebp], 0
	jne	SHORT $LN10@RGBCombine

; 821  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBCombine
$LN10@RGBCombine:

; 822  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN11@RGBCombine

; 823  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RGBCombine
$LN11@RGBCombine:

; 824  : 
; 825  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 826  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 827  :     BYTE *Red = (BYTE *)RedSource;

	mov	ecx, DWORD PTR _RedSource$[ebp]
	mov	DWORD PTR _Red$[ebp], ecx

; 828  :     BYTE *Green = (BYTE *)GreenSource;

	mov	edx, DWORD PTR _GreenSource$[ebp]
	mov	DWORD PTR _Green$[ebp], edx

; 829  :     BYTE *Blue = (BYTE *)BlueSource;

	mov	eax, DWORD PTR _BlueSource$[ebp]
	mov	DWORD PTR _Blue$[ebp], eax

; 830  : 
; 831  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@RGBCombine
$LN2@RGBCombine:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@RGBCombine:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	SHORT $LN3@RGBCombine

; 832  :     {
; 833  :         int RowOffset = Row * Stride;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 834  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@RGBCombine
$LN5@RGBCombine:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@RGBCombine:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	SHORT $LN6@RGBCombine

; 835  :         {
; 836  :             int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$2[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 837  :             Dest[Index + 3] = AlphaValue;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _AlphaValue$[ebp]
	mov	BYTE PTR [ecx+3], dl

; 838  :             Dest[Index + 2] = Red[Index + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Red$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 839  :             Dest[Index + 1] = Green[Index + 1];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Green$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 840  :             Dest[Index + 0] = Blue[Index + 0];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Blue$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 841  :         }

	jmp	SHORT $LN5@RGBCombine
$LN6@RGBCombine:

; 842  :     }

	jmp	$LN2@RGBCombine
$LN3@RGBCombine:

; 843  : 
; 844  :     return Success;

	xor	eax, eax
$LN1@RGBCombine:

; 845  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_RGBCombine@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_L$1 = -84						; size = 8
_S$2 = -76						; size = 8
_H$3 = -68						; size = 8
_RowOffset$4 = -60					; size = 4
_PixelSize$ = -56					; size = 4
tv179 = -52						; size = 4
tv138 = -48						; size = 4
tv131 = -44						; size = 4
tv92 = -40						; size = 4
_Src$ = -36						; size = 4
_Index$5 = -32						; size = 4
_Column$6 = -28						; size = 4
_Row$7 = -24						; size = 4
_BLUE$8 = -20						; size = 4
_GREEN$9 = -16						; size = 4
_RED$10 = -12						; size = 4
_Dest$ = -8						; size = 4
_Gray$11 = -4						; size = 1
_FinalH$12 = -3						; size = 1
_FinalS$13 = -2						; size = 1
_FinalL$14 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SelectHue$ = 28					; size = 4
_SelectSaturation$ = 32					; size = 4
_SelectLuminance$ = 36					; size = 4
_AsGray$ = 40						; size = 1
_ChannelOrder$ = 44					; size = 4
_SelectHSLChannels@40 PROC

; 708  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 709  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN10@SelectHSLC

; 710  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@SelectHSLC
$LN10@SelectHSLC:

; 711  : 
; 712  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 713  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 714  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 715  : 
; 716  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$7[ebp], 0
	jmp	SHORT $LN4@SelectHSLC
$LN2@SelectHSLC:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN4@SelectHSLC:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@SelectHSLC

; 717  :     {
; 718  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], ecx

; 719  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$6[ebp], 0
	jmp	SHORT $LN7@SelectHSLC
$LN5@SelectHSLC:
	mov	edx, DWORD PTR _Column$6[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$6[ebp], edx
$LN7@SelectHSLC:
	mov	eax, DWORD PTR _Column$6[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@SelectHSLC

; 720  :         {
; 721  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$6[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$5[ebp], ecx

; 722  :             int RED = Index + 2;

	mov	edx, DWORD PTR _Index$5[ebp]
	add	edx, 2
	mov	DWORD PTR _RED$10[ebp], edx

; 723  :             int GREEN = Index + 1;

	mov	eax, DWORD PTR _Index$5[ebp]
	add	eax, 1
	mov	DWORD PTR _GREEN$9[ebp], eax

; 724  :             int BLUE = Index + 0;

	mov	ecx, DWORD PTR _Index$5[ebp]
	mov	DWORD PTR _BLUE$8[ebp], ecx

; 725  :             double H = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _H$3[ebp], xmm0

; 726  :             double S = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _S$2[ebp], xmm0

; 727  :             double L = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _L$1[ebp], xmm0

; 728  :             RGBtoHSL2(Src[RED], Src[GREEN], Src[BLUE], &H, &S, &L);

	lea	edx, DWORD PTR _L$1[ebp]
	push	edx
	lea	eax, DWORD PTR _S$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _H$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _BLUE$8[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _GREEN$9[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _RED$10[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	_RGBtoHSL2@24

; 729  :             BYTE FinalH = SelectHue ? (BYTE)((H / 360.0) * 255.0) : 0;

	cmp	DWORD PTR _SelectHue$[ebp], 0
	je	SHORT $LN27@SelectHSLC
	movsd	xmm0, QWORD PTR _H$3[ebp]
	divsd	xmm0, QWORD PTR __real@4076800000000000
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si edx, xmm0
	movzx	eax, dl
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN28@SelectHSLC
$LN27@SelectHSLC:
	mov	DWORD PTR tv92[ebp], 0
$LN28@SelectHSLC:
	mov	cl, BYTE PTR tv92[ebp]
	mov	BYTE PTR _FinalH$12[ebp], cl

; 730  :             BYTE FinalS = SelectSaturation ? (BYTE)(S * 255.0) : 0;

	cmp	DWORD PTR _SelectSaturation$[ebp], 0
	je	SHORT $LN29@SelectHSLC
	movsd	xmm0, QWORD PTR _S$2[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si edx, xmm0
	movzx	eax, dl
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN30@SelectHSLC
$LN29@SelectHSLC:
	mov	DWORD PTR tv131[ebp], 0
$LN30@SelectHSLC:
	mov	cl, BYTE PTR tv131[ebp]
	mov	BYTE PTR _FinalS$13[ebp], cl

; 731  :             BYTE FinalL = SelectLuminance ? (BYTE)(L * 255.0) : 0;

	cmp	DWORD PTR _SelectLuminance$[ebp], 0
	je	SHORT $LN31@SelectHSLC
	movsd	xmm0, QWORD PTR _L$1[ebp]
	mulsd	xmm0, QWORD PTR __real@406fe00000000000
	cvttsd2si edx, xmm0
	movzx	eax, dl
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $LN32@SelectHSLC
$LN31@SelectHSLC:
	mov	DWORD PTR tv138[ebp], 0
$LN32@SelectHSLC:
	mov	cl, BYTE PTR tv138[ebp]
	mov	BYTE PTR _FinalL$14[ebp], cl

; 732  :             Dest[Index + 3] = 0xff;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$5[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH

; 733  :             if (SelectHue)

	cmp	DWORD PTR _SelectHue$[ebp], 0
	je	SHORT $LN11@SelectHSLC

; 734  :                 Dest[RED] = FinalH;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _RED$10[ebp]
	mov	cl, BYTE PTR _FinalH$12[ebp]
	mov	BYTE PTR [eax], cl

; 735  :             else

	jmp	SHORT $LN12@SelectHSLC
$LN11@SelectHSLC:

; 736  :                 Dest[RED] = 0;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _RED$10[ebp]
	mov	BYTE PTR [edx], 0
$LN12@SelectHSLC:

; 737  :             if (SelectSaturation)

	cmp	DWORD PTR _SelectSaturation$[ebp], 0
	je	SHORT $LN13@SelectHSLC

; 738  :                 Dest[GREEN] = FinalS;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _GREEN$9[ebp]
	mov	cl, BYTE PTR _FinalS$13[ebp]
	mov	BYTE PTR [eax], cl

; 739  :             else

	jmp	SHORT $LN14@SelectHSLC
$LN13@SelectHSLC:

; 740  :                 Dest[GREEN] = 0;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _GREEN$9[ebp]
	mov	BYTE PTR [edx], 0
$LN14@SelectHSLC:

; 741  :             if (SelectLuminance)

	cmp	DWORD PTR _SelectLuminance$[ebp], 0
	je	SHORT $LN15@SelectHSLC

; 742  :                 Dest[BLUE] = FinalL;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _BLUE$8[ebp]
	mov	cl, BYTE PTR _FinalL$14[ebp]
	mov	BYTE PTR [eax], cl

; 743  :             else

	jmp	SHORT $LN16@SelectHSLC
$LN15@SelectHSLC:

; 744  :                 Dest[BLUE] = 0;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _BLUE$8[ebp]
	mov	BYTE PTR [edx], 0
$LN16@SelectHSLC:

; 745  :             if (AsGray)

	movzx	eax, BYTE PTR _AsGray$[ebp]
	test	eax, eax
	je	SHORT $LN17@SelectHSLC

; 746  :             {
; 747  :                 BYTE Gray = (Dest[RED] + Dest[GREEN] + Dest[BLUE]) / 3;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _RED$10[ebp]
	movzx	eax, BYTE PTR [ecx]
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _GREEN$9[ebp]
	movzx	ecx, BYTE PTR [edx]
	add	eax, ecx
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _BLUE$8[ebp]
	movzx	ecx, BYTE PTR [edx]
	add	eax, ecx
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	BYTE PTR _Gray$11[ebp], al

; 748  :                 Dest[RED] = Gray;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _RED$10[ebp]
	mov	al, BYTE PTR _Gray$11[ebp]
	mov	BYTE PTR [edx], al

; 749  :                 Dest[GREEN] = Gray;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _GREEN$9[ebp]
	mov	dl, BYTE PTR _Gray$11[ebp]
	mov	BYTE PTR [ecx], dl

; 750  :                 Dest[BLUE] = Gray;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _BLUE$8[ebp]
	mov	cl, BYTE PTR _Gray$11[ebp]
	mov	BYTE PTR [eax], cl

; 751  :             }
; 752  :             else

	jmp	$LN8@SelectHSLC
$LN17@SelectHSLC:

; 753  :             {
; 754  :                 switch (ChannelOrder)

	mov	edx, DWORD PTR _ChannelOrder$[ebp]
	mov	DWORD PTR tv179[ebp], edx
	cmp	DWORD PTR tv179[ebp], 5
	ja	$LN25@SelectHSLC
	mov	eax, DWORD PTR tv179[ebp]
	jmp	DWORD PTR $LN33@SelectHSLC[eax*4]
$LN19@SelectHSLC:

; 755  :                 {
; 756  :                 case 0: //HSL
; 757  :                     Dest[RED] = FinalH;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _RED$10[ebp]
	mov	dl, BYTE PTR _FinalH$12[ebp]
	mov	BYTE PTR [ecx], dl

; 758  :                     Dest[GREEN] = FinalS;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _GREEN$9[ebp]
	mov	cl, BYTE PTR _FinalS$13[ebp]
	mov	BYTE PTR [eax], cl

; 759  :                     Dest[BLUE] = FinalL;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _BLUE$8[ebp]
	mov	al, BYTE PTR _FinalL$14[ebp]
	mov	BYTE PTR [edx], al

; 760  :                     break;

	jmp	$LN8@SelectHSLC
$LN20@SelectHSLC:

; 761  : 
; 762  :                 case 1: //HLS
; 763  :                     Dest[RED] = FinalH;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _RED$10[ebp]
	mov	dl, BYTE PTR _FinalH$12[ebp]
	mov	BYTE PTR [ecx], dl

; 764  :                     Dest[GREEN] = FinalL;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _GREEN$9[ebp]
	mov	cl, BYTE PTR _FinalL$14[ebp]
	mov	BYTE PTR [eax], cl

; 765  :                     Dest[BLUE] = FinalS;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _BLUE$8[ebp]
	mov	al, BYTE PTR _FinalS$13[ebp]
	mov	BYTE PTR [edx], al

; 766  :                     break;

	jmp	$LN8@SelectHSLC
$LN21@SelectHSLC:

; 767  : 
; 768  :                 case 2: //SHL
; 769  :                     Dest[RED] = FinalS;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _RED$10[ebp]
	mov	dl, BYTE PTR _FinalS$13[ebp]
	mov	BYTE PTR [ecx], dl

; 770  :                     Dest[GREEN] = FinalH;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _GREEN$9[ebp]
	mov	cl, BYTE PTR _FinalH$12[ebp]
	mov	BYTE PTR [eax], cl

; 771  :                     Dest[BLUE] = FinalL;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _BLUE$8[ebp]
	mov	al, BYTE PTR _FinalL$14[ebp]
	mov	BYTE PTR [edx], al

; 772  :                     break;

	jmp	SHORT $LN8@SelectHSLC
$LN22@SelectHSLC:

; 773  : 
; 774  :                 case 3: //SLH
; 775  :                     Dest[RED] = FinalS;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _RED$10[ebp]
	mov	dl, BYTE PTR _FinalS$13[ebp]
	mov	BYTE PTR [ecx], dl

; 776  :                     Dest[GREEN] = FinalL;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _GREEN$9[ebp]
	mov	cl, BYTE PTR _FinalL$14[ebp]
	mov	BYTE PTR [eax], cl

; 777  :                     Dest[BLUE] = FinalH;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _BLUE$8[ebp]
	mov	al, BYTE PTR _FinalH$12[ebp]
	mov	BYTE PTR [edx], al

; 778  :                     break;

	jmp	SHORT $LN8@SelectHSLC
$LN23@SelectHSLC:

; 779  : 
; 780  :                 case 4: //LHS
; 781  :                     Dest[RED] = FinalL;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _RED$10[ebp]
	mov	dl, BYTE PTR _FinalL$14[ebp]
	mov	BYTE PTR [ecx], dl

; 782  :                     Dest[GREEN] = FinalH;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _GREEN$9[ebp]
	mov	cl, BYTE PTR _FinalH$12[ebp]
	mov	BYTE PTR [eax], cl

; 783  :                     Dest[BLUE] = FinalS;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _BLUE$8[ebp]
	mov	al, BYTE PTR _FinalS$13[ebp]
	mov	BYTE PTR [edx], al

; 784  :                     break;

	jmp	SHORT $LN8@SelectHSLC
$LN24@SelectHSLC:

; 785  : 
; 786  :                 case 5: //LSH
; 787  :                     Dest[RED] = FinalL;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _RED$10[ebp]
	mov	dl, BYTE PTR _FinalL$14[ebp]
	mov	BYTE PTR [ecx], dl

; 788  :                     Dest[GREEN] = FinalS;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _GREEN$9[ebp]
	mov	cl, BYTE PTR _FinalS$13[ebp]
	mov	BYTE PTR [eax], cl

; 789  :                     Dest[BLUE] = FinalH;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _BLUE$8[ebp]
	mov	al, BYTE PTR _FinalH$12[ebp]
	mov	BYTE PTR [edx], al

; 790  :                     break;

	jmp	SHORT $LN8@SelectHSLC
$LN25@SelectHSLC:

; 791  : 
; 792  :                 default:
; 793  :                     return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@SelectHSLC
$LN8@SelectHSLC:

; 794  :                 }
; 795  :             }
; 796  :         }

	jmp	$LN5@SelectHSLC
$LN6@SelectHSLC:

; 797  :     }

	jmp	$LN2@SelectHSLC
$LN3@SelectHSLC:

; 798  : 
; 799  :     return Success;

	xor	eax, eax
$LN1@SelectHSLC:

; 800  : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
$LN33@SelectHSLC:
	DD	$LN19@SelectHSLC
	DD	$LN20@SelectHSLC
	DD	$LN21@SelectHSLC
	DD	$LN22@SelectHSLC
	DD	$LN23@SelectHSLC
	DD	$LN24@SelectHSLC
_SelectHSLChannels@40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Src$ = -20						; size = 4
_Column$2 = -16						; size = 4
_Row$3 = -12						; size = 4
_Dest$ = -8						; size = 4
_Index$4 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SelectRed$ = 28					; size = 4
_SelectGreen$ = 32					; size = 4
_SelectBlue$ = 36					; size = 4
_AsGray$ = 40						; size = 4
_SelectRGBChannels@36 PROC

; 642  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 643  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN8@SelectRGBC

; 644  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@SelectRGBC
$LN8@SelectRGBC:

; 645  : 
; 646  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 647  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 648  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 649  : 
; 650  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@SelectRGBC
$LN2@SelectRGBC:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@SelectRGBC:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@SelectRGBC

; 651  :     {
; 652  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 653  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@SelectRGBC
$LN5@SelectRGBC:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@SelectRGBC:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@SelectRGBC

; 654  :         {
; 655  :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 656  :             Dest[Index + 3] = 0xff;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx+3], 255			; 000000ffH

; 657  :             if (SelectRed)

	cmp	DWORD PTR _SelectRed$[ebp], 0
	je	SHORT $LN9@SelectRGBC

; 658  :                 Dest[Index + 2] = Src[Index + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 659  :             else

	jmp	SHORT $LN10@SelectRGBC
$LN9@SelectRGBC:

; 660  :                 Dest[Index + 2] = 0;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [eax+2], 0
$LN10@SelectRGBC:

; 661  :             if (SelectGreen)

	cmp	DWORD PTR _SelectGreen$[ebp], 0
	je	SHORT $LN11@SelectRGBC

; 662  :                 Dest[Index + 1] = Src[Index + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 663  :             else

	jmp	SHORT $LN12@SelectRGBC
$LN11@SelectRGBC:

; 664  :                 Dest[Index + 1] = 0;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx+1], 0
$LN12@SelectRGBC:

; 665  :             if (SelectBlue)

	cmp	DWORD PTR _SelectBlue$[ebp], 0
	je	SHORT $LN13@SelectRGBC

; 666  :                 Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 667  :             else

	jmp	SHORT $LN14@SelectRGBC
$LN13@SelectRGBC:

; 668  :                 Dest[Index + 0] = 0;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx], 0
$LN14@SelectRGBC:

; 669  :             if (((int)SelectRed + (int)SelectGreen + (int)SelectBlue) > 1)

	mov	eax, DWORD PTR _SelectRed$[ebp]
	add	eax, DWORD PTR _SelectGreen$[ebp]
	add	eax, DWORD PTR _SelectBlue$[ebp]
	cmp	eax, 1
	jle	SHORT $LN15@SelectRGBC

; 670  :                 continue;

	jmp	$LN5@SelectRGBC
$LN15@SelectRGBC:

; 671  :             if (AsGray)

	cmp	DWORD PTR _AsGray$[ebp], 0
	je	SHORT $LN16@SelectRGBC

; 672  :             {
; 673  :                 if (SelectRed)

	cmp	DWORD PTR _SelectRed$[ebp], 0
	je	SHORT $LN17@SelectRGBC

; 674  :                 {
; 675  :                     Dest[Index + 1] = Dest[Index + 2];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+1], al

; 676  :                     Dest[Index + 0] = Dest[Index + 2];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx], al
$LN17@SelectRGBC:

; 677  :                 }
; 678  :                 if (SelectGreen)

	cmp	DWORD PTR _SelectGreen$[ebp], 0
	je	SHORT $LN18@SelectRGBC

; 679  :                 {
; 680  :                     Dest[Index + 2] = Dest[Index + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+2], al

; 681  :                     Dest[Index + 0] = Dest[Index + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx], al
$LN18@SelectRGBC:

; 682  :                 }
; 683  :                 if (SelectBlue)

	cmp	DWORD PTR _SelectBlue$[ebp], 0
	je	SHORT $LN16@SelectRGBC

; 684  :                 {
; 685  :                     Dest[Index + 2] = Dest[Index + 0];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+2], al

; 686  :                     Dest[Index + 1] = Dest[Index + 0];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+1], al
$LN16@SelectRGBC:

; 687  :                 }
; 688  :             }
; 689  :         }

	jmp	$LN5@SelectRGBC
$LN6@SelectRGBC:

; 690  :     }

	jmp	$LN2@SelectRGBC
$LN3@SelectRGBC:

; 691  : 
; 692  :     return Success;

	xor	eax, eax
$LN1@SelectRGBC:

; 693  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_SelectRGBChannels@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_PixLuminance$1 = -76					; size = 8
tv91 = -68						; size = 4
_OptionsPresent$ = -64					; size = 4
_RowOffset$2 = -60					; size = 4
_PixelSize$ = -56					; size = 4
_DoSwap$3 = -52						; size = 4
tv134 = -48						; size = 4
tv130 = -44						; size = 4
tv69 = -40						; size = 4
_Options$ = -36						; size = 4
tv137 = -32						; size = 4
_ThresholdMet$4 = -28					; size = 4
_Src$ = -24						; size = 4
_Column$5 = -20						; size = 4
_Row$6 = -16						; size = 4
_Dest$ = -12						; size = 4
_Index$7 = -8						; size = 4
_A$8 = -4						; size = 1
_B$9 = -3						; size = 1
_G$10 = -2						; size = 1
_R$11 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SwapOrder$ = 28					; size = 4
_ExecOptions$ = 32					; size = 4
_ChannelSwap2@28 PROC

; 421  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 422  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN12@ChannelSwa

; 423  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelSwa
$LN12@ChannelSwa:

; 424  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN13@ChannelSwa

; 425  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelSwa
$LN13@ChannelSwa:

; 426  :     if ((SwapOrder < SortRBG) || (SwapOrder > SortBGR))

	cmp	DWORD PTR _SwapOrder$[ebp], 1
	jl	SHORT $LN15@ChannelSwa
	cmp	DWORD PTR _SwapOrder$[ebp], 5
	jle	SHORT $LN14@ChannelSwa
$LN15@ChannelSwa:

; 427  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ChannelSwa
$LN14@ChannelSwa:

; 428  :     BOOL OptionsPresent = ExecOptions == NULL ? FALSE : TRUE;

	cmp	DWORD PTR _ExecOptions$[ebp], 0
	jne	SHORT $LN29@ChannelSwa
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN30@ChannelSwa
$LN29@ChannelSwa:
	mov	DWORD PTR tv69[ebp], 1
$LN30@ChannelSwa:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _OptionsPresent$[ebp], eax

; 429  :     ExecutionOptions *Options = (ExecutionOptions *)ExecOptions;

	mov	ecx, DWORD PTR _ExecOptions$[ebp]
	mov	DWORD PTR _Options$[ebp], ecx

; 430  : 
; 431  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 432  :     BYTE *Src = (BYTE *)Source;

	mov	edx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], edx

; 433  :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 434  : 
; 435  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@ChannelSwa
$LN2@ChannelSwa:
	mov	ecx, DWORD PTR _Row$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$6[ebp], ecx
$LN4@ChannelSwa:
	mov	edx, DWORD PTR _Row$6[ebp]
	cmp	edx, DWORD PTR _Height$[ebp]
	jge	$LN3@ChannelSwa

; 436  :     {
; 437  :         int RowOffset = (Row * Stride);

	mov	eax, DWORD PTR _Row$6[ebp]
	imul	eax, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], eax

; 438  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@ChannelSwa
$LN5@ChannelSwa:
	mov	ecx, DWORD PTR _Column$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$5[ebp], ecx
$LN7@ChannelSwa:
	mov	edx, DWORD PTR _Column$5[ebp]
	cmp	edx, DWORD PTR _Width$[ebp]
	jge	$LN6@ChannelSwa

; 439  :         {
; 440  :             int Index = (Column * PixelSize) + RowOffset;

	mov	eax, DWORD PTR _Column$5[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$7[ebp], eax

; 441  :             BYTE A = Src[Index + 3];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR _A$8[ebp], dl

; 442  :             BYTE R = Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _R$11[ebp], cl

; 443  :             BYTE G = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _G$10[ebp], al

; 444  :             BYTE B = Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _B$9[ebp], dl

; 445  :             BOOL DoSwap = true;

	mov	DWORD PTR _DoSwap$3[ebp], 1

; 446  :             if (OptionsPresent)

	cmp	DWORD PTR _OptionsPresent$[ebp], 0
	je	$LN8@ChannelSwa

; 447  :             {
; 448  :                 BOOL ThresholdMet = TRUE;

	mov	DWORD PTR _ThresholdMet$4[ebp], 1

; 449  :                 double PixLuminance = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR _PixLuminance$1[ebp], xmm0

; 450  :                 switch (Options->ExecOption)

	mov	eax, DWORD PTR _Options$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv91[ebp], ecx
	cmp	DWORD PTR tv91[ebp], 0
	je	SHORT $LN17@ChannelSwa
	jmp	SHORT $LN19@ChannelSwa
$LN17@ChannelSwa:

; 451  :                 {
; 452  :                 case ExecOpLuminance:
; 453  :                     PixLuminance = PixelLuminance(R, G, B);

	movzx	edx, BYTE PTR _B$9[ebp]
	push	edx
	movzx	eax, BYTE PTR _G$10[ebp]
	push	eax
	movzx	ecx, BYTE PTR _R$11[ebp]
	push	ecx
	call	?PixelLuminance@@YGNEEE@Z		; PixelLuminance
	fstp	QWORD PTR _PixLuminance$1[ebp]

; 454  :                     ThresholdMet = PixLuminance >= Options->LuminanceThreshold;

	mov	edx, DWORD PTR _Options$[ebp]
	movsd	xmm0, QWORD PTR _PixLuminance$1[ebp]
	comisd	xmm0, QWORD PTR [edx+8]
	jb	SHORT $LN31@ChannelSwa
	mov	DWORD PTR tv130[ebp], 1
	jmp	SHORT $LN32@ChannelSwa
$LN31@ChannelSwa:
	mov	DWORD PTR tv130[ebp], 0
$LN32@ChannelSwa:
	mov	eax, DWORD PTR tv130[ebp]
	mov	DWORD PTR _ThresholdMet$4[ebp], eax

; 455  :                     if (Options->InvertLuminanceThreshold)

	mov	ecx, DWORD PTR _Options$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN18@ChannelSwa

; 456  :                         ThresholdMet = !ThresholdMet;

	cmp	DWORD PTR _ThresholdMet$4[ebp], 0
	jne	SHORT $LN33@ChannelSwa
	mov	DWORD PTR tv134[ebp], 1
	jmp	SHORT $LN34@ChannelSwa
$LN33@ChannelSwa:
	mov	DWORD PTR tv134[ebp], 0
$LN34@ChannelSwa:
	mov	edx, DWORD PTR tv134[ebp]
	mov	DWORD PTR _ThresholdMet$4[ebp], edx
$LN18@ChannelSwa:

; 457  :                     DoSwap = ThresholdMet;

	mov	eax, DWORD PTR _ThresholdMet$4[ebp]
	mov	DWORD PTR _DoSwap$3[ebp], eax

; 458  :                     break;

	jmp	SHORT $LN8@ChannelSwa
$LN19@ChannelSwa:

; 459  : 
; 460  :                 default:
; 461  :                     return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ChannelSwa
$LN8@ChannelSwa:

; 462  :                 }
; 463  :             }
; 464  : 
; 465  :             if (DoSwap)

	cmp	DWORD PTR _DoSwap$3[ebp], 0
	je	$LN20@ChannelSwa

; 466  :             {
; 467  :                 switch (SwapOrder)

	mov	ecx, DWORD PTR _SwapOrder$[ebp]
	mov	DWORD PTR tv137[ebp], ecx
	mov	edx, DWORD PTR tv137[ebp]
	sub	edx, 1
	mov	DWORD PTR tv137[ebp], edx
	cmp	DWORD PTR tv137[ebp], 4
	ja	$LN27@ChannelSwa
	mov	eax, DWORD PTR tv137[ebp]
	jmp	DWORD PTR $LN35@ChannelSwa[eax*4]
$LN22@ChannelSwa:

; 468  :                 {
; 469  :                 case SortRBG:
; 470  :                     Dest[Index + 3] = A;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 471  :                     Dest[Index + 2] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [eax+2], cl

; 472  :                     Dest[Index + 1] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [edx+1], al

; 473  :                     Dest[Index + 0] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [ecx], dl

; 474  :                     break;

	jmp	$LN10@ChannelSwa
$LN23@ChannelSwa:

; 475  : 
; 476  :                 case SortGRB:
; 477  :                     Dest[Index + 3] = A;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [eax+3], cl

; 478  :                     Dest[Index + 2] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [edx+2], al

; 479  :                     Dest[Index + 1] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [ecx+1], dl

; 480  :                     Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [eax], cl

; 481  :                     break;

	jmp	$LN10@ChannelSwa
$LN24@ChannelSwa:

; 482  : 
; 483  :                 case SortGBR:
; 484  :                     Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [edx+3], al

; 485  :                     Dest[Index + 2] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [ecx+2], dl

; 486  :                     Dest[Index + 1] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [eax+1], cl

; 487  :                     Dest[Index + 0] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [edx], al

; 488  :                     break;

	jmp	SHORT $LN10@ChannelSwa
$LN25@ChannelSwa:

; 489  : 
; 490  :                 case SortBRG:
; 491  :                     Dest[Index + 3] = A;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [ecx+3], dl

; 492  :                     Dest[Index + 2] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [eax+2], cl

; 493  :                     Dest[Index + 1] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [edx+1], al

; 494  :                     Dest[Index + 0] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [ecx], dl

; 495  :                     break;

	jmp	SHORT $LN10@ChannelSwa
$LN26@ChannelSwa:

; 496  : 
; 497  :                 case SortBGR:
; 498  :                     Dest[Index + 3] = A;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [eax+3], cl

; 499  :                     Dest[Index + 2] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [edx+2], al

; 500  :                     Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [ecx+1], dl

; 501  :                     Dest[Index + 0] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [eax], cl

; 502  :                     break;

	jmp	SHORT $LN10@ChannelSwa
$LN27@ChannelSwa:

; 503  : 
; 504  :                 default:
; 505  :                     return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@ChannelSwa
$LN10@ChannelSwa:

; 506  :                 }
; 507  :             }
; 508  :             else

	jmp	SHORT $LN21@ChannelSwa
$LN20@ChannelSwa:

; 509  :             {
; 510  :                 Dest[Index + 3] = A;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _A$8[ebp]
	mov	BYTE PTR [edx+3], al

; 511  :                 Dest[Index + 2] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$7[ebp]
	mov	dl, BYTE PTR _R$11[ebp]
	mov	BYTE PTR [ecx+2], dl

; 512  :                 Dest[Index + 1] = G;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$7[ebp]
	mov	cl, BYTE PTR _G$10[ebp]
	mov	BYTE PTR [eax+1], cl

; 513  :                 Dest[Index + 0] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$7[ebp]
	mov	al, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [edx], al
$LN21@ChannelSwa:

; 514  :             }
; 515  :         }

	jmp	$LN5@ChannelSwa
$LN6@ChannelSwa:

; 516  :     }

	jmp	$LN2@ChannelSwa
$LN3@ChannelSwa:

; 517  :     return Success;

	xor	eax, eax
$LN1@ChannelSwa:

; 518  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN35@ChannelSwa:
	DD	$LN22@ChannelSwa
	DD	$LN23@ChannelSwa
	DD	$LN24@ChannelSwa
	DD	$LN25@ChannelSwa
	DD	$LN26@ChannelSwa
_ChannelSwap2@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_Target$ = 8						; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_MigrateBy$ = 24					; size = 4
_IgnoreAlpha$ = 28					; size = 1
_PixelMigrate@24 PROC

; 140  : {

	push	ebp
	mov	ebp, esp

; 141  :     return Success;

	xor	eax, eax

; 142  : }

	pop	ebp
	ret	24					; 00000018H
_PixelMigrate@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Index$4 = -12						; size = 4
_Buffer$ = -8						; size = 4
_Alpha$5 = -4						; size = 1
_Blue$6 = -3						; size = 1
_Green$7 = -2						; size = 1
_Red$8 = -1						; size = 1
_Target$ = 8						; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_Seed$ = 24						; size = 4
_IncludeAlpha$ = 28					; size = 4
_RandomChannelSwap@24 PROC

; 591  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 592  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN8@RandomChan

; 593  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@RandomChan
$LN8@RandomChan:

; 594  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 595  :     BYTE *Buffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 596  :     srand(Seed);

	mov	ecx, DWORD PTR _Seed$[ebp]
	push	ecx
	call	DWORD PTR __imp__srand
	add	esp, 4

; 597  : 
; 598  :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@RandomChan
$LN2@RandomChan:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@RandomChan:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _BufferHeight$[ebp]
	jge	$LN3@RandomChan

; 599  :     {
; 600  :         int RowOffset = Row * BufferStride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 601  :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@RandomChan
$LN5@RandomChan:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@RandomChan:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _BufferWidth$[ebp]
	jge	$LN6@RandomChan

; 602  :         {
; 603  :             int Index = RowOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 604  :             BYTE Alpha = Buffer[Index + 3];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _Alpha$5[ebp], al

; 605  :             BYTE Red = Buffer[Index + 2];

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _Red$8[ebp], dl

; 606  :             BYTE Green = Buffer[Index + 1];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _Green$7[ebp], cl

; 607  :             BYTE Blue = Buffer[Index + 0];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _Blue$6[ebp], al

; 608  :             if (IncludeAlpha)

	cmp	DWORD PTR _IncludeAlpha$[ebp], 0
	je	SHORT $LN9@RandomChan

; 609  :             {
; 610  :                 Random4(&Alpha, &Red, &Green, &Blue);

	lea	ecx, DWORD PTR _Blue$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _Green$7[ebp]
	push	edx
	lea	eax, DWORD PTR _Red$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _Alpha$5[ebp]
	push	ecx
	call	?Random4@@YGXPAE000@Z			; Random4

; 611  :                 Buffer[Index + 3] = Alpha;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Alpha$5[ebp]
	mov	BYTE PTR [edx+3], al

; 612  :                 Buffer[Index + 2] = Red;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _Red$8[ebp]
	mov	BYTE PTR [ecx+2], dl

; 613  :                 Buffer[Index + 1] = Green;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Green$7[ebp]
	mov	BYTE PTR [eax+1], cl

; 614  :                 Buffer[Index + 0] = Blue;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Blue$6[ebp]
	mov	BYTE PTR [edx], al

; 615  :             }
; 616  :             else

	jmp	SHORT $LN10@RandomChan
$LN9@RandomChan:

; 617  :             {
; 618  :                 Random3(&Red, &Green, &Blue);

	lea	ecx, DWORD PTR _Blue$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _Green$7[ebp]
	push	edx
	lea	eax, DWORD PTR _Red$8[ebp]
	push	eax
	call	?Random3@@YGXPAE00@Z			; Random3

; 619  :                 Buffer[Index + 2] = Red;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _Red$8[ebp]
	mov	BYTE PTR [ecx+2], dl

; 620  :                 Buffer[Index + 1] = Green;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Green$7[ebp]
	mov	BYTE PTR [eax+1], cl

; 621  :                 Buffer[Index + 0] = Blue;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Blue$6[ebp]
	mov	BYTE PTR [edx], al
$LN10@RandomChan:

; 622  :             }
; 623  :         }

	jmp	$LN5@RandomChan
$LN6@RandomChan:

; 624  :     }

	jmp	$LN2@RandomChan
$LN3@RandomChan:

; 625  : 
; 626  :     return Success;

	xor	eax, eax
$LN1@RandomChan:

; 627  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_RandomChannelSwap@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_BufferSize$ = -48					; size = 4
_RowOffset$1 = -44					; size = 4
_PixelSize$ = -40					; size = 4
_PixelIndex$ = -36					; size = 4
_Column$2 = -32						; size = 4
_Row$3 = -28						; size = 4
_Index$4 = -24						; size = 4
_Buffer$ = -20						; size = 4
_Br$5 = -16						; size = 1
_Gr$6 = -15						; size = 1
_Rr$7 = -14						; size = 1
_Ar$8 = -13						; size = 1
_Bs$ = -12						; size = 1
_B$9 = -11						; size = 1
_Gs$ = -10						; size = 1
_G$10 = -9						; size = 1
_Rs$ = -8						; size = 1
_R$11 = -7						; size = 1
_As$ = -6						; size = 1
_A$12 = -5						; size = 1
_Bd$13 = -4						; size = 1
_Gd$14 = -3						; size = 1
_Rd$15 = -2						; size = 1
_Ad$16 = -1						; size = 1
_Target$ = 8						; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_MigrateBy$ = 24					; size = 4
_MigrateAlpha$ = 28					; size = 4
_MigrateRed$ = 32					; size = 4
_MigrateGreen$ = 36					; size = 4
_MigrateBlue$ = 40					; size = 4
_ChannelMigrate@36 PROC

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	ebx

; 66   :     if (MigrateBy == 0)

	cmp	DWORD PTR _MigrateBy$[ebp], 0
	jne	SHORT $LN8@ChannelMig

; 67   :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@ChannelMig
$LN8@ChannelMig:

; 68   :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN9@ChannelMig

; 69   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelMig
$LN9@ChannelMig:

; 70   :     if (!MigrateAlpha && !MigrateRed && !MigrateGreen && !MigrateBlue)

	cmp	DWORD PTR _MigrateAlpha$[ebp], 0
	jne	SHORT $LN10@ChannelMig
	cmp	DWORD PTR _MigrateRed$[ebp], 0
	jne	SHORT $LN10@ChannelMig
	cmp	DWORD PTR _MigrateGreen$[ebp], 0
	jne	SHORT $LN10@ChannelMig
	cmp	DWORD PTR _MigrateBlue$[ebp], 0
	jne	SHORT $LN10@ChannelMig

; 71   :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@ChannelMig
$LN10@ChannelMig:

; 72   : 
; 73   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 74   :     BYTE *Buffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 75   :     UINT32 BufferSize = BufferWidth * BufferHeight;

	mov	ecx, DWORD PTR _BufferWidth$[ebp]
	imul	ecx, DWORD PTR _BufferHeight$[ebp]
	mov	DWORD PTR _BufferSize$[ebp], ecx

; 76   :     UINT32 PixelIndex = 0;

	mov	DWORD PTR _PixelIndex$[ebp], 0

; 77   : 
; 78   :     BYTE As = 0;

	mov	BYTE PTR _As$[ebp], 0

; 79   :     BYTE Rs = 0;

	mov	BYTE PTR _Rs$[ebp], 0

; 80   :     BYTE Gs = 0;

	mov	BYTE PTR _Gs$[ebp], 0

; 81   :     BYTE Bs = 0;

	mov	BYTE PTR _Bs$[ebp], 0

; 82   : 
; 83   :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ChannelMig
$LN2@ChannelMig:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@ChannelMig:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _BufferHeight$[ebp]
	jge	$LN3@ChannelMig

; 84   :     {
; 85   :         int RowOffset = Row * BufferStride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 86   :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ChannelMig
$LN5@ChannelMig:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@ChannelMig:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _BufferWidth$[ebp]
	jge	$LN6@ChannelMig

; 87   :         {
; 88   :             PixelIndex++;

	mov	ecx, DWORD PTR _PixelIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _PixelIndex$[ebp], ecx

; 89   :             int Index = RowOffset + (Column * PixelSize);

	mov	edx, DWORD PTR _Column$2[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], edx

; 90   :             if (MigrateAlpha)

	cmp	DWORD PTR _MigrateAlpha$[ebp], 0
	je	SHORT $LN11@ChannelMig

; 91   :             {
; 92   :                 BYTE A = Buffer[Index + 3];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR _A$12[ebp], cl

; 93   :                 BYTE Ar = A & BMask(MigrateBy);

	movzx	ebx, BYTE PTR _A$12[ebp]
	mov	edx, DWORD PTR _MigrateBy$[ebp]
	push	edx
	call	?BMask@@YGEH@Z				; BMask
	movzx	eax, al
	and	ebx, eax
	mov	BYTE PTR _Ar$8[ebp], bl

; 94   :                 BYTE Ad = A >> MigrateBy;

	movzx	edx, BYTE PTR _A$12[ebp]
	mov	ecx, DWORD PTR _MigrateBy$[ebp]
	sar	edx, cl
	mov	BYTE PTR _Ad$16[ebp], dl

; 95   :                 Ad |= As;

	movzx	eax, BYTE PTR _As$[ebp]
	movzx	ecx, BYTE PTR _Ad$16[ebp]
	or	ecx, eax
	mov	BYTE PTR _Ad$16[ebp], cl

; 96   :                 Buffer[Index + 3] = Ad;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Ad$16[ebp]
	mov	BYTE PTR [edx+3], al

; 97   :                 As = Ar;

	mov	cl, BYTE PTR _Ar$8[ebp]
	mov	BYTE PTR _As$[ebp], cl
$LN11@ChannelMig:

; 98   :             }
; 99   :             if (MigrateRed)

	cmp	DWORD PTR _MigrateRed$[ebp], 0
	je	SHORT $LN12@ChannelMig

; 100  :             {
; 101  :                 BYTE R = Buffer[Index + 2];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$11[ebp], al

; 102  :                 BYTE Rr = R & BMask(MigrateBy);

	movzx	ebx, BYTE PTR _R$11[ebp]
	mov	ecx, DWORD PTR _MigrateBy$[ebp]
	push	ecx
	call	?BMask@@YGEH@Z				; BMask
	movzx	edx, al
	and	ebx, edx
	mov	BYTE PTR _Rr$7[ebp], bl

; 103  :                 BYTE Rd = R >> MigrateBy;

	movzx	eax, BYTE PTR _R$11[ebp]
	mov	ecx, DWORD PTR _MigrateBy$[ebp]
	sar	eax, cl
	mov	BYTE PTR _Rd$15[ebp], al

; 104  :                 Rd |= Rs;

	movzx	ecx, BYTE PTR _Rs$[ebp]
	movzx	edx, BYTE PTR _Rd$15[ebp]
	or	edx, ecx
	mov	BYTE PTR _Rd$15[ebp], dl

; 105  :                 Buffer[Index + 2] = Rd;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Rd$15[ebp]
	mov	BYTE PTR [eax+2], cl

; 106  :                 Rs = Rr;

	mov	dl, BYTE PTR _Rr$7[ebp]
	mov	BYTE PTR _Rs$[ebp], dl
$LN12@ChannelMig:

; 107  :             }
; 108  :             if (MigrateGreen)

	cmp	DWORD PTR _MigrateGreen$[ebp], 0
	je	SHORT $LN13@ChannelMig

; 109  :             {
; 110  :                 BYTE G = Buffer[Index + 1];

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$10[ebp], cl

; 111  :                 BYTE Gr = G & BMask(MigrateBy);

	movzx	ebx, BYTE PTR _G$10[ebp]
	mov	edx, DWORD PTR _MigrateBy$[ebp]
	push	edx
	call	?BMask@@YGEH@Z				; BMask
	movzx	eax, al
	and	ebx, eax
	mov	BYTE PTR _Gr$6[ebp], bl

; 112  :                 BYTE Gd = G >> MigrateBy;

	movzx	edx, BYTE PTR _G$10[ebp]
	mov	ecx, DWORD PTR _MigrateBy$[ebp]
	sar	edx, cl
	mov	BYTE PTR _Gd$14[ebp], dl

; 113  :                 Gd |= Gs;

	movzx	eax, BYTE PTR _Gs$[ebp]
	movzx	ecx, BYTE PTR _Gd$14[ebp]
	or	ecx, eax
	mov	BYTE PTR _Gd$14[ebp], cl

; 114  :                 Buffer[Index + 1] = Gd;

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _Gd$14[ebp]
	mov	BYTE PTR [edx+1], al

; 115  :                 Gs = Gr;

	mov	cl, BYTE PTR _Gr$6[ebp]
	mov	BYTE PTR _Gs$[ebp], cl
$LN13@ChannelMig:

; 116  :             }
; 117  :             if (MigrateBlue)

	cmp	DWORD PTR _MigrateBlue$[ebp], 0
	je	SHORT $LN14@ChannelMig

; 118  :             {
; 119  :                 BYTE B = Buffer[Index + 1];

	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _B$9[ebp], al

; 120  :                 BYTE Br = B & BMask(MigrateBy);

	movzx	ebx, BYTE PTR _B$9[ebp]
	mov	ecx, DWORD PTR _MigrateBy$[ebp]
	push	ecx
	call	?BMask@@YGEH@Z				; BMask
	movzx	edx, al
	and	ebx, edx
	mov	BYTE PTR _Br$5[ebp], bl

; 121  :                 BYTE Bd = B >> MigrateBy;

	movzx	eax, BYTE PTR _B$9[ebp]
	mov	ecx, DWORD PTR _MigrateBy$[ebp]
	sar	eax, cl
	mov	BYTE PTR _Bd$13[ebp], al

; 122  :                 Bd |= Bs;

	movzx	ecx, BYTE PTR _Bs$[ebp]
	movzx	edx, BYTE PTR _Bd$13[ebp]
	or	edx, ecx
	mov	BYTE PTR _Bd$13[ebp], dl

; 123  :                 Buffer[Index + 1] = Bd;

	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _Bd$13[ebp]
	mov	BYTE PTR [eax+1], cl

; 124  :                 Bs = Br;

	mov	dl, BYTE PTR _Br$5[ebp]
	mov	BYTE PTR _Bs$[ebp], dl
$LN14@ChannelMig:

; 125  :             }
; 126  :         }

	jmp	$LN5@ChannelMig
$LN6@ChannelMig:

; 127  :     }

	jmp	$LN2@ChannelMig
$LN3@ChannelMig:

; 128  : 
; 129  :     return Success;

	xor	eax, eax
$LN1@ChannelMig:

; 130  : }

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_ChannelMigrate@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_PixelLuminance$1 = -60					; size = 8
_RowOffset$2 = -52					; size = 4
_PixelSize$ = -48					; size = 4
tv193 = -44						; size = 4
tv133 = -40						; size = 4
_Src$ = -36						; size = 4
_Column$3 = -32						; size = 4
_Row$4 = -28						; size = 4
_DoSwap$5 = -24						; size = 4
_Dest$ = -20						; size = 4
_Index$6 = -16						; size = 4
tv178 = -12						; size = 1
tv177 = -11						; size = 1
tv171 = -10						; size = 1
tv163 = -9						; size = 1
tv162 = -8						; size = 1
tv156 = -7						; size = 1
tv148 = -6						; size = 1
tv147 = -5						; size = 1
tv141 = -4						; size = 1
_R$7 = -3						; size = 1
_G$8 = -2						; size = 1
_B$9 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SwapOrder$ = 28					; size = 4
_LuminanceThreshold$ = 32				; size = 8
_Conditional$ = 40					; size = 4
_ChannelSwap4@36 PROC

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 295  :     if (Conditional == SwapIf_Unconditional || Conditional == SwapIf_NotSet)

	cmp	DWORD PTR _Conditional$[ebp], 0
	je	SHORT $LN13@ChannelSwa
	cmp	DWORD PTR _Conditional$[ebp], 6
	jne	SHORT $LN12@ChannelSwa
$LN13@ChannelSwa:

; 296  :         return ChannelSwap3(Source, Width, Height, Stride, Destination, SwapOrder);

	mov	eax, DWORD PTR _SwapOrder$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Destination$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Stride$[ebp]
	push	edx
	mov	eax, DWORD PTR _Height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Source$[ebp]
	push	edx
	call	_ChannelSwap3@24
	jmp	$LN1@ChannelSwa
$LN12@ChannelSwa:

; 297  : 
; 298  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN14@ChannelSwa

; 299  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelSwa
$LN14@ChannelSwa:

; 300  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN15@ChannelSwa

; 301  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelSwa
$LN15@ChannelSwa:

; 302  : 
; 303  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 304  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 305  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 306  : 
; 307  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$4[ebp], 0
	jmp	SHORT $LN4@ChannelSwa
$LN2@ChannelSwa:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN4@ChannelSwa:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@ChannelSwa

; 308  :     {
; 309  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 310  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$3[ebp], 0
	jmp	SHORT $LN7@ChannelSwa
$LN5@ChannelSwa:
	mov	edx, DWORD PTR _Column$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$3[ebp], edx
$LN7@ChannelSwa:
	mov	eax, DWORD PTR _Column$3[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@ChannelSwa

; 311  :         {
; 312  :             int Index = RowOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$3[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$6[ebp], ecx

; 313  :             Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 314  :             BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$7[ebp], al

; 315  :             BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$8[ebp], dl

; 316  :             BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$9[ebp], cl

; 317  : 
; 318  :             BOOL DoSwap = false;

	mov	DWORD PTR _DoSwap$5[ebp], 0

; 319  :             double PixelLuminance = ColorLuminance(R, G, B);

	movzx	edx, BYTE PTR _B$9[ebp]
	push	edx
	movzx	eax, BYTE PTR _G$8[ebp]
	push	eax
	movzx	ecx, BYTE PTR _R$7[ebp]
	push	ecx
	call	_ColorLuminance@12
	fstp	QWORD PTR _PixelLuminance$1[ebp]

; 320  :             switch (Conditional)

	mov	edx, DWORD PTR _Conditional$[ebp]
	mov	DWORD PTR tv133[ebp], edx
	mov	eax, DWORD PTR tv133[ebp]
	sub	eax, 1
	mov	DWORD PTR tv133[ebp], eax
	cmp	DWORD PTR tv133[ebp], 4
	ja	$LN26@ChannelSwa
	mov	ecx, DWORD PTR tv133[ebp]
	jmp	DWORD PTR $LN53@ChannelSwa[ecx*4]
$LN16@ChannelSwa:

; 321  :             {
; 322  :             case SwapIf_LuminanceGTE:
; 323  :                 if (PixelLuminance >= LuminanceThreshold)

	movsd	xmm0, QWORD PTR _PixelLuminance$1[ebp]
	comisd	xmm0, QWORD PTR _LuminanceThreshold$[ebp]
	jb	SHORT $LN17@ChannelSwa

; 324  :                     DoSwap = TRUE;

	mov	DWORD PTR _DoSwap$5[ebp], 1
$LN17@ChannelSwa:

; 325  :                 break;

	jmp	$LN8@ChannelSwa
$LN18@ChannelSwa:

; 326  : 
; 327  :             case SwapIf_LuminanceLTE:
; 328  :                 if (PixelLuminance <= LuminanceThreshold)

	movsd	xmm0, QWORD PTR _LuminanceThreshold$[ebp]
	comisd	xmm0, QWORD PTR _PixelLuminance$1[ebp]
	jb	SHORT $LN19@ChannelSwa

; 329  :                     DoSwap = TRUE;

	mov	DWORD PTR _DoSwap$5[ebp], 1
$LN19@ChannelSwa:

; 330  :                 break;

	jmp	$LN8@ChannelSwa
$LN20@ChannelSwa:

; 331  : 
; 332  :             case SwapIf_R_GTE_GB:
; 333  :                 if (R == max(R, max(G, B)))

	movzx	edx, BYTE PTR _G$8[ebp]
	movzx	eax, BYTE PTR _B$9[ebp]
	cmp	edx, eax
	jle	SHORT $LN35@ChannelSwa
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv141[ebp], cl
	jmp	SHORT $LN36@ChannelSwa
$LN35@ChannelSwa:
	mov	dl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR tv141[ebp], dl
$LN36@ChannelSwa:
	movzx	eax, BYTE PTR _R$7[ebp]
	movzx	ecx, BYTE PTR tv141[ebp]
	cmp	eax, ecx
	jle	SHORT $LN39@ChannelSwa
	mov	dl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR tv148[ebp], dl
	jmp	SHORT $LN40@ChannelSwa
$LN39@ChannelSwa:
	movzx	eax, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _B$9[ebp]
	cmp	eax, ecx
	jle	SHORT $LN37@ChannelSwa
	mov	dl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv147[ebp], dl
	jmp	SHORT $LN38@ChannelSwa
$LN37@ChannelSwa:
	mov	al, BYTE PTR _B$9[ebp]
	mov	BYTE PTR tv147[ebp], al
$LN38@ChannelSwa:
	mov	cl, BYTE PTR tv147[ebp]
	mov	BYTE PTR tv148[ebp], cl
$LN40@ChannelSwa:
	movzx	edx, BYTE PTR _R$7[ebp]
	movzx	eax, BYTE PTR tv148[ebp]
	cmp	edx, eax
	jne	SHORT $LN21@ChannelSwa

; 334  :                     DoSwap = TRUE;

	mov	DWORD PTR _DoSwap$5[ebp], 1
$LN21@ChannelSwa:

; 335  :                 break;

	jmp	$LN8@ChannelSwa
$LN22@ChannelSwa:

; 336  : 
; 337  :             case SwapIf_G_GTE_RB:
; 338  :                 if (G == max(R, max(G, B)))

	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$9[ebp]
	cmp	ecx, edx
	jle	SHORT $LN41@ChannelSwa
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv156[ebp], al
	jmp	SHORT $LN42@ChannelSwa
$LN41@ChannelSwa:
	mov	cl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR tv156[ebp], cl
$LN42@ChannelSwa:
	movzx	edx, BYTE PTR _R$7[ebp]
	movzx	eax, BYTE PTR tv156[ebp]
	cmp	edx, eax
	jle	SHORT $LN45@ChannelSwa
	mov	cl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR tv163[ebp], cl
	jmp	SHORT $LN46@ChannelSwa
$LN45@ChannelSwa:
	movzx	edx, BYTE PTR _G$8[ebp]
	movzx	eax, BYTE PTR _B$9[ebp]
	cmp	edx, eax
	jle	SHORT $LN43@ChannelSwa
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv162[ebp], cl
	jmp	SHORT $LN44@ChannelSwa
$LN43@ChannelSwa:
	mov	dl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR tv162[ebp], dl
$LN44@ChannelSwa:
	mov	al, BYTE PTR tv162[ebp]
	mov	BYTE PTR tv163[ebp], al
$LN46@ChannelSwa:
	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR tv163[ebp]
	cmp	ecx, edx
	jne	SHORT $LN23@ChannelSwa

; 339  :                     DoSwap = TRUE;

	mov	DWORD PTR _DoSwap$5[ebp], 1
$LN23@ChannelSwa:

; 340  :                 break;

	jmp	SHORT $LN8@ChannelSwa
$LN24@ChannelSwa:

; 341  : 
; 342  :             case SwapIf_B_GTE_RG:
; 343  :                 if (B == max(R, max(G, B)))

	movzx	eax, BYTE PTR _G$8[ebp]
	movzx	ecx, BYTE PTR _B$9[ebp]
	cmp	eax, ecx
	jle	SHORT $LN47@ChannelSwa
	mov	dl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv171[ebp], dl
	jmp	SHORT $LN48@ChannelSwa
$LN47@ChannelSwa:
	mov	al, BYTE PTR _B$9[ebp]
	mov	BYTE PTR tv171[ebp], al
$LN48@ChannelSwa:
	movzx	ecx, BYTE PTR _R$7[ebp]
	movzx	edx, BYTE PTR tv171[ebp]
	cmp	ecx, edx
	jle	SHORT $LN51@ChannelSwa
	mov	al, BYTE PTR _R$7[ebp]
	mov	BYTE PTR tv178[ebp], al
	jmp	SHORT $LN52@ChannelSwa
$LN51@ChannelSwa:
	movzx	ecx, BYTE PTR _G$8[ebp]
	movzx	edx, BYTE PTR _B$9[ebp]
	cmp	ecx, edx
	jle	SHORT $LN49@ChannelSwa
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR tv177[ebp], al
	jmp	SHORT $LN50@ChannelSwa
$LN49@ChannelSwa:
	mov	cl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR tv177[ebp], cl
$LN50@ChannelSwa:
	mov	dl, BYTE PTR tv177[ebp]
	mov	BYTE PTR tv178[ebp], dl
$LN52@ChannelSwa:
	movzx	eax, BYTE PTR _B$9[ebp]
	movzx	ecx, BYTE PTR tv178[ebp]
	cmp	eax, ecx
	jne	SHORT $LN25@ChannelSwa

; 344  :                     DoSwap = TRUE;

	mov	DWORD PTR _DoSwap$5[ebp], 1
$LN25@ChannelSwa:

; 345  :                 break;

	jmp	SHORT $LN8@ChannelSwa
$LN26@ChannelSwa:

; 346  : 
; 347  :             default:
; 348  :                 return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ChannelSwa
$LN8@ChannelSwa:

; 349  :             }
; 350  : 
; 351  :             if (!DoSwap)

	cmp	DWORD PTR _DoSwap$5[ebp], 0
	jne	SHORT $LN27@ChannelSwa

; 352  :             {
; 353  :                 Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [edx+2], al

; 354  :                 Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR [ecx+1], dl

; 355  :                 Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [eax], cl

; 356  :                 continue;

	jmp	$LN5@ChannelSwa
$LN27@ChannelSwa:

; 357  :             }
; 358  : 
; 359  :             switch (SwapOrder)

	mov	edx, DWORD PTR _SwapOrder$[ebp]
	mov	DWORD PTR tv193[ebp], edx
	mov	eax, DWORD PTR tv193[ebp]
	sub	eax, 1
	mov	DWORD PTR tv193[ebp], eax
	cmp	DWORD PTR tv193[ebp], 4
	ja	$LN33@ChannelSwa
	mov	ecx, DWORD PTR tv193[ebp]
	jmp	DWORD PTR $LN54@ChannelSwa[ecx*4]
$LN28@ChannelSwa:

; 360  :             {
; 361  :             case SortRBG:
; 362  :                 Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [edx+2], al

; 363  :                 Dest[Index + 1] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [ecx+1], dl

; 364  :                 Dest[Index + 0] = G;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR [eax], cl

; 365  :                 break;

	jmp	$LN10@ChannelSwa
$LN29@ChannelSwa:

; 366  : 
; 367  :             case SortGRB:
; 368  :                 Dest[Index + 2] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR [edx+2], al

; 369  :                 Dest[Index + 1] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [ecx+1], dl

; 370  :                 Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [eax], cl

; 371  :                 break;

	jmp	SHORT $LN10@ChannelSwa
$LN30@ChannelSwa:

; 372  : 
; 373  :             case SortGBR:
; 374  :                 Dest[Index + 2] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _G$8[ebp]
	mov	BYTE PTR [edx+2], al

; 375  :                 Dest[Index + 1] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [ecx+1], dl

; 376  :                 Dest[Index + 0] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [eax], cl

; 377  :                 break;

	jmp	SHORT $LN10@ChannelSwa
$LN31@ChannelSwa:

; 378  : 
; 379  :             case SortBRG:
; 380  :                 Dest[Index + 2] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [edx+2], al

; 381  :                 Dest[Index + 1] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [ecx+1], dl

; 382  :                 Dest[Index + 0] = G;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR [eax], cl

; 383  :                 break;

	jmp	SHORT $LN10@ChannelSwa
$LN32@ChannelSwa:

; 384  : 
; 385  :             case SortBGR:
; 386  :                 Dest[Index + 2] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$6[ebp]
	mov	al, BYTE PTR _B$9[ebp]
	mov	BYTE PTR [edx+2], al

; 387  :                 Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$6[ebp]
	mov	dl, BYTE PTR _G$8[ebp]
	mov	BYTE PTR [ecx+1], dl

; 388  :                 Dest[Index + 0] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$6[ebp]
	mov	cl, BYTE PTR _R$7[ebp]
	mov	BYTE PTR [eax], cl

; 389  :                 break;

	jmp	SHORT $LN10@ChannelSwa
$LN33@ChannelSwa:

; 390  : 
; 391  :             default:
; 392  :                 return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@ChannelSwa
$LN10@ChannelSwa:

; 393  :             }
; 394  :         }

	jmp	$LN5@ChannelSwa
$LN6@ChannelSwa:

; 395  :     }

	jmp	$LN2@ChannelSwa
$LN3@ChannelSwa:

; 396  : 
; 397  :     return Success;

	xor	eax, eax
$LN1@ChannelSwa:

; 398  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
$LN53@ChannelSwa:
	DD	$LN16@ChannelSwa
	DD	$LN18@ChannelSwa
	DD	$LN20@ChannelSwa
	DD	$LN22@ChannelSwa
	DD	$LN24@ChannelSwa
$LN54@ChannelSwa:
	DD	$LN28@ChannelSwa
	DD	$LN29@ChannelSwa
	DD	$LN30@ChannelSwa
	DD	$LN31@ChannelSwa
	DD	$LN32@ChannelSwa
_ChannelSwap4@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_RowOffset$1 = -36					; size = 4
_PixelSize$ = -32					; size = 4
tv88 = -28						; size = 4
_Src$ = -24						; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Dest$ = -12						; size = 4
_Index$4 = -8						; size = 4
_R$5 = -3						; size = 1
_G$6 = -2						; size = 1
_B$7 = -1						; size = 1
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_SwapOrder$ = 28					; size = 4
_ChannelSwap3@24 PROC

; 212  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 213  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN10@ChannelSwa

; 214  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelSwa
$LN10@ChannelSwa:

; 215  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN11@ChannelSwa

; 216  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelSwa
$LN11@ChannelSwa:

; 217  : 
; 218  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 219  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 220  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 221  : 
; 222  :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ChannelSwa
$LN2@ChannelSwa:
	mov	edx, DWORD PTR _Row$3[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$3[ebp], edx
$LN4@ChannelSwa:
	mov	eax, DWORD PTR _Row$3[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@ChannelSwa

; 223  :     {
; 224  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$3[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], ecx

; 225  :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ChannelSwa
$LN5@ChannelSwa:
	mov	edx, DWORD PTR _Column$2[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$2[ebp], edx
$LN7@ChannelSwa:
	mov	eax, DWORD PTR _Column$2[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@ChannelSwa

; 226  :         {
; 227  :             int Index = RowOffset + (Column * PixelSize);

	mov	ecx, DWORD PTR _Column$2[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], ecx

; 228  :             Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 229  :             BYTE R = Src[Index + 2];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR _R$5[ebp], al

; 230  :             BYTE G = Src[Index + 1];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR _G$6[ebp], dl

; 231  :             BYTE B = Src[Index + 0];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _B$7[ebp], cl

; 232  :             switch (SwapOrder)

	mov	edx, DWORD PTR _SwapOrder$[ebp]
	mov	DWORD PTR tv88[ebp], edx
	mov	eax, DWORD PTR tv88[ebp]
	sub	eax, 1
	mov	DWORD PTR tv88[ebp], eax
	cmp	DWORD PTR tv88[ebp], 4
	ja	$LN17@ChannelSwa
	mov	ecx, DWORD PTR tv88[ebp]
	jmp	DWORD PTR $LN19@ChannelSwa[ecx*4]
$LN12@ChannelSwa:

; 233  :             {
; 234  :             case SortRBG:
; 235  :                 Dest[Index + 2] = R;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _R$5[ebp]
	mov	BYTE PTR [edx+2], al

; 236  :                 Dest[Index + 1] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR [ecx+1], dl

; 237  :                 Dest[Index + 0] = G;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [eax], cl

; 238  :                 break;

	jmp	$LN8@ChannelSwa
$LN13@ChannelSwa:

; 239  : 
; 240  :             case SortGRB:
; 241  :                 Dest[Index + 2] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [edx+2], al

; 242  :                 Dest[Index + 1] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _R$5[ebp]
	mov	BYTE PTR [ecx+1], dl

; 243  :                 Dest[Index + 0] = B;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR [eax], cl

; 244  :                 break;

	jmp	SHORT $LN8@ChannelSwa
$LN14@ChannelSwa:

; 245  : 
; 246  :             case SortGBR:
; 247  :                 Dest[Index + 2] = G;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [edx+2], al

; 248  :                 Dest[Index + 1] = B;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _B$7[ebp]
	mov	BYTE PTR [ecx+1], dl

; 249  :                 Dest[Index + 0] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _R$5[ebp]
	mov	BYTE PTR [eax], cl

; 250  :                 break;

	jmp	SHORT $LN8@ChannelSwa
$LN15@ChannelSwa:

; 251  : 
; 252  :             case SortBRG:
; 253  :                 Dest[Index + 2] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _B$7[ebp]
	mov	BYTE PTR [edx+2], al

; 254  :                 Dest[Index + 1] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _R$5[ebp]
	mov	BYTE PTR [ecx+1], dl

; 255  :                 Dest[Index + 0] = G;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [eax], cl

; 256  :                 break;

	jmp	SHORT $LN8@ChannelSwa
$LN16@ChannelSwa:

; 257  : 
; 258  :             case SortBGR:
; 259  :                 Dest[Index + 2] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	al, BYTE PTR _B$7[ebp]
	mov	BYTE PTR [edx+2], al

; 260  :                 Dest[Index + 1] = G;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	dl, BYTE PTR _G$6[ebp]
	mov	BYTE PTR [ecx+1], dl

; 261  :                 Dest[Index + 0] = R;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	cl, BYTE PTR _R$5[ebp]
	mov	BYTE PTR [eax], cl

; 262  :                 break;

	jmp	SHORT $LN8@ChannelSwa
$LN17@ChannelSwa:

; 263  : 
; 264  :             default:
; 265  :                 return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	SHORT $LN1@ChannelSwa
$LN8@ChannelSwa:

; 266  :             }
; 267  :         }

	jmp	$LN5@ChannelSwa
$LN6@ChannelSwa:

; 268  :     }

	jmp	$LN2@ChannelSwa
$LN3@ChannelSwa:

; 269  : 
; 270  :     return Success;

	xor	eax, eax
$LN1@ChannelSwa:

; 271  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	3
$LN19@ChannelSwa:
	DD	$LN12@ChannelSwa
	DD	$LN13@ChannelSwa
	DD	$LN14@ChannelSwa
	DD	$LN15@ChannelSwa
	DD	$LN16@ChannelSwa
_ChannelSwap3@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_D$1 = -52						; size = 4
_Dest$ = -48						; size = 4
_Source$ = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
_RowOffset$4 = -32					; size = 4
_PixelSize$ = -28					; size = 4
_Column$5 = -24						; size = 4
_Row$6 = -20						; size = 4
_i$7 = -16						; size = 4
_Index$8 = -12						; size = 4
_Buffer$ = -8						; size = 4
_S$9 = -4						; size = 4
_Target$ = 8						; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_SourceIndices$ = 24					; size = 4
_DestIndices$ = 28					; size = 4
_IndexCount$ = 32					; size = 4
_ChannelSwap@28 PROC

; 157  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi

; 158  :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN11@ChannelSwa

; 159  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelSwa
$LN11@ChannelSwa:

; 160  :     if (SourceIndices == NULL)

	cmp	DWORD PTR _SourceIndices$[ebp], 0
	jne	SHORT $LN12@ChannelSwa

; 161  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelSwa
$LN12@ChannelSwa:

; 162  :     if (DestIndices == NULL)

	cmp	DWORD PTR _DestIndices$[ebp], 0
	jne	SHORT $LN13@ChannelSwa

; 163  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelSwa
$LN13@ChannelSwa:

; 164  :     if (IndexCount < 1)

	cmp	DWORD PTR _IndexCount$[ebp], 1
	jge	SHORT $LN14@ChannelSwa

; 165  :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@ChannelSwa
$LN14@ChannelSwa:

; 166  :     if (IndexCount > 4)

	cmp	DWORD PTR _IndexCount$[ebp], 4
	jle	SHORT $LN15@ChannelSwa

; 167  :         return BadIndex;

	mov	eax, 2
	jmp	$LN1@ChannelSwa
$LN15@ChannelSwa:

; 168  : 
; 169  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 170  :     BYTE *Buffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 171  :     int *Source = (int *)SourceIndices;

	mov	ecx, DWORD PTR _SourceIndices$[ebp]
	mov	DWORD PTR _Source$[ebp], ecx

; 172  :     int *Dest = (int *)DestIndices;

	mov	edx, DWORD PTR _DestIndices$[ebp]
	mov	DWORD PTR _Dest$[ebp], edx

; 173  : 
; 174  :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$6[ebp], 0
	jmp	SHORT $LN4@ChannelSwa
$LN2@ChannelSwa:
	mov	eax, DWORD PTR _Row$6[ebp]
	add	eax, 1
	mov	DWORD PTR _Row$6[ebp], eax
$LN4@ChannelSwa:
	mov	ecx, DWORD PTR _Row$6[ebp]
	cmp	ecx, DWORD PTR _BufferHeight$[ebp]
	jge	$LN3@ChannelSwa

; 175  :     {
; 176  :         int RowOffset = Row * BufferStride;

	mov	edx, DWORD PTR _Row$6[ebp]
	imul	edx, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$4[ebp], edx

; 177  :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$5[ebp], 0
	jmp	SHORT $LN7@ChannelSwa
$LN5@ChannelSwa:
	mov	eax, DWORD PTR _Column$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$5[ebp], eax
$LN7@ChannelSwa:
	mov	ecx, DWORD PTR _Column$5[ebp]
	cmp	ecx, DWORD PTR _BufferWidth$[ebp]
	jge	$LN6@ChannelSwa

; 178  :         {
; 179  :             int Index = RowOffset + (Column * PixelSize);

	mov	edx, DWORD PTR _Column$5[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$4[ebp]
	mov	DWORD PTR _Index$8[ebp], edx

; 180  :             BYTE *S = new BYTE[4];

	push	4
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR _S$9[ebp], eax

; 181  :             S[0] = Buffer[Index + 3];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	ecx, DWORD PTR _S$9[ebp]
	mov	al, BYTE PTR [eax+3]
	mov	BYTE PTR [ecx+edx], al

; 182  :             S[1] = Buffer[Index + 2];

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	eax, DWORD PTR _S$9[ebp]
	mov	dl, BYTE PTR [edx+2]
	mov	BYTE PTR [eax+ecx], dl

; 183  :             S[2] = Buffer[Index + 1];

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	edx, DWORD PTR _S$9[ebp]
	mov	cl, BYTE PTR [ecx+1]
	mov	BYTE PTR [edx+eax], cl

; 184  :             S[3] = Buffer[Index + 0];

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	edx, DWORD PTR _S$9[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [edx+eax], cl

; 185  :             BYTE *D = new BYTE[4];

	push	4
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	edx, DWORD PTR $T2[ebp]
	mov	DWORD PTR _D$1[ebp], edx

; 186  :             for (int i = 0; i < IndexCount; i++)

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN10@ChannelSwa
$LN8@ChannelSwa:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
$LN10@ChannelSwa:
	mov	ecx, DWORD PTR _i$7[ebp]
	cmp	ecx, DWORD PTR _IndexCount$[ebp]
	jge	SHORT $LN9@ChannelSwa

; 187  :             {
; 188  :                 D[Dest[i]] = S[Source[i]];

	mov	edx, DWORD PTR _i$7[ebp]
	mov	eax, DWORD PTR _Source$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _i$7[ebp]
	mov	eax, DWORD PTR _Dest$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR _D$1[ebp]
	mov	esi, DWORD PTR _S$9[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl

; 189  :             }

	jmp	SHORT $LN8@ChannelSwa
$LN9@ChannelSwa:

; 190  :             Buffer[Index + 3] = S[3];

	mov	edx, 1
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$8[ebp]
	mov	edx, DWORD PTR _S$9[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx+3], al

; 191  :             Buffer[Index + 2] = S[2];

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	eax, DWORD PTR _S$9[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx+2], cl

; 192  :             Buffer[Index + 1] = S[1];

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$8[ebp]
	mov	ecx, DWORD PTR _S$9[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax+1], dl

; 193  :             Buffer[Index + 0] = S[0];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$8[ebp]
	mov	eax, DWORD PTR _S$9[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx], cl

; 194  :         }

	jmp	$LN5@ChannelSwa
$LN6@ChannelSwa:

; 195  :     }

	jmp	$LN2@ChannelSwa
$LN3@ChannelSwa:

; 196  : 
; 197  :     return Success;

	xor	eax, eax
$LN1@ChannelSwa:

; 198  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_ChannelSwap@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\channels.cpp
_TEXT	SEGMENT
_RowOffset$1 = -28					; size = 4
_PixelSize$ = -24					; size = 4
_Column$2 = -20						; size = 4
_Row$3 = -16						; size = 4
_Index$4 = -12						; size = 4
_Buffer$ = -8						; size = 4
_FullPixel$5 = -4					; size = 4
_Target$ = 8						; size = 4
_BufferWidth$ = 12					; size = 4
_BufferHeight$ = 16					; size = 4
_BufferStride$ = 20					; size = 4
_ShiftBy$ = 24						; size = 4
_ChannelShift@20 PROC

; 16   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 17   :     if (ShiftBy == 0)

	cmp	DWORD PTR _ShiftBy$[ebp], 0
	jne	SHORT $LN8@ChannelShi

; 18   :         return NoActionTaken;

	mov	eax, 12					; 0000000cH
	jmp	$LN1@ChannelShi
$LN8@ChannelShi:

; 19   :     if (Target == NULL)

	cmp	DWORD PTR _Target$[ebp], 0
	jne	SHORT $LN9@ChannelShi

; 20   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ChannelShi
$LN9@ChannelShi:

; 21   : 
; 22   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 23   :     BYTE *Buffer = (BYTE *)Target;

	mov	eax, DWORD PTR _Target$[ebp]
	mov	DWORD PTR _Buffer$[ebp], eax

; 24   : 
; 25   :     for (int Row = 0; Row < BufferHeight; Row++)

	mov	DWORD PTR _Row$3[ebp], 0
	jmp	SHORT $LN4@ChannelShi
$LN2@ChannelShi:
	mov	ecx, DWORD PTR _Row$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _Row$3[ebp], ecx
$LN4@ChannelShi:
	mov	edx, DWORD PTR _Row$3[ebp]
	cmp	edx, DWORD PTR _BufferHeight$[ebp]
	jge	$LN3@ChannelShi

; 26   :     {
; 27   :         int RowOffset = Row * BufferStride;

	mov	eax, DWORD PTR _Row$3[ebp]
	imul	eax, DWORD PTR _BufferStride$[ebp]
	mov	DWORD PTR _RowOffset$1[ebp], eax

; 28   :         for (int Column = 0; Column < BufferWidth; Column++)

	mov	DWORD PTR _Column$2[ebp], 0
	jmp	SHORT $LN7@ChannelShi
$LN5@ChannelShi:
	mov	ecx, DWORD PTR _Column$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _Column$2[ebp], ecx
$LN7@ChannelShi:
	mov	edx, DWORD PTR _Column$2[ebp]
	cmp	edx, DWORD PTR _BufferWidth$[ebp]
	jge	$LN6@ChannelShi

; 29   :         {
; 30   :             int Index = RowOffset + (Column * PixelSize);

	mov	eax, DWORD PTR _Column$2[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _RowOffset$1[ebp]
	mov	DWORD PTR _Index$4[ebp], eax

; 31   :             UINT32 FullPixel = (Buffer[Index + 3] << 24) | (Buffer[Index + 2] << 16) | (Buffer[Index + 1] << 8) | (Buffer[Index + 0] << 0);

	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	shl	ecx, 16					; 00000010H
	or	edx, ecx
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	shl	ecx, 8
	or	edx, ecx
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	edx, ecx
	mov	DWORD PTR _FullPixel$5[ebp], edx

; 32   :             if (ShiftBy < 0)

	cmp	DWORD PTR _ShiftBy$[ebp], 0
	jge	SHORT $LN10@ChannelShi

; 33   :                 FullPixel = RotateLeft32(FullPixel, ShiftBy);

	mov	edx, DWORD PTR _FullPixel$5[ebp]
	mov	ecx, DWORD PTR _ShiftBy$[ebp]
	rol	edx, cl
	mov	DWORD PTR _FullPixel$5[ebp], edx

; 34   :             else

	jmp	SHORT $LN11@ChannelShi
$LN10@ChannelShi:

; 35   :                 FullPixel = RotateRight32(FullPixel, ShiftBy);

	mov	eax, DWORD PTR _FullPixel$5[ebp]
	mov	ecx, DWORD PTR _ShiftBy$[ebp]
	ror	eax, cl
	mov	DWORD PTR _FullPixel$5[ebp], eax
$LN11@ChannelShi:

; 36   :             Buffer[Index + 3] = (FullPixel & 0xff000000) >> 24;

	mov	ecx, DWORD PTR _FullPixel$5[ebp]
	and	ecx, -16777216				; ff000000H
	shr	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx+3], cl

; 37   :             Buffer[Index + 2] = (FullPixel & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _FullPixel$5[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _Buffer$[ebp]
	add	ecx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [ecx+2], al

; 38   :             Buffer[Index + 1] = (FullPixel & 0x0000ff00) >> 8;

	mov	edx, DWORD PTR _FullPixel$5[ebp]
	and	edx, 65280				; 0000ff00H
	shr	edx, 8
	mov	eax, DWORD PTR _Buffer$[ebp]
	add	eax, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [eax+1], dl

; 39   :             Buffer[Index + 0] = (FullPixel & 0x000000ff) >> 0;

	mov	ecx, DWORD PTR _FullPixel$5[ebp]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _Buffer$[ebp]
	add	edx, DWORD PTR _Index$4[ebp]
	mov	BYTE PTR [edx], cl

; 40   :         }

	jmp	$LN5@ChannelShi
$LN6@ChannelShi:

; 41   :     }

	jmp	$LN2@ChannelShi
$LN3@ChannelShi:

; 42   :     return Success;

	xor	eax, eax
$LN1@ChannelShi:

; 43   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_ChannelShift@20 ENDP
_TEXT	ENDS
END
