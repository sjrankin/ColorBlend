; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\SinglePixels.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_GetPixelAtLocation@20
PUBLIC	_GetPixelAtLocation2@24
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\singlepixels.cpp
_TEXT	SEGMENT
_Result$ = -20						; size = 4
_PixelSize$ = -16					; size = 4
_Src$ = -12						; size = 4
_Index$ = -8						; size = 4
_B$ = -4						; size = 1
_G$ = -3						; size = 1
_R$ = -2						; size = 1
_A$ = -1						; size = 1
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_SourceStride$ = 20					; size = 4
_X$ = 24						; size = 4
_Y$ = 28						; size = 4
_GetPixelAtLocation2@24 PROC

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 52   : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@GetPixelAt

; 53   : 		return 0;

	xor	eax, eax
	jmp	$LN1@GetPixelAt
$LN2@GetPixelAt:

; 54   : 	if (X < 0)

	cmp	DWORD PTR _X$[ebp], 0
	jge	SHORT $LN3@GetPixelAt

; 55   : 		X = 0;

	mov	DWORD PTR _X$[ebp], 0
$LN3@GetPixelAt:

; 56   : 	if (X > SourceWidth - 1)

	mov	eax, DWORD PTR _SourceWidth$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _X$[ebp], eax
	jle	SHORT $LN4@GetPixelAt

; 57   : 		X = SourceWidth - 1;

	mov	ecx, DWORD PTR _SourceWidth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _X$[ebp], ecx
$LN4@GetPixelAt:

; 58   : 	if (Y < 0)

	cmp	DWORD PTR _Y$[ebp], 0
	jge	SHORT $LN5@GetPixelAt

; 59   : 		Y = 0;

	mov	DWORD PTR _Y$[ebp], 0
$LN5@GetPixelAt:

; 60   : 	if (Y > SourceHeight - 1)

	mov	edx, DWORD PTR _SourceHeight$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _Y$[ebp], edx
	jle	SHORT $LN6@GetPixelAt

; 61   : 		Y = SourceHeight - 1;

	mov	eax, DWORD PTR _SourceHeight$[ebp]
	sub	eax, 1
	mov	DWORD PTR _Y$[ebp], eax
$LN6@GetPixelAt:

; 62   : 
; 63   : 	BYTE *Src = (BYTE *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 64   : 	int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 65   : 
; 66   : 	UINT32 Index = Y * SourceStride;

	mov	edx, DWORD PTR _Y$[ebp]
	imul	edx, DWORD PTR _SourceStride$[ebp]
	mov	DWORD PTR _Index$[ebp], edx

; 67   : 	Index += (X * PixelSize);

	mov	eax, DWORD PTR _X$[ebp]
	imul	eax, DWORD PTR _PixelSize$[ebp]
	add	eax, DWORD PTR _Index$[ebp]
	mov	DWORD PTR _Index$[ebp], eax

; 68   : 
; 69   : 	BYTE A = Src[Index + 3];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR _A$[ebp], dl

; 70   : 	BYTE R = Src[Index + 2];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR _R$[ebp], cl

; 71   : 	BYTE G = Src[Index + 1];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR _G$[ebp], al

; 72   : 	BYTE B = Src[Index + 0];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _B$[ebp], dl

; 73   : 
; 74   : 	UINT32 Result = (A << 24) | (R << 16) | (G << 8) | (B << 0);

	movzx	eax, BYTE PTR _A$[ebp]
	shl	eax, 24					; 00000018H
	movzx	ecx, BYTE PTR _R$[ebp]
	shl	ecx, 16					; 00000010H
	or	eax, ecx
	movzx	edx, BYTE PTR _G$[ebp]
	shl	edx, 8
	or	eax, edx
	movzx	ecx, BYTE PTR _B$[ebp]
	or	eax, ecx
	mov	DWORD PTR _Result$[ebp], eax

; 75   : 
; 76   : 	return Result;

	mov	eax, DWORD PTR _Result$[ebp]
$LN1@GetPixelAt:

; 77   : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_GetPixelAtLocation2@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\singlepixels.cpp
_TEXT	SEGMENT
_Src$ = -8						; size = 4
_Index$ = -4						; size = 4
_Source$ = 8						; size = 4
_SourceWidth$ = 12					; size = 4
_SourceHeight$ = 16					; size = 4
_X$ = 20						; size = 4
_Y$ = 24						; size = 4
_GetPixelAtLocation@20 PROC

; 19   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 20   : 	if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN2@GetPixelAt

; 21   : 		return 0;

	xor	eax, eax
	jmp	SHORT $LN1@GetPixelAt
$LN2@GetPixelAt:

; 22   : 	if (X < 0)

	cmp	DWORD PTR _X$[ebp], 0
	jge	SHORT $LN3@GetPixelAt

; 23   : 		X = 0;

	mov	DWORD PTR _X$[ebp], 0
$LN3@GetPixelAt:

; 24   : 	if (X > SourceWidth - 1)

	mov	eax, DWORD PTR _SourceWidth$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _X$[ebp], eax
	jle	SHORT $LN4@GetPixelAt

; 25   : 		X = SourceWidth - 1;

	mov	ecx, DWORD PTR _SourceWidth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _X$[ebp], ecx
$LN4@GetPixelAt:

; 26   : 	if (Y < 0)

	cmp	DWORD PTR _Y$[ebp], 0
	jge	SHORT $LN5@GetPixelAt

; 27   : 		Y = 0;

	mov	DWORD PTR _Y$[ebp], 0
$LN5@GetPixelAt:

; 28   : 	if (Y > SourceHeight - 1)

	mov	edx, DWORD PTR _SourceHeight$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _Y$[ebp], edx
	jle	SHORT $LN6@GetPixelAt

; 29   : 		Y = SourceHeight - 1;

	mov	eax, DWORD PTR _SourceHeight$[ebp]
	sub	eax, 1
	mov	DWORD PTR _Y$[ebp], eax
$LN6@GetPixelAt:

; 30   : 
; 31   : 	UINT32 *Src = (UINT32 *)Source;

	mov	ecx, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 32   : 
; 33   : 	UINT32 Index = Y * SourceWidth;

	mov	edx, DWORD PTR _Y$[ebp]
	imul	edx, DWORD PTR _SourceWidth$[ebp]
	mov	DWORD PTR _Index$[ebp], edx

; 34   : 	Index += X;

	mov	eax, DWORD PTR _Index$[ebp]
	add	eax, DWORD PTR _X$[ebp]
	mov	DWORD PTR _Index$[ebp], eax

; 35   : 
; 36   : 	return Src[Index];

	mov	ecx, DWORD PTR _Index$[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
$LN1@GetPixelAt:

; 37   : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_GetPixelAtLocation@20 ENDP
_TEXT	ENDS
END
