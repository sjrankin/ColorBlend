; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25831.0 

	TITLE	C:\Users\Stuart\Desktop\Projects4\ColorBlend\ColorBlender\Grayscale.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_BufferGrayscaleRegion@48
PUBLIC	_BufferGrayscale@24
PUBLIC	_GrayLevelsRegion@48
PUBLIC	_GrayLevels@24
PUBLIC	_ColorLevelsRegion@48
PUBLIC	_ColorLevels@24
PUBLIC	__real@3fb27bb2fec56d5d
PUBLIC	__real@3fb95810624dd2f2
PUBLIC	__real@3fbc28f5c28f5c29
PUBLIC	__real@3fbd2f1a9fbe76c9
PUBLIC	__real@3fcb367a0f9096bc
PUBLIC	__real@3fd3333333333333
PUBLIC	__real@3fe2c8b439581062
PUBLIC	__real@3fe2e147ae147ae1
PUBLIC	__real@3fe6e2eb1c432ca5
PUBLIC	__real@4000000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@406fe00000000000
EXTRN	_ColorLuminance@12:PROC
EXTRN	_floor:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@406fe00000000000
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3fe6e2eb1c432ca5
CONST	SEGMENT
__real@3fe6e2eb1c432ca5 DQ 03fe6e2eb1c432ca5r	; 0.7152
CONST	ENDS
;	COMDAT __real@3fe2e147ae147ae1
CONST	SEGMENT
__real@3fe2e147ae147ae1 DQ 03fe2e147ae147ae1r	; 0.59
CONST	ENDS
;	COMDAT __real@3fe2c8b439581062
CONST	SEGMENT
__real@3fe2c8b439581062 DQ 03fe2c8b439581062r	; 0.587
CONST	ENDS
;	COMDAT __real@3fd3333333333333
CONST	SEGMENT
__real@3fd3333333333333 DQ 03fd3333333333333r	; 0.3
CONST	ENDS
;	COMDAT __real@3fcb367a0f9096bc
CONST	SEGMENT
__real@3fcb367a0f9096bc DQ 03fcb367a0f9096bcr	; 0.2126
CONST	ENDS
;	COMDAT __real@3fbd2f1a9fbe76c9
CONST	SEGMENT
__real@3fbd2f1a9fbe76c9 DQ 03fbd2f1a9fbe76c9r	; 0.114
CONST	ENDS
;	COMDAT __real@3fbc28f5c28f5c29
CONST	SEGMENT
__real@3fbc28f5c28f5c29 DQ 03fbc28f5c28f5c29r	; 0.11
CONST	ENDS
;	COMDAT __real@3fb95810624dd2f2
CONST	SEGMENT
__real@3fb95810624dd2f2 DQ 03fb95810624dd2f2r	; 0.099
CONST	ENDS
;	COMDAT __real@3fb27bb2fec56d5d
CONST	SEGMENT
__real@3fb27bb2fec56d5d DQ 03fb27bb2fec56d5dr	; 0.0722
CONST	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\grayscale.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_LevelCount$ = 28					; size = 4
_ColorLevels@24 PROC

; 347  : {

	push	ebp
	mov	ebp, esp

; 348  :     return ColorLevelsRegion(Source, Width, Height, Stride, Destination, LevelCount, 0, 0, Width - 1, Height - 1, FALSE, 0x0);

	push	0
	push	0
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _LevelCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_ColorLevelsRegion@48

; 349  : }

	pop	ebp
	ret	24					; 00000018H
_ColorLevels@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\grayscale.cpp
_TEXT	SEGMENT
_Grays$ = -320						; size = 256
_f$1 = -64						; size = 8
tv262 = -56						; size = 8
_Factor$ = -48						; size = 8
_RowOffset$2 = -40					; size = 4
_PixelSize$ = -36					; size = 4
_i$3 = -32						; size = 4
_Row$4 = -28						; size = 4
_Column$5 = -24						; size = 4
_NonOpB$ = -20						; size = 1
_NonOpG$ = -19						; size = 1
_NonOpR$ = -18						; size = 1
_NonOpA$ = -17						; size = 1
_B$6 = -16						; size = 1
_G$7 = -15						; size = 1
_R$8 = -14						; size = 1
_M$9 = -13						; size = 1
_Src$ = -12						; size = 4
_Dest$ = -8						; size = 4
_Index$10 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_LevelCount$ = 28					; size = 4
_Left$ = 32						; size = 4
_Top$ = 36						; size = 4
_Right$ = 40						; size = 4
_Bottom$ = 44						; size = 4
_CopyOutOfRegion$ = 48					; size = 4
_PackedOut$ = 52					; size = 4
_ColorLevelsRegion@48 PROC

; 259  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H

; 260  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN11@ColorLevel

; 261  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ColorLevel
$LN11@ColorLevel:

; 262  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN12@ColorLevel

; 263  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@ColorLevel
$LN12@ColorLevel:

; 264  :     if (LevelCount < 2)

	cmp	DWORD PTR _LevelCount$[ebp], 2
	jge	SHORT $LN13@ColorLevel

; 265  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ColorLevel
$LN13@ColorLevel:

; 266  :     if (LevelCount > 255)

	cmp	DWORD PTR _LevelCount$[ebp], 255	; 000000ffH
	jle	SHORT $LN14@ColorLevel

; 267  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ColorLevel
$LN14@ColorLevel:

; 268  : 
; 269  :     if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN15@ColorLevel

; 270  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ColorLevel
$LN15@ColorLevel:

; 271  :     if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN16@ColorLevel

; 272  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ColorLevel
$LN16@ColorLevel:

; 273  :     if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN17@ColorLevel

; 274  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ColorLevel
$LN17@ColorLevel:

; 275  :     if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN18@ColorLevel

; 276  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@ColorLevel
$LN18@ColorLevel:

; 277  : 
; 278  :     BYTE NonOpA = (PackedOut & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _NonOpA$[ebp], dl

; 279  :     BYTE NonOpR = (PackedOut & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedOut$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _NonOpR$[ebp], al

; 280  :     BYTE NonOpG = (PackedOut & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedOut$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _NonOpG$[ebp], cl

; 281  :     BYTE NonOpB = (PackedOut & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _NonOpB$[ebp], dl

; 282  : 
; 283  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 284  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 285  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 286  :     double Factor = 255.0 / (double)(LevelCount - 1);

	mov	edx, DWORD PTR _LevelCount$[ebp]
	sub	edx, 1
	cvtsi2sd xmm0, edx
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	divsd	xmm1, xmm0
	movsd	QWORD PTR _Factor$[ebp], xmm1

; 287  : 
; 288  :     BYTE Grays[256];
; 289  :     for (int i = 0; i < 256; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@ColorLevel
$LN2@ColorLevel:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@ColorLevel:
	cmp	DWORD PTR _i$3[ebp], 256		; 00000100H
	jge	SHORT $LN3@ColorLevel

; 290  :     {
; 291  :         double f = floor((double)i / Factor);

	cvtsi2sd xmm0, DWORD PTR _i$3[ebp]
	divsd	xmm0, QWORD PTR _Factor$[ebp]
	movsd	QWORD PTR tv262[ebp], xmm0
	fld	QWORD PTR tv262[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR _f$1[ebp]

; 292  :         BYTE M = (BYTE)(f * Factor);

	movsd	xmm0, QWORD PTR _f$1[ebp]
	mulsd	xmm0, QWORD PTR _Factor$[ebp]
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _M$9[ebp], cl

; 293  :         Grays[i] = M;

	mov	edx, DWORD PTR _i$3[ebp]
	mov	al, BYTE PTR _M$9[ebp]
	mov	BYTE PTR _Grays$[ebp+edx], al

; 294  :     }

	jmp	SHORT $LN2@ColorLevel
$LN3@ColorLevel:

; 295  : 
; 296  :     for (int Row = Top; Row <= Bottom; Row++)

	mov	ecx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$4[ebp], ecx
	jmp	SHORT $LN7@ColorLevel
$LN5@ColorLevel:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN7@ColorLevel:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Bottom$[ebp]
	jg	$LN6@ColorLevel

; 297  :     {
; 298  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 299  :         for (int Column = Left; Column <= Right; Column++)

	mov	edx, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$5[ebp], edx
	jmp	SHORT $LN10@ColorLevel
$LN8@ColorLevel:
	mov	eax, DWORD PTR _Column$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$5[ebp], eax
$LN10@ColorLevel:
	mov	ecx, DWORD PTR _Column$5[ebp]
	cmp	ecx, DWORD PTR _Right$[ebp]
	jg	$LN9@ColorLevel

; 300  :         {
; 301  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$5[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$10[ebp], edx

; 302  :             Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$10[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 303  : 
; 304  :             BYTE R = Grays[Src[Index + 2]];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$10[ebp]
	movzx	ecx, BYTE PTR [eax+2]
	mov	dl, BYTE PTR _Grays$[ebp+ecx]
	mov	BYTE PTR _R$8[ebp], dl

; 305  :             BYTE G = Grays[Src[Index + 1]];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$10[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	mov	dl, BYTE PTR _Grays$[ebp+ecx]
	mov	BYTE PTR _G$7[ebp], dl

; 306  :             BYTE B = Grays[Src[Index + 0]];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$10[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	dl, BYTE PTR _Grays$[ebp+ecx]
	mov	BYTE PTR _B$6[ebp], dl

; 307  : 
; 308  :             if ((Column >= Left) && (Column <= Right) && (Row >= Top) && (Row <= Bottom))

	mov	eax, DWORD PTR _Column$5[ebp]
	cmp	eax, DWORD PTR _Left$[ebp]
	jl	SHORT $LN19@ColorLevel
	mov	ecx, DWORD PTR _Column$5[ebp]
	cmp	ecx, DWORD PTR _Right$[ebp]
	jg	SHORT $LN19@ColorLevel
	mov	edx, DWORD PTR _Row$4[ebp]
	cmp	edx, DWORD PTR _Top$[ebp]
	jl	SHORT $LN19@ColorLevel
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN19@ColorLevel

; 309  :             {
; 310  :                 Dest[Index + 2] = R;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	dl, BYTE PTR _R$8[ebp]
	mov	BYTE PTR [ecx+2], dl

; 311  :                 Dest[Index + 1] = G;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$10[ebp]
	mov	cl, BYTE PTR _G$7[ebp]
	mov	BYTE PTR [eax+1], cl

; 312  :                 Dest[Index + 0] = B;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$10[ebp]
	mov	al, BYTE PTR _B$6[ebp]
	mov	BYTE PTR [edx], al

; 313  :             }
; 314  :             else

	jmp	SHORT $LN22@ColorLevel
$LN19@ColorLevel:

; 315  :             {
; 316  :                 if (CopyOutOfRegion)

	cmp	DWORD PTR _CopyOutOfRegion$[ebp], 0
	je	SHORT $LN21@ColorLevel

; 317  :                 {
; 318  :                     Dest[Index + 3] = Src[Index + 3];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$10[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR [ecx+3], al

; 319  :                     Dest[Index + 2] = Src[Index + 2];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$10[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx+2], al

; 320  :                     Dest[Index + 1] = Src[Index + 1];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$10[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al

; 321  :                     Dest[Index + 0] = Src[Index + 0];

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$10[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 322  :                 }
; 323  :                 else

	jmp	SHORT $LN22@ColorLevel
$LN21@ColorLevel:

; 324  :                 {
; 325  :                     Dest[Index + 3] = NonOpA;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	dl, BYTE PTR _NonOpA$[ebp]
	mov	BYTE PTR [ecx+3], dl

; 326  :                     Dest[Index + 2] = NonOpR;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$10[ebp]
	mov	cl, BYTE PTR _NonOpR$[ebp]
	mov	BYTE PTR [eax+2], cl

; 327  :                     Dest[Index + 1] = NonOpG;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$10[ebp]
	mov	al, BYTE PTR _NonOpG$[ebp]
	mov	BYTE PTR [edx+1], al

; 328  :                     Dest[Index + 0] = NonOpB;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$10[ebp]
	mov	dl, BYTE PTR _NonOpB$[ebp]
	mov	BYTE PTR [ecx], dl
$LN22@ColorLevel:

; 329  :                 }
; 330  :             }
; 331  :         }

	jmp	$LN8@ColorLevel
$LN9@ColorLevel:

; 332  :     }

	jmp	$LN5@ColorLevel
$LN6@ColorLevel:

; 333  : 
; 334  :     return Success;

	xor	eax, eax
$LN1@ColorLevel:

; 335  : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_ColorLevelsRegion@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\grayscale.cpp
_TEXT	SEGMENT
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_LevelCount$ = 28					; size = 4
_GrayLevels@24 PROC

; 471  : {

	push	ebp
	mov	ebp, esp

; 472  :     return GrayLevelsRegion(Source, Width, Height, Stride, Destination, LevelCount, 0, 0, Width - 1, Height - 1, FALSE, 0x0);

	push	0
	push	0
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _LevelCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Source$[ebp]
	push	ecx
	call	_GrayLevelsRegion@48

; 473  : }

	pop	ebp
	ret	24					; 00000018H
_GrayLevels@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\grayscale.cpp
_TEXT	SEGMENT
_Grays$ = -324						; size = 256
_f$1 = -68						; size = 8
tv263 = -60						; size = 8
_Factor$ = -52						; size = 8
_RowOffset$2 = -44					; size = 4
_PixelSize$ = -40					; size = 4
_i$3 = -36						; size = 4
_Row$4 = -32						; size = 4
_Column$5 = -28						; size = 4
_NonOpB$ = -22						; size = 1
_NonOpG$ = -21						; size = 1
_NonOpR$ = -20						; size = 1
_NonOpA$ = -19						; size = 1
_MeanGray$6 = -18					; size = 1
_M$7 = -17						; size = 1
_Src$ = -16						; size = 4
_Dest$ = -12						; size = 4
_GrayVal$8 = -5						; size = 1
_Index$9 = -4						; size = 4
_Source$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_LevelCount$ = 28					; size = 4
_Left$ = 32						; size = 4
_Top$ = 36						; size = 4
_Right$ = 40						; size = 4
_Bottom$ = 44						; size = 4
_CopyOutOfRegion$ = 48					; size = 4
_PackedOut$ = 52					; size = 4
_GrayLevelsRegion@48 PROC

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H

; 385  :     if (Source == NULL)

	cmp	DWORD PTR _Source$[ebp], 0
	jne	SHORT $LN11@GrayLevels

; 386  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@GrayLevels
$LN11@GrayLevels:

; 387  :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN12@GrayLevels

; 388  :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@GrayLevels
$LN12@GrayLevels:

; 389  :     if (LevelCount < 2)

	cmp	DWORD PTR _LevelCount$[ebp], 2
	jge	SHORT $LN13@GrayLevels

; 390  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@GrayLevels
$LN13@GrayLevels:

; 391  :     if (LevelCount > 255)

	cmp	DWORD PTR _LevelCount$[ebp], 255	; 000000ffH
	jle	SHORT $LN14@GrayLevels

; 392  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@GrayLevels
$LN14@GrayLevels:

; 393  : 
; 394  :     if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN15@GrayLevels

; 395  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@GrayLevels
$LN15@GrayLevels:

; 396  :     if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN16@GrayLevels

; 397  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@GrayLevels
$LN16@GrayLevels:

; 398  :     if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN17@GrayLevels

; 399  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@GrayLevels
$LN17@GrayLevels:

; 400  :     if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN18@GrayLevels

; 401  :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@GrayLevels
$LN18@GrayLevels:

; 402  : 
; 403  :     BYTE NonOpA = (PackedOut & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _NonOpA$[ebp], dl

; 404  :     BYTE NonOpR = (PackedOut & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedOut$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _NonOpR$[ebp], al

; 405  :     BYTE NonOpG = (PackedOut & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedOut$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _NonOpG$[ebp], cl

; 406  :     BYTE NonOpB = (PackedOut & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _NonOpB$[ebp], dl

; 407  : 
; 408  :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 409  :     BYTE *Src = (BYTE *)Source;

	mov	eax, DWORD PTR _Source$[ebp]
	mov	DWORD PTR _Src$[ebp], eax

; 410  :     BYTE *Dest = (BYTE *)Destination;

	mov	ecx, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], ecx

; 411  :     double Factor = 255.0 / (double)(LevelCount - 1);

	mov	edx, DWORD PTR _LevelCount$[ebp]
	sub	edx, 1
	cvtsi2sd xmm0, edx
	movsd	xmm1, QWORD PTR __real@406fe00000000000
	divsd	xmm1, xmm0
	movsd	QWORD PTR _Factor$[ebp], xmm1

; 412  : 
; 413  :     BYTE Grays[256];
; 414  :     for (int i = 0; i < 256; i++)

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@GrayLevels
$LN2@GrayLevels:
	mov	eax, DWORD PTR _i$3[ebp]
	add	eax, 1
	mov	DWORD PTR _i$3[ebp], eax
$LN4@GrayLevels:
	cmp	DWORD PTR _i$3[ebp], 256		; 00000100H
	jge	SHORT $LN3@GrayLevels

; 415  :     {
; 416  :         double f = floor((double)i / Factor);

	cvtsi2sd xmm0, DWORD PTR _i$3[ebp]
	divsd	xmm0, QWORD PTR _Factor$[ebp]
	movsd	QWORD PTR tv263[ebp], xmm0
	fld	QWORD PTR tv263[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fstp	QWORD PTR _f$1[ebp]

; 417  :         BYTE M = (BYTE)(f * Factor);

	movsd	xmm0, QWORD PTR _f$1[ebp]
	mulsd	xmm0, QWORD PTR _Factor$[ebp]
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _M$7[ebp], cl

; 418  :         Grays[i] = M;

	mov	edx, DWORD PTR _i$3[ebp]
	mov	al, BYTE PTR _M$7[ebp]
	mov	BYTE PTR _Grays$[ebp+edx], al

; 419  :     }

	jmp	SHORT $LN2@GrayLevels
$LN3@GrayLevels:

; 420  : 
; 421  :     for (int Row = Top; Row <= Bottom; Row++)

	mov	ecx, DWORD PTR _Top$[ebp]
	mov	DWORD PTR _Row$4[ebp], ecx
	jmp	SHORT $LN7@GrayLevels
$LN5@GrayLevels:
	mov	edx, DWORD PTR _Row$4[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$4[ebp], edx
$LN7@GrayLevels:
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Bottom$[ebp]
	jg	$LN6@GrayLevels

; 422  :     {
; 423  :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$4[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$2[ebp], ecx

; 424  :         for (int Column = Left; Column <= Right; Column++)

	mov	edx, DWORD PTR _Left$[ebp]
	mov	DWORD PTR _Column$5[ebp], edx
	jmp	SHORT $LN10@GrayLevels
$LN8@GrayLevels:
	mov	eax, DWORD PTR _Column$5[ebp]
	add	eax, 1
	mov	DWORD PTR _Column$5[ebp], eax
$LN10@GrayLevels:
	mov	ecx, DWORD PTR _Column$5[ebp]
	cmp	ecx, DWORD PTR _Right$[ebp]
	jg	$LN9@GrayLevels

; 425  :         {
; 426  :             int Index = (Column * PixelSize) + RowOffset;

	mov	edx, DWORD PTR _Column$5[ebp]
	imul	edx, DWORD PTR _PixelSize$[ebp]
	add	edx, DWORD PTR _RowOffset$2[ebp]
	mov	DWORD PTR _Index$9[ebp], edx

; 427  :             Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 428  : 
; 429  :             BYTE MeanGray = (Src[Index + 2] + Src[Index + 1] + Src[Index + 0]) / 3;

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	movzx	eax, BYTE PTR [eax+2]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	add	eax, edx
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	movzx	edx, BYTE PTR [ecx]
	add	eax, edx
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	BYTE PTR _MeanGray$6[ebp], al

; 430  :             BYTE GrayVal = Grays[MeanGray];

	movzx	edx, BYTE PTR _MeanGray$6[ebp]
	mov	al, BYTE PTR _Grays$[ebp+edx]
	mov	BYTE PTR _GrayVal$8[ebp], al

; 431  : 
; 432  :             if ((Column >= Left) && (Column <= Right) && (Row >= Top) && (Row <= Bottom))

	mov	ecx, DWORD PTR _Column$5[ebp]
	cmp	ecx, DWORD PTR _Left$[ebp]
	jl	SHORT $LN19@GrayLevels
	mov	edx, DWORD PTR _Column$5[ebp]
	cmp	edx, DWORD PTR _Right$[ebp]
	jg	SHORT $LN19@GrayLevels
	mov	eax, DWORD PTR _Row$4[ebp]
	cmp	eax, DWORD PTR _Top$[ebp]
	jl	SHORT $LN19@GrayLevels
	mov	ecx, DWORD PTR _Row$4[ebp]
	cmp	ecx, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN19@GrayLevels

; 433  :             {
; 434  :                 Dest[Index + 2] = GrayVal;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	al, BYTE PTR _GrayVal$8[ebp]
	mov	BYTE PTR [edx+2], al

; 435  :                 Dest[Index + 1] = GrayVal;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	dl, BYTE PTR _GrayVal$8[ebp]
	mov	BYTE PTR [ecx+1], dl

; 436  :                 Dest[Index + 0] = GrayVal;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR _GrayVal$8[ebp]
	mov	BYTE PTR [eax], cl

; 437  :             }
; 438  :             else

	jmp	SHORT $LN22@GrayLevels
$LN19@GrayLevels:

; 439  :             {
; 440  :                 if (CopyOutOfRegion)

	cmp	DWORD PTR _CopyOutOfRegion$[ebp], 0
	je	SHORT $LN21@GrayLevels

; 441  :                 {
; 442  :                     Dest[Index + 3] = Src[Index + 3];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx+3], cl

; 443  :                     Dest[Index + 2] = Src[Index + 2];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax+2]
	mov	BYTE PTR [edx+2], cl

; 444  :                     Dest[Index + 1] = Src[Index + 1];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx+1], cl

; 445  :                     Dest[Index + 0] = Src[Index + 0];

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl

; 446  :                 }
; 447  :                 else

	jmp	SHORT $LN22@GrayLevels
$LN21@GrayLevels:

; 448  :                 {
; 449  :                     Dest[Index + 3] = NonOpA;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	al, BYTE PTR _NonOpA$[ebp]
	mov	BYTE PTR [edx+3], al

; 450  :                     Dest[Index + 2] = NonOpR;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$9[ebp]
	mov	dl, BYTE PTR _NonOpR$[ebp]
	mov	BYTE PTR [ecx+2], dl

; 451  :                     Dest[Index + 1] = NonOpG;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$9[ebp]
	mov	cl, BYTE PTR _NonOpG$[ebp]
	mov	BYTE PTR [eax+1], cl

; 452  :                     Dest[Index + 0] = NonOpB;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$9[ebp]
	mov	al, BYTE PTR _NonOpB$[ebp]
	mov	BYTE PTR [edx], al
$LN22@GrayLevels:

; 453  :                 }
; 454  :             }
; 455  :         }

	jmp	$LN8@GrayLevels
$LN9@GrayLevels:

; 456  :     }

	jmp	$LN5@GrayLevels
$LN6@GrayLevels:

; 457  : 
; 458  :     return Success;

	xor	eax, eax
$LN1@GrayLevels:

; 459  : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_GrayLevelsRegion@48 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\grayscale.cpp
_TEXT	SEGMENT
_Buffer$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_GrayscaleType$ = 28					; size = 4
_BufferGrayscale@24 PROC

; 362  : {

	push	ebp
	mov	ebp, esp

; 363  :     return BufferGrayscaleRegion(Buffer, Width, Height, Stride, Destination, GrayscaleType,

	push	0
	push	1
	mov	eax, DWORD PTR _Height$[ebp]
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _Width$[ebp]
	sub	ecx, 1
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _GrayscaleType$[ebp]
	push	edx
	mov	eax, DWORD PTR _Destination$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Height$[ebp]
	push	edx
	mov	eax, DWORD PTR _Width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Buffer$[ebp]
	push	ecx
	call	_BufferGrayscaleRegion@48

; 364  :         0, 0, Width - 1, Height - 1, TRUE, 0x0);
; 365  : }

	pop	ebp
	ret	24					; 00000018H
_BufferGrayscale@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\stuart\desktop\projects4\colorblend\colorblender\grayscale.cpp
_TEXT	SEGMENT
_YellowVal$1 = -112					; size = 8
_MagentaVal$2 = -104					; size = 8
_CyanVal$3 = -96					; size = 8
_GrayLum$4 = -88					; size = 8
_gm$5 = -80						; size = 8
_RowOffset$6 = -72					; size = 4
_PixelSize$ = -68					; size = 4
tv132 = -64						; size = 4
_Row$7 = -60						; size = 4
_Column$8 = -56						; size = 4
_Smallest$9 = -51					; size = 1
_Biggest$10 = -50					; size = 1
_NonOpB$ = -49						; size = 1
_NonOpG$ = -48						; size = 1
_NonOpR$ = -47						; size = 1
_NonOpA$ = -46						; size = 1
_GA$11 = -45						; size = 1
_Src$ = -44						; size = 4
tv281 = -40						; size = 1
tv275 = -39						; size = 1
tv326 = -38						; size = 1
tv325 = -37						; size = 1
tv319 = -36						; size = 1
tv314 = -35						; size = 1
tv313 = -34						; size = 1
tv307 = -33						; size = 1
tv294 = -32						; size = 1
tv293 = -31						; size = 1
tv287 = -30						; size = 1
tv282 = -29						; size = 1
_Dest$ = -28						; size = 4
_FinalMinDecomp$12 = -23				; size = 1
_FinalMaxDecomp$13 = -22				; size = 1
_FinalDesat$14 = -21					; size = 1
_FinalYellow$15 = -20					; size = 1
_FinalMagenta$16 = -19					; size = 1
_FinalCyan$17 = -18					; size = 1
_FinalLum$18 = -17					; size = 1
_Final7$19 = -16					; size = 1
_Final6$20 = -15					; size = 1
_FinalP$21 = -14					; size = 1
_A$22 = -13						; size = 1
_Index$23 = -12						; size = 4
_GB$24 = -6						; size = 1
_GG$25 = -5						; size = 1
_GR$26 = -4						; size = 1
_R$27 = -3						; size = 1
_B$28 = -2						; size = 1
_G$29 = -1						; size = 1
_Buffer$ = 8						; size = 4
_Width$ = 12						; size = 4
_Height$ = 16						; size = 4
_Stride$ = 20						; size = 4
_Destination$ = 24					; size = 4
_GrayscaleType$ = 28					; size = 4
_Left$ = 32						; size = 4
_Top$ = 36						; size = 4
_Right$ = 40						; size = 4
_Bottom$ = 44						; size = 4
_CopyOutOfRegion$ = 48					; size = 4
_PackedOut$ = 52					; size = 4
_BufferGrayscaleRegion@48 PROC

; 39   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H

; 40   :     if (Buffer == NULL)

	cmp	DWORD PTR _Buffer$[ebp], 0
	jne	SHORT $LN10@BufferGray

; 41   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@BufferGray
$LN10@BufferGray:

; 42   :     if (Destination == NULL)

	cmp	DWORD PTR _Destination$[ebp], 0
	jne	SHORT $LN11@BufferGray

; 43   :         return NullPointer;

	mov	eax, 3
	jmp	$LN1@BufferGray
$LN11@BufferGray:

; 44   :     if (Left < 0)

	cmp	DWORD PTR _Left$[ebp], 0
	jge	SHORT $LN12@BufferGray

; 45   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@BufferGray
$LN12@BufferGray:

; 46   :     if (Right >= Width)

	mov	eax, DWORD PTR _Right$[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jl	SHORT $LN13@BufferGray

; 47   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@BufferGray
$LN13@BufferGray:

; 48   :     if (Top < 0)

	cmp	DWORD PTR _Top$[ebp], 0
	jge	SHORT $LN14@BufferGray

; 49   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@BufferGray
$LN14@BufferGray:

; 50   :     if (Bottom >= Height)

	mov	ecx, DWORD PTR _Bottom$[ebp]
	cmp	ecx, DWORD PTR _Height$[ebp]
	jl	SHORT $LN15@BufferGray

; 51   :         return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@BufferGray
$LN15@BufferGray:

; 52   : 
; 53   :     BYTE NonOpA = (PackedOut & 0xff000000) >> 24;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, -16777216				; ff000000H
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _NonOpA$[ebp], dl

; 54   :     BYTE NonOpR = (PackedOut & 0x00ff0000) >> 16;

	mov	eax, DWORD PTR _PackedOut$[ebp]
	and	eax, 16711680				; 00ff0000H
	shr	eax, 16					; 00000010H
	mov	BYTE PTR _NonOpR$[ebp], al

; 55   :     BYTE NonOpG = (PackedOut & 0x0000ff00) >> 8;

	mov	ecx, DWORD PTR _PackedOut$[ebp]
	and	ecx, 65280				; 0000ff00H
	shr	ecx, 8
	mov	BYTE PTR _NonOpG$[ebp], cl

; 56   :     BYTE NonOpB = (PackedOut & 0x000000ff) >> 0;

	mov	edx, DWORD PTR _PackedOut$[ebp]
	and	edx, 255				; 000000ffH
	mov	BYTE PTR _NonOpB$[ebp], dl

; 57   : 
; 58   :     int PixelSize = 4;

	mov	DWORD PTR _PixelSize$[ebp], 4

; 59   :     BYTE *Dest = (BYTE *)Destination;

	mov	eax, DWORD PTR _Destination$[ebp]
	mov	DWORD PTR _Dest$[ebp], eax

; 60   :     BYTE *Src = (BYTE *)Buffer;

	mov	ecx, DWORD PTR _Buffer$[ebp]
	mov	DWORD PTR _Src$[ebp], ecx

; 61   : 
; 62   :     for (int Row = 0; Row < Height; Row++)

	mov	DWORD PTR _Row$7[ebp], 0
	jmp	SHORT $LN4@BufferGray
$LN2@BufferGray:
	mov	edx, DWORD PTR _Row$7[ebp]
	add	edx, 1
	mov	DWORD PTR _Row$7[ebp], edx
$LN4@BufferGray:
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _Height$[ebp]
	jge	$LN3@BufferGray

; 63   :     {
; 64   :         int RowOffset = Row * Stride;

	mov	ecx, DWORD PTR _Row$7[ebp]
	imul	ecx, DWORD PTR _Stride$[ebp]
	mov	DWORD PTR _RowOffset$6[ebp], ecx

; 65   :         for (int Column = 0; Column < Width; Column++)

	mov	DWORD PTR _Column$8[ebp], 0
	jmp	SHORT $LN7@BufferGray
$LN5@BufferGray:
	mov	edx, DWORD PTR _Column$8[ebp]
	add	edx, 1
	mov	DWORD PTR _Column$8[ebp], edx
$LN7@BufferGray:
	mov	eax, DWORD PTR _Column$8[ebp]
	cmp	eax, DWORD PTR _Width$[ebp]
	jge	$LN6@BufferGray

; 66   :         {
; 67   :             int Index = (Column * PixelSize) + RowOffset;

	mov	ecx, DWORD PTR _Column$8[ebp]
	imul	ecx, DWORD PTR _PixelSize$[ebp]
	add	ecx, DWORD PTR _RowOffset$6[ebp]
	mov	DWORD PTR _Index$23[ebp], ecx

; 68   :             BYTE A = Src[Index + 3];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$23[ebp]
	mov	al, BYTE PTR [edx+3]
	mov	BYTE PTR _A$22[ebp], al

; 69   :             BYTE R = Src[Index + 2];

	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$23[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR _R$27[ebp], dl

; 70   :             BYTE G = Src[Index + 1];

	mov	eax, DWORD PTR _Src$[ebp]
	add	eax, DWORD PTR _Index$23[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _G$29[ebp], cl

; 71   :             BYTE B = Src[Index + 0];

	mov	edx, DWORD PTR _Src$[ebp]
	add	edx, DWORD PTR _Index$23[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _B$28[ebp], al

; 72   :             BYTE GA = A;

	mov	cl, BYTE PTR _A$22[ebp]
	mov	BYTE PTR _GA$11[ebp], cl

; 73   :             BYTE GR = 0x0;

	mov	BYTE PTR _GR$26[ebp], 0

; 74   :             BYTE GG = 0x0;

	mov	BYTE PTR _GG$25[ebp], 0

; 75   :             BYTE GB = 0x0;

	mov	BYTE PTR _GB$24[ebp], 0

; 76   : 
; 77   :             switch (GrayscaleType)

	mov	edx, DWORD PTR _GrayscaleType$[ebp]
	mov	DWORD PTR tv132[ebp], edx
	cmp	DWORD PTR tv132[ebp], 14		; 0000000eH
	ja	$LN31@BufferGray
	mov	eax, DWORD PTR tv132[ebp]
	jmp	DWORD PTR $LN61@BufferGray[eax*4]
$LN16@BufferGray:

; 78   :             {
; 79   :                 case Grayscale_Mean:
; 80   :                 {
; 81   :                     double gm = ((double)R + (double)G + (double)B) / 3.0;

	movzx	ecx, BYTE PTR _R$27[ebp]
	cvtsi2sd xmm0, ecx
	movzx	edx, BYTE PTR _G$29[ebp]
	cvtsi2sd xmm1, edx
	addsd	xmm0, xmm1
	movzx	eax, BYTE PTR _B$28[ebp]
	cvtsi2sd xmm1, eax
	addsd	xmm0, xmm1
	divsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	QWORD PTR _gm$5[ebp], xmm0

; 82   :                     GR = (BYTE)gm;

	cvttsd2si ecx, QWORD PTR _gm$5[ebp]
	mov	BYTE PTR _GR$26[ebp], cl

; 83   :                     GG = (BYTE)gm;

	cvttsd2si edx, QWORD PTR _gm$5[ebp]
	mov	BYTE PTR _GG$25[ebp], dl

; 84   :                     GB = (BYTE)gm;

	cvttsd2si eax, QWORD PTR _gm$5[ebp]
	mov	BYTE PTR _GB$24[ebp], al

; 85   :                 }
; 86   :                 break;

	jmp	$LN8@BufferGray
$LN17@BufferGray:

; 87   : 
; 88   :                 case Grayscale_Perceptual:
; 89   :                 {
; 90   :                     BYTE FinalP = (BYTE)((double)R * 0.30) + (BYTE)((double)G * 0.59) + (BYTE)((double)B * 0.11);

	movzx	ecx, BYTE PTR _R$27[ebp]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR __real@3fd3333333333333
	cvttsd2si edx, xmm0
	movzx	eax, dl
	movzx	ecx, BYTE PTR _G$29[ebp]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR __real@3fe2e147ae147ae1
	cvttsd2si edx, xmm0
	movzx	ecx, dl
	add	eax, ecx
	movzx	edx, BYTE PTR _B$28[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR __real@3fbc28f5c28f5c29
	cvttsd2si ecx, xmm0
	movzx	edx, cl
	add	eax, edx
	mov	BYTE PTR _FinalP$21[ebp], al

; 91   :                     GR = FinalP;

	mov	al, BYTE PTR _FinalP$21[ebp]
	mov	BYTE PTR _GR$26[ebp], al

; 92   :                     GG = FinalP;

	mov	cl, BYTE PTR _FinalP$21[ebp]
	mov	BYTE PTR _GG$25[ebp], cl

; 93   :                     GB = FinalP;

	mov	dl, BYTE PTR _FinalP$21[ebp]
	mov	BYTE PTR _GB$24[ebp], dl

; 94   :                 }
; 95   :                 break;

	jmp	$LN8@BufferGray
$LN18@BufferGray:

; 96   : 
; 97   :                 case Grayscale_BT601:
; 98   :                 {
; 99   :                     BYTE Final6 = (BYTE)((double)R * 0.099) + (BYTE)((double)G * 0.587) + (BYTE)((double)B * 0.114);

	movzx	eax, BYTE PTR _R$27[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3fb95810624dd2f2
	cvttsd2si ecx, xmm0
	movzx	edx, cl
	movzx	eax, BYTE PTR _G$29[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3fe2c8b439581062
	cvttsd2si ecx, xmm0
	movzx	eax, cl
	add	edx, eax
	movzx	ecx, BYTE PTR _B$28[ebp]
	cvtsi2sd xmm0, ecx
	mulsd	xmm0, QWORD PTR __real@3fbd2f1a9fbe76c9
	cvttsd2si eax, xmm0
	movzx	ecx, al
	add	edx, ecx
	mov	BYTE PTR _Final6$20[ebp], dl

; 100  :                     GR = Final6;

	mov	dl, BYTE PTR _Final6$20[ebp]
	mov	BYTE PTR _GR$26[ebp], dl

; 101  :                     GG = Final6;

	mov	al, BYTE PTR _Final6$20[ebp]
	mov	BYTE PTR _GG$25[ebp], al

; 102  :                     GB = Final6;

	mov	cl, BYTE PTR _Final6$20[ebp]
	mov	BYTE PTR _GB$24[ebp], cl

; 103  :                 }
; 104  :                 break;

	jmp	$LN8@BufferGray
$LN19@BufferGray:

; 105  : 
; 106  :                 case Grayscale_BT709:
; 107  :                 {
; 108  :                     BYTE Final7 = (BYTE)((double)R * 0.2126) + (BYTE)((double)G * 0.7152) + (BYTE)((double)B * 0.0722);

	movzx	edx, BYTE PTR _R$27[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR __real@3fcb367a0f9096bc
	cvttsd2si eax, xmm0
	movzx	ecx, al
	movzx	edx, BYTE PTR _G$29[ebp]
	cvtsi2sd xmm0, edx
	mulsd	xmm0, QWORD PTR __real@3fe6e2eb1c432ca5
	cvttsd2si eax, xmm0
	movzx	edx, al
	add	ecx, edx
	movzx	eax, BYTE PTR _B$28[ebp]
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3fb27bb2fec56d5d
	cvttsd2si edx, xmm0
	movzx	eax, dl
	add	ecx, eax
	mov	BYTE PTR _Final7$19[ebp], cl

; 109  :                     GR = Final7;

	mov	cl, BYTE PTR _Final7$19[ebp]
	mov	BYTE PTR _GR$26[ebp], cl

; 110  :                     GG = Final7;

	mov	dl, BYTE PTR _Final7$19[ebp]
	mov	BYTE PTR _GG$25[ebp], dl

; 111  :                     GB = Final7;

	mov	al, BYTE PTR _Final7$19[ebp]
	mov	BYTE PTR _GB$24[ebp], al

; 112  :                 }
; 113  :                 break;

	jmp	$LN8@BufferGray
$LN20@BufferGray:

; 114  : 
; 115  :                 case Grayscale_Brightness:
; 116  :                 {
; 117  :                     double GrayLum = ColorLuminance(R, G, B);

	movzx	ecx, BYTE PTR _B$28[ebp]
	push	ecx
	movzx	edx, BYTE PTR _G$29[ebp]
	push	edx
	movzx	eax, BYTE PTR _R$27[ebp]
	push	eax
	call	_ColorLuminance@12
	fstp	QWORD PTR _GrayLum$4[ebp]

; 118  :                     BYTE FinalLum = (BYTE)(255.0 * GrayLum);

	movsd	xmm0, QWORD PTR __real@406fe00000000000
	mulsd	xmm0, QWORD PTR _GrayLum$4[ebp]
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _FinalLum$18[ebp], cl

; 119  :                     GR = FinalLum;

	mov	dl, BYTE PTR _FinalLum$18[ebp]
	mov	BYTE PTR _GR$26[ebp], dl

; 120  :                     GG = FinalLum;

	mov	al, BYTE PTR _FinalLum$18[ebp]
	mov	BYTE PTR _GG$25[ebp], al

; 121  :                     GB = FinalLum;

	mov	cl, BYTE PTR _FinalLum$18[ebp]
	mov	BYTE PTR _GB$24[ebp], cl

; 122  :                 }
; 123  :                 break;

	jmp	$LN8@BufferGray
$LN21@BufferGray:

; 124  : 
; 125  :                 case Grayscale_RedChannel:
; 126  :                     GR = R;

	mov	dl, BYTE PTR _R$27[ebp]
	mov	BYTE PTR _GR$26[ebp], dl

; 127  :                     GG = R;

	mov	al, BYTE PTR _R$27[ebp]
	mov	BYTE PTR _GG$25[ebp], al

; 128  :                     GB = R;

	mov	cl, BYTE PTR _R$27[ebp]
	mov	BYTE PTR _GB$24[ebp], cl

; 129  :                     break;

	jmp	$LN8@BufferGray
$LN22@BufferGray:

; 130  : 
; 131  :                 case Grayscale_GreenChannel:
; 132  :                     GR = G;

	mov	dl, BYTE PTR _G$29[ebp]
	mov	BYTE PTR _GR$26[ebp], dl

; 133  :                     GG = G;

	mov	al, BYTE PTR _G$29[ebp]
	mov	BYTE PTR _GG$25[ebp], al

; 134  :                     GB = G;

	mov	cl, BYTE PTR _G$29[ebp]
	mov	BYTE PTR _GB$24[ebp], cl

; 135  :                     break;

	jmp	$LN8@BufferGray
$LN23@BufferGray:

; 136  : 
; 137  :                 case Grayscale_BlueChannel:
; 138  :                     GR = B;

	mov	dl, BYTE PTR _B$28[ebp]
	mov	BYTE PTR _GR$26[ebp], dl

; 139  :                     GG = B;

	mov	al, BYTE PTR _B$28[ebp]
	mov	BYTE PTR _GG$25[ebp], al

; 140  :                     GB = B;

	mov	cl, BYTE PTR _B$28[ebp]
	mov	BYTE PTR _GB$24[ebp], cl

; 141  :                     break;

	jmp	$LN8@BufferGray
$LN24@BufferGray:

; 142  : 
; 143  :                 case Grayscale_CyanChannel:
; 144  :                 {
; 145  :                     double CyanVal = (double)G + (double)B;

	movzx	edx, BYTE PTR _G$29[ebp]
	cvtsi2sd xmm0, edx
	movzx	eax, BYTE PTR _B$28[ebp]
	cvtsi2sd xmm1, eax
	addsd	xmm0, xmm1
	movsd	QWORD PTR _CyanVal$3[ebp], xmm0

; 146  :                     BYTE FinalCyan = (BYTE)(CyanVal / 2.0);

	movsd	xmm0, QWORD PTR _CyanVal$3[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _FinalCyan$17[ebp], cl

; 147  :                     GR = FinalCyan;

	mov	dl, BYTE PTR _FinalCyan$17[ebp]
	mov	BYTE PTR _GR$26[ebp], dl

; 148  :                     GG = FinalCyan;

	mov	al, BYTE PTR _FinalCyan$17[ebp]
	mov	BYTE PTR _GG$25[ebp], al

; 149  :                     GB = FinalCyan;

	mov	cl, BYTE PTR _FinalCyan$17[ebp]
	mov	BYTE PTR _GB$24[ebp], cl

; 150  :                 }
; 151  :                 break;

	jmp	$LN8@BufferGray
$LN25@BufferGray:

; 152  : 
; 153  :                 case Grayscale_MagentaChannel:
; 154  :                 {
; 155  :                     double MagentaVal = (double)R + (double)B;

	movzx	edx, BYTE PTR _R$27[ebp]
	cvtsi2sd xmm0, edx
	movzx	eax, BYTE PTR _B$28[ebp]
	cvtsi2sd xmm1, eax
	addsd	xmm0, xmm1
	movsd	QWORD PTR _MagentaVal$2[ebp], xmm0

; 156  :                     BYTE FinalMagenta = (BYTE)(MagentaVal / 2.0);

	movsd	xmm0, QWORD PTR _MagentaVal$2[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _FinalMagenta$16[ebp], cl

; 157  :                     GR = FinalMagenta;

	mov	dl, BYTE PTR _FinalMagenta$16[ebp]
	mov	BYTE PTR _GR$26[ebp], dl

; 158  :                     GG = FinalMagenta;

	mov	al, BYTE PTR _FinalMagenta$16[ebp]
	mov	BYTE PTR _GG$25[ebp], al

; 159  :                     GB = FinalMagenta;

	mov	cl, BYTE PTR _FinalMagenta$16[ebp]
	mov	BYTE PTR _GB$24[ebp], cl

; 160  :                 }
; 161  :                 break;

	jmp	$LN8@BufferGray
$LN26@BufferGray:

; 162  : 
; 163  :                 case Grayscale_YellowChannel:
; 164  :                 {
; 165  :                     double YellowVal = (double)R + (double)G;

	movzx	edx, BYTE PTR _R$27[ebp]
	cvtsi2sd xmm0, edx
	movzx	eax, BYTE PTR _G$29[ebp]
	cvtsi2sd xmm1, eax
	addsd	xmm0, xmm1
	movsd	QWORD PTR _YellowVal$1[ebp], xmm0

; 166  :                     BYTE FinalYellow = (BYTE)(YellowVal / 2.0);

	movsd	xmm0, QWORD PTR _YellowVal$1[ebp]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si ecx, xmm0
	mov	BYTE PTR _FinalYellow$15[ebp], cl

; 167  :                     GR = FinalYellow;

	mov	dl, BYTE PTR _FinalYellow$15[ebp]
	mov	BYTE PTR _GR$26[ebp], dl

; 168  :                     GG = FinalYellow;

	mov	al, BYTE PTR _FinalYellow$15[ebp]
	mov	BYTE PTR _GG$25[ebp], al

; 169  :                     GB = FinalYellow;

	mov	cl, BYTE PTR _FinalYellow$15[ebp]
	mov	BYTE PTR _GB$24[ebp], cl

; 170  :                 }
; 171  :                 break;

	jmp	$LN8@BufferGray
$LN27@BufferGray:

; 172  : 
; 173  :                 case Grayscale_AlphaChannel:
; 174  :                     GR = A;

	mov	dl, BYTE PTR _A$22[ebp]
	mov	BYTE PTR _GR$26[ebp], dl

; 175  :                     GG = A;

	mov	al, BYTE PTR _A$22[ebp]
	mov	BYTE PTR _GG$25[ebp], al

; 176  :                     GB = A;

	mov	cl, BYTE PTR _A$22[ebp]
	mov	BYTE PTR _GB$24[ebp], cl

; 177  :                     break;

	jmp	$LN8@BufferGray
$LN28@BufferGray:

; 178  : 
; 179  :                 case Grayscale_Desaturation:
; 180  :                 {
; 181  :                     BYTE Biggest = max(R, max(G, B));

	movzx	edx, BYTE PTR _G$29[ebp]
	movzx	eax, BYTE PTR _B$28[ebp]
	cmp	edx, eax
	jle	SHORT $LN37@BufferGray
	mov	cl, BYTE PTR _G$29[ebp]
	mov	BYTE PTR tv275[ebp], cl
	jmp	SHORT $LN38@BufferGray
$LN37@BufferGray:
	mov	dl, BYTE PTR _B$28[ebp]
	mov	BYTE PTR tv275[ebp], dl
$LN38@BufferGray:
	movzx	eax, BYTE PTR _R$27[ebp]
	movzx	ecx, BYTE PTR tv275[ebp]
	cmp	eax, ecx
	jle	SHORT $LN41@BufferGray
	mov	dl, BYTE PTR _R$27[ebp]
	mov	BYTE PTR tv282[ebp], dl
	jmp	SHORT $LN42@BufferGray
$LN41@BufferGray:
	movzx	eax, BYTE PTR _G$29[ebp]
	movzx	ecx, BYTE PTR _B$28[ebp]
	cmp	eax, ecx
	jle	SHORT $LN39@BufferGray
	mov	dl, BYTE PTR _G$29[ebp]
	mov	BYTE PTR tv281[ebp], dl
	jmp	SHORT $LN40@BufferGray
$LN39@BufferGray:
	mov	al, BYTE PTR _B$28[ebp]
	mov	BYTE PTR tv281[ebp], al
$LN40@BufferGray:
	mov	cl, BYTE PTR tv281[ebp]
	mov	BYTE PTR tv282[ebp], cl
$LN42@BufferGray:
	mov	dl, BYTE PTR tv282[ebp]
	mov	BYTE PTR _Biggest$10[ebp], dl

; 182  :                     BYTE Smallest = min(R, min(G, B));

	movzx	eax, BYTE PTR _G$29[ebp]
	movzx	ecx, BYTE PTR _B$28[ebp]
	cmp	eax, ecx
	jge	SHORT $LN43@BufferGray
	mov	dl, BYTE PTR _G$29[ebp]
	mov	BYTE PTR tv287[ebp], dl
	jmp	SHORT $LN44@BufferGray
$LN43@BufferGray:
	mov	al, BYTE PTR _B$28[ebp]
	mov	BYTE PTR tv287[ebp], al
$LN44@BufferGray:
	movzx	ecx, BYTE PTR _R$27[ebp]
	movzx	edx, BYTE PTR tv287[ebp]
	cmp	ecx, edx
	jge	SHORT $LN47@BufferGray
	mov	al, BYTE PTR _R$27[ebp]
	mov	BYTE PTR tv294[ebp], al
	jmp	SHORT $LN48@BufferGray
$LN47@BufferGray:
	movzx	ecx, BYTE PTR _G$29[ebp]
	movzx	edx, BYTE PTR _B$28[ebp]
	cmp	ecx, edx
	jge	SHORT $LN45@BufferGray
	mov	al, BYTE PTR _G$29[ebp]
	mov	BYTE PTR tv293[ebp], al
	jmp	SHORT $LN46@BufferGray
$LN45@BufferGray:
	mov	cl, BYTE PTR _B$28[ebp]
	mov	BYTE PTR tv293[ebp], cl
$LN46@BufferGray:
	mov	dl, BYTE PTR tv293[ebp]
	mov	BYTE PTR tv294[ebp], dl
$LN48@BufferGray:
	mov	al, BYTE PTR tv294[ebp]
	mov	BYTE PTR _Smallest$9[ebp], al

; 183  :                     BYTE FinalDesat = (BYTE)(((double)Biggest + (double)Smallest) / 2);

	movzx	ecx, BYTE PTR _Biggest$10[ebp]
	cvtsi2sd xmm0, ecx
	movzx	edx, BYTE PTR _Smallest$9[ebp]
	cvtsi2sd xmm1, edx
	addsd	xmm0, xmm1
	divsd	xmm0, QWORD PTR __real@4000000000000000
	cvttsd2si eax, xmm0
	mov	BYTE PTR _FinalDesat$14[ebp], al

; 184  :                     GR = FinalDesat;

	mov	cl, BYTE PTR _FinalDesat$14[ebp]
	mov	BYTE PTR _GR$26[ebp], cl

; 185  :                     GG = FinalDesat;

	mov	dl, BYTE PTR _FinalDesat$14[ebp]
	mov	BYTE PTR _GG$25[ebp], dl

; 186  :                     GB = FinalDesat;

	mov	al, BYTE PTR _FinalDesat$14[ebp]
	mov	BYTE PTR _GB$24[ebp], al

; 187  :                 }
; 188  :                 break;

	jmp	$LN8@BufferGray
$LN29@BufferGray:

; 189  : 
; 190  :                 case Grayscale_MaxDecomposition:
; 191  :                 {
; 192  :                     BYTE FinalMaxDecomp = max(R, max(G, B));

	movzx	ecx, BYTE PTR _G$29[ebp]
	movzx	edx, BYTE PTR _B$28[ebp]
	cmp	ecx, edx
	jle	SHORT $LN49@BufferGray
	mov	al, BYTE PTR _G$29[ebp]
	mov	BYTE PTR tv307[ebp], al
	jmp	SHORT $LN50@BufferGray
$LN49@BufferGray:
	mov	cl, BYTE PTR _B$28[ebp]
	mov	BYTE PTR tv307[ebp], cl
$LN50@BufferGray:
	movzx	edx, BYTE PTR _R$27[ebp]
	movzx	eax, BYTE PTR tv307[ebp]
	cmp	edx, eax
	jle	SHORT $LN53@BufferGray
	mov	cl, BYTE PTR _R$27[ebp]
	mov	BYTE PTR tv314[ebp], cl
	jmp	SHORT $LN54@BufferGray
$LN53@BufferGray:
	movzx	edx, BYTE PTR _G$29[ebp]
	movzx	eax, BYTE PTR _B$28[ebp]
	cmp	edx, eax
	jle	SHORT $LN51@BufferGray
	mov	cl, BYTE PTR _G$29[ebp]
	mov	BYTE PTR tv313[ebp], cl
	jmp	SHORT $LN52@BufferGray
$LN51@BufferGray:
	mov	dl, BYTE PTR _B$28[ebp]
	mov	BYTE PTR tv313[ebp], dl
$LN52@BufferGray:
	mov	al, BYTE PTR tv313[ebp]
	mov	BYTE PTR tv314[ebp], al
$LN54@BufferGray:
	mov	cl, BYTE PTR tv314[ebp]
	mov	BYTE PTR _FinalMaxDecomp$13[ebp], cl

; 193  :                     GR = FinalMaxDecomp;

	mov	dl, BYTE PTR _FinalMaxDecomp$13[ebp]
	mov	BYTE PTR _GR$26[ebp], dl

; 194  :                     GG = FinalMaxDecomp;

	mov	al, BYTE PTR _FinalMaxDecomp$13[ebp]
	mov	BYTE PTR _GG$25[ebp], al

; 195  :                     GB = FinalMaxDecomp;

	mov	cl, BYTE PTR _FinalMaxDecomp$13[ebp]
	mov	BYTE PTR _GB$24[ebp], cl

; 196  :                 }
; 197  :                 break;

	jmp	SHORT $LN8@BufferGray
$LN30@BufferGray:

; 198  : 
; 199  :                 case Grayscale_MinDecomposition:
; 200  :                 {
; 201  :                     BYTE FinalMinDecomp = min(R, min(G, B));

	movzx	edx, BYTE PTR _G$29[ebp]
	movzx	eax, BYTE PTR _B$28[ebp]
	cmp	edx, eax
	jge	SHORT $LN55@BufferGray
	mov	cl, BYTE PTR _G$29[ebp]
	mov	BYTE PTR tv319[ebp], cl
	jmp	SHORT $LN56@BufferGray
$LN55@BufferGray:
	mov	dl, BYTE PTR _B$28[ebp]
	mov	BYTE PTR tv319[ebp], dl
$LN56@BufferGray:
	movzx	eax, BYTE PTR _R$27[ebp]
	movzx	ecx, BYTE PTR tv319[ebp]
	cmp	eax, ecx
	jge	SHORT $LN59@BufferGray
	mov	dl, BYTE PTR _R$27[ebp]
	mov	BYTE PTR tv326[ebp], dl
	jmp	SHORT $LN60@BufferGray
$LN59@BufferGray:
	movzx	eax, BYTE PTR _G$29[ebp]
	movzx	ecx, BYTE PTR _B$28[ebp]
	cmp	eax, ecx
	jge	SHORT $LN57@BufferGray
	mov	dl, BYTE PTR _G$29[ebp]
	mov	BYTE PTR tv325[ebp], dl
	jmp	SHORT $LN58@BufferGray
$LN57@BufferGray:
	mov	al, BYTE PTR _B$28[ebp]
	mov	BYTE PTR tv325[ebp], al
$LN58@BufferGray:
	mov	cl, BYTE PTR tv325[ebp]
	mov	BYTE PTR tv326[ebp], cl
$LN60@BufferGray:
	mov	dl, BYTE PTR tv326[ebp]
	mov	BYTE PTR _FinalMinDecomp$12[ebp], dl

; 202  :                     GR = FinalMinDecomp;

	mov	al, BYTE PTR _FinalMinDecomp$12[ebp]
	mov	BYTE PTR _GR$26[ebp], al

; 203  :                     GG = FinalMinDecomp;

	mov	cl, BYTE PTR _FinalMinDecomp$12[ebp]
	mov	BYTE PTR _GG$25[ebp], cl

; 204  :                     GB = FinalMinDecomp;

	mov	dl, BYTE PTR _FinalMinDecomp$12[ebp]
	mov	BYTE PTR _GB$24[ebp], dl

; 205  :                 }
; 206  :                 break;

	jmp	SHORT $LN8@BufferGray
$LN31@BufferGray:

; 207  : 
; 208  :                 default:
; 209  :                     return InvalidOperation;

	mov	eax, 11					; 0000000bH
	jmp	$LN1@BufferGray
$LN8@BufferGray:

; 210  :             }
; 211  : 
; 212  :             if ((Column >= Left) && (Column <= Right) && (Row >= Top) && (Row <= Bottom))

	mov	eax, DWORD PTR _Column$8[ebp]
	cmp	eax, DWORD PTR _Left$[ebp]
	jl	SHORT $LN32@BufferGray
	mov	ecx, DWORD PTR _Column$8[ebp]
	cmp	ecx, DWORD PTR _Right$[ebp]
	jg	SHORT $LN32@BufferGray
	mov	edx, DWORD PTR _Row$7[ebp]
	cmp	edx, DWORD PTR _Top$[ebp]
	jl	SHORT $LN32@BufferGray
	mov	eax, DWORD PTR _Row$7[ebp]
	cmp	eax, DWORD PTR _Bottom$[ebp]
	jg	SHORT $LN32@BufferGray

; 213  :             {
; 214  :                 Dest[Index + 3] = GA;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$23[ebp]
	mov	dl, BYTE PTR _GA$11[ebp]
	mov	BYTE PTR [ecx+3], dl

; 215  :                 Dest[Index + 2] = GR;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$23[ebp]
	mov	cl, BYTE PTR _GR$26[ebp]
	mov	BYTE PTR [eax+2], cl

; 216  :                 Dest[Index + 1] = GG;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$23[ebp]
	mov	al, BYTE PTR _GG$25[ebp]
	mov	BYTE PTR [edx+1], al

; 217  :                 Dest[Index + 0] = GB;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$23[ebp]
	mov	dl, BYTE PTR _GB$24[ebp]
	mov	BYTE PTR [ecx], dl

; 218  :             }
; 219  :             else

	jmp	SHORT $LN35@BufferGray
$LN32@BufferGray:

; 220  :             {
; 221  :                 if (CopyOutOfRegion)

	cmp	DWORD PTR _CopyOutOfRegion$[ebp], 0
	je	SHORT $LN34@BufferGray

; 222  :                 {
; 223  :                     Dest[Index + 3] = Src[Index + 3];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$23[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$23[ebp]
	mov	dl, BYTE PTR [ecx+3]
	mov	BYTE PTR [eax+3], dl

; 224  :                     Dest[Index + 2] = Src[Index + 2];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$23[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$23[ebp]
	mov	dl, BYTE PTR [ecx+2]
	mov	BYTE PTR [eax+2], dl

; 225  :                     Dest[Index + 1] = Src[Index + 1];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$23[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$23[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax+1], dl

; 226  :                     Dest[Index + 0] = Src[Index + 0];

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$23[ebp]
	mov	ecx, DWORD PTR _Src$[ebp]
	add	ecx, DWORD PTR _Index$23[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 227  :                 }
; 228  :                 else

	jmp	SHORT $LN35@BufferGray
$LN34@BufferGray:

; 229  :                 {
; 230  :                     Dest[Index + 3] = NonOpA;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$23[ebp]
	mov	cl, BYTE PTR _NonOpA$[ebp]
	mov	BYTE PTR [eax+3], cl

; 231  :                     Dest[Index + 2] = NonOpR;

	mov	edx, DWORD PTR _Dest$[ebp]
	add	edx, DWORD PTR _Index$23[ebp]
	mov	al, BYTE PTR _NonOpR$[ebp]
	mov	BYTE PTR [edx+2], al

; 232  :                     Dest[Index + 1] = NonOpG;

	mov	ecx, DWORD PTR _Dest$[ebp]
	add	ecx, DWORD PTR _Index$23[ebp]
	mov	dl, BYTE PTR _NonOpG$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 233  :                     Dest[Index + 0] = NonOpB;

	mov	eax, DWORD PTR _Dest$[ebp]
	add	eax, DWORD PTR _Index$23[ebp]
	mov	cl, BYTE PTR _NonOpB$[ebp]
	mov	BYTE PTR [eax], cl
$LN35@BufferGray:

; 234  :                 }
; 235  :             }
; 236  :         }

	jmp	$LN5@BufferGray
$LN6@BufferGray:

; 237  :     }

	jmp	$LN2@BufferGray
$LN3@BufferGray:

; 238  : 
; 239  :     return Success;

	xor	eax, eax
$LN1@BufferGray:

; 240  : }

	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
$LN61@BufferGray:
	DD	$LN16@BufferGray
	DD	$LN20@BufferGray
	DD	$LN17@BufferGray
	DD	$LN21@BufferGray
	DD	$LN22@BufferGray
	DD	$LN23@BufferGray
	DD	$LN24@BufferGray
	DD	$LN25@BufferGray
	DD	$LN26@BufferGray
	DD	$LN27@BufferGray
	DD	$LN18@BufferGray
	DD	$LN19@BufferGray
	DD	$LN28@BufferGray
	DD	$LN29@BufferGray
	DD	$LN30@BufferGray
_BufferGrayscaleRegion@48 ENDP
_TEXT	ENDS
END
